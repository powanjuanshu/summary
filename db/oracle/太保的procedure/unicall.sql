--------------------------------------------------
-- Export file for user UNICALL                 --
-- Created by wangjizheng on 2013-3-8, 14:42:51 --
--------------------------------------------------

spool unicall.log

prompt
prompt Creating table A
prompt ================
prompt
create table UNICALL.A
(
  a1 VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table ACCOUNT
prompt ======================
prompt
create table UNICALL.ACCOUNT
(
  sno        NUMBER(20),
  typeid     NUMBER(7) not null,
  account_id NUMBER(20),
  acco_no    VARCHAR2(120) not null,
  usetype    CHAR(1) not null,
  regdate    DATE,
  open_date  DATE,
  status     CHAR(1),
  s_date     DATE,
  s_reason   CHAR(2),
  currency   CHAR(3) not null,
  bankcode   VARCHAR2(20) not null,
  bankname   VARCHAR2(80),
  policyno   VARCHAR2(20) not null,
  ownerid    VARCHAR2(20) not null,
  oper_no    VARCHAR2(20),
  begtime    NUMBER(11) not null,
  endtime    NUMBER(11) not null,
  branch     CHAR(14) not null,
  etl_time   TIMESTAMP(6) not null,
  src_sys    VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.ACCOUNT
  is '  账户信息（银行账户）';
comment on column UNICALL.ACCOUNT.sno
  is 'IAA物理主键
';
comment on column UNICALL.ACCOUNT.typeid
  is 'IAA数据类型
';
comment on column UNICALL.ACCOUNT.account_id
  is 'IAA锚点，Agreement
';
comment on column UNICALL.ACCOUNT.acco_no
  is '银行账户号
';
comment on column UNICALL.ACCOUNT.usetype
  is '账户用途（收费、付费、收付费）
';
comment on column UNICALL.ACCOUNT.regdate
  is '录入日期
';
comment on column UNICALL.ACCOUNT.open_date
  is '开户日期
';
comment on column UNICALL.ACCOUNT.status
  is '账户状态
';
comment on column UNICALL.ACCOUNT.s_date
  is '账户状态日期
';
comment on column UNICALL.ACCOUNT.s_reason
  is '账户状态原因
';
comment on column UNICALL.ACCOUNT.currency
  is '币种
';
comment on column UNICALL.ACCOUNT.bankcode
  is '银行账户开户行代码
';
comment on column UNICALL.ACCOUNT.bankname
  is '银行账户开户行名称
';
comment on column UNICALL.ACCOUNT.policyno
  is '保单号
';
comment on column UNICALL.ACCOUNT.ownerid
  is '账户所有人证件号
';
comment on column UNICALL.ACCOUNT.oper_no
  is '操作员';
comment on column UNICALL.ACCOUNT.begtime
  is '开始日期
';
comment on column UNICALL.ACCOUNT.endtime
  is '中止日期
';
comment on column UNICALL.ACCOUNT.branch
  is '分公司代码
';
comment on column UNICALL.ACCOUNT.etl_time
  is 'ETL处理时间
';
comment on column UNICALL.ACCOUNT.src_sys
  is '来源系统
';
create index UNICALL.ACCOUNT_INDEX on UNICALL.ACCOUNT (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ACCOUNT_CHANGE
prompt =============================
prompt
create table UNICALL.ACCOUNT_CHANGE
(
  agent_id     VARCHAR2(200),
  orgname      VARCHAR2(200),
  classname    VARCHAR2(200),
  appno        VARCHAR2(200),
  policyno     VARCHAR2(200),
  acus_name    VARCHAR2(20),
  apid         VARCHAR2(200),
  fee_acc_bank VARCHAR2(200),
  fee_acc_no   VARCHAR2(200),
  regdate      VARCHAR2(200),
  bankname     VARCHAR2(200),
  acco_no      VARCHAR2(200),
  years        VARCHAR2(10),
  nextdate     VARCHAR2(50),
  tsrid        VARCHAR2(50),
  importdate   VARCHAR2(50),
  xh           NUMBER,
  changedate   VARCHAR2(50)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.ACCOUNT_CHANGE
  is '账号变更统计报表';
comment on column UNICALL.ACCOUNT_CHANGE.agent_id
  is '业务员工号';
comment on column UNICALL.ACCOUNT_CHANGE.orgname
  is '保单归属地分公司';
comment on column UNICALL.ACCOUNT_CHANGE.classname
  is '险种名称';
comment on column UNICALL.ACCOUNT_CHANGE.appno
  is '投保单号';
comment on column UNICALL.ACCOUNT_CHANGE.policyno
  is '保单号';
comment on column UNICALL.ACCOUNT_CHANGE.acus_name
  is '投保人姓名';
comment on column UNICALL.ACCOUNT_CHANGE.apid
  is '身份证号码';
comment on column UNICALL.ACCOUNT_CHANGE.fee_acc_bank
  is '开户行';
comment on column UNICALL.ACCOUNT_CHANGE.fee_acc_no
  is '投保时缴费账号';
comment on column UNICALL.ACCOUNT_CHANGE.regdate
  is '变更时间';
comment on column UNICALL.ACCOUNT_CHANGE.bankname
  is '现开户行';
comment on column UNICALL.ACCOUNT_CHANGE.acco_no
  is '现缴费账号';
comment on column UNICALL.ACCOUNT_CHANGE.years
  is '已缴费期数';
comment on column UNICALL.ACCOUNT_CHANGE.nextdate
  is '下次缴费日';
comment on column UNICALL.ACCOUNT_CHANGE.tsrid
  is '销售座席工号';
comment on column UNICALL.ACCOUNT_CHANGE.importdate
  is '每周导入时间';
comment on column UNICALL.ACCOUNT_CHANGE.xh
  is '序号';
comment on column UNICALL.ACCOUNT_CHANGE.changedate
  is '每周变更日期';

prompt
prompt Creating table ADDRESS
prompt ======================
prompt
create table UNICALL.ADDRESS
(
  sno              NUMBER(20),
  typeid           NUMBER(7) not null,
  country          VARCHAR2(20),
  city             VARCHAR2(60),
  region           VARCHAR2(60),
  subregion        VARCHAR2(80),
  street           VARCHAR2(20),
  subaddr          VARCHAR2(500),
  zip              VARCHAR2(20),
  addr             VARCHAR2(500) not null,
  usage            CHAR(1) not null,
  person_id        NUMBER(20),
  pid              VARCHAR2(40) not null,
  idtype           CHAR(2),
  purpose          CHAR(1) not null,
  seq              VARCHAR2(10) not null,
  source_person_id VARCHAR2(20) not null,
  id15             VARCHAR2(40),
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         TIMESTAMP(6) not null,
  src_sys          VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.ADDRESS
  is '  地址信息';
comment on column UNICALL.ADDRESS.sno
  is 'IAA物理主键
';
comment on column UNICALL.ADDRESS.typeid
  is 'IAA数据类型
';
comment on column UNICALL.ADDRESS.country
  is '国家
';
comment on column UNICALL.ADDRESS.city
  is '市
';
comment on column UNICALL.ADDRESS.region
  is '省
';
comment on column UNICALL.ADDRESS.subregion
  is '区（县）
';
comment on column UNICALL.ADDRESS.street
  is '街道(乡/镇）
';
comment on column UNICALL.ADDRESS.subaddr
  is '地址
';
comment on column UNICALL.ADDRESS.zip
  is '邮政编码
';
comment on column UNICALL.ADDRESS.addr
  is '完整地址信息
';
comment on column UNICALL.ADDRESS.usage
  is '类型（家庭、工作单位）
';
comment on column UNICALL.ADDRESS.person_id
  is '地址所属客户IAA业务相关主键
';
comment on column UNICALL.ADDRESS.pid
  is '身份证号/团体客户号
';
comment on column UNICALL.ADDRESS.idtype
  is '证件类型
';
comment on column UNICALL.ADDRESS.purpose
  is '属性（主要、非主要）
';
comment on column UNICALL.ADDRESS.seq
  is '序号
';
comment on column UNICALL.ADDRESS.source_person_id
  is '源系统客户号
';
comment on column UNICALL.ADDRESS.id15
  is '15位身份证号码
';
comment on column UNICALL.ADDRESS.begtime
  is '开始日期
';
comment on column UNICALL.ADDRESS.endtime
  is '中止日期
';
comment on column UNICALL.ADDRESS.branch
  is '分公司代码
';
comment on column UNICALL.ADDRESS.etl_time
  is 'ETL处理时间
';
comment on column UNICALL.ADDRESS.src_sys
  is '来源系统
';
create index UNICALL.ADDRESS_INDEX on UNICALL.ADDRESS (PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ADDRESS_QF
prompt =========================
prompt
create table UNICALL.ADDRESS_QF
(
  sno              NUMBER(20),
  typeid           NUMBER(7) not null,
  country          VARCHAR2(20),
  city             VARCHAR2(30),
  region           VARCHAR2(60),
  subregion        VARCHAR2(80),
  street           VARCHAR2(20),
  subaddr          VARCHAR2(500),
  zip              VARCHAR2(20),
  addr             VARCHAR2(500) not null,
  usage            CHAR(1) not null,
  person_id        NUMBER(20),
  pid              VARCHAR2(40) not null,
  idtype           CHAR(2) not null,
  purpose          CHAR(1) not null,
  seq              VARCHAR2(10) not null,
  source_person_id VARCHAR2(20) not null,
  id15             VARCHAR2(40),
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         TIMESTAMP(6) not null,
  src_sys          VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ADDRESS_TEMP
prompt ===========================
prompt
create table UNICALL.ADDRESS_TEMP
(
  sno              NUMBER(20),
  typeid           NUMBER(7) not null,
  country          VARCHAR2(20),
  city             VARCHAR2(60),
  region           VARCHAR2(60),
  subregion        VARCHAR2(80),
  street           VARCHAR2(20),
  subaddr          VARCHAR2(500),
  zip              VARCHAR2(20),
  addr             VARCHAR2(500) not null,
  usage            CHAR(1) not null,
  person_id        NUMBER(20),
  pid              VARCHAR2(40) not null,
  idtype           CHAR(2),
  purpose          CHAR(1),
  seq              VARCHAR2(10) not null,
  source_person_id VARCHAR2(20) not null,
  id15             VARCHAR2(40),
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         DATE not null,
  src_sys          VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX1_ADDRESS_TEMP_BEGTIME on UNICALL.ADDRESS_TEMP (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX1_ADDRESS_TEMP_USS on UNICALL.ADDRESS_TEMP (USAGE, SOURCE_PERSON_ID, SEQ)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_A_AD_ID15 on UNICALL.ADDRESS_TEMP (ID15)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_A_AD_PID on UNICALL.ADDRESS_TEMP (PID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_A_AD_S_P_ID on UNICALL.ADDRESS_TEMP (SOURCE_PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table AGCALLINFO
prompt =========================
prompt
create table UNICALL.AGCALLINFO
(
  callid       VARCHAR2(20) not null,
  callno       VARCHAR2(20),
  begintime    VARCHAR2(30),
  endtime      VARCHAR2(30),
  duration     VARCHAR2(10),
  cardid       VARCHAR2(16),
  istransfer   CHAR(1),
  presshistory VARCHAR2(500)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 82M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.AGCALLINFO
  add constraint PK_AGCALLINFO primary key (CALLID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 16M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table AGMPACKER
prompt ========================
prompt
create table UNICALL.AGMPACKER
(
  vid      INTEGER not null,
  mpackid  VARCHAR2(10) not null,
  key      VARCHAR2(20) not null,
  length   INTEGER not null,
  tcheck   VARCHAR2(64) not null,
  vproc    VARCHAR2(64),
  sendflag CHAR(1) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.AGMPACKER
  add primary key (VID, MPACKID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table AGMUNPACKER
prompt ==========================
prompt
create table UNICALL.AGMUNPACKER
(
  vid       INTEGER not null,
  munpackid VARCHAR2(10) not null,
  key       VARCHAR2(20) not null,
  length    INTEGER not null,
  vproc     VARCHAR2(64),
  getflag   CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.AGMUNPACKER
  add primary key (VID, MUNPACKID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table AGPACKER
prompt =======================
prompt
create table UNICALL.AGPACKER
(
  vid      INTEGER not null,
  packid   VARCHAR2(10) not null,
  key      VARCHAR2(20) not null,
  length   INTEGER not null,
  tcheck   VARCHAR2(64),
  vproc    VARCHAR2(64),
  sendflag CHAR(1) not null,
  logflag  CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.AGPACKER
  add primary key (VID, PACKID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table AGROUTER
prompt =======================
prompt
create table UNICALL.AGROUTER
(
  txncode   VARCHAR2(6) not null,
  tscode    VARCHAR2(8),
  txnname   VARCHAR2(100),
  txntype   CHAR(1),
  foredeal  VARCHAR2(64),
  swcomm    VARCHAR2(20) not null,
  backdeal  VARCHAR2(64),
  packer    VARCHAR2(20),
  mpacker   VARCHAR2(20),
  unpacker  VARCHAR2(20),
  munpacker VARCHAR2(20),
  packid    VARCHAR2(10),
  mpackid   VARCHAR2(10),
  unpackid  VARCHAR2(10),
  munpackid VARCHAR2(10),
  locdeal   VARCHAR2(64),
  openflag  CHAR(1) not null,
  btxncode  VARCHAR2(6)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.AGROUTER
  add primary key (TXNCODE)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table AGSMS
prompt ====================
prompt
create table UNICALL.AGSMS
(
  callid     VARCHAR2(20) not null,
  mobileno   VARCHAR2(20) not null,
  message    VARCHAR2(500) not null,
  createtime DATE default sysdate,
  status     CHAR(1) default 0
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 37M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.AGSMS.status
  is '发送状态：0-未发送，1-已发送';
alter table UNICALL.AGSMS
  add primary key (CALLID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 6M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table AGTXNLOG
prompt =======================
prompt
create table UNICALL.AGTXNLOG
(
  logid      VARCHAR2(24) not null,
  callinno   VARCHAR2(20),
  callid     VARCHAR2(20),
  logorg     VARCHAR2(2),
  agentid    VARCHAR2(20),
  txncode    VARCHAR2(6) not null,
  jygydh     VARCHAR2(10),
  dqdm       VARCHAR2(10),
  custno     VARCHAR2(10),
  begintime  VARCHAR2(20),
  endtime    VARCHAR2(20),
  txnrepcode VARCHAR2(5),
  trcode     VARCHAR2(10),
  cardno     VARCHAR2(16)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 1481M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table AGUNPACKER
prompt =========================
prompt
create table UNICALL.AGUNPACKER
(
  vid      INTEGER not null,
  unpackid VARCHAR2(10) not null,
  key      VARCHAR2(20) not null,
  length   INTEGER not null,
  vproc    VARCHAR2(64),
  getflag  CHAR(1),
  logflag  CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.AGUNPACKER
  add primary key (VID, UNPACKID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table APP_NB
prompt =====================
prompt
create table UNICALL.APP_NB
(
  sno                   NUMBER(20),
  typeid                NUMBER(7),
  status                CHAR(2),
  procdate              DATE,
  abstr                 VARCHAR2(500),
  appdate               DATE,
  appno                 VARCHAR2(40),
  con_id                NUMBER(20),
  policyno              VARCHAR2(20),
  classcode             CHAR(8),
  opdate                DATE,
  operid                NUMBER(20),
  operno                VARCHAR2(20),
  oper_role             VARCHAR2(20),
  pieces                NUMBER(20,6),
  yearnum               NUMBER(10),
  saleattr              CHAR(2),
  agt_rp_id             NUMBER(20),
  agt_rp_type           NUMBER(7),
  agt_no                VARCHAR2(20),
  owner_rp_id           NUMBER(20),
  owner_rp_type         NUMBER(7),
  owner_id              VARCHAR2(40),
  insured_rp_id         NUMBER(20),
  insured_rp_type       NUMBER(7),
  insured_id            VARCHAR2(40),
  owner_insured_rlship  CHAR(3),
  rider_ind             CHAR(1),
  prem_start_date       DATE,
  prem_end_date         DATE,
  rec_postal_code       VARCHAR2(20),
  rec_addr              VARCHAR2(500),
  rec_tel               VARCHAR2(30),
  prem_frq              CHAR(2),
  prem_mthd             CHAR(1),
  std_piece_prem        NUMBER(20,6),
  std_add_piece_prem    NUMBER(10,2),
  nonstd_add_piece_prem NUMBER(10,2),
  agt_phone             VARCHAR2(30),
  sale_type             CHAR(2),
  sale_prod_code        VARCHAR2(8),
  app_age               NUMBER(3),
  begtime               NUMBER(11),
  endtime               NUMBER(11),
  branch                CHAR(14),
  etl_time              DATE,
  src_sys               VARCHAR2(20),
  app_confirm_no        VARCHAR2(20),
  app_terminal_id       VARCHAR2(20),
  cross_sale_ind        VARCHAR2(1),
  sub_sale_type         VARCHAR2(2),
  cstmzd_rcmd_no        VARCHAR2(30),
  app_ip_date           DATE,
  digital_sign_ind      VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.APP_NB
  is 'IAA物理主键';
comment on column UNICALL.APP_NB.sno
  is 'IAA物理主键';
comment on column UNICALL.APP_NB.typeid
  is '交易类型';
comment on column UNICALL.APP_NB.status
  is '交易状态（只需要生效后的交易，所有投保单），投保单状态';
comment on column UNICALL.APP_NB.procdate
  is '交易生效日期';
comment on column UNICALL.APP_NB.abstr
  is '原因';
comment on column UNICALL.APP_NB.appdate
  is '交易申请日期';
comment on column UNICALL.APP_NB.appno
  is '投保单号';
comment on column UNICALL.APP_NB.con_id
  is '保单IAA业务相关主键';
comment on column UNICALL.APP_NB.policyno
  is '保单号';
comment on column UNICALL.APP_NB.classcode
  is '险种';
comment on column UNICALL.APP_NB.opdate
  is '操作日期';
comment on column UNICALL.APP_NB.operid
  is '操作员IAA业务相关主键';
comment on column UNICALL.APP_NB.operno
  is '操作员工号';
comment on column UNICALL.APP_NB.oper_role
  is '操作员岗位类型';
comment on column UNICALL.APP_NB.pieces
  is '份数';
comment on column UNICALL.APP_NB.yearnum
  is '缴费年限';
comment on column UNICALL.APP_NB.saleattr
  is '销售渠道';
comment on column UNICALL.APP_NB.agt_rp_id
  is '业务员对应的ROLE_PLAYER主键';
comment on column UNICALL.APP_NB.agt_rp_type
  is '业务员对应的ROLE_PLAYER类型';
comment on column UNICALL.APP_NB.agt_no
  is '业务员工号';
comment on column UNICALL.APP_NB.owner_rp_id
  is '投保人对应的ROLE_PLAYER主键';
comment on column UNICALL.APP_NB.owner_rp_type
  is '业务员对应的ROLE_PLAYER类型';
comment on column UNICALL.APP_NB.owner_id
  is '投保人身份证';
comment on column UNICALL.APP_NB.insured_rp_id
  is '被保险人对应的ROLE_PLAYER主键';
comment on column UNICALL.APP_NB.insured_rp_type
  is '被保险人对应的ROLE_PLAYER类型';
comment on column UNICALL.APP_NB.insured_id
  is '被保险人身份证';
comment on column UNICALL.APP_NB.owner_insured_rlship
  is '投被保人关系';
comment on column UNICALL.APP_NB.rider_ind
  is '主附险标示';
comment on column UNICALL.APP_NB.prem_start_date
  is '缴费起始日期';
comment on column UNICALL.APP_NB.prem_end_date
  is '缴费终止日期';
comment on column UNICALL.APP_NB.rec_postal_code
  is '收费邮政编码';
comment on column UNICALL.APP_NB.rec_addr
  is '收费地址信息';
comment on column UNICALL.APP_NB.rec_tel
  is '收费联系电话';
comment on column UNICALL.APP_NB.prem_frq
  is '缴费频率';
comment on column UNICALL.APP_NB.prem_mthd
  is '缴费方式';
comment on column UNICALL.APP_NB.std_piece_prem
  is '每份标准保费';
comment on column UNICALL.APP_NB.std_add_piece_prem
  is '每份标准加费';
comment on column UNICALL.APP_NB.nonstd_add_piece_prem
  is '每份非标准加费';
comment on column UNICALL.APP_NB.agt_phone
  is '新保转账催缴电话（业务员电话，一般为手机）';
comment on column UNICALL.APP_NB.sale_type
  is '销售方式';
comment on column UNICALL.APP_NB.sale_prod_code
  is '销售产品代码（例如福宝宝产品代码）';
comment on column UNICALL.APP_NB.app_age
  is '投保年龄';
comment on column UNICALL.APP_NB.begtime
  is '开始日期';
comment on column UNICALL.APP_NB.endtime
  is '中止日期';
comment on column UNICALL.APP_NB.branch
  is '分公司代码';
comment on column UNICALL.APP_NB.etl_time
  is 'ETL处理时间';
comment on column UNICALL.APP_NB.src_sys
  is '来源系统';
comment on column UNICALL.APP_NB.app_confirm_no
  is '投保确认书号';
comment on column UNICALL.APP_NB.app_terminal_id
  is '投保终端设备号';
comment on column UNICALL.APP_NB.cross_sale_ind
  is '是否交叉销售标示';
comment on column UNICALL.APP_NB.sub_sale_type
  is '销售方式（二级分类）';
comment on column UNICALL.APP_NB.cstmzd_rcmd_no
  is '客制化推荐流水号';
comment on column UNICALL.APP_NB.app_ip_date
  is '投保单录入时间（到秒），录入后不再变化';
comment on column UNICALL.APP_NB.digital_sign_ind
  is '数字签名标识';

prompt
prompt Creating table APP_POS
prompt ======================
prompt
create table UNICALL.APP_POS
(
  sno           NUMBER(20),
  typeid        NUMBER(7) not null,
  changeid      CHAR(2) not null,
  status        CHAR(1) not null,
  procdate      DATE not null,
  abstr         VARCHAR2(500),
  appdate       DATE not null,
  modino        VARCHAR2(20) not null,
  con_id        NUMBER(20),
  policyno      VARCHAR2(20) not null,
  classcode     CHAR(8) not null,
  opdate        DATE not null,
  operid        NUMBER(20),
  operno        VARCHAR2(20) not null,
  oper_role     VARCHAR2(20),
  id            VARCHAR2(40),
  name          VARCHAR2(120),
  veri_no       VARCHAR2(20),
  veri_date     DATE,
  app_channel   VARCHAR2(3),
  begtime       NUMBER(11) not null,
  endtime       NUMBER(11) not null,
  branch        CHAR(14) not null,
  etl_time      DATE not null,
  src_sys       VARCHAR2(20) not null,
  ff_event_id   VARCHAR2(20),
  ff_event_type VARCHAR2(60),
  chief_pos_ind VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.APP_POS
  is '  保全服务';
comment on column UNICALL.APP_POS.sno
  is 'IAA物理主键';
comment on column UNICALL.APP_POS.typeid
  is '交易类型';
comment on column UNICALL.APP_POS.changeid
  is '变更类型编码';
comment on column UNICALL.APP_POS.status
  is '保全服务交易状态';
comment on column UNICALL.APP_POS.procdate
  is '交易生效日期';
comment on column UNICALL.APP_POS.abstr
  is '通融、撤保原因';
comment on column UNICALL.APP_POS.appdate
  is '交易申请日期';
comment on column UNICALL.APP_POS.modino
  is '业务交易批单号';
comment on column UNICALL.APP_POS.con_id
  is '保单IAA业务相关主键';
comment on column UNICALL.APP_POS.policyno
  is '保单号';
comment on column UNICALL.APP_POS.classcode
  is '险种';
comment on column UNICALL.APP_POS.opdate
  is '操作日期';
comment on column UNICALL.APP_POS.operid
  is '操作员IAA业务相关主键';
comment on column UNICALL.APP_POS.operno
  is '操作员工号';
comment on column UNICALL.APP_POS.oper_role
  is '操作员岗位类型';
comment on column UNICALL.APP_POS.id
  is '申请人身份证号';
comment on column UNICALL.APP_POS.name
  is '申请人姓名';
comment on column UNICALL.APP_POS.veri_no
  is '审核人工号
';
comment on column UNICALL.APP_POS.veri_date
  is '审核日期
';
comment on column UNICALL.APP_POS.app_channel
  is '受理渠道
';
comment on column UNICALL.APP_POS.begtime
  is '开始日期';
comment on column UNICALL.APP_POS.endtime
  is '中止日期';
comment on column UNICALL.APP_POS.branch
  is '分公司代码';
comment on column UNICALL.APP_POS.etl_time
  is 'ETL处理时间';
comment on column UNICALL.APP_POS.src_sys
  is '来源系统';
comment on column UNICALL.APP_POS.ff_event_id
  is 'FF事件号';
comment on column UNICALL.APP_POS.ff_event_type
  is 'FF事件类型';
comment on column UNICALL.APP_POS.chief_pos_ind
  is '是否主变更类型';
create index UNICALL.IDX_APP_POS_CHANGEID on UNICALL.APP_POS (CHANGEID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_APP_POS_ID on UNICALL.APP_POS (ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.APP_POS
  add constraint APP_POS_BK_PRIMARY primary key (MODINO, POLICYNO, CLASSCODE)
  disable;

prompt
prompt Creating table APP_POS_ID
prompt =========================
prompt
create table UNICALL.APP_POS_ID
(
  sno           NUMBER(20),
  typeid        NUMBER(7) not null,
  changeid      CHAR(2),
  status        CHAR(1) not null,
  procdate      DATE not null,
  abstr         VARCHAR2(500),
  appdate       DATE not null,
  modino        VARCHAR2(20) not null,
  con_id        NUMBER(20),
  oid_num       VARCHAR2(100),
  id            VARCHAR2(40) not null,
  id15          VARCHAR2(20),
  opdate        DATE not null,
  operid        NUMBER(20),
  operno        VARCHAR2(20) not null,
  oper_role     VARCHAR2(20),
  veri_no       VARCHAR2(20),
  veri_date     DATE,
  app_channel   VARCHAR2(3),
  begtime       NUMBER(11) not null,
  endtime       NUMBER(11) not null,
  branch        CHAR(14) not null,
  etl_time      DATE not null,
  src_sys       VARCHAR2(20) not null,
  ff_event_id   VARCHAR2(20),
  ff_event_type VARCHAR2(60),
  pos_print_ind VARCHAR2(1),
  chief_pos_ind VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.APP_POS_ID
  is '  变更申请表';
comment on column UNICALL.APP_POS_ID.sno
  is 'IAA物理主键';
comment on column UNICALL.APP_POS_ID.typeid
  is '交易类型';
comment on column UNICALL.APP_POS_ID.changeid
  is '变更类型编码';
comment on column UNICALL.APP_POS_ID.status
  is '保全服务交易状态';
comment on column UNICALL.APP_POS_ID.procdate
  is '交易生效日期';
comment on column UNICALL.APP_POS_ID.abstr
  is '通融、撤保原因';
comment on column UNICALL.APP_POS_ID.appdate
  is '交易申请日期';
comment on column UNICALL.APP_POS_ID.modino
  is '业务交易批单号';
comment on column UNICALL.APP_POS_ID.con_id
  is '保单IAA业务相关主键';
comment on column UNICALL.APP_POS_ID.oid_num
  is '客户代码';
comment on column UNICALL.APP_POS_ID.id
  is '申请人身份证号';
comment on column UNICALL.APP_POS_ID.id15
  is '15位身份证号';
comment on column UNICALL.APP_POS_ID.opdate
  is '操作日期';
comment on column UNICALL.APP_POS_ID.operid
  is '操作员IAA业务相关主键';
comment on column UNICALL.APP_POS_ID.operno
  is '操作员工号';
comment on column UNICALL.APP_POS_ID.oper_role
  is '操作员岗位类型';
comment on column UNICALL.APP_POS_ID.veri_no
  is '审核人工号
';
comment on column UNICALL.APP_POS_ID.veri_date
  is '审核日期
';
comment on column UNICALL.APP_POS_ID.app_channel
  is '受理渠道
';
comment on column UNICALL.APP_POS_ID.begtime
  is '开始日期';
comment on column UNICALL.APP_POS_ID.endtime
  is '中止日期';
comment on column UNICALL.APP_POS_ID.branch
  is '分公司代码';
comment on column UNICALL.APP_POS_ID.etl_time
  is 'ETL处理时间';
comment on column UNICALL.APP_POS_ID.src_sys
  is '来源系统';
comment on column UNICALL.APP_POS_ID.ff_event_id
  is 'FF事件号';
comment on column UNICALL.APP_POS_ID.ff_event_type
  is 'FF事件类型';
comment on column UNICALL.APP_POS_ID.pos_print_ind
  is '批单打印标示';
comment on column UNICALL.APP_POS_ID.chief_pos_ind
  is '是否主变更类型';
create index UNICALL.IDX_APP_POS_ID_CHANGEID on UNICALL.APP_POS_ID (CHANGEID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_APP_POS_ID_ID on UNICALL.APP_POS_ID (ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_APP_POS_ID_ID15 on UNICALL.APP_POS_ID (ID15)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table BACK_FILE
prompt ========================
prompt
create table UNICALL.BACK_FILE
(
  appno      VARCHAR2(15) not null,
  updatedate VARCHAR2(19) not null,
  backstatus VARCHAR2(3) not null,
  note       VARCHAR2(500)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.BACK_FILE.appno
  is '投保单号';
comment on column UNICALL.BACK_FILE.updatedate
  is '更新时间';
comment on column UNICALL.BACK_FILE.backstatus
  is '投保单状态';
comment on column UNICALL.BACK_FILE.note
  is '状态变更说明';

prompt
prompt Creating table BANKCOMM_APP_NB
prompt ==============================
prompt
create table UNICALL.BANKCOMM_APP_NB
(
  sno                   NUMBER(20) not null,
  typeid                NUMBER(7),
  status                CHAR(2),
  procdate              DATE,
  abstr                 VARCHAR2(500),
  appdate               DATE,
  appno                 VARCHAR2(40),
  con_id                NUMBER(20),
  policyno              VARCHAR2(20),
  classcode             CHAR(8),
  opdate                DATE,
  operid                NUMBER(20),
  operno                VARCHAR2(20),
  oper_role             VARCHAR2(20),
  pieces                NUMBER(20,6),
  yearnum               NUMBER(10),
  saleattr              CHAR(2),
  agt_rp_id             NUMBER(20),
  agt_rp_type           NUMBER(7),
  agt_no                VARCHAR2(20),
  owner_rp_id           NUMBER(20),
  owner_rp_type         NUMBER(7),
  owner_id              VARCHAR2(40),
  insured_rp_id         NUMBER(20),
  insured_rp_type       NUMBER(7),
  insured_id            VARCHAR2(40),
  owner_insured_rlship  CHAR(3),
  rider_ind             CHAR(1),
  prem_start_date       DATE,
  prem_end_date         DATE,
  rec_postal_code       VARCHAR2(20),
  rec_addr              VARCHAR2(500),
  rec_tel               VARCHAR2(30),
  prem_frq              CHAR(2),
  prem_mthd             CHAR(1),
  std_piece_prem        NUMBER(20,6),
  std_add_piece_prem    NUMBER(10,2),
  nonstd_add_piece_prem NUMBER(10,2),
  agt_phone             VARCHAR2(30),
  sale_type             CHAR(2),
  sale_prod_code        VARCHAR2(8),
  app_age               NUMBER(3),
  begtime               NUMBER(11),
  endtime               NUMBER(11),
  branch                CHAR(14),
  etl_time              DATE,
  src_sys               VARCHAR2(20),
  app_confirm_no        VARCHAR2(20),
  app_terminal_id       VARCHAR2(20),
  cross_sale_ind        VARCHAR2(1),
  sub_sale_type         VARCHAR2(2),
  cstmzd_rcmd_no        VARCHAR2(30),
  create_time           DATE not null,
  update_time           DATE,
  mark_state            CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.BANKCOMM_APP_NB
  is 'IAA物理主键';
comment on column UNICALL.BANKCOMM_APP_NB.sno
  is 'IAA物理主键';
comment on column UNICALL.BANKCOMM_APP_NB.typeid
  is '交易类型';
comment on column UNICALL.BANKCOMM_APP_NB.status
  is '交易状态（只需要生效后的交易，所有投保单），投保单状态';
comment on column UNICALL.BANKCOMM_APP_NB.procdate
  is '交易生效日期';
comment on column UNICALL.BANKCOMM_APP_NB.abstr
  is '原因';
comment on column UNICALL.BANKCOMM_APP_NB.appdate
  is '交易申请日期';
comment on column UNICALL.BANKCOMM_APP_NB.appno
  is '投保单号';
comment on column UNICALL.BANKCOMM_APP_NB.con_id
  is '保单IAA业务相关主键';
comment on column UNICALL.BANKCOMM_APP_NB.policyno
  is '保单号';
comment on column UNICALL.BANKCOMM_APP_NB.classcode
  is '险种';
comment on column UNICALL.BANKCOMM_APP_NB.opdate
  is '操作日期';
comment on column UNICALL.BANKCOMM_APP_NB.operid
  is '操作员IAA业务相关主键';
comment on column UNICALL.BANKCOMM_APP_NB.operno
  is '操作员工号';
comment on column UNICALL.BANKCOMM_APP_NB.oper_role
  is '操作员岗位类型';
comment on column UNICALL.BANKCOMM_APP_NB.pieces
  is '份数';
comment on column UNICALL.BANKCOMM_APP_NB.yearnum
  is '缴费年限';
comment on column UNICALL.BANKCOMM_APP_NB.saleattr
  is '销售渠道';
comment on column UNICALL.BANKCOMM_APP_NB.agt_rp_id
  is '业务员对应的ROLE_PLAYER主键';
comment on column UNICALL.BANKCOMM_APP_NB.agt_rp_type
  is '业务员对应的ROLE_PLAYER类型';
comment on column UNICALL.BANKCOMM_APP_NB.agt_no
  is '业务员工号';
comment on column UNICALL.BANKCOMM_APP_NB.owner_rp_id
  is '投保人对应的ROLE_PLAYER主键';
comment on column UNICALL.BANKCOMM_APP_NB.owner_rp_type
  is '业务员对应的ROLE_PLAYER类型';
comment on column UNICALL.BANKCOMM_APP_NB.owner_id
  is '投保人身份证';
comment on column UNICALL.BANKCOMM_APP_NB.insured_rp_id
  is '被保险人对应的ROLE_PLAYER主键';
comment on column UNICALL.BANKCOMM_APP_NB.insured_rp_type
  is '被保险人对应的ROLE_PLAYER类型';
comment on column UNICALL.BANKCOMM_APP_NB.insured_id
  is '被保险人身份证';
comment on column UNICALL.BANKCOMM_APP_NB.owner_insured_rlship
  is '投被保人关系';
comment on column UNICALL.BANKCOMM_APP_NB.rider_ind
  is '主附险标示';
comment on column UNICALL.BANKCOMM_APP_NB.prem_start_date
  is '缴费起始日期';
comment on column UNICALL.BANKCOMM_APP_NB.prem_end_date
  is '缴费终止日期';
comment on column UNICALL.BANKCOMM_APP_NB.rec_postal_code
  is '收费邮政编码';
comment on column UNICALL.BANKCOMM_APP_NB.rec_addr
  is '收费地址信息';
comment on column UNICALL.BANKCOMM_APP_NB.rec_tel
  is '收费联系电话';
comment on column UNICALL.BANKCOMM_APP_NB.prem_frq
  is '缴费频率';
comment on column UNICALL.BANKCOMM_APP_NB.prem_mthd
  is '缴费方式';
comment on column UNICALL.BANKCOMM_APP_NB.std_piece_prem
  is '每份标准保费';
comment on column UNICALL.BANKCOMM_APP_NB.std_add_piece_prem
  is '每份标准加费';
comment on column UNICALL.BANKCOMM_APP_NB.nonstd_add_piece_prem
  is '每份非标准加费';
comment on column UNICALL.BANKCOMM_APP_NB.agt_phone
  is '新保转账催缴电话（业务员电话，一般为手机）';
comment on column UNICALL.BANKCOMM_APP_NB.sale_type
  is '销售方式';
comment on column UNICALL.BANKCOMM_APP_NB.sale_prod_code
  is '销售产品代码（例如福宝宝产品代码）';
comment on column UNICALL.BANKCOMM_APP_NB.app_age
  is '投保年龄';
comment on column UNICALL.BANKCOMM_APP_NB.begtime
  is '开始日期';
comment on column UNICALL.BANKCOMM_APP_NB.endtime
  is '中止日期';
comment on column UNICALL.BANKCOMM_APP_NB.branch
  is '分公司代码';
comment on column UNICALL.BANKCOMM_APP_NB.etl_time
  is 'ETL处理时间';
comment on column UNICALL.BANKCOMM_APP_NB.src_sys
  is '来源系统';
comment on column UNICALL.BANKCOMM_APP_NB.app_confirm_no
  is '投保确认书号';
comment on column UNICALL.BANKCOMM_APP_NB.app_terminal_id
  is '投保终端设备号';
comment on column UNICALL.BANKCOMM_APP_NB.cross_sale_ind
  is '是否交叉销售标示';
comment on column UNICALL.BANKCOMM_APP_NB.sub_sale_type
  is '销售方式（二级分类）';
comment on column UNICALL.BANKCOMM_APP_NB.cstmzd_rcmd_no
  is '客制化推荐流水号';
comment on column UNICALL.BANKCOMM_APP_NB.create_time
  is '创建时间';
comment on column UNICALL.BANKCOMM_APP_NB.update_time
  is '更新时间';
comment on column UNICALL.BANKCOMM_APP_NB.mark_state
  is '状态标示 1：插入 2：更新';
create index UNICALL.IDX_BANKCOMM_APP_NB_MARK_STATE on UNICALL.BANKCOMM_APP_NB (MARK_STATE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_BANKCOMM_POLICYNO on UNICALL.BANKCOMM_APP_NB (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.BANKCOMM_APP_NB
  add constraint PK_BANKCOMM_APP_NB primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.BANKCOMM_APP_NB
  add constraint BK_BANKCOMM_APP_NB unique (APPNO, CLASSCODE)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table BANKCOMM_INFO
prompt ============================
prompt
create table UNICALL.BANKCOMM_INFO
(
  id          NUMBER not null,
  id_type     VARCHAR2(30) not null,
  id_no       VARCHAR2(60) not null,
  proid       CHAR(30) not null,
  appno       CHAR(52),
  idorg       VARCHAR2(18),
  firstcreate DATE,
  app_status  VARCHAR2(3),
  regdate     DATE,
  opdate      DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 4M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.BANKCOMM_INFO.id
  is 'ID';
comment on column UNICALL.BANKCOMM_INFO.id_type
  is '证件类型';
comment on column UNICALL.BANKCOMM_INFO.id_no
  is '证件编号';
comment on column UNICALL.BANKCOMM_INFO.proid
  is '产品代码';
comment on column UNICALL.BANKCOMM_INFO.appno
  is '投保单号';
comment on column UNICALL.BANKCOMM_INFO.idorg
  is '中支公司';
comment on column UNICALL.BANKCOMM_INFO.firstcreate
  is '创建时间';
comment on column UNICALL.BANKCOMM_INFO.app_status
  is '投保单状态';
comment on column UNICALL.BANKCOMM_INFO.regdate
  is '退保日期';
comment on column UNICALL.BANKCOMM_INFO.opdate
  is '承保日期';

prompt
prompt Creating table BANKCOMM_POLICY_SEND
prompt ===================================
prompt
create table UNICALL.BANKCOMM_POLICY_SEND
(
  sno          NUMBER(20) not null,
  typeid       NUMBER(7),
  policyno     VARCHAR2(20),
  empno        VARCHAR2(20),
  senddate     DATE,
  canceldate   DATE,
  process_date DATE,
  sendoperno   VARCHAR2(20),
  canceloperno VARCHAR2(20),
  begtime      NUMBER(11),
  endtime      NUMBER(11),
  branch       CHAR(14),
  etl_time     DATE,
  src_sys      VARCHAR2(20),
  create_time  DATE,
  update_time  DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table UNICALL.BANKCOMM_POLICY_SEND
  is '  保单回执情况';
comment on column UNICALL.BANKCOMM_POLICY_SEND.sno
  is '  IAA物理主键';
comment on column UNICALL.BANKCOMM_POLICY_SEND.typeid
  is '  IAA数据类型';
comment on column UNICALL.BANKCOMM_POLICY_SEND.policyno
  is '  保单号';
comment on column UNICALL.BANKCOMM_POLICY_SEND.empno
  is '  业务员代码';
comment on column UNICALL.BANKCOMM_POLICY_SEND.senddate
  is '  派发日期';
comment on column UNICALL.BANKCOMM_POLICY_SEND.canceldate
  is '  客户签收日期';
comment on column UNICALL.BANKCOMM_POLICY_SEND.process_date
  is '  回执录入系统日期';
comment on column UNICALL.BANKCOMM_POLICY_SEND.sendoperno
  is '  派发人';
comment on column UNICALL.BANKCOMM_POLICY_SEND.canceloperno
  is '  销号人';
comment on column UNICALL.BANKCOMM_POLICY_SEND.begtime
  is '  开始日期';
comment on column UNICALL.BANKCOMM_POLICY_SEND.endtime
  is '  中止日期';
comment on column UNICALL.BANKCOMM_POLICY_SEND.branch
  is '  分公司代码';
comment on column UNICALL.BANKCOMM_POLICY_SEND.etl_time
  is '  ETL处理时间';
comment on column UNICALL.BANKCOMM_POLICY_SEND.src_sys
  is '  来源系统';
comment on column UNICALL.BANKCOMM_POLICY_SEND.create_time
  is '创建时间';
comment on column UNICALL.BANKCOMM_POLICY_SEND.update_time
  is '更新时间';
alter table UNICALL.BANKCOMM_POLICY_SEND
  add constraint PK_BANKCOMM_POLICY_SEND primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.BANKCOMM_POLICY_SEND
  add constraint BK_BANKCOMM_POLICY_SEND unique (POLICYNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table BANKCOMM_PRINT_ACTVTY
prompt ====================================
prompt
create table UNICALL.BANKCOMM_PRINT_ACTVTY
(
  print_actvty_id     NUMBER(20) not null,
  sno                 NUMBER(20),
  print_job_name      VARCHAR2(100),
  print_type          CHAR(1),
  oper_type           CHAR(1),
  print_busi_no       VARCHAR2(60),
  status              CHAR(1),
  create_date         DATE,
  print_date          DATE,
  dispatch_date       DATE,
  receive_date        DATE,
  begtime             NUMBER(11),
  endtime             NUMBER(11),
  branch              CHAR(14),
  etl_time            DATE,
  src_sys             VARCHAR2(20),
  oper_no             VARCHAR2(20),
  print_pieces        NUMBER(10),
  print_desc          VARCHAR2(1024),
  commit_date         DATE,
  print_center        VARCHAR2(20),
  busi_branch         VARCHAR2(20),
  dispatch_branch_lv4 VARCHAR2(14),
  create_time         DATE,
  update_time         DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255;
comment on table UNICALL.BANKCOMM_PRINT_ACTVTY
  is '  打印记录';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.print_actvty_id
  is '物理主键';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.sno
  is '  记录行号';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.print_job_name
  is '  打印作业名称';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.print_type
  is '  打印类型';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.oper_type
  is '  打印操作类型';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.print_busi_no
  is '  打印业务单号（集中出单个险存放个人保单号，集中出单团险存放团体保单号）';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.status
  is '  状态';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.create_date
  is '  打印任务创建日期';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.print_date
  is '  打印日期';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.dispatch_date
  is '  分发日期';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.receive_date
  is '  邮包收发岗签收保单的日期';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.begtime
  is '  开始日期';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.endtime
  is '  中止日期';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.branch
  is '  分公司代码';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.etl_time
  is '  ETL处理时间';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.src_sys
  is '  来源系统';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.oper_no
  is '操作员工号';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.print_pieces
  is '打印份数';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.print_desc
  is '打印报告描述';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.commit_date
  is '打印提交日期（精确到秒）';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.print_center
  is '制单中心代码';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.busi_branch
  is '业务归属中支（存放集中出单的7位机构代码）';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.dispatch_branch_lv4
  is '县区代码（14位机构代码）不为空，表示该作业采取区县直递，如果为空，表示不是区县直递';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.create_time
  is '创建时间';
comment on column UNICALL.BANKCOMM_PRINT_ACTVTY.update_time
  is '更新时间';
alter table UNICALL.BANKCOMM_PRINT_ACTVTY
  add constraint PK_BANKCOMM_PRINT_ACTVTY primary key (PRINT_ACTVTY_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.BANKCOMM_PRINT_ACTVTY
  add constraint BK_BANKCOMM_PRINT_ACTVTY unique (PRINT_JOB_NAME, PRINT_TYPE, PRINT_BUSI_NO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table BAN_SHCPIC_PREINS_CUS_INF
prompt ========================================
prompt
create table UNICALL.BAN_SHCPIC_PREINS_CUS_INF
(
  ban_shcpic_preins_cus_inf_id  NUMBER(10) not null,
  ban_shcpic_preins_cus_inf_num VARCHAR2(20),
  c_agentcompany_code           VARCHAR2(100),
  ban_shcpic_preins_cus_inf_nam VARCHAR2(100),
  ban_shcpic_preins_cus_inf_tab VARCHAR2(100),
  ban_shcpic_preins_cus_inf_dat VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 9M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.BAN_SHCPIC_PREINS_CUS_INF
  add constraint PK_BAN_SHCPIC_PREINS_CUS_INF primary key (BAN_SHCPIC_PREINS_CUS_INF_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 4M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C
prompt ================
prompt
create global temporary table UNICALL.C
(
  id      INTEGER,
  orgname VARCHAR2(20),
  d1      NUMBER(20,6),
  n1      NUMBER(20,6),
  rate1   NUMBER(20,6),
  d2      NUMBER(20,6),
  n2      NUMBER(20,6),
  rate2   NUMBER(20,6),
  d3      NUMBER(20,6),
  n3      NUMBER(20,6),
  rate3   NUMBER(20,6),
  d4      NUMBER(20,6),
  n4      NUMBER(20,6),
  rate4   NUMBER(20,6)
)
on commit delete rows;

prompt
prompt Creating table CHARGE_FAILURE
prompt =============================
prompt
create table UNICALL.CHARGE_FAILURE
(
  sno             NUMBER(20),
  typeid          NUMBER(7) not null,
  policyno        VARCHAR2(20) not null,
  bankcode        VARCHAR2(24) not null,
  bankno          CHAR(30) not null,
  pid             VARCHAR2(40),
  name            VARCHAR2(120),
  amount          NUMBER(15,2),
  status          CHAR(2),
  reason          VARCHAR2(200),
  cover1          DATE,
  cover2          DATE,
  appdate         DATE not null,
  transfer_reason CHAR(1) not null,
  begtime         NUMBER(11) not null,
  endtime         NUMBER(11) not null,
  branch          CHAR(14) not null,
  etl_time        TIMESTAMP(6) not null,
  src_sys         VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 4M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.CHARGE_FAILURE
  is '  转帐结果';
comment on column UNICALL.CHARGE_FAILURE.sno
  is '  IAA物理主键';
comment on column UNICALL.CHARGE_FAILURE.typeid
  is '  IAA数据类型';
comment on column UNICALL.CHARGE_FAILURE.policyno
  is '  保单号';
comment on column UNICALL.CHARGE_FAILURE.bankcode
  is '  银行代码';
comment on column UNICALL.CHARGE_FAILURE.bankno
  is '  银行账号';
comment on column UNICALL.CHARGE_FAILURE.pid
  is '  身份证号';
comment on column UNICALL.CHARGE_FAILURE.name
  is '  姓名';
comment on column UNICALL.CHARGE_FAILURE.amount
  is '  金额';
comment on column UNICALL.CHARGE_FAILURE.status
  is '  扣款状态';
comment on column UNICALL.CHARGE_FAILURE.reason
  is '  状态原因';
comment on column UNICALL.CHARGE_FAILURE.cover1
  is '  cover1';
comment on column UNICALL.CHARGE_FAILURE.cover2
  is '  cover2';
comment on column UNICALL.CHARGE_FAILURE.appdate
  is '  扣款日期';
comment on column UNICALL.CHARGE_FAILURE.transfer_reason
  is '  转帐原因';
comment on column UNICALL.CHARGE_FAILURE.begtime
  is '  开始日期';
comment on column UNICALL.CHARGE_FAILURE.endtime
  is '  中止日期';
comment on column UNICALL.CHARGE_FAILURE.branch
  is '  分公司代码';
comment on column UNICALL.CHARGE_FAILURE.etl_time
  is '  ETL处理时间';
comment on column UNICALL.CHARGE_FAILURE.src_sys
  is '  来源系统';
create index UNICALL.IDX_CHARGE_FAILURE_POLICYNO on UNICALL.CHARGE_FAILURE (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_COMPANY
prompt =============================
prompt
create table UNICALL.SHCPIC_COMPANY
(
  id                   NUMBER(10) not null,
  company_code         VARCHAR2(20),
  company_name         VARCHAR2(50),
  operate_user_code    VARCHAR2(20),
  operate_user_name    VARCHAR2(20),
  is_del               VARCHAR2(2),
  is_branch_company    VARCHAR2(2),
  parent_company_id    NUMBER(10),
  isff                 VARCHAR2(2),
  company_finance_code VARCHAR2(10),
  region_code          VARCHAR2(30),
  company_type         CHAR(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_COMPANY.isff
  is '配送保单时辅助判断是否长险：1 是，0 否';
comment on column UNICALL.SHCPIC_COMPANY.company_finance_code
  is '财务机构代码';
comment on column UNICALL.SHCPIC_COMPANY.region_code
  is '区域编码';
comment on column UNICALL.SHCPIC_COMPANY.company_type
  is '机构类型：01:分公司;02:中支公司;03:内部职场;04:外包职场;';
alter table UNICALL.SHCPIC_COMPANY
  add constraint PK_COMPANY primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
grant select on UNICALL.SHCPIC_COMPANY to SXDXETL;

prompt
prompt Creating table COMPANY_ABBREVIATION
prompt ===================================
prompt
create table UNICALL.COMPANY_ABBREVIATION
(
  id           NUMBER(10) not null,
  abbreviation VARCHAR2(3) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.COMPANY_ABBREVIATION
  is '分公司简称';
comment on column UNICALL.COMPANY_ABBREVIATION.id
  is '公司id';
comment on column UNICALL.COMPANY_ABBREVIATION.abbreviation
  is '简称';
alter table UNICALL.COMPANY_ABBREVIATION
  add constraint PK_COMPANY_ABBREVIATION primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.COMPANY_ABBREVIATION
  add constraint FK_COMPANY_ABBR_ID foreign key (ID)
  references UNICALL.SHCPIC_COMPANY (ID);

prompt
prompt Creating table COMPANY_DATACONTROL
prompt ==================================
prompt
create table UNICALL.COMPANY_DATACONTROL
(
  pk_id        NUMBER not null,
  use_id       NUMBER(10),
  data_control NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.COMPANY_DATACONTROL
  add constraint PK_COMPANY_DATACONTROL primary key (PK_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CONTINUATION
prompt ===========================
prompt
create global temporary table UNICALL.CONTINUATION
(
  id      INTEGER,
  orgname VARCHAR2(20),
  d1      NUMBER(20,6),
  n1      NUMBER(20,6),
  rate1   NUMBER(20,6),
  d2      NUMBER(20,6),
  n2      NUMBER(20,6),
  rate2   NUMBER(20,6),
  d3      NUMBER(20,6),
  n3      NUMBER(20,6),
  rate3   NUMBER(20,6),
  d4      NUMBER(20,6),
  n4      NUMBER(20,6),
  rate4   NUMBER(20,6)
)
on commit delete rows;
comment on table UNICALL.CONTINUATION
  is '继续率报表展现表';
comment on column UNICALL.CONTINUATION.id
  is '排序字段';
comment on column UNICALL.CONTINUATION.orgname
  is '机构名称';
comment on column UNICALL.CONTINUATION.d1
  is '当月分子';
comment on column UNICALL.CONTINUATION.n1
  is '当月分母';
comment on column UNICALL.CONTINUATION.rate1
  is '当月继续率';
comment on column UNICALL.CONTINUATION.d2
  is '宽一分子';
comment on column UNICALL.CONTINUATION.n2
  is '宽一分母';
comment on column UNICALL.CONTINUATION.rate2
  is '宽一继续率';
comment on column UNICALL.CONTINUATION.d3
  is '宽末分子';
comment on column UNICALL.CONTINUATION.n3
  is '宽末分母';
comment on column UNICALL.CONTINUATION.rate3
  is '宽末继续率';
comment on column UNICALL.CONTINUATION.d4
  is '累计分子';
comment on column UNICALL.CONTINUATION.n4
  is '累计分母';
comment on column UNICALL.CONTINUATION.rate4
  is '累计继续率';

prompt
prompt Creating table CPIC_BOCOM_CARD_SFT
prompt ==================================
prompt
create table UNICALL.CPIC_BOCOM_CARD_SFT
(
  id          NUMBER(10) not null,
  card_id     VARCHAR2(19) not null,
  insu_id     VARCHAR2(15) not null,
  order_id    VARCHAR2(24) not null,
  mer_code    VARCHAR2(8) not null,
  retb_date   VARCHAR2(8) not null,
  return_code VARCHAR2(2) not null,
  imp_date    DATE not null,
  res1        VARCHAR2(100),
  res2        VARCHAR2(100),
  res3        VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on column UNICALL.CPIC_BOCOM_CARD_SFT.id
  is '主键';
comment on column UNICALL.CPIC_BOCOM_CARD_SFT.card_id
  is '客户信用卡卡号';
comment on column UNICALL.CPIC_BOCOM_CARD_SFT.insu_id
  is '投保单号';
comment on column UNICALL.CPIC_BOCOM_CARD_SFT.order_id
  is '订单号，格式：XXXCCCCCCCCCYYYYMMDDNNNN';
comment on column UNICALL.CPIC_BOCOM_CARD_SFT.mer_code
  is '商户代码';
comment on column UNICALL.CPIC_BOCOM_CARD_SFT.retb_date
  is '回盘日期';
comment on column UNICALL.CPIC_BOCOM_CARD_SFT.return_code
  is '返回码，00―表示调额成功';
comment on column UNICALL.CPIC_BOCOM_CARD_SFT.imp_date
  is '数据导入日期';
comment on column UNICALL.CPIC_BOCOM_CARD_SFT.res1
  is '备用字段1';
comment on column UNICALL.CPIC_BOCOM_CARD_SFT.res2
  is '备用字段2';
comment on column UNICALL.CPIC_BOCOM_CARD_SFT.res3
  is '备用字段3';
alter table UNICALL.CPIC_BOCOM_CARD_SFT
  add constraint PK_CPIC_BOCOM_CARD_SFT primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table CPIC_CLASSCOD_EFTOFF
prompt ===================================
prompt
create table UNICALL.CPIC_CLASSCOD_EFTOFF
(
  oldclasscode VARCHAR2(6),
  newclasscode VARCHAR2(8),
  sex          VARCHAR2(1),
  paystd       VARCHAR2(1),
  dutystd      VARCHAR2(1),
  yearnum      VARCHAR2(10),
  period       VARCHAR2(10),
  delway       VARCHAR2(1),
  yearnum1     VARCHAR2(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.CPIC_CLASSCOD_EFTOFF
  is 'EF to FF 险种转换定义表';
comment on column UNICALL.CPIC_CLASSCOD_EFTOFF.oldclasscode
  is '原险种代码';
comment on column UNICALL.CPIC_CLASSCOD_EFTOFF.newclasscode
  is '转换后的险种代码';
comment on column UNICALL.CPIC_CLASSCOD_EFTOFF.sex
  is '性别';

prompt
prompt Creating table CPIC_CONFIG
prompt ==========================
prompt
create table UNICALL.CPIC_CONFIG
(
  key       VARCHAR2(500) not null,
  value     VARCHAR2(1024),
  comments  VARCHAR2(1024),
  is_delete NUMBER(1) default 0 not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.CPIC_CONFIG
  is '配置表';
comment on column UNICALL.CPIC_CONFIG.key
  is 'key';
comment on column UNICALL.CPIC_CONFIG.value
  is 'value';
comment on column UNICALL.CPIC_CONFIG.comments
  is '备注';
comment on column UNICALL.CPIC_CONFIG.is_delete
  is '是否删除 0：否，1：是';
alter table UNICALL.CPIC_CONFIG
  add constraint PK_CPIC_CONFIG_KEY primary key (KEY)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CPIC_CUSINS_AUTO_LOAD
prompt ====================================
prompt
create table UNICALL.CPIC_CUSINS_AUTO_LOAD
(
  id          NUMBER(20) not null,
  file_name   VARCHAR2(50) not null,
  file_path   VARCHAR2(100) not null,
  upload_date DATE not null,
  use_ali_id  VARCHAR2(20) not null,
  file_type   VARCHAR2(2) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.CPIC_CUSINS_AUTO_LOAD
  is '自动名单上载';
comment on column UNICALL.CPIC_CUSINS_AUTO_LOAD.file_name
  is '文件名称';
comment on column UNICALL.CPIC_CUSINS_AUTO_LOAD.file_path
  is '文件路径';
comment on column UNICALL.CPIC_CUSINS_AUTO_LOAD.upload_date
  is '上传日期';
comment on column UNICALL.CPIC_CUSINS_AUTO_LOAD.use_ali_id
  is '上传坐席工号';
comment on column UNICALL.CPIC_CUSINS_AUTO_LOAD.file_type
  is '上传文件类型1、批次.2、名单';
create index UNICALL.INDEX_C_C_A_L_DATE on UNICALL.CPIC_CUSINS_AUTO_LOAD (UPLOAD_DATE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.INDEX_C_C_A_L_PATH on UNICALL.CPIC_CUSINS_AUTO_LOAD (FILE_PATH)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.CPIC_CUSINS_AUTO_LOAD
  add constraint PK_C_C_A_LOAD_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CPIC_CUS_BLACKLIST
prompt =================================
prompt
create table UNICALL.CPIC_CUS_BLACKLIST
(
  cus_id      NUMBER(10) not null,
  cus_nam     VARCHAR2(50),
  ide_typ     VARCHAR2(2),
  ide_num     VARCHAR2(50),
  mobile      VARCHAR2(20),
  hom_tel     VARCHAR2(30),
  off_tel     VARCHAR2(30),
  other_tel   VARCHAR2(30),
  use_id      NUMBER(10),
  creat_time  VARCHAR2(20),
  stat        VARCHAR2(2),
  res1        VARCHAR2(100),
  res2        VARCHAR2(100),
  res3        VARCHAR2(100),
  send_status VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.CPIC_CUS_BLACKLIST
  is '黑名单基本信息表';
comment on column UNICALL.CPIC_CUS_BLACKLIST.cus_id
  is '序列号，主键';
comment on column UNICALL.CPIC_CUS_BLACKLIST.cus_nam
  is '客户姓名';
comment on column UNICALL.CPIC_CUS_BLACKLIST.ide_typ
  is '证件类型,0身份证';
comment on column UNICALL.CPIC_CUS_BLACKLIST.ide_num
  is '证件编号';
comment on column UNICALL.CPIC_CUS_BLACKLIST.mobile
  is '手机号码';
comment on column UNICALL.CPIC_CUS_BLACKLIST.hom_tel
  is '家庭电话';
comment on column UNICALL.CPIC_CUS_BLACKLIST.off_tel
  is '办公电话';
comment on column UNICALL.CPIC_CUS_BLACKLIST.other_tel
  is '其他电话';
comment on column UNICALL.CPIC_CUS_BLACKLIST.use_id
  is '用户ID';
comment on column UNICALL.CPIC_CUS_BLACKLIST.creat_time
  is '创建时间';
comment on column UNICALL.CPIC_CUS_BLACKLIST.stat
  is '状态';
comment on column UNICALL.CPIC_CUS_BLACKLIST.res1
  is '备用1';
comment on column UNICALL.CPIC_CUS_BLACKLIST.res2
  is '备用2';
comment on column UNICALL.CPIC_CUS_BLACKLIST.res3
  is '备用3';
comment on column UNICALL.CPIC_CUS_BLACKLIST.send_status
  is '是否供数（00或者NULL-未供数，01-已供数）';
alter table UNICALL.CPIC_CUS_BLACKLIST
  add constraint PK_CPIC_CUS_BLACKLIST primary key (CUS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CPIC_CUS_TYPE_BAND
prompt =================================
prompt
create table UNICALL.CPIC_CUS_TYPE_BAND
(
  cus_id       NUMBER not null,
  prevent_flag CHAR(1),
  active_id    NUMBER,
  oper_id      NUMBER,
  oper_date    VARCHAR2(50),
  check_status CHAR(1),
  check_id     NUMBER,
  check_date   VARCHAR2(50),
  prevent_sta  VARCHAR2(50),
  prevent_end  VARCHAR2(50),
  ext_1        VARCHAR2(50),
  ext_2        VARCHAR2(50)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.CPIC_CUS_TYPE_BAND
  is '白名单客户管理';
alter table UNICALL.CPIC_CUS_TYPE_BAND
  add constraint PK_CPIC_CUS_TYPE_BAND primary key (CUS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CPIC_MAR_PRESENTINS_FAIL
prompt =======================================
prompt
create table UNICALL.CPIC_MAR_PRESENTINS_FAIL
(
  id            NUMBER(10) not null,
  imp_ser_num   VARCHAR2(20),
  imp_file_name VARCHAR2(100),
  imp_content   VARCHAR2(1024),
  fail_reason   VARCHAR2(300),
  create_time   DATE,
  mar_imp_time  DATE,
  state         CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.CPIC_MAR_PRESENTINS_FAIL
  is '行销网站导入赠险失败数据';
comment on column UNICALL.CPIC_MAR_PRESENTINS_FAIL.id
  is 'ID';
comment on column UNICALL.CPIC_MAR_PRESENTINS_FAIL.imp_ser_num
  is '导入编号';
comment on column UNICALL.CPIC_MAR_PRESENTINS_FAIL.imp_file_name
  is '导入文件名';
comment on column UNICALL.CPIC_MAR_PRESENTINS_FAIL.imp_content
  is '导入报文';
comment on column UNICALL.CPIC_MAR_PRESENTINS_FAIL.fail_reason
  is '失败原因';
comment on column UNICALL.CPIC_MAR_PRESENTINS_FAIL.create_time
  is '创建时间';
comment on column UNICALL.CPIC_MAR_PRESENTINS_FAIL.mar_imp_time
  is '行销网站导入时间';
comment on column UNICALL.CPIC_MAR_PRESENTINS_FAIL.state
  is '状态   0：未删除   1：删除';
create index UNICALL.IDX_CPIC_MAR_PREINS_FAIL_SN on UNICALL.CPIC_MAR_PRESENTINS_FAIL (IMP_SER_NUM)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.CPIC_MAR_PRESENTINS_FAIL
  add constraint PK_CPIC_MAR_PRESENTINS_FAIL_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CPIC_NEW_PRESENTINS_INFO
prompt =======================================
prompt
create table UNICALL.CPIC_NEW_PRESENTINS_INFO
(
  id                           NUMBER(10) not null,
  id_old                       NUMBER(10),
  actcode_id                   NUMBER(10),
  policyno                     VARCHAR2(18),
  app_stat                     VARCHAR2(2),
  apper_name                   VARCHAR2(50),
  apper_gender                 VARCHAR2(2),
  apper_lic_type               VARCHAR2(2),
  apper_lic_no                 VARCHAR2(50),
  apper_insed_rel              VARCHAR2(2),
  apper_email                  VARCHAR2(100),
  apper_cell_no                VARCHAR2(100),
  apper_phone_no               VARCHAR2(100),
  apper_birthday               VARCHAR2(10),
  apper_postcode               VARCHAR2(20),
  apper_adds                   VARCHAR2(1000),
  insed_name                   VARCHAR2(50),
  insed_lic_type               VARCHAR2(2),
  insed_lic_no                 VARCHAR2(50),
  insed_birthday               VARCHAR2(10),
  app_startdt                  VARCHAR2(10),
  res1                         VARCHAR2(100),
  res2                         VARCHAR2(100),
  res3                         VARCHAR2(100),
  create_time                  VARCHAR2(20),
  submit_time                  VARCHAR2(20),
  sms_time                     VARCHAR2(20),
  update_time                  VARCHAR2(20),
  company_id                   NUMBER(10),
  product_code_id              NUMBER(10),
  benifit                      VARCHAR2(2),
  use_id                       NUMBER(10) not null,
  apper_province               VARCHAR2(50),
  apper_city                   VARCHAR2(50),
  apper_area                   VARCHAR2(50),
  is_take_in                   CHAR(1),
  is_buy                       CHAR(1),
  end_time                     VARCHAR2(10),
  call_agency                  VARCHAR2(50),
  call_date                    VARCHAR2(10),
  sale_source                  VARCHAR2(100),
  school_insurance_shcool_name VARCHAR2(120),
  school_insurance_grade_name  VARCHAR2(20),
  isbuyfromagency              VARCHAR2(2),
  call_status                  VARCHAR2(2),
  nameisright                  VARCHAR2(2),
  brithdayisright              VARCHAR2(2),
  agencycompanyid              NUMBER(10),
  isexport                     VARCHAR2(2),
  calldatetime                 VARCHAR2(20),
  pre_insure_export            VARCHAR2(2),
  message_id                   VARCHAR2(50),
  app_stat_new                 VARCHAR2(2),
  presentins_type              CHAR(1),
  sms_fail_code                VARCHAR2(100),
  sms_fail_zh                  VARCHAR2(100),
  sms_stat                     VARCHAR2(2),
  apper_metier                 VARCHAR2(200),
  apper_keep_soc_ins           VARCHAR2(2),
  apper_int_ins                VARCHAR2(2),
  apper_marital                VARCHAR2(2),
  apper_education              VARCHAR2(2),
  apper_salary                 VARCHAR2(2),
  apper_health                 VARCHAR2(2),
  apper_keep_ins               VARCHAR2(2),
  mar_imp_ser_num              VARCHAR2(20),
  mar_create_time              DATE,
  sms_count                    NUMBER(1),
  handle_time                  VARCHAR2(200),
  submit_amount                NUMBER(2),
  handle_status                VARCHAR2(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.id
  is '序列号，主键
';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.id_old
  is '原有序列号，主键
';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.actcode_id
  is '激活码ID';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.policyno
  is '保单号';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.app_stat
  is '投保单状态
 01：暂存成功 02：暂存成功，自动激活失败 03：暂存成功，自动激活成功，发送短信失败 04：暂存成功，自动激活成功，发送短信成功
   * 05：暂存成功，网上激活短信发送失败 06：暂存成功，网上激活短信发送成功 07:暂存成功,激活信息已发送成功,未接收 99：注销';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_name
  is '投保人姓名';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_gender
  is '投保人性别-01:男 02:女';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_lic_type
  is '投保人证件类型';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_lic_no
  is '投保人证件号';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_insed_rel
  is '投保人与被保人关系
01:本人';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_email
  is '投保人EMAIL';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_cell_no
  is '投保人手机号';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_phone_no
  is '投保人固定电话号';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_birthday
  is '投保人出生日期(YYYY-MM-DD)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_postcode
  is '投保人邮政编码';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_adds
  is '投保人地址';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.insed_name
  is '被保人姓名';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.insed_lic_type
  is '被保人证件类型';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.insed_lic_no
  is '被保人证件号';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.insed_birthday
  is '被保人出生日期(YYYY-MM-DD)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.app_startdt
  is '保障起期(YYYY-MM-DD)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.res1
  is '备用1';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.res2
  is '备用2';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.res3
  is '备用3';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.create_time
  is '暂存时间(YYYY-MM-DD HH:MM:SS)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.submit_time
  is '提交时间(YYYY-MM-DD HH:MM:SS)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.sms_time
  is '短信发送时间(YYYY-MM-DD HH:MM:SS)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.update_time
  is '最后修改时间(YYYY-MM-DD HH:MM:SS)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.company_id
  is '投保分公司';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.product_code_id
  is '投保产品';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.benifit
  is '受益人 01：法定继承人';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.use_id
  is '座席ID';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_province
  is '所属省份';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_city
  is '所属城市';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_area
  is '所属县(区)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.is_take_in
  is '是否接受其它险种';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.is_buy
  is '是否有车';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.end_time
  is '车险到期时间';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.call_agency
  is '拨打机构';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.call_date
  is '呼叫时间';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.sale_source
  is '销售来源';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.school_insurance_shcool_name
  is '学平险学校名称';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.school_insurance_grade_name
  is '学平险班级名称';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.isbuyfromagency
  is '是否是从中介购买的数据，01：是 其他：否';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.call_status
  is '营销拨打接通情况 01：无人接听/关机，02：无人接听/关机，03：外地号码， 04：外地号码， 05：拒访  ';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.nameisright
  is '姓名是否正确，01：是 02：否';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.brithdayisright
  is '姓名是否正确，01：是 02：否';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.agencycompanyid
  is '中介id';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.isexport
  is '是否到导出 空：未导出， 01：导出';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.calldatetime
  is '赠险小结拨打时间 ';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.pre_insure_export
  is '赠险供数导出；空：未导出，02：激活失败；03发送失败；04发送成功';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.message_id
  is 'P11接口异步发送时返回的message_id,用于后面的异步接收时使用';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.app_stat_new
  is '新流程保单状态 01:暂存成功 02:分配保单号成功 03:已提交 04:已发送短信 05:发送短信成功 06:发送短信失败';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.presentins_type
  is '保单类型 1：自建赠险信息 2：导入赠险信息';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.sms_fail_code
  is '发送短信失败原因';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.sms_fail_zh
  is '发送短信错误的中文说明';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.sms_stat
  is '发送短信状态（01：succ 成功，02：fail 失败，03：wait 等待状态报告）';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_metier
  is '投保人职业';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_keep_soc_ins
  is '是否有社保  0：否；1：是';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_int_ins
  is '感兴趣的险种 1:车险 2:大病保险 3:意外险 4:分红险  5:其它';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_marital
  is '婚姻状况 1:已婚 2:未婚 3:离异 4:丧偶 5:未知';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_education
  is '最高学历 1:博士研究生 2:硕士研究生 3:大学本科 4:大学专科 5:普通高中 6:中职（中专、职校、技校） 7:初中及以下';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_salary
  is '年收入金额   1:3万元以下  2:3万（含）至10万元  3:10万（含）至30万元  4:30万元（含）以上';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_health
  is '健康状况  1:良好  2:一般  3:有慢性病  4:残疾  5:死亡 6:未知';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.apper_keep_ins
  is '是否购买过保险  0：否；1：是';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.mar_imp_ser_num
  is '行销导入编号';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.mar_create_time
  is '行销导入时间';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.sms_count
  is '短信发送次数';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.handle_time
  is '提交综意险处理时间';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.submit_amount
  is '提交综意险处理次数';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO.handle_status
  is '综意险处理返回状态
（01：同一文件不能上传2次）
（02：保单已存在）
（03：流水等数据生成错误）
（04：文件格式不对）
（05：没有返回处理结果）
（99：其他）
';
create index UNICALL.IDX_AGENCYCOMPANYID on UNICALL.CPIC_NEW_PRESENTINS_INFO (AGENCYCOMPANYID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CPIC_APP_STARTDT on UNICALL.CPIC_NEW_PRESENTINS_INFO (APP_STARTDT)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CPIC_NEW_IDOLD_TYP_06 on UNICALL.CPIC_NEW_PRESENTINS_INFO (ID_OLD, PRESENTINS_TYPE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CPIC_NEW_PINFO_ASTAR_TYP on UNICALL.CPIC_NEW_PRESENTINS_INFO (APP_STAT_NEW, PRESENTINS_TYPE, ISBUYFROMAGENCY)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CPIC_NEW_PINFO_COMPD on UNICALL.CPIC_NEW_PRESENTINS_INFO (COMPANY_ID, PRODUCT_CODE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CPIC_NEW_PIN_POLICYNO_05 on UNICALL.CPIC_NEW_PRESENTINS_INFO (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create unique index UNICALL.IDX_CPIC_NEW_PRESENTINS_ID on UNICALL.CPIC_NEW_PRESENTINS_INFO (ID DESC)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CREATE_TIME on UNICALL.CPIC_NEW_PRESENTINS_INFO (CREATE_TIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_NEW_CELL_NO on UNICALL.CPIC_NEW_PRESENTINS_INFO (APPER_CELL_NO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CPIC_NEW_PRESENTINS_INFO_BAK
prompt ===========================================
prompt
create table UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK
(
  id                           NUMBER(10) not null,
  id_old                       NUMBER(10),
  actcode_id                   NUMBER(10),
  policyno                     VARCHAR2(18),
  app_stat                     VARCHAR2(2),
  apper_name                   VARCHAR2(50),
  apper_gender                 VARCHAR2(2),
  apper_lic_type               VARCHAR2(2),
  apper_lic_no                 VARCHAR2(50),
  apper_insed_rel              VARCHAR2(2),
  apper_email                  VARCHAR2(100),
  apper_cell_no                VARCHAR2(100),
  apper_phone_no               VARCHAR2(100),
  apper_birthday               VARCHAR2(10),
  apper_postcode               VARCHAR2(20),
  apper_adds                   VARCHAR2(1000),
  insed_name                   VARCHAR2(50),
  insed_lic_type               VARCHAR2(2),
  insed_lic_no                 VARCHAR2(50),
  insed_birthday               VARCHAR2(10),
  app_startdt                  VARCHAR2(10),
  res1                         VARCHAR2(100),
  res2                         VARCHAR2(100),
  res3                         VARCHAR2(100),
  create_time                  VARCHAR2(20),
  submit_time                  VARCHAR2(20),
  sms_time                     VARCHAR2(20),
  update_time                  VARCHAR2(20),
  company_id                   NUMBER(10),
  product_code_id              NUMBER(10),
  benifit                      VARCHAR2(2),
  use_id                       NUMBER(10) not null,
  apper_province               VARCHAR2(50),
  apper_city                   VARCHAR2(50),
  apper_area                   VARCHAR2(50),
  is_take_in                   CHAR(1),
  is_buy                       CHAR(1),
  end_time                     VARCHAR2(10),
  call_agency                  VARCHAR2(50),
  call_date                    VARCHAR2(10),
  sale_source                  VARCHAR2(100),
  school_insurance_shcool_name VARCHAR2(120),
  school_insurance_grade_name  VARCHAR2(20),
  isbuyfromagency              VARCHAR2(2),
  call_status                  VARCHAR2(2),
  nameisright                  VARCHAR2(2),
  brithdayisright              VARCHAR2(2),
  agencycompanyid              NUMBER(10),
  isexport                     VARCHAR2(2),
  calldatetime                 VARCHAR2(20),
  pre_insure_export            VARCHAR2(2),
  message_id                   VARCHAR2(50),
  app_stat_new                 VARCHAR2(2),
  presentins_type              CHAR(1),
  sms_fail_code                VARCHAR2(100),
  sms_fail_zh                  VARCHAR2(100),
  sms_stat                     VARCHAR2(2),
  apper_metier                 VARCHAR2(200),
  apper_keep_soc_ins           VARCHAR2(2),
  apper_int_ins                VARCHAR2(2),
  apper_marital                VARCHAR2(2),
  apper_education              VARCHAR2(2),
  apper_salary                 VARCHAR2(2),
  apper_health                 VARCHAR2(2),
  apper_keep_ins               VARCHAR2(2),
  mar_imp_ser_num              VARCHAR2(20),
  mar_create_time              DATE,
  sms_count                    NUMBER(1),
  handle_time                  VARCHAR2(200),
  submit_amount                NUMBER(2),
  handle_status                VARCHAR2(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.id
  is '序列号，主键
';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.id_old
  is '原有序列号，主键
';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.actcode_id
  is '激活码ID';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.policyno
  is '保单号';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.app_stat
  is '投保单状态
 01：暂存成功 02：暂存成功，自动激活失败 03：暂存成功，自动激活成功，发送短信失败 04：暂存成功，自动激活成功，发送短信成功
   * 05：暂存成功，网上激活短信发送失败 06：暂存成功，网上激活短信发送成功 07:暂存成功,激活信息已发送成功,未接收 99：注销';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_name
  is '投保人姓名';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_gender
  is '投保人性别-01:男 02:女';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_lic_type
  is '投保人证件类型';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_lic_no
  is '投保人证件号';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_insed_rel
  is '投保人与被保人关系
01:本人';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_email
  is '投保人EMAIL';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_cell_no
  is '投保人手机号';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_phone_no
  is '投保人固定电话号';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_birthday
  is '投保人出生日期(YYYY-MM-DD)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_postcode
  is '投保人邮政编码';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_adds
  is '投保人地址';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.insed_name
  is '被保人姓名';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.insed_lic_type
  is '被保人证件类型';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.insed_lic_no
  is '被保人证件号';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.insed_birthday
  is '被保人出生日期(YYYY-MM-DD)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.app_startdt
  is '保障起期(YYYY-MM-DD)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.res1
  is '备用1';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.res2
  is '备用2';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.res3
  is '备用3';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.create_time
  is '暂存时间(YYYY-MM-DD HH:MM:SS)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.submit_time
  is '提交时间(YYYY-MM-DD HH:MM:SS)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.sms_time
  is '短信发送时间(YYYY-MM-DD HH:MM:SS)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.update_time
  is '最后修改时间(YYYY-MM-DD HH:MM:SS)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.company_id
  is '投保分公司';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.product_code_id
  is '投保产品';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.benifit
  is '受益人 01：法定继承人';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.use_id
  is '座席ID';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_province
  is '所属省份';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_city
  is '所属城市';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_area
  is '所属县(区)';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.is_take_in
  is '是否接受其它险种';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.is_buy
  is '是否有车';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.end_time
  is '车险到期时间';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.call_agency
  is '拨打机构';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.call_date
  is '呼叫时间';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.sale_source
  is '销售来源';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.school_insurance_shcool_name
  is '学平险学校名称';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.school_insurance_grade_name
  is '学平险班级名称';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.isbuyfromagency
  is '是否是从中介购买的数据，01：是 其他：否';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.call_status
  is '营销拨打接通情况 01：无人接听/关机，02：无人接听/关机，03：外地号码， 04：外地号码， 05：拒访  ';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.nameisright
  is '姓名是否正确，01：是 02：否';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.brithdayisright
  is '姓名是否正确，01：是 02：否';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.agencycompanyid
  is '中介id';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.isexport
  is '是否到导出 空：未导出， 01：导出';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.calldatetime
  is '赠险小结拨打时间 ';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.pre_insure_export
  is '赠险供数导出；空：未导出，02：激活失败；03发送失败；04发送成功';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.message_id
  is 'P11接口异步发送时返回的message_id,用于后面的异步接收时使用';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.app_stat_new
  is '新流程保单状态 01:暂存成功 02:分配保单号成功 03:已提交 04:已发送短信 05:发送短信成功 06:发送短信失败';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.presentins_type
  is '保单类型 1：自建赠险信息 2：导入赠险信息';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.sms_fail_code
  is '发送短信失败原因';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.sms_fail_zh
  is '发送短信错误的中文说明';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.sms_stat
  is '发送短信状态（01：succ 成功，02：fail 失败，03：wait 等待状态报告）';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_metier
  is '投保人职业';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_keep_soc_ins
  is '是否有社保  0：否；1：是';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_int_ins
  is '感兴趣的险种 1:车险 2:大病保险 3:意外险 4:分红险  5:其它';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_marital
  is '婚姻状况 1:已婚 2:未婚 3:离异 4:丧偶 5:未知';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_education
  is '最高学历 1:博士研究生 2:硕士研究生 3:大学本科 4:大学专科 5:普通高中 6:中职（中专、职校、技校） 7:初中及以下';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_salary
  is '年收入金额   1:3万元以下  2:3万（含）至10万元  3:10万（含）至30万元  4:30万元（含）以上';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_health
  is '健康状况  1:良好  2:一般  3:有慢性病  4:残疾  5:死亡 6:未知';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.apper_keep_ins
  is '是否购买过保险  0：否；1：是';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.mar_imp_ser_num
  is '行销导入编号';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.mar_create_time
  is '行销导入时间';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.sms_count
  is '短信发送次数';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.handle_time
  is '提交综意险处理时间';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.submit_amount
  is '提交综意险处理次数';
comment on column UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK.handle_status
  is '综意险处理返回状态
（01：同一文件不能上传2次）
（02：保单已存在）
（03：流水等数据生成错误）
（04：文件格式不对）
（05：没有返回处理结果）
（99：其他）
';
create index UNICALL.IDX_CPIC_APP_STARTDT_01 on UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK (APP_STARTDT)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CPIC_NEW_PIN_POLICYNO_02 on UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_NEW_CELL_NO_03 on UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK (APPER_CELL_NO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.CPIC_NEW_PRESENTINS_INFO_BAK
  add constraint PK_CPIC_NEW_PREINS_BAK primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CPIC_OPERATOR
prompt ============================
prompt
create table UNICALL.CPIC_OPERATOR
(
  op_id NUMBER(20) not null,
  fgs   VARCHAR2(60),
  kshdm VARCHAR2(60),
  bmdm  VARCHAR2(60),
  rydm  VARCHAR2(60),
  rymc  VARCHAR2(60),
  rymm  VARCHAR2(60),
  hbjb  INTEGER,
  hpjb  INTEGER,
  zzgs  VARCHAR2(60),
  cdddm VARCHAR2(3),
  cddmc VARCHAR2(40)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CPIC_PREINS_EXPORT_LOG
prompt =====================================
prompt
create table UNICALL.CPIC_PREINS_EXPORT_LOG
(
  id          NUMBER(18) not null,
  preins_time VARCHAR2(10),
  file_name   VARCHAR2(2048),
  amount      NUMBER(10),
  create_time DATE,
  is_del      NUMBER(1) default 0
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.CPIC_PREINS_EXPORT_LOG.id
  is 'ID';
comment on column UNICALL.CPIC_PREINS_EXPORT_LOG.preins_time
  is '赠险时间';
comment on column UNICALL.CPIC_PREINS_EXPORT_LOG.file_name
  is '文件名';
comment on column UNICALL.CPIC_PREINS_EXPORT_LOG.amount
  is '数量';
comment on column UNICALL.CPIC_PREINS_EXPORT_LOG.create_time
  is '创建时间';
comment on column UNICALL.CPIC_PREINS_EXPORT_LOG.is_del
  is '是否删除 0：否  1：是';
alter table UNICALL.CPIC_PREINS_EXPORT_LOG
  add constraint PK_CPIC_PREINS_EXPORT_LOG primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CPIC_PRESENTINS_BDZR
prompt ===================================
prompt
create table UNICALL.CPIC_PRESENTINS_BDZR
(
  id              NUMBER(10) not null,
  product_code_id NUMBER(10) not null,
  bxzr            NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.CPIC_PRESENTINS_BDZR
  is '赠险责任绑定表';
comment on column UNICALL.CPIC_PRESENTINS_BDZR.id
  is 'ID';
comment on column UNICALL.CPIC_PRESENTINS_BDZR.product_code_id
  is '赠险ID';
comment on column UNICALL.CPIC_PRESENTINS_BDZR.bxzr
  is '保险责任ID';
alter table UNICALL.CPIC_PRESENTINS_BDZR
  add constraint PK_CPIC_PRESENTINS_BDZR primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CPIC_PRESENTINS_BXZR
prompt ===================================
prompt
create table UNICALL.CPIC_PRESENTINS_BXZR
(
  id     NUMBER(10) not null,
  zrdm   VARCHAR2(2) not null,
  zrname VARCHAR2(50) not null,
  bxje   NUMBER(7) not null,
  bz     VARCHAR2(50),
  kfbd   NUMBER(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.CPIC_PRESENTINS_BXZR
  is '赠险责任表';
comment on column UNICALL.CPIC_PRESENTINS_BXZR.id
  is 'ID';
comment on column UNICALL.CPIC_PRESENTINS_BXZR.zrdm
  is '保险责任代码';
comment on column UNICALL.CPIC_PRESENTINS_BXZR.zrname
  is '保险责任名称';
comment on column UNICALL.CPIC_PRESENTINS_BXZR.bxje
  is '保险金额';
comment on column UNICALL.CPIC_PRESENTINS_BXZR.bz
  is '备注';
comment on column UNICALL.CPIC_PRESENTINS_BXZR.kfbd
  is '是否可绑定 0 可以，1不可以';
alter table UNICALL.CPIC_PRESENTINS_BXZR
  add constraint PK_CPIC_PRESENTINS_BXZR primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_RIG_STA
prompt ========================
prompt
create table UNICALL.C_RIG_STA
(
  rig_sta_id  NUMBER(5) not null,
  rig_sta_des VARCHAR2(64),
  is_del      VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_RIG_STA
  add constraint PKRIG_STA primary key (RIG_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_USE
prompt ====================
prompt
create table UNICALL.C_USE
(
  use_nam        VARCHAR2(30) not null,
  password       VARCHAR2(10) not null,
  log_des        VARCHAR2(200),
  is_adm         NUMBER(5) default 0,
  rig_sta_id     NUMBER(5) not null,
  sta_dat        VARCHAR2(20),
  use_id         NUMBER(10) not null,
  use_ali_id     VARCHAR2(20),
  id_in_biz      VARCHAR2(32),
  ob_list_count  NUMBER(5),
  is_leader      NUMBER(2),
  c_workplace_id NUMBER(10),
  company_id     NUMBER,
  use_level      NUMBER(2),
  use_flag       VARCHAR2(2) default 0,
  is_task        VARCHAR2(2),
  org_id         NUMBER(10),
  is_allocation  NUMBER(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 512K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_USE.is_leader
  is '是否组长：0，不是；1，是';
comment on column UNICALL.C_USE.use_level
  is '坐席5个级别；主管3个级别';
comment on column UNICALL.C_USE.use_flag
  is '0：电销  1：续收';
comment on column UNICALL.C_USE.is_task
  is '续收坐席是否分单 0:否，1:是';
comment on column UNICALL.C_USE.org_id
  is '电销中心';
create index UNICALL.IDX_CUSE_LEVEL on UNICALL.C_USE (USE_LEVEL)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CUSE_USE_FLAG on UNICALL.C_USE (USE_FLAG)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_USE_ALI_ID on UNICALL.C_USE (USE_ALI_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2544 on UNICALL.C_USE (RIG_STA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE
  add constraint PKC_USE primary key (USE_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE
  add constraint REFC_RIG_STA441 foreign key (RIG_STA_ID)
  references UNICALL.C_RIG_STA (RIG_STA_ID);

prompt
prompt Creating table CPIC_PRESENTINS_INFO
prompt ===================================
prompt
create table UNICALL.CPIC_PRESENTINS_INFO
(
  id                           NUMBER(10) not null,
  actcode_id                   NUMBER(10),
  policyno                     VARCHAR2(18),
  app_stat                     VARCHAR2(2),
  apper_name                   VARCHAR2(50),
  apper_gender                 VARCHAR2(2),
  apper_lic_type               VARCHAR2(2),
  apper_lic_no                 VARCHAR2(50),
  apper_insed_rel              VARCHAR2(2),
  apper_email                  VARCHAR2(100),
  apper_cell_no                VARCHAR2(100),
  apper_phone_no               VARCHAR2(100),
  apper_birthday               VARCHAR2(10),
  apper_postcode               VARCHAR2(20),
  apper_adds                   VARCHAR2(1000),
  insed_name                   VARCHAR2(50),
  insed_lic_type               VARCHAR2(2),
  insed_lic_no                 VARCHAR2(50),
  insed_birthday               VARCHAR2(10),
  app_startdt                  VARCHAR2(10),
  res1                         VARCHAR2(100),
  res2                         VARCHAR2(100),
  res3                         VARCHAR2(100),
  create_time                  VARCHAR2(20),
  submit_time                  VARCHAR2(20),
  sms_time                     VARCHAR2(20),
  update_time                  VARCHAR2(20),
  company_id                   NUMBER(10),
  product_code_id              NUMBER(10),
  benifit                      VARCHAR2(2),
  use_id                       NUMBER(10) not null,
  apper_province               VARCHAR2(50),
  apper_city                   VARCHAR2(50),
  apper_area                   VARCHAR2(50),
  is_take_in                   CHAR(1),
  is_buy                       CHAR(1),
  end_time                     VARCHAR2(10),
  school_insurance_shcool_name VARCHAR2(120),
  school_insurance_grade_name  VARCHAR2(20),
  pre_insure_export            VARCHAR2(2),
  message_id                   VARCHAR2(50)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 165M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.CPIC_PRESENTINS_INFO
  is '赠险基本信息表';
comment on column UNICALL.CPIC_PRESENTINS_INFO.id
  is '序列号，主键
';
comment on column UNICALL.CPIC_PRESENTINS_INFO.actcode_id
  is '激活码ID';
comment on column UNICALL.CPIC_PRESENTINS_INFO.policyno
  is '保单号';
comment on column UNICALL.CPIC_PRESENTINS_INFO.app_stat
  is '投保单状态
 01：暂存成功 02：暂存成功，自动激活失败 03：暂存成功，自动激活成功，发送短信失败 04：暂存成功，自动激活成功，发送短信成功
   * 05：暂存成功，网上激活短信发送失败 06：暂存成功，网上激活短信发送成功 07:暂存成功,P11激活中 99：注销';
comment on column UNICALL.CPIC_PRESENTINS_INFO.apper_name
  is '投保人姓名';
comment on column UNICALL.CPIC_PRESENTINS_INFO.apper_gender
  is '投保人性别-01:男 02:女';
comment on column UNICALL.CPIC_PRESENTINS_INFO.apper_lic_type
  is '投保人证件类型';
comment on column UNICALL.CPIC_PRESENTINS_INFO.apper_lic_no
  is '投保人证件号';
comment on column UNICALL.CPIC_PRESENTINS_INFO.apper_insed_rel
  is '投保人与被保人关系
01:本人';
comment on column UNICALL.CPIC_PRESENTINS_INFO.apper_email
  is '投保人EMAIL';
comment on column UNICALL.CPIC_PRESENTINS_INFO.apper_cell_no
  is '投保人手机号';
comment on column UNICALL.CPIC_PRESENTINS_INFO.apper_phone_no
  is '投保人固定电话号';
comment on column UNICALL.CPIC_PRESENTINS_INFO.apper_birthday
  is '投保人出生日期(YYYY-MM-DD)';
comment on column UNICALL.CPIC_PRESENTINS_INFO.apper_postcode
  is '投保人邮政编码';
comment on column UNICALL.CPIC_PRESENTINS_INFO.apper_adds
  is '投保人地址';
comment on column UNICALL.CPIC_PRESENTINS_INFO.insed_name
  is '被保人姓名';
comment on column UNICALL.CPIC_PRESENTINS_INFO.insed_lic_type
  is '被保人证件类型';
comment on column UNICALL.CPIC_PRESENTINS_INFO.insed_lic_no
  is '被保人证件号';
comment on column UNICALL.CPIC_PRESENTINS_INFO.insed_birthday
  is '被保人出生日期(YYYY-MM-DD)';
comment on column UNICALL.CPIC_PRESENTINS_INFO.app_startdt
  is '保障起期(YYYY-MM-DD)';
comment on column UNICALL.CPIC_PRESENTINS_INFO.res1
  is '备用1';
comment on column UNICALL.CPIC_PRESENTINS_INFO.res2
  is '备用2';
comment on column UNICALL.CPIC_PRESENTINS_INFO.res3
  is '备用3';
comment on column UNICALL.CPIC_PRESENTINS_INFO.create_time
  is '暂存时间(YYYY-MM-DD HH:MM:SS)';
comment on column UNICALL.CPIC_PRESENTINS_INFO.submit_time
  is '提交时间(YYYY-MM-DD HH:MM:SS)';
comment on column UNICALL.CPIC_PRESENTINS_INFO.sms_time
  is '短信发送时间(YYYY-MM-DD HH:MM:SS)';
comment on column UNICALL.CPIC_PRESENTINS_INFO.update_time
  is '最后修改时间(YYYY-MM-DD HH:MM:SS)';
comment on column UNICALL.CPIC_PRESENTINS_INFO.company_id
  is '投保分公司';
comment on column UNICALL.CPIC_PRESENTINS_INFO.product_code_id
  is '投保产品';
comment on column UNICALL.CPIC_PRESENTINS_INFO.benifit
  is '受益人 01：法定继承人';
comment on column UNICALL.CPIC_PRESENTINS_INFO.use_id
  is '座席ID';
comment on column UNICALL.CPIC_PRESENTINS_INFO.school_insurance_shcool_name
  is '学平险学校名称';
comment on column UNICALL.CPIC_PRESENTINS_INFO.school_insurance_grade_name
  is '学平险班级名称';
comment on column UNICALL.CPIC_PRESENTINS_INFO.pre_insure_export
  is '赠险供数导出；空：未导出，02：激活失败；03发送失败；04发送成功';
comment on column UNICALL.CPIC_PRESENTINS_INFO.message_id
  is 'P11接口异步发送时返回的message_id,,用于后面的异步接收时使用';
create index UNICALL.CPIC_PRESENTINS_INFO_USE_ID on UNICALL.CPIC_PRESENTINS_INFO (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 12M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CPIC_PINFO_ACTCODE on UNICALL.CPIC_PRESENTINS_INFO (ACTCODE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CPIC_PINFO_ASTAR on UNICALL.CPIC_PRESENTINS_INFO (APP_STAT, RES1)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CPIC_PINFO_CELL_NO on UNICALL.CPIC_PRESENTINS_INFO (APPER_CELL_NO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CPIC_PINFO_COMPANYPD on UNICALL.CPIC_PRESENTINS_INFO (COMPANY_ID, PRODUCT_CODE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.CPIC_PRESENTINS_INFO
  add constraint PK_CPIC_PRESENTINS_INFO primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 13M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.CPIC_PRESENTINS_INFO
  add constraint FK_CPIC_PRES_INFO_USER foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table CPIC_PRESENTINS_INFO_VOLUMN
prompt ==========================================
prompt
create table UNICALL.CPIC_PRESENTINS_INFO_VOLUMN
(
  id                           NUMBER(10) not null,
  actcode_id                   NUMBER(10),
  policyno                     VARCHAR2(18),
  app_stat                     VARCHAR2(2),
  apper_name                   VARCHAR2(50),
  apper_gender                 VARCHAR2(2),
  apper_lic_type               VARCHAR2(2),
  apper_lic_no                 VARCHAR2(50),
  apper_insed_rel              VARCHAR2(2),
  apper_email                  VARCHAR2(100),
  apper_cell_no                VARCHAR2(100),
  apper_phone_no               VARCHAR2(100),
  apper_birthday               VARCHAR2(10),
  apper_postcode               VARCHAR2(20),
  apper_adds                   VARCHAR2(1000),
  insed_name                   VARCHAR2(50),
  insed_lic_type               VARCHAR2(2),
  insed_lic_no                 VARCHAR2(50),
  insed_birthday               VARCHAR2(10),
  app_startdt                  VARCHAR2(10),
  res1                         VARCHAR2(100),
  res2                         VARCHAR2(100),
  res3                         VARCHAR2(100),
  create_time                  VARCHAR2(20),
  submit_time                  VARCHAR2(20),
  sms_time                     VARCHAR2(20),
  update_time                  VARCHAR2(20),
  company_id                   NUMBER(10),
  product_code_id              NUMBER(10),
  benifit                      VARCHAR2(2),
  use_id                       NUMBER(10) not null,
  apper_province               VARCHAR2(50),
  apper_city                   VARCHAR2(50),
  apper_area                   VARCHAR2(50),
  is_take_in                   CHAR(1),
  is_buy                       CHAR(1),
  end_time                     VARCHAR2(10),
  call_agency                  VARCHAR2(50),
  call_date                    VARCHAR2(10),
  sale_source                  VARCHAR2(100),
  school_insurance_shcool_name VARCHAR2(120),
  school_insurance_grade_name  VARCHAR2(20),
  agencycompanyid              NUMBER(10),
  isbuyfromagency              VARCHAR2(2),
  call_status                  VARCHAR2(2),
  nameisright                  VARCHAR2(2),
  brithdayisright              VARCHAR2(2),
  isexport                     VARCHAR2(2),
  calldatetime                 VARCHAR2(20),
  pre_insure_export            VARCHAR2(2),
  message_id                   VARCHAR2(50)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 800M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.CPIC_PRESENTINS_INFO_VOLUMN.app_stat
  is '投保单状态
 01：暂存成功 02：暂存成功，自动激活失败 03：暂存成功，自动激活成功，发送短信失败 04：暂存成功，自动激活成功，发送短信成功
   * 05：暂存成功，网上激活短信发送失败 06：暂存成功，网上激活短信发送成功 07:暂存成功,P11激活中 99：注销';
comment on column UNICALL.CPIC_PRESENTINS_INFO_VOLUMN.school_insurance_shcool_name
  is '学平险学校名称';
comment on column UNICALL.CPIC_PRESENTINS_INFO_VOLUMN.school_insurance_grade_name
  is '学平险班级名称';
comment on column UNICALL.CPIC_PRESENTINS_INFO_VOLUMN.agencycompanyid
  is '中介id';
comment on column UNICALL.CPIC_PRESENTINS_INFO_VOLUMN.isbuyfromagency
  is '营销机构，01：电销中心 02：中介';
comment on column UNICALL.CPIC_PRESENTINS_INFO_VOLUMN.call_status
  is '营销拨打接通情况 01：无人接听/关机，02：停机/过期，03：外地号码， 04：空号/错号， 05：拒访，06：接通  ';
comment on column UNICALL.CPIC_PRESENTINS_INFO_VOLUMN.nameisright
  is '姓名是否正确，01：正确 02：错误';
comment on column UNICALL.CPIC_PRESENTINS_INFO_VOLUMN.brithdayisright
  is '生日是否正确，01：正确 02：错误';
comment on column UNICALL.CPIC_PRESENTINS_INFO_VOLUMN.isexport
  is '是否到导出 空：未导出， 01：导出';
comment on column UNICALL.CPIC_PRESENTINS_INFO_VOLUMN.calldatetime
  is '赠险小结拨打时间 ';
comment on column UNICALL.CPIC_PRESENTINS_INFO_VOLUMN.pre_insure_export
  is '赠险供数导出；空：未导出，02：激活失败；03发送失败；04发送成功';
comment on column UNICALL.CPIC_PRESENTINS_INFO_VOLUMN.message_id
  is 'P11接口异步发送时返回的message_id,,用于后面的异步接收时使用';
create index UNICALL.IDX_CELL_NO on UNICALL.CPIC_PRESENTINS_INFO_VOLUMN (APPER_CELL_NO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 80M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CPIC_PINFO_VOLUMN_ACTCODE on UNICALL.CPIC_PRESENTINS_INFO_VOLUMN (ACTCODE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CPIC_PINFO_VOLUMN_ASTAR on UNICALL.CPIC_PRESENTINS_INFO_VOLUMN (APP_STAT, RES1)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_CPIC_PINFO_VOLUMN_COMPD on UNICALL.CPIC_PRESENTINS_INFO_VOLUMN (COMPANY_ID, PRODUCT_CODE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.CPIC_PRESENTINS_INFO_VOLUMN
  add constraint PK_CPIC_PRESENTINS_INFO_VOLUMN primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 50M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table CPIC_WORKPLACE
prompt =============================
prompt
create table UNICALL.CPIC_WORKPLACE
(
  id             NUMBER(10) not null,
  workplace_code VARCHAR2(18),
  workplace_name VARCHAR2(30),
  phone_url      VARCHAR2(100),
  create_time    VARCHAR2(20),
  update_time    VARCHAR2(20),
  remark         VARCHAR2(400),
  status         VARCHAR2(2),
  res1           VARCHAR2(50),
  res2           VARCHAR2(50),
  res3           VARCHAR2(50),
  workplace_adds VARCHAR2(300),
  contact_name   VARCHAR2(100),
  contact_tel    VARCHAR2(100),
  par_org_id     NUMBER(10),
  workplace_type VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.CPIC_WORKPLACE
  is '职场表';
comment on column UNICALL.CPIC_WORKPLACE.workplace_code
  is '职场编码';
comment on column UNICALL.CPIC_WORKPLACE.workplace_name
  is '职场名称';
comment on column UNICALL.CPIC_WORKPLACE.phone_url
  is '软电话url';
comment on column UNICALL.CPIC_WORKPLACE.create_time
  is '创建日期';
comment on column UNICALL.CPIC_WORKPLACE.update_time
  is '修改日期';
comment on column UNICALL.CPIC_WORKPLACE.remark
  is '备注';
comment on column UNICALL.CPIC_WORKPLACE.status
  is '删除标记（0：正常 1：删除）';
comment on column UNICALL.CPIC_WORKPLACE.workplace_adds
  is '职场地址';
comment on column UNICALL.CPIC_WORKPLACE.contact_name
  is '联系人';
comment on column UNICALL.CPIC_WORKPLACE.contact_tel
  is '联系电话';
comment on column UNICALL.CPIC_WORKPLACE.par_org_id
  is '上级机构ID';
comment on column UNICALL.CPIC_WORKPLACE.workplace_type
  is '职场类型（03：内部职场 04：外包职场）';
alter table UNICALL.CPIC_WORKPLACE
  add constraint PK_CPIC_WORKPLACE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_ROL
prompt ====================
prompt
create table UNICALL.C_ROL
(
  rol_id       NUMBER(5) not null,
  rol_des      VARCHAR2(40) not null,
  sta_dat      VARCHAR2(20),
  rig_sta_id   NUMBER(5) not null,
  use_id       NUMBER(10),
  company_id   NUMBER,
  company_type VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create unique index UNICALL.AKROL on UNICALL.C_ROL (ROL_DES)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF184 on UNICALL.C_ROL (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2568 on UNICALL.C_ROL (RIG_STA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_ROL
  add constraint PKTBL_ROLE primary key (ROL_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_ROL
  add constraint REFC_RIG_STA681 foreign key (RIG_STA_ID)
  references UNICALL.C_RIG_STA (RIG_STA_ID);

prompt
prompt Creating table CPIC_WORKPLACE_ROL
prompt =================================
prompt
create table UNICALL.CPIC_WORKPLACE_ROL
(
  id     NUMBER(10) not null,
  rol_id NUMBER(5) not null,
  wp_id  NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on table UNICALL.CPIC_WORKPLACE_ROL
  is '职场和动作组绑定表';
comment on column UNICALL.CPIC_WORKPLACE_ROL.id
  is '主键';
comment on column UNICALL.CPIC_WORKPLACE_ROL.rol_id
  is '动作组ID';
comment on column UNICALL.CPIC_WORKPLACE_ROL.wp_id
  is '职场ID';
alter table UNICALL.CPIC_WORKPLACE_ROL
  add constraint PK_CPIC_WORKPLACE_ROL primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.CPIC_WORKPLACE_ROL
  add constraint FK_CPIC_WORKPLACE_ROL_01 foreign key (WP_ID)
  references UNICALL.CPIC_WORKPLACE (ID);
alter table UNICALL.CPIC_WORKPLACE_ROL
  add constraint FK_CPIC_WORKPLACE_ROL_02 foreign key (ROL_ID)
  references UNICALL.C_ROL (ROL_ID);

prompt
prompt Creating table C_0B_CSR_LIS_TA
prompt ==============================
prompt
create table UNICALL.C_0B_CSR_LIS_TA
(
  ob_csr_lis_id NUMBER(10) not null,
  tas_id        NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_0B_CSR_LIS_TA
  add constraint PK_OB_CSR_LIS_TA primary key (OB_CSR_LIS_ID, TAS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_801010
prompt =======================
prompt
create table UNICALL.C_801010
(
  aud_id     NUMBER(10) not null,
  sta_dat    VARCHAR2(20),
  end_dat    VARCHAR2(20),
  opinion    VARCHAR2(4000),
  content    VARCHAR2(4000),
  use_id     NUMBER(10),
  status     NUMBER(30),
  inf_id     NUMBER(10),
  aud_use_id NUMBER(10),
  cat_id     NUMBER(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table T_AGENTCOMPANY_TYPE
prompt ==================================
prompt
create table UNICALL.T_AGENTCOMPANY_TYPE
(
  t_agentcompany_type_id   NUMBER(10) not null,
  t_agentcompany_type_name VARCHAR2(100),
  t_agentcompany_type_desc VARCHAR2(500)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.T_AGENTCOMPANY_TYPE
  add constraint PK_T_AGENTCOMPANY_TYPE primary key (T_AGENTCOMPANY_TYPE_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_AGENTCOMPANY
prompt =============================
prompt
create table UNICALL.C_AGENTCOMPANY
(
  c_agentcompany_id          NUMBER(10) not null,
  t_agentcompany_type_id     NUMBER(10),
  c_agentcompany_name        VARCHAR2(100),
  c_agentcompany_code        VARCHAR2(100),
  c_company_id               NUMBER(10),
  c_agentcompany_contact     VARCHAR2(100),
  c_agentcompany_contact_sub VARCHAR2(100),
  c_agentcompany_addr        VARCHAR2(500),
  c_agentcompany_status      NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create unique index UNICALL.C_AGENTCOMPANY_CODE_UK on UNICALL.C_AGENTCOMPANY (C_AGENTCOMPANY_CODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_AGENTCOMPANY
  add constraint PK_C_AGENTCOMPANY primary key (C_AGENTCOMPANY_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_AGENTCOMPANY
  add constraint FK_C_AGENTC_C_AGENTCO_T_AGENTC foreign key (T_AGENTCOMPANY_TYPE_ID)
  references UNICALL.T_AGENTCOMPANY_TYPE (T_AGENTCOMPANY_TYPE_ID);

prompt
prompt Creating table C_AGENTCOMPANY_FACTOR
prompt ====================================
prompt
create table UNICALL.C_AGENTCOMPANY_FACTOR
(
  c_agentcompany_factor_id   NUMBER(10) not null,
  c_agentcompany_id          NUMBER(10),
  c_agentcompany_factor_date VARCHAR2(50),
  c_agentcompany_factor_sale NUMBER(10),
  c_agentcompany_factor_grow NUMBER(5,2),
  c_agentcompany_factor_com  NUMBER(5,2),
  c_agentcompany_factor_new  NUMBER(5,2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_AGENTCOMPANY_FACTOR
  add constraint PK_C_AGENTCOMPANY_FACTOR primary key (C_AGENTCOMPANY_FACTOR_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_AGENTCOMPANY_FACTOR
  add constraint FK_C_AGENTC_C_AGENTCO_C_AGENTC foreign key (C_AGENTCOMPANY_ID)
  references UNICALL.C_AGENTCOMPANY (C_AGENTCOMPANY_ID);

prompt
prompt Creating table C_CAT_TYP
prompt ========================
prompt
create table UNICALL.C_CAT_TYP
(
  cat_typ_id     NUMBER(5) not null,
  cat_fun_typ_id NUMBER(5) not null,
  cat_typ_des    VARCHAR2(64),
  is_del         VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF3971 on UNICALL.C_CAT_TYP (CAT_FUN_TYP_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CAT_TYP
  add constraint PKCAT_TYP primary key (CAT_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CAT_TYP
  add constraint REFC_CAT_TYP711 foreign key (CAT_FUN_TYP_ID)
  references UNICALL.C_CAT_TYP (CAT_TYP_ID);

prompt
prompt Creating table C_MOD
prompt ====================
prompt
create table UNICALL.C_MOD
(
  mod_id     NUMBER(5) not null,
  mod_des    VARCHAR2(64),
  is_dat_vie VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_MOD
  add constraint PKMOD primary key (MOD_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_TO_FRA
prompt =======================
prompt
create table UNICALL.C_TO_FRA
(
  to_fra_id   NUMBER(5) not null,
  to_fra_desc VARCHAR2(64),
  is_del      VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_TO_FRA
  add constraint PKTO_FRA primary key (TO_FRA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CAT
prompt ====================
prompt
create table UNICALL.C_CAT
(
  rig_sta_id NUMBER(5) not null,
  dis_ord    VARCHAR2(40),
  cat_nam    VARCHAR2(2000),
  cat_des    VARCHAR2(1024),
  in_tre     VARCHAR2(1) default 0 not null,
  lev_no     VARCHAR2(40),
  mod_id     NUMBER(5),
  tag_ima    VARCHAR2(512),
  is_del     VARCHAR2(1) default 0,
  to_fra_id  NUMBER(5),
  cat_typ_id NUMBER(5) not null,
  par_cat_id NUMBER(30),
  cat_id     NUMBER(30) not null,
  cal        VARCHAR2(512),
  to_fra     VARCHAR2(512),
  hig_lig    VARCHAR2(1),
  is_aut     VARCHAR2(1) default 1 not null,
  is_act     VARCHAR2(1) default 0,
  val        VARCHAR2(1024),
  org_id     NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_CAT.cat_des
  is '‘805001’CTI类型:genesys/infobird/qmanager';
comment on column UNICALL.C_CAT.org_id
  is '实现数据权限过滤';
create index UNICALL.ADD_IDX_C_CAT on UNICALL.C_CAT (TO_CHAR(PAR_CAT_ID))
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CAT
  add constraint PKCAT_ID primary key (CAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CAT
  add constraint REFC_CAT_TYP721 foreign key (CAT_TYP_ID)
  references UNICALL.C_CAT_TYP (CAT_TYP_ID)
  disable;
alter table UNICALL.C_CAT
  add constraint REFC_MOD641 foreign key (MOD_ID)
  references UNICALL.C_MOD (MOD_ID)
  disable;
alter table UNICALL.C_CAT
  add constraint REFC_RIG_STA771 foreign key (RIG_STA_ID)
  references UNICALL.C_RIG_STA (RIG_STA_ID)
  disable;
alter table UNICALL.C_CAT
  add constraint REFC_TO_FRA661 foreign key (TO_FRA_ID)
  references UNICALL.C_TO_FRA (TO_FRA_ID)
  disable;

prompt
prompt Creating table C_CAT_INF
prompt ========================
prompt
create table UNICALL.C_CAT_INF
(
  cat_id  NUMBER(30) not null,
  inf_id  NUMBER(10) not null,
  dis_ord NUMBER(5)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF6069 on UNICALL.C_CAT_INF (INF_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF6468 on UNICALL.C_CAT_INF (CAT_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CAT_INF
  add constraint PKCAT_INF primary key (CAT_ID, INF_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CAT_PAR
prompt ========================
prompt
create table UNICALL.C_CAT_PAR
(
  cat_par_id  NUMBER(5) not null,
  cat_par_des VARCHAR2(256) not null,
  cat_par_val VARCHAR2(256),
  cat_id      NUMBER(30) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF6473 on UNICALL.C_CAT_PAR (CAT_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CAT_PAR
  add constraint PKCAT_PAR primary key (CAT_PAR_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_CAT_TMP
prompt ========================
prompt
create table UNICALL.C_CAT_TMP
(
  rig_sta_id NUMBER(5) not null,
  dis_ord    VARCHAR2(40),
  cat_nam    VARCHAR2(40),
  cat_des    VARCHAR2(1024),
  in_tre     VARCHAR2(1) not null,
  lev_no     VARCHAR2(40),
  mod_id     NUMBER(5),
  tag_ima    VARCHAR2(512),
  is_del     VARCHAR2(1),
  to_fra_id  NUMBER(5),
  cat_typ_id NUMBER(5) not null,
  par_cat_id NUMBER(30),
  cat_id     NUMBER(30),
  cal        VARCHAR2(512),
  to_fra     VARCHAR2(512),
  hig_lig    VARCHAR2(1),
  is_aut     VARCHAR2(1) not null,
  is_act     VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_CHA_STA
prompt ========================
prompt
create table UNICALL.C_CHA_STA
(
  con_sta_id  NUMBER(5) not null,
  con_sta_des VARCHAR2(64),
  is_del      VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CHA_STA
  add constraint PKCHA_STA primary key (CON_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CHA_TYP
prompt ========================
prompt
create table UNICALL.C_CHA_TYP
(
  cha_typ_id  NUMBER(5) not null,
  cha_typ_des VARCHAR2(40) not null,
  is_del      VARCHAR2(1),
  is_gro      VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CHA_TYP
  add constraint PKCHA_TYP primary key (CHA_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CHA
prompt ====================
prompt
create table UNICALL.C_CHA
(
  cha_id     NUMBER(10) not null,
  cha_typ_id NUMBER(5) not null,
  contact    VARCHAR2(1024),
  sta_dat    VARCHAR2(20),
  end_dat    VARCHAR2(20),
  is_def     VARCHAR2(1),
  pos_cod    VARCHAR2(6),
  note       VARCHAR2(256),
  con_sta_id NUMBER(5) not null,
  is_del     VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 164M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.ADD_IDX_C_CHA on UNICALL.C_CHA (CONTACT)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 80M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF1212 on UNICALL.C_CHA (CHA_TYP_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 40M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF5557 on UNICALL.C_CHA (CON_STA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 40M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CHA
  add constraint PKCHA primary key (CHA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 44M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CHA
  add constraint REFC_CHA_STA57 foreign key (CON_STA_ID)
  references UNICALL.C_CHA_STA (CON_STA_ID);
alter table UNICALL.C_CHA
  add constraint REFC_CHA_TYP12 foreign key (CHA_TYP_ID)
  references UNICALL.C_CHA_TYP (CHA_TYP_ID);

prompt
prompt Creating table C_CHA_INS_STA
prompt ============================
prompt
create table UNICALL.C_CHA_INS_STA
(
  cha_ins_sta_id  NUMBER(5) not null,
  cha_ins_sta_des VARCHAR2(64),
  is_del          VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CHA_INS_STA
  add constraint PKCHA_INS_STA primary key (CHA_INS_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_DIR
prompt ====================
prompt
create table UNICALL.C_DIR
(
  dir_id  NUMBER(5) not null,
  dir_des VARCHAR2(64),
  is_del  VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_DIR
  add constraint PKDIR primary key (DIR_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CHA_INS
prompt ========================
prompt
create table UNICALL.C_CHA_INS
(
  cha_ins_id     NUMBER(10) not null,
  cha_typ_id     NUMBER(5) not null,
  dir_id         NUMBER(5) not null,
  cha_ins_sta_id NUMBER(5) not null,
  path           VARCHAR2(512),
  abstract       VARCHAR2(1024),
  use_id         NUMBER(10) not null,
  sta_dat        VARCHAR2(20),
  end_dat        VARCHAR2(20),
  other          VARCHAR2(2048),
  note           VARCHAR2(1024)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 151M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF4850 on UNICALL.C_CHA_INS (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 41M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CHA_INS
  add constraint PKCHA_INS primary key (CHA_INS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 40M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CHA_INS
  add constraint REFC_CHA_INS_STA47 foreign key (CHA_INS_STA_ID)
  references UNICALL.C_CHA_INS_STA (CHA_INS_STA_ID);
alter table UNICALL.C_CHA_INS
  add constraint REFC_CHA_TYP45 foreign key (CHA_TYP_ID)
  references UNICALL.C_CHA_TYP (CHA_TYP_ID);
alter table UNICALL.C_CHA_INS
  add constraint REFC_DIR46 foreign key (DIR_ID)
  references UNICALL.C_DIR (DIR_ID);

prompt
prompt Creating table C_CHA_INS_CHA
prompt ============================
prompt
create table UNICALL.C_CHA_INS_CHA
(
  cha_ins_id NUMBER(10) not null,
  cha_id     NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 39M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF1349 on UNICALL.C_CHA_INS_CHA (CHA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 45M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF4152 on UNICALL.C_CHA_INS_CHA (CHA_INS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 42M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CHA_INS_CHA
  add constraint PKCHA_INS_CHA primary key (CHA_INS_ID, CHA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 53M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CHA_INS_CHA
  add constraint REFC_CHA49 foreign key (CHA_ID)
  references UNICALL.C_CHA (CHA_ID);
alter table UNICALL.C_CHA_INS_CHA
  add constraint REFC_CHA_INS52 foreign key (CHA_INS_ID)
  references UNICALL.C_CHA_INS (CHA_INS_ID);

prompt
prompt Creating table C_CUS_STA
prompt ========================
prompt
create table UNICALL.C_CUS_STA
(
  cus_sta_id  NUMBER(5) not null,
  cus_sta_des VARCHAR2(40) not null,
  is_del      VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_STA
  add constraint PKCUS_STA primary key (CUS_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CUS_TIT
prompt ========================
prompt
create table UNICALL.C_CUS_TIT
(
  cus_tit_id  NUMBER(5) not null,
  cus_tit_des VARCHAR2(64),
  is_del      VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_TIT
  add constraint PKCUS_TIT primary key (CUS_TIT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CUS_TRA
prompt ========================
prompt
create table UNICALL.C_CUS_TRA
(
  cus_tra_id  NUMBER(5) not null,
  cus_tra_des VARCHAR2(80) not null,
  is_del      VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_TRA
  add constraint PKCUS_TRA primary key (CUS_TRA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CUS_TYP
prompt ========================
prompt
create table UNICALL.C_CUS_TYP
(
  cus_typ_id     NUMBER(5) not null,
  par_typ_bas_id NUMBER(5),
  par_typ_id     NUMBER(5) not null,
  cus_typ_des    VARCHAR2(80) not null,
  dis_id         NUMBER(4),
  tab_dis_id     NUMBER(5),
  tab_id         NUMBER(5),
  is_del         VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF21 on UNICALL.C_CUS_TYP (PAR_TYP_BAS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF22 on UNICALL.C_CUS_TYP (PAR_TYP_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_TYP
  add constraint PKCUS_TYP primary key (CUS_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_TYP
  add constraint REFC_CUS_TYP1 foreign key (PAR_TYP_BAS_ID)
  references UNICALL.C_CUS_TYP (CUS_TYP_ID);
alter table UNICALL.C_CUS_TYP
  add constraint REFC_CUS_TYP2 foreign key (PAR_TYP_ID)
  references UNICALL.C_CUS_TYP (CUS_TYP_ID);

prompt
prompt Creating table C_CUS_BAS
prompt ========================
prompt
create table UNICALL.C_CUS_BAS
(
  cus_id                 NUMBER(10) not null,
  cus_typ_id             NUMBER(5) not null,
  cus_tra_id             NUMBER(5),
  cus_sta_id             NUMBER(5),
  cus_tit_id             NUMBER(5),
  cus_nam                VARCHAR2(512),
  ope_dat                VARCHAR2(20),
  cus_ali_id             VARCHAR2(40),
  cus_gra_id             NUMBER(5),
  cha_typ_3              VARCHAR2(60),
  cha_typ_4              VARCHAR2(60),
  cha_typ_5              VARCHAR2(60),
  cha_typ_6              VARCHAR2(256),
  cha_typ_8              VARCHAR2(1024),
  ext_1                  VARCHAR2(2000),
  ext_2                  VARCHAR2(2000),
  ext_3                  VARCHAR2(1000),
  ext_4                  VARCHAR2(1000),
  ext_5                  VARCHAR2(1000),
  ext_6                  VARCHAR2(1000),
  use_id                 NUMBER(10),
  pho                    VARCHAR2(256),
  cat_id_03              NUMBER(30),
  cat_id_02              NUMBER(30),
  cat_id_01              NUMBER(30),
  car                    VARCHAR2(64),
  rem                    VARCHAR2(4000),
  gen                    VARCHAR2(8),
  bir                    VARCHAR2(10),
  hom_tel                VARCHAR2(100),
  off_tel                VARCHAR2(100),
  pos_cod                VARCHAR2(20),
  credit_card            VARCHAR2(64),
  credit_expire_date     VARCHAR2(128),
  ide_num                VARCHAR2(50),
  insdesc_in_biz         VARCHAR2(500),
  ide_typ                VARCHAR2(2),
  is_take_in             CHAR(1),
  is_buy                 CHAR(1),
  end_time               VARCHAR2(10),
  create_time            VARCHAR2(10),
  insurance_per_volum_id VARCHAR2(30),
  org_id                 NUMBER(10),
  send_status            VARCHAR2(2),
  cus_marital            VARCHAR2(2),
  cus_education          VARCHAR2(2),
  cus_salary             VARCHAR2(2),
  cus_health             VARCHAR2(2),
  cus_keep_ins           VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 2143M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_CUS_BAS.insurance_per_volum_id
  is '如果不为空，表示此为赠险id';
comment on column UNICALL.C_CUS_BAS.org_id
  is '实现数据权限过滤';
comment on column UNICALL.C_CUS_BAS.send_status
  is '是否供数（00或者NULL-未供数，01-已供数）';
comment on column UNICALL.C_CUS_BAS.cus_marital
  is '婚姻状况 1:已婚 2:未婚 3:离异 4:丧偶 5:未知';
comment on column UNICALL.C_CUS_BAS.cus_education
  is '最高学历 1:博士研究生 2:硕士研究生 3:大学本科 4:大学专科 5:普通高中 6:中职（中专、职校、技校） 7:初中及以下';
comment on column UNICALL.C_CUS_BAS.cus_salary
  is '年收入金额   1:3万元以下  2:3万（含）至10万元  3:10万（含）至30万元  4:30万元（含）以上';
comment on column UNICALL.C_CUS_BAS.cus_health
  is '健康状况  1:良好  2:一般  3:有慢性病  4:残疾  5:死亡 6:未知';
comment on column UNICALL.C_CUS_BAS.cus_keep_ins
  is '是否购买过保险  0：否；1：是';
create index UNICALL.IDX_C_CUS_BAS_01 on UNICALL.C_CUS_BAS (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 33M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_C_CUS_BAS_02 on UNICALL.C_CUS_BAS (CUS_NAM)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 455M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_HOMETEL on UNICALL.C_CUS_BAS (HOM_TEL)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 104M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_IDENUM on UNICALL.C_CUS_BAS (IDE_NUM)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 186M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_OFFETEL on UNICALL.C_CUS_BAS (OFF_TEL)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_TYP5 on UNICALL.C_CUS_BAS (CHA_TYP_5)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 313M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_BAS
  add constraint PK_C_CUS_BAS primary key (CUS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_BAS
  add constraint REFC_CUS_STA9 foreign key (CUS_STA_ID)
  references UNICALL.C_CUS_STA (CUS_STA_ID);
alter table UNICALL.C_CUS_BAS
  add constraint REFC_CUS_TIT11 foreign key (CUS_TIT_ID)
  references UNICALL.C_CUS_TIT (CUS_TIT_ID);
alter table UNICALL.C_CUS_BAS
  add constraint REFC_CUS_TRA7 foreign key (CUS_TRA_ID)
  references UNICALL.C_CUS_TRA (CUS_TRA_ID);
alter table UNICALL.C_CUS_BAS
  add constraint REFC_CUS_TYP3 foreign key (CUS_TYP_ID)
  references UNICALL.C_CUS_TYP (CUS_TYP_ID);

prompt
prompt Creating table C_CHA_INS_CUS
prompt ============================
prompt
create table UNICALL.C_CHA_INS_CUS
(
  cha_ins_id NUMBER(10) not null,
  cus_id     NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 29M
    next 1M
    minextents 1
    maxextents unlimited
  );
create unique index UNICALL.WXX_UIDX on UNICALL.C_CHA_INS_CUS (CUS_ID, CHA_INS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 38M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CHA_INS_CUS
  add constraint PK74 primary key (CHA_INS_ID, CUS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 38M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CHA_INS_CUS
  add constraint REFC_CHA_INS78 foreign key (CHA_INS_ID)
  references UNICALL.C_CHA_INS (CHA_INS_ID);
alter table UNICALL.C_CHA_INS_CUS
  add constraint REFC_CUS_BAS79 foreign key (CUS_ID)
  references UNICALL.C_CUS_BAS (CUS_ID);

prompt
prompt Creating table C_CHA_INS_DI_RU
prompt ==============================
prompt
create table UNICALL.C_CHA_INS_DI_RU
(
  cha_ins_di_ru_id NUMBER(10) not null,
  ani              VARCHAR2(200),
  gro_id           NUMBER(30),
  ski_typ_id       NUMBER(30) not null,
  use_id           NUMBER(10),
  dni              VARCHAR2(200)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48138 on UNICALL.C_CHA_INS_DI_RU (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF64137 on UNICALL.C_CHA_INS_DI_RU (GRO_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF64141 on UNICALL.C_CHA_INS_DI_RU (SKI_TYP_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CHA_INS_DI_RU
  add constraint PK108 primary key (CHA_INS_DI_RU_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CHA_INS_DI_RU
  add constraint REFC_USE1381 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_CHA_INS_FIL
prompt ============================
prompt
create table UNICALL.C_CHA_INS_FIL
(
  fil_no      NUMBER not null,
  cha_ins_id  NUMBER,
  is_cha      VARCHAR2(1),
  fil_nam     VARCHAR2(200),
  tif_fil_nam VARCHAR2(200),
  src_nam     VARCHAR2(200)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 832K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF41224 on UNICALL.C_CHA_INS_FIL (CHA_INS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CLA
prompt ====================
prompt
create table UNICALL.C_CLA
(
  cla_typ_id  NUMBER(10) not null,
  cla_typ_des VARCHAR2(64),
  sta_dat     VARCHAR2(20),
  end_dat     VARCHAR2(20),
  cla_typ_con VARCHAR2(1024),
  pre_per_cou NUMBER(10),
  gen_dat     VARCHAR2(20),
  use_id      NUMBER(10),
  is_del      VARCHAR2(1),
  cla_sta_id  NUMBER(5),
  cat_id      NUMBER(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF109142 on UNICALL.C_CLA (CLA_STA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF4880 on UNICALL.C_CLA (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA
  add constraint PK75 primary key (CLA_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_CLA_BAS
prompt ========================
prompt
create table UNICALL.C_CLA_BAS
(
  cla_bas_id NUMBER(10) not null,
  tec_gro_id NUMBER(30),
  sta_dat    VARCHAR2(20),
  pre_cal    NUMBER(10),
  rel_cal    NUMBER(10),
  pre_per    NUMBER(5)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF64261 on UNICALL.C_CLA_BAS (TEC_GRO_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_BAS
  add constraint PK184 primary key (CLA_BAS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_CLA_INS
prompt ========================
prompt
create table UNICALL.C_CLA_INS
(
  cla_ins_id     NUMBER(10) not null,
  cla_typ_id     NUMBER(10) not null,
  val_dat        VARCHAR2(20),
  cur_per_cou    NUMBER(10),
  pra_per_cou    NUMBER(10),
  cla_ins_sta_id NUMBER(5)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF111143 on UNICALL.C_CLA_INS (CLA_INS_STA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF7581 on UNICALL.C_CLA_INS (CLA_TYP_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_INS
  add constraint PK76 primary key (CLA_INS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_INS
  add constraint REFC_CLA81 foreign key (CLA_TYP_ID)
  references UNICALL.C_CLA (CLA_TYP_ID);

prompt
prompt Creating table C_CLA_TIM_ARR
prompt ============================
prompt
create table UNICALL.C_CLA_TIM_ARR
(
  cla_tim_arr_id NUMBER(10) not null,
  use_id         NUMBER(10),
  sta_dat        VARCHAR2(20),
  end_dat        VARCHAR2(20),
  cla_ins_id     NUMBER(10),
  pra_sta_dat    VARCHAR2(20),
  pra_end_dat    VARCHAR2(20),
  cat_id         NUMBER(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48266 on UNICALL.C_CLA_TIM_ARR (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF76267 on UNICALL.C_CLA_TIM_ARR (CLA_INS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_TIM_ARR
  add constraint PK188 primary key (CLA_TIM_ARR_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_TIM_ARR
  add constraint REFC_CLA_INS267 foreign key (CLA_INS_ID)
  references UNICALL.C_CLA_INS (CLA_INS_ID);
alter table UNICALL.C_CLA_TIM_ARR
  add constraint REFC_USE266 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_CLA_CHA_LOG
prompt ============================
prompt
create table UNICALL.C_CLA_CHA_LOG
(
  cla_cha_id     NUMBER(10) not null,
  cla_tim_arr_id NUMBER(10),
  fro_use_id     NUMBER(10),
  to_use_id      NUMBER(10),
  opr_use_id     NUMBER(10),
  mod_dat        VARCHAR2(20),
  con            VARCHAR2(2000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF188290 on UNICALL.C_CLA_CHA_LOG (CLA_TIM_ARR_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48291 on UNICALL.C_CLA_CHA_LOG (FRO_USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48292 on UNICALL.C_CLA_CHA_LOG (TO_USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48293 on UNICALL.C_CLA_CHA_LOG (OPR_USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_CHA_LOG
  add constraint PK194 primary key (CLA_CHA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_CHA_LOG
  add constraint REFC_CLA_TIM_ARR290 foreign key (CLA_TIM_ARR_ID)
  references UNICALL.C_CLA_TIM_ARR (CLA_TIM_ARR_ID);
alter table UNICALL.C_CLA_CHA_LOG
  add constraint REFC_USE291 foreign key (FRO_USE_ID)
  references UNICALL.C_USE (USE_ID);
alter table UNICALL.C_CLA_CHA_LOG
  add constraint REFC_USE292 foreign key (TO_USE_ID)
  references UNICALL.C_USE (USE_ID);
alter table UNICALL.C_CLA_CHA_LOG
  add constraint REFC_USE293 foreign key (OPR_USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_CLA_ERL_C_PAR
prompt ==============================
prompt
create table UNICALL.C_CLA_ERL_C_PAR
(
  cla_erl_c_par_id NUMBER(10) not null,
  tec_gro_id       NUMBER(30),
  sta_dat          VARCHAR2(20),
  end_dat          VARCHAR2(20),
  cal_dur          NUMBER(8,2),
  avg_del          NUMBER(8,2),
  cla_ins_sta_id   NUMBER(5),
  per              NUMBER(8,2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF64268 on UNICALL.C_CLA_ERL_C_PAR (TEC_GRO_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_ERL_C_PAR
  add constraint PK187 primary key (CLA_ERL_C_PAR_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_CLA_EXC
prompt ========================
prompt
create table UNICALL.C_CLA_EXC
(
  c_cla_exc_id NUMBER(10) not null,
  use_id       NUMBER(10),
  sta_dat      VARCHAR2(20),
  end_dat      VARCHAR2(20),
  rul_typ_id   NUMBER(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48262 on UNICALL.C_CLA_EXC (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF64276 on UNICALL.C_CLA_EXC (RUL_TYP_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_EXC
  add constraint PK185 primary key (C_CLA_EXC_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_EXC
  add constraint REFC_USE262 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_CLA_INS_STA
prompt ============================
prompt
create table UNICALL.C_CLA_INS_STA
(
  cla_ins_sta_id  NUMBER(5) not null,
  cla_ins_sta_des VARCHAR2(64),
  is_del          VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_INS_STA
  add constraint PKCLA_INS_STA primary key (CLA_INS_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_TAS_CRI
prompt ========================
prompt
create table UNICALL.C_TAS_CRI
(
  is_del      VARCHAR2(1),
  tas_cri_id  NUMBER(5) not null,
  tas_cri_des VARCHAR2(64)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_TAS_CRI
  add constraint PKTAS_CRI primary key (TAS_CRI_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_TAS_MET
prompt ========================
prompt
create table UNICALL.C_TAS_MET
(
  tas_met_id  NUMBER(5) not null,
  tas_met_des VARCHAR2(64) not null,
  is_del      VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_TAS_MET
  add constraint PKTAS_MET primary key (TAS_MET_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_TAS_PRI
prompt ========================
prompt
create table UNICALL.C_TAS_PRI
(
  tas_pri_id  NUMBER(5) not null,
  tas_pri_des VARCHAR2(40) not null,
  is_del      VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_TAS_PRI
  add constraint PKTAS_PRI primary key (TAS_PRI_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_TAS_STA
prompt ========================
prompt
create table UNICALL.C_TAS_STA
(
  is_del      VARCHAR2(1),
  tas_sta_id  NUMBER(5) not null,
  tas_sta_des VARCHAR2(64)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_TAS_STA
  add constraint PKTAS_STA primary key (TAS_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_TAS
prompt ====================
prompt
create table UNICALL.C_TAS
(
  tas_id     NUMBER(10) not null,
  dir_id     NUMBER(5) not null,
  tas_met_id NUMBER(5),
  tas_pri_id NUMBER(5),
  sta_dat    VARCHAR2(20),
  end_dat    VARCHAR2(20),
  on_dat     VARCHAR2(20),
  tas_cri_id NUMBER(5),
  tas_sta_id NUMBER(5),
  cat_id     NUMBER(30),
  con        VARCHAR2(4000),
  fro_use_id NUMBER(10),
  to_use_id  NUMBER(10),
  res        VARCHAR2(4000),
  cal_id     VARCHAR2(40),
  pro_cou    NUMBER(5),
  cha_con    VARCHAR2(64)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 445M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2418 on UNICALL.C_TAS (TAS_STA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 35M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2621 on UNICALL.C_TAS (TAS_PRI_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 35M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2722 on UNICALL.C_TAS (TAS_CRI_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 35M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF3530 on UNICALL.C_TAS (TAS_MET_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 35M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF3840 on UNICALL.C_TAS (DIR_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 35M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF48122 on UNICALL.C_TAS (TO_USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 41M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF4851 on UNICALL.C_TAS (FRO_USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 40M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF64109 on UNICALL.C_TAS (CAT_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 40M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF64111 on UNICALL.C_TAS (STA_DAT)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 79M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_TAS
  add constraint PKTAS primary key (TAS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 40M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_TAS
  add constraint REFC_DIR40 foreign key (DIR_ID)
  references UNICALL.C_DIR (DIR_ID);
alter table UNICALL.C_TAS
  add constraint REFC_TAS_CRI22 foreign key (TAS_CRI_ID)
  references UNICALL.C_TAS_CRI (TAS_CRI_ID);
alter table UNICALL.C_TAS
  add constraint REFC_TAS_MET30 foreign key (TAS_MET_ID)
  references UNICALL.C_TAS_MET (TAS_MET_ID);
alter table UNICALL.C_TAS
  add constraint REFC_TAS_PRI21 foreign key (TAS_PRI_ID)
  references UNICALL.C_TAS_PRI (TAS_PRI_ID);
alter table UNICALL.C_TAS
  add constraint REFC_TAS_STA18 foreign key (TAS_STA_ID)
  references UNICALL.C_TAS_STA (TAS_STA_ID);

prompt
prompt Creating table C_CLA_INS_TAS
prompt ============================
prompt
create table UNICALL.C_CLA_INS_TAS
(
  cla_ins_id NUMBER(10) not null,
  tas_id     NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF3384 on UNICALL.C_CLA_INS_TAS (TAS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF7682 on UNICALL.C_CLA_INS_TAS (CLA_INS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_INS_TAS
  add constraint PK77 primary key (CLA_INS_ID, TAS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_INS_TAS
  add constraint REFC_CLA_INS82 foreign key (CLA_INS_ID)
  references UNICALL.C_CLA_INS (CLA_INS_ID);
alter table UNICALL.C_CLA_INS_TAS
  add constraint REFC_TAS84 foreign key (TAS_ID)
  references UNICALL.C_TAS (TAS_ID);

prompt
prompt Creating table C_CLA_STA
prompt ========================
prompt
create table UNICALL.C_CLA_STA
(
  cla_sta_id  NUMBER(5) not null,
  cla_sta_des VARCHAR2(64),
  is_del      VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CLA_STA
  add constraint PKCLA_STA primary key (CLA_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_CPIC_DIAL
prompt ==========================
prompt
create table UNICALL.C_CPIC_DIAL
(
  id         NUMBER not null,
  name       VARCHAR2(20),
  sex        VARCHAR2(2),
  card_type  VARCHAR2(2),
  card_id    VARCHAR2(30),
  birth      VARCHAR2(30),
  ftel       VARCHAR2(30),
  ctel       VARCHAR2(30),
  mobie      VARCHAR2(30),
  otel       VARCHAR2(30),
  fax        VARCHAR2(30),
  zipcode    VARCHAR2(30),
  addr       VARCHAR2(100),
  pro        VARCHAR2(20),
  company    VARCHAR2(50),
  e_mail     VARCHAR2(50),
  bank       VARCHAR2(50),
  bank_acc   VARCHAR2(50),
  insurace   VARCHAR2(50),
  remark     VARCHAR2(500),
  ftel_sta   VARCHAR2(3),
  ctel_sta   VARCHAR2(3),
  mobie_sta  VARCHAR2(3),
  otel_sta   VARCHAR2(3),
  exp_flag   VARCHAR2(1),
  ftel_time  VARCHAR2(30),
  ctel_time  VARCHAR2(30),
  mobie_time VARCHAR2(30),
  otel_time  VARCHAR2(30),
  fgs_code   VARCHAR2(30),
  ext1       VARCHAR2(30),
  ext2       VARCHAR2(30),
  ext3       VARCHAR2(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 1129M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CPIC_DIAL
  add constraint PK_C_CPIC_DIAL primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 112M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CPIC_POLICY_STA
prompt ================================
prompt
create table UNICALL.C_CPIC_POLICY_STA
(
  id        NUMBER not null,
  appno     VARCHAR2(18),
  policyno  VARCHAR2(18),
  t1        VARCHAR2(20),
  t2        VARCHAR2(20),
  t3        VARCHAR2(20),
  t4        VARCHAR2(20),
  t5        VARCHAR2(20),
  t6        VARCHAR2(20),
  t7        VARCHAR2(20),
  t8        VARCHAR2(20),
  ext1      VARCHAR2(200),
  ext2      VARCHAR2(200),
  ext3      VARCHAR2(200),
  ext4      VARCHAR2(200),
  ext5      VARCHAR2(200),
  chttime   VARCHAR2(200),
  policysta VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 4M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_CPIC_POLICY_STA.id
  is 'ID';
comment on column UNICALL.C_CPIC_POLICY_STA.appno
  is '投保单号';
comment on column UNICALL.C_CPIC_POLICY_STA.policyno
  is '保单号';
comment on column UNICALL.C_CPIC_POLICY_STA.t1
  is '成交数据导出并传回总公司';
comment on column UNICALL.C_CPIC_POLICY_STA.t2
  is '成交数据导入总公司系统';
comment on column UNICALL.C_CPIC_POLICY_STA.t3
  is '检查投保单';
comment on column UNICALL.C_CPIC_POLICY_STA.t4
  is '投保单递交出单室';
comment on column UNICALL.C_CPIC_POLICY_STA.t5
  is '领取投保单';
comment on column UNICALL.C_CPIC_POLICY_STA.t6
  is '反馈客户签收信息给电销内勤';
comment on column UNICALL.C_CPIC_POLICY_STA.t7
  is '在保单回执系统内录入回执信息';
comment on column UNICALL.C_CPIC_POLICY_STA.t8
  is '发回执和递送信息给总公司电销内勤';

prompt
prompt Creating table C_CPIC_TMP
prompt =========================
prompt
create table UNICALL.C_CPIC_TMP
(
  id      NUMBER not null,
  card_id VARCHAR2(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 768K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CPIC_TMP
  add constraint CCPICTMPPK primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CUR_AGE
prompt ========================
prompt
create table UNICALL.C_CUR_AGE
(
  cat_id NUMBER(30) not null,
  use_id NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF48145 on UNICALL.C_CUR_AGE (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUR_AGE
  add constraint PKCUR_AGE primary key (CAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUR_AGE
  add constraint REFC_USE145 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_CUS_BAS_CHANGE
prompt ===============================
prompt
create table UNICALL.C_CUS_BAS_CHANGE
(
  id          NUMBER(20) not null,
  cus_id      NUMBER(20) not null,
  cus_nam     VARCHAR2(512),
  ide_num     VARCHAR2(50),
  office_tel  VARCHAR2(60),
  home_tel    VARCHAR2(60),
  mobile_tel  VARCHAR2(60),
  other_tel   VARCHAR2(60),
  address     VARCHAR2(1024),
  change_date DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 4M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_BAS_CHANGE
  add constraint PK_C_CUS_BAS_CHANGE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 512K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_ECIF
prompt =====================
prompt
create table UNICALL.C_ECIF
(
  id         NUMBER(10) not null,
  file_name  VARCHAR2(500),
  creat_time VARCHAR2(100),
  succss_num NUMBER(10),
  error_num  NUMBER(10),
  r_1        VARCHAR2(1000),
  r_2        VARCHAR2(1000),
  r_3        VARCHAR2(1000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.IDX_C_ECIF_CREAT_TIME on UNICALL.C_ECIF (CREAT_TIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_ECIF
  add constraint PK_C_ECIF primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_CUS_BAS_ECIF
prompt =============================
prompt
create table UNICALL.C_CUS_BAS_ECIF
(
  cus_id             NUMBER(10) not null,
  cus_typ_id         NUMBER(5) not null,
  cus_tra_id         NUMBER(5),
  cus_sta_id         NUMBER(5),
  cus_tit_id         NUMBER(5),
  cus_nam            VARCHAR2(512),
  ope_dat            VARCHAR2(20),
  cus_ali_id         VARCHAR2(40),
  cus_gra_id         NUMBER(5),
  cha_typ_3          VARCHAR2(60),
  cha_typ_4          VARCHAR2(60),
  cha_typ_5          VARCHAR2(60),
  cha_typ_6          VARCHAR2(256),
  cha_typ_8          VARCHAR2(1024),
  ext_1              VARCHAR2(2000),
  ext_2              VARCHAR2(2000),
  ext_3              VARCHAR2(1000),
  ext_4              VARCHAR2(1000),
  ext_5              VARCHAR2(1000),
  ext_6              VARCHAR2(1000),
  use_id             NUMBER(10),
  pho                VARCHAR2(256),
  cat_id_03          NUMBER(30),
  cat_id_02          NUMBER(30),
  cat_id_01          NUMBER(30),
  car                VARCHAR2(64),
  rem                VARCHAR2(4000),
  gen                VARCHAR2(8),
  bir                VARCHAR2(10),
  hom_tel            VARCHAR2(100),
  off_tel            VARCHAR2(100),
  pos_cod            VARCHAR2(20),
  credit_card        VARCHAR2(64),
  credit_expire_date VARCHAR2(128),
  ide_num            VARCHAR2(50),
  insdesc_in_biz     VARCHAR2(500),
  ide_typ            VARCHAR2(2),
  state              VARCHAR2(2),
  res_log            VARCHAR2(4000),
  ecif_id            NUMBER(10) not null,
  r_1                VARCHAR2(1000),
  r_2                VARCHAR2(1000),
  r_3                VARCHAR2(1000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.IDX_C_CUS_BAS_ECIF_01 on UNICALL.C_CUS_BAS_ECIF (OPE_DAT)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.IDX_C_CUS_BAS_ECIF_02 on UNICALL.C_CUS_BAS_ECIF (STATE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.IDX_C_CUS_BAS_ECIF_03 on UNICALL.C_CUS_BAS_ECIF (ECIF_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_BAS_ECIF
  add constraint PK_C_CUS_BAS_ECIF primary key (CUS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_BAS_ECIF
  add constraint FK_C_CUS_BAS_ECIF foreign key (ECIF_ID)
  references UNICALL.C_ECIF (ID);

prompt
prompt Creating table C_CUS_BAS_FAIL_TEMP
prompt ==================================
prompt
create table UNICALL.C_CUS_BAS_FAIL_TEMP
(
  id                     NUMBER(10) not null,
  cus_nam                VARCHAR2(512),
  gen                    VARCHAR2(8),
  ide_typ                VARCHAR2(2),
  ide_num                VARCHAR2(50),
  bir                    VARCHAR2(10),
  hom_tel                VARCHAR2(100),
  off_tel                VARCHAR2(100),
  cha_typ_5              VARCHAR2(60),
  cha_typ_3              VARCHAR2(60),
  cha_typ_4              VARCHAR2(60),
  pos_cod                VARCHAR2(20),
  cha_typ_8              VARCHAR2(1024),
  ext_3                  VARCHAR2(1000),
  ext_4                  VARCHAR2(1000),
  cha_typ_6              VARCHAR2(256),
  bank_name              VARCHAR2(1024),
  bank_account           VARCHAR2(1024),
  insurance_name         VARCHAR2(1024),
  rem                    VARCHAR2(4000),
  insurance_per_volum_id VARCHAR2(30),
  fail_reason            VARCHAR2(4000),
  cus_gro_id             NUMBER(10),
  ob_com_id              NUMBER(10),
  use_id                 NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.id
  is '主键';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.cus_nam
  is '客户姓名';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.gen
  is '性别';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.ide_typ
  is '证件类型';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.ide_num
  is '证件号码';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.bir
  is '生日';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.hom_tel
  is '家庭电话号码';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.off_tel
  is '办公电话号码';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.cha_typ_5
  is '移动电话号码';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.cha_typ_3
  is '其他电话号码';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.cha_typ_4
  is '传真';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.pos_cod
  is '邮政编码';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.cha_typ_8
  is '通信地址';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.ext_3
  is '职业';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.ext_4
  is '所属企业名称';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.cha_typ_6
  is '电子邮件';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.bank_name
  is '开户银行';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.bank_account
  is '开户银行账户';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.insurance_name
  is '险种';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.rem
  is '备注';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.insurance_per_volum_id
  is '赠险ID';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.fail_reason
  is '失败原因';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.cus_gro_id
  is '活动ID';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.ob_com_id
  is '活动ID';
comment on column UNICALL.C_CUS_BAS_FAIL_TEMP.use_id
  is '导入人ID';
alter table UNICALL.C_CUS_BAS_FAIL_TEMP
  add constraint PK_C_CUS_BAS_FAIL_TEMP primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CUS_BAS_HIS
prompt ============================
prompt
create table UNICALL.C_CUS_BAS_HIS
(
  cus_id     NUMBER(30) not null,
  ser_id     NUMBER(30) not null,
  mod_dat    VARCHAR2(20),
  cus_ali_id VARCHAR2(80),
  cus_typ_id NUMBER(20) not null,
  cus_tra_id NUMBER(20),
  cus_sta_id NUMBER(20),
  cus_tit_id NUMBER(20),
  cus_nam    VARCHAR2(512),
  bir        VARCHAR2(20),
  gen        VARCHAR2(2),
  ope_dat    VARCHAR2(20),
  rem        VARCHAR2(512),
  car        VARCHAR2(512),
  cus_gra_id NUMBER(20),
  cha_typ_3  VARCHAR2(512),
  cha_typ_4  VARCHAR2(512),
  cha_typ_5  VARCHAR2(512),
  cha_typ_6  VARCHAR2(512),
  cha_typ_8  VARCHAR2(512),
  ext_1      VARCHAR2(20),
  ext_2      VARCHAR2(20),
  ext_3      VARCHAR2(40),
  ext_4      VARCHAR2(20),
  ext_5      VARCHAR2(20),
  cat_id_01  NUMBER(30),
  cat_id_02  NUMBER(30),
  use_id     NUMBER(10) not null,
  pho        VARCHAR2(256),
  cat_id_03  NUMBER(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF1130 on UNICALL.C_CUS_BAS_HIS (CUS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48131 on UNICALL.C_CUS_BAS_HIS (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_BAS_HIS
  add constraint PKCUS_BAS_HIS primary key (CUS_ID, SER_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_BAS_HIS
  add constraint REFC_CUS_BAS130 foreign key (CUS_ID)
  references UNICALL.C_CUS_BAS (CUS_ID);
alter table UNICALL.C_CUS_BAS_HIS
  add constraint REFC_USE131 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_CUS_BAS_TEMP
prompt =============================
prompt
create table UNICALL.C_CUS_BAS_TEMP
(
  cus_id                 NUMBER(10) not null,
  cus_typ_id             NUMBER(5) not null,
  cus_tra_id             NUMBER(5),
  cus_nam                VARCHAR2(512),
  gen                    VARCHAR2(8),
  ide_typ                VARCHAR2(2),
  ide_num                VARCHAR2(50),
  bir                    VARCHAR2(10),
  hom_tel                VARCHAR2(100),
  off_tel                VARCHAR2(100),
  cha_typ_5              VARCHAR2(60),
  cha_typ_3              VARCHAR2(60),
  cha_typ_4              VARCHAR2(60),
  pos_cod                VARCHAR2(20),
  cha_typ_8              VARCHAR2(1024),
  ext_3                  VARCHAR2(1000),
  ext_4                  VARCHAR2(1000),
  cha_typ_6              VARCHAR2(256),
  bank_name              VARCHAR2(1024),
  bank_account           VARCHAR2(1024),
  insurance_name         VARCHAR2(1024),
  rem                    VARCHAR2(4000),
  ori_rem                VARCHAR2(4000),
  insurance_per_volum_id VARCHAR2(30),
  use_id                 NUMBER(10),
  org_id                 NUMBER(10),
  cus_gro_id             NUMBER(10),
  ob_com_id              NUMBER(10),
  ob_com_cus_id          NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_CUS_BAS_TEMP.cus_id
  is '客户ID';
comment on column UNICALL.C_CUS_BAS_TEMP.cus_typ_id
  is '客户类型ID';
comment on column UNICALL.C_CUS_BAS_TEMP.cus_tra_id
  is '客户行业ID';
comment on column UNICALL.C_CUS_BAS_TEMP.cus_nam
  is '客户姓名';
comment on column UNICALL.C_CUS_BAS_TEMP.gen
  is '性别';
comment on column UNICALL.C_CUS_BAS_TEMP.ide_typ
  is '证件类型';
comment on column UNICALL.C_CUS_BAS_TEMP.ide_num
  is '证件号码';
comment on column UNICALL.C_CUS_BAS_TEMP.bir
  is '生日';
comment on column UNICALL.C_CUS_BAS_TEMP.hom_tel
  is '家庭电话号码';
comment on column UNICALL.C_CUS_BAS_TEMP.off_tel
  is '办公电话号码';
comment on column UNICALL.C_CUS_BAS_TEMP.cha_typ_5
  is '移动电话号码';
comment on column UNICALL.C_CUS_BAS_TEMP.cha_typ_3
  is '其他电话号码';
comment on column UNICALL.C_CUS_BAS_TEMP.cha_typ_4
  is '传真';
comment on column UNICALL.C_CUS_BAS_TEMP.pos_cod
  is '邮政编码';
comment on column UNICALL.C_CUS_BAS_TEMP.cha_typ_8
  is '通信地址';
comment on column UNICALL.C_CUS_BAS_TEMP.ext_3
  is '职业';
comment on column UNICALL.C_CUS_BAS_TEMP.ext_4
  is '所属企业名称';
comment on column UNICALL.C_CUS_BAS_TEMP.cha_typ_6
  is '电子邮件';
comment on column UNICALL.C_CUS_BAS_TEMP.bank_name
  is '开户银行';
comment on column UNICALL.C_CUS_BAS_TEMP.bank_account
  is '开户银行账户';
comment on column UNICALL.C_CUS_BAS_TEMP.insurance_name
  is '险种';
comment on column UNICALL.C_CUS_BAS_TEMP.rem
  is '备注';
comment on column UNICALL.C_CUS_BAS_TEMP.ori_rem
  is '初始备注';
comment on column UNICALL.C_CUS_BAS_TEMP.insurance_per_volum_id
  is '赠险ID';
comment on column UNICALL.C_CUS_BAS_TEMP.use_id
  is '导入人ID';
comment on column UNICALL.C_CUS_BAS_TEMP.org_id
  is '数据权限ID';
comment on column UNICALL.C_CUS_BAS_TEMP.cus_gro_id
  is '名单ID';
comment on column UNICALL.C_CUS_BAS_TEMP.ob_com_id
  is '活动ID';
comment on column UNICALL.C_CUS_BAS_TEMP.ob_com_cus_id
  is '外拨目标接口表ID';
create index UNICALL.IDXHOMETEL on UNICALL.C_CUS_BAS_TEMP (HOM_TEL)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDXIDENUM on UNICALL.C_CUS_BAS_TEMP (IDE_NUM)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDXMOBIL on UNICALL.C_CUS_BAS_TEMP (CHA_TYP_5)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDXOFFETEL on UNICALL.C_CUS_BAS_TEMP (OFF_TEL)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDXOHTERTEL on UNICALL.C_CUS_BAS_TEMP (CHA_TYP_3)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.INDEXGROID on UNICALL.C_CUS_BAS_TEMP (CUS_GRO_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_BAS_TEMP
  add constraint PK_C_CUS_BAS_TEMP primary key (CUS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CUS_BAS_TMP
prompt ============================
prompt
create table UNICALL.C_CUS_BAS_TMP
(
  cus_id     NUMBER(10) not null,
  cus_ali_id VARCHAR2(40),
  cus_typ_id NUMBER(5),
  cus_tra_id NUMBER(5),
  cus_sta_id NUMBER(5),
  cus_tit_id NUMBER(5),
  cus_nam    VARCHAR2(512),
  bir        VARCHAR2(10),
  gen        VARCHAR2(1),
  ope_dat    VARCHAR2(20),
  rem        VARCHAR2(512),
  car        VARCHAR2(64),
  cus_gra_id NUMBER(5),
  cha_typ_3  VARCHAR2(4000),
  cha_typ_4  VARCHAR2(4000),
  cha_typ_5  VARCHAR2(4000),
  cha_typ_6  VARCHAR2(4000),
  cha_typ_8  VARCHAR2(4000),
  ext_1      VARCHAR2(20),
  ext_2      VARCHAR2(20),
  ext_3      VARCHAR2(40),
  ext_4      VARCHAR2(20),
  ext_5      VARCHAR2(20),
  cat_id_01  NUMBER(30),
  cat_id_02  NUMBER(30),
  cat_id_03  NUMBER(30),
  use_id     NUMBER(10),
  pho        VARCHAR2(256),
  u1         VARCHAR2(512),
  u2         VARCHAR2(512),
  u3         VARCHAR2(512),
  u4         VARCHAR2(512),
  u5         VARCHAR2(512),
  u6         VARCHAR2(512),
  u7         VARCHAR2(512),
  u8         VARCHAR2(512),
  u9         VARCHAR2(512),
  u10        VARCHAR2(512),
  u11        VARCHAR2(512),
  u12        VARCHAR2(512),
  u13        VARCHAR2(512),
  u14        VARCHAR2(512),
  u15        VARCHAR2(512),
  u16        VARCHAR2(512),
  u17        VARCHAR2(512),
  u18        VARCHAR2(512),
  u19        VARCHAR2(512),
  u20        VARCHAR2(512),
  u21        VARCHAR2(512),
  u22        VARCHAR2(512),
  u23        VARCHAR2(512),
  u24        VARCHAR2(512),
  u25        VARCHAR2(512),
  u26        VARCHAR2(512),
  u27        VARCHAR2(512),
  u28        VARCHAR2(512),
  u29        VARCHAR2(512),
  u30        VARCHAR2(512)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_BAS_TMP
  add constraint PKCUS_BAS_1 primary key (CUS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_CUS_CAR_TYP
prompt ============================
prompt
create table UNICALL.C_CUS_CAR_TYP
(
  cus_car_typ_id  NUMBER(5) not null,
  cus_car_typ_des VARCHAR2(20) not null,
  is_del          VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_CAR_TYP
  add constraint PKCUS_CAR_TYP primary key (CUS_CAR_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_CUS_CHA
prompt ========================
prompt
create table UNICALL.C_CUS_CHA
(
  cus_id NUMBER(10) not null,
  cha_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 41M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF1338 on UNICALL.C_CUS_CHA (CHA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 42M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF137 on UNICALL.C_CUS_CHA (CUS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 42M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_CHA
  add constraint PKCUS_CHA primary key (CUS_ID, CHA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 54M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_CHA
  add constraint REFC_CHA38 foreign key (CHA_ID)
  references UNICALL.C_CHA (CHA_ID);
alter table UNICALL.C_CUS_CHA
  add constraint REFC_CUS_BAS37 foreign key (CUS_ID)
  references UNICALL.C_CUS_BAS (CUS_ID);

prompt
prompt Creating table C_CUS_COMMINFO
prompt =============================
prompt
create table UNICALL.C_CUS_COMMINFO
(
  cid           NUMBER(10) not null,
  documentsname VARCHAR2(128),
  commidate     TIMESTAMP(6),
  branchcode    VARCHAR2(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_COMMINFO
  add constraint PK_C_CUS_COMMINFO primary key (CID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CUS_COMMISSION
prompt ===============================
prompt
create table UNICALL.C_CUS_COMMISSION
(
  id            NUMBER(10) not null,
  pno           VARCHAR2(120),
  plcno         VARCHAR2(120),
  productid     VARCHAR2(60),
  paymenttimes  VARCHAR2(2),
  inpremiumdate VARCHAR2(10),
  paidtimes     VARCHAR2(2),
  returnpremium VARCHAR2(15),
  surrenderdate VARCHAR2(10),
  paymentrate   VARCHAR2(2),
  paymentnorm   VARCHAR2(15),
  parts         VARCHAR2(10),
  payagelimit   VARCHAR2(15),
  comminfoid    NUMBER(10),
  discriminator NUMBER(1) default 0
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 320K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_COMMISSION
  add constraint PK_C_CUS_COMMISSION primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CUS_CREDIT
prompt ===========================
prompt
create table UNICALL.C_CUS_CREDIT
(
  identity_number VARCHAR2(32) not null,
  valid_from      VARCHAR2(32),
  valid_to        VARCHAR2(32),
  type            VARCHAR2(8)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_CREDIT
  add constraint PK_CUS_CREDIT_PK primary key (IDENTITY_NUMBER)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_CUS_GRA
prompt ========================
prompt
create table UNICALL.C_CUS_GRA
(
  cus_gra_id  NUMBER(5) not null,
  cus_gra_des VARCHAR2(64),
  is_del      VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_GRA
  add constraint PK103 primary key (CUS_GRA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_CUS_GRO
prompt ========================
prompt
create table UNICALL.C_CUS_GRO
(
  cus_gro_id     NUMBER(10) not null,
  cus_gro_des    VARCHAR2(4000),
  sta_dat        VARCHAR2(20),
  cus_gro_nam    VARCHAR2(512),
  cus_gro_sta_id NUMBER(5),
  use_id         NUMBER(10),
  org_id         NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_CUS_GRO.org_id
  is '实现数据权限过滤';
create index UNICALL.REF106133 on UNICALL.C_CUS_GRO (CUS_GRO_STA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF48134 on UNICALL.C_CUS_GRO (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_GRO
  add constraint PKCUS_GRO primary key (CUS_GRO_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CUS_GRO_CUS
prompt ============================
prompt
create table UNICALL.C_CUS_GRO_CUS
(
  cus_gro_id NUMBER(10) not null,
  cus_id     NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 116M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF159 on UNICALL.C_CUS_GRO_CUS (CUS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF5658 on UNICALL.C_CUS_GRO_CUS (CUS_GRO_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 121M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_GRO_CUS
  add constraint PKCUS_GRO_CUS primary key (CUS_GRO_ID, CUS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 160M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_GRO_CUS
  add constraint REFC_CUS_BAS59 foreign key (CUS_ID)
  references UNICALL.C_CUS_BAS (CUS_ID);
alter table UNICALL.C_CUS_GRO_CUS
  add constraint REFC_CUS_GRO58 foreign key (CUS_GRO_ID)
  references UNICALL.C_CUS_GRO (CUS_GRO_ID);

prompt
prompt Creating table C_CUS_GRO_STA
prompt ============================
prompt
create table UNICALL.C_CUS_GRO_STA
(
  cus_gro_sta_id  NUMBER(5) not null,
  cus_gro_sta_des VARCHAR2(64),
  is_del          VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_GRO_STA
  add constraint PKCUS_GRO_STA primary key (CUS_GRO_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CUS_IDE_TYP
prompt ============================
prompt
create table UNICALL.C_CUS_IDE_TYP
(
  cus_ide_typ_id  NUMBER(5) not null,
  cus_ide_typ_des VARCHAR2(20),
  is_del          VARCHAR2(1) default 0 not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_IDE_TYP
  add constraint PK_CUS_IDE_TYP_ID primary key (CUS_IDE_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CUS_REL_TYP
prompt ============================
prompt
create table UNICALL.C_CUS_REL_TYP
(
  cus_rel_typ_id  NUMBER(5) not null,
  cus_rel_typ_des VARCHAR2(64),
  is_del          VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_CUS_REL_TYP
  add constraint PKCUS_REL_TYP primary key (CUS_REL_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_CUS_REL
prompt ========================
prompt
create table UNICALL.C_CUS_REL
(
  cus_id         NUMBER(10) not null,
  rel_cus_id     NUMBER(10) not null,
  cus_rel_typ_id NUMBER(5) not null,
  sta_dat        VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF160 on UNICALL.C_CUS_REL (CUS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF161 on UNICALL.C_CUS_REL (REL_CUS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF5962 on UNICALL.C_CUS_REL (CUS_REL_TYP_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_REL
  add constraint PKCUS_REL primary key (CUS_ID, REL_CUS_ID, CUS_REL_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_REL
  add constraint REFC_CUS_BAS60 foreign key (CUS_ID)
  references UNICALL.C_CUS_BAS (CUS_ID);
alter table UNICALL.C_CUS_REL
  add constraint REFC_CUS_BAS61 foreign key (REL_CUS_ID)
  references UNICALL.C_CUS_BAS (CUS_ID);
alter table UNICALL.C_CUS_REL
  add constraint REFC_CUS_REL_TYP62 foreign key (CUS_REL_TYP_ID)
  references UNICALL.C_CUS_REL_TYP (CUS_REL_TYP_ID);

prompt
prompt Creating table C_CUS_UP_CON
prompt ===========================
prompt
create table UNICALL.C_CUS_UP_CON
(
  cus_gro_id NUMBER(10) not null,
  ext_nam    VARCHAR2(256),
  cat_id     NUMBER(30) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_UP_CON
  add constraint PK180 primary key (CUS_GRO_ID, CAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_UP_CON
  add constraint REFC_CUS_GRO254 foreign key (CUS_GRO_ID)
  references UNICALL.C_CUS_GRO (CUS_GRO_ID);

prompt
prompt Creating table C_CUS_UP_LOA
prompt ===========================
prompt
create table UNICALL.C_CUS_UP_LOA
(
  cus_id     NUMBER(10) not null,
  u1         VARCHAR2(512),
  u2         VARCHAR2(512),
  u3         VARCHAR2(512),
  u4         VARCHAR2(512),
  u5         VARCHAR2(512),
  u6         VARCHAR2(512),
  u7         VARCHAR2(512),
  u8         VARCHAR2(512),
  u9         VARCHAR2(512),
  u10        VARCHAR2(512),
  u11        VARCHAR2(512),
  u12        VARCHAR2(512),
  u13        VARCHAR2(512),
  u14        VARCHAR2(512),
  u15        VARCHAR2(512),
  u16        VARCHAR2(512),
  u17        VARCHAR2(512),
  u18        VARCHAR2(512),
  u19        VARCHAR2(512),
  u20        VARCHAR2(512),
  u21        VARCHAR2(512),
  u22        VARCHAR2(512),
  u23        VARCHAR2(512),
  u24        VARCHAR2(512),
  u25        VARCHAR2(512),
  u26        VARCHAR2(512),
  u27        VARCHAR2(512),
  u28        VARCHAR2(512),
  u29        VARCHAR2(512),
  u30        VARCHAR2(512),
  cus_gro_id NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_UP_LOA
  add constraint PK179 primary key (CUS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_CUS_UP_LOA
  add constraint REFC_CUS_BAS253 foreign key (CUS_ID)
  references UNICALL.C_CUS_BAS (CUS_ID);

prompt
prompt Creating table C_EXA_COM_TYP
prompt ============================
prompt
create table UNICALL.C_EXA_COM_TYP
(
  exa_com_typ_id  NUMBER(5) not null,
  exa_com_typ_des VARCHAR2(64),
  is_del          VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on table UNICALL.C_EXA_COM_TYP
  is '考核指标包计算类别';
comment on column UNICALL.C_EXA_COM_TYP.exa_com_typ_des
  is '3：累计分值
4：百分比';
alter table UNICALL.C_EXA_COM_TYP
  add constraint PK168 primary key (EXA_COM_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_EXA_DIS_TYP
prompt ============================
prompt
create table UNICALL.C_EXA_DIS_TYP
(
  exa_dis_typ_id  NUMBER(5) not null,
  exa_dis_typ_des VARCHAR2(64),
  is_del          VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_DIS_TYP
  add constraint PKEXA_DIS_TYP_ID primary key (EXA_DIS_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_EXA_DIS_BAG
prompt ============================
prompt
create table UNICALL.C_EXA_DIS_BAG
(
  cat_id         NUMBER(30) not null,
  exa_dis_typ_id NUMBER(5) not null,
  exa_com_typ_id NUMBER(5) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on column UNICALL.C_EXA_DIS_BAG.cat_id
  is '目录Id';
alter table UNICALL.C_EXA_DIS_BAG
  add constraint PK167 primary key (CAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_DIS_BAG
  add constraint REFC_EXA_COM_TYP238 foreign key (EXA_COM_TYP_ID)
  references UNICALL.C_EXA_COM_TYP (EXA_COM_TYP_ID);
alter table UNICALL.C_EXA_DIS_BAG
  add constraint REFC_EXA_DIS_TYP237 foreign key (EXA_DIS_TYP_ID)
  references UNICALL.C_EXA_DIS_TYP (EXA_DIS_TYP_ID);

prompt
prompt Creating table C_EX_ME_BY_TY
prompt ============================
prompt
create table UNICALL.C_EX_ME_BY_TY
(
  ex_me_by_ty_id NUMBER(5) not null,
  ex_me_by_ty_de VARCHAR2(64),
  is_del         VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EX_ME_BY_TY
  add constraint PK138 primary key (EX_ME_BY_TY_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_EXA_MET_STA
prompt ============================
prompt
create table UNICALL.C_EXA_MET_STA
(
  exa_met_sta_id  NUMBER(5) not null,
  exa_met_sta_des VARCHAR2(64),
  is_del          VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_MET_STA
  add constraint PK125 primary key (EXA_MET_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_EX_ME_EX_ME
prompt ============================
prompt
create table UNICALL.C_EX_ME_EX_ME
(
  ex_me_ex_me_id NUMBER(5) not null,
  ex_me_ex_me_de VARCHAR2(64),
  is_del         VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EX_ME_EX_ME
  add constraint PK126 primary key (EX_ME_EX_ME_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_EXA_MET
prompt ========================
prompt
create table UNICALL.C_EXA_MET
(
  exa_met_id     NUMBER(10) not null,
  exa_met_nam    VARCHAR2(1024),
  exa_met_des    VARCHAR2(4000),
  sta_dat        VARCHAR2(20),
  exa_met_sta_id NUMBER(5) not null,
  ex_me_ex_me_id NUMBER(5) not null,
  cal            VARCHAR2(4000),
  use_id         NUMBER(10) not null,
  end_dat        VARCHAR2(20),
  exa_met_typ    VARCHAR2(4000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF125176 on UNICALL.C_EXA_MET (EXA_MET_STA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF126177 on UNICALL.C_EXA_MET (EX_ME_EX_ME_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48198 on UNICALL.C_EXA_MET (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_MET
  add constraint PK123 primary key (EXA_MET_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_MET
  add constraint REFC_EXA_MET_STA176 foreign key (EXA_MET_STA_ID)
  references UNICALL.C_EXA_MET_STA (EXA_MET_STA_ID);
alter table UNICALL.C_EXA_MET
  add constraint REFC_EX_ME_EX_ME177 foreign key (EX_ME_EX_ME_ID)
  references UNICALL.C_EX_ME_EX_ME (EX_ME_EX_ME_ID);
alter table UNICALL.C_EXA_MET
  add constraint REFC_USE198 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_EX_ME_BY
prompt =========================
prompt
create table UNICALL.C_EX_ME_BY
(
  ex_me_by_id    NUMBER(10) not null,
  exa_met_id     NUMBER(10),
  ex_me_by_de    VARCHAR2(4000),
  par            NUMBER(10,2) not null,
  exa_met_sta_id NUMBER(5) not null,
  ex_me_by_ty_id NUMBER(5) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF123178 on UNICALL.C_EX_ME_BY (EXA_MET_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF125191 on UNICALL.C_EX_ME_BY (EXA_MET_STA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF138201 on UNICALL.C_EX_ME_BY (EX_ME_BY_TY_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EX_ME_BY
  add constraint PK127 primary key (EX_ME_BY_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EX_ME_BY
  add constraint REFC_EXA_MET178 foreign key (EXA_MET_ID)
  references UNICALL.C_EXA_MET (EXA_MET_ID);
alter table UNICALL.C_EX_ME_BY
  add constraint REFC_EXA_MET_STA191 foreign key (EXA_MET_STA_ID)
  references UNICALL.C_EXA_MET_STA (EXA_MET_STA_ID);
alter table UNICALL.C_EX_ME_BY
  add constraint REFC_EX_ME_BY_TY201 foreign key (EX_ME_BY_TY_ID)
  references UNICALL.C_EX_ME_BY_TY (EX_ME_BY_TY_ID);

prompt
prompt Creating table C_EXA_DIR_RED
prompt ============================
prompt
create table UNICALL.C_EXA_DIR_RED
(
  cat_id      NUMBER(30) not null,
  ex_me_by_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on table UNICALL.C_EXA_DIR_RED
  is '指标包直接扣分项';
comment on column UNICALL.C_EXA_DIR_RED.cat_id
  is '目录Id';
comment on column UNICALL.C_EXA_DIR_RED.ex_me_by_id
  is '评分依据Id';
alter table UNICALL.C_EXA_DIR_RED
  add constraint PK169 primary key (CAT_ID, EX_ME_BY_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_DIR_RED
  add constraint REFC_EXA_DIS_BAG239 foreign key (CAT_ID)
  references UNICALL.C_EXA_DIS_BAG (CAT_ID);
alter table UNICALL.C_EXA_DIR_RED
  add constraint REFC_EX_ME_BY241 foreign key (EX_ME_BY_ID)
  references UNICALL.C_EX_ME_BY (EX_ME_BY_ID);

prompt
prompt Creating table C_EXA_DIS
prompt ========================
prompt
create table UNICALL.C_EXA_DIS
(
  cat_id     NUMBER(30) not null,
  exa_met_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF123179 on UNICALL.C_EXA_DIS (EXA_MET_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF64180 on UNICALL.C_EXA_DIS (CAT_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_DIS
  add constraint PK128 primary key (CAT_ID, EXA_MET_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_DIS
  add constraint REFC_EXA_MET179 foreign key (EXA_MET_ID)
  references UNICALL.C_EXA_MET (EXA_MET_ID);

prompt
prompt Creating table C_EXA_INS
prompt ========================
prompt
create table UNICALL.C_EXA_INS
(
  exa_ins_id     NUMBER(10) not null,
  exa_ins_nam    VARCHAR2(1024),
  exa_ins_des    VARCHAR2(4000),
  to_use_id      NUMBER(10) not null,
  dat            VARCHAR2(20),
  fro_use_id     NUMBER(10) not null,
  exa_met_sta_id NUMBER(5) not null,
  par            NUMBER(10,2),
  rem            VARCHAR2(4000),
  cat_id         NUMBER(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF125199 on UNICALL.C_EXA_INS (EXA_MET_STA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48196 on UNICALL.C_EXA_INS (TO_USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48197 on UNICALL.C_EXA_INS (FRO_USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_INS
  add constraint PK137 primary key (EXA_INS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_INS
  add constraint REFC_EXA_MET_STA199 foreign key (EXA_MET_STA_ID)
  references UNICALL.C_EXA_MET_STA (EXA_MET_STA_ID);
alter table UNICALL.C_EXA_INS
  add constraint REFC_USE196 foreign key (TO_USE_ID)
  references UNICALL.C_USE (USE_ID);
alter table UNICALL.C_EXA_INS
  add constraint REFC_USE197 foreign key (FRO_USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_EXA_INS_STA
prompt ============================
prompt
create table UNICALL.C_EXA_INS_STA
(
  exa_ins_sta_id  NUMBER(5) not null,
  exa_ins_sta_des VARCHAR2(64),
  is_del          VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_INS_STA
  add constraint PK primary key (EXA_INS_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_EXA_MAR
prompt ========================
prompt
create table UNICALL.C_EXA_MAR
(
  exa_mar_id  NUMBER(10) not null,
  exa_met_id  NUMBER(10),
  to_use_id   NUMBER(10),
  ex_me_by_id NUMBER(10),
  rem         VARCHAR2(4000),
  fro_use_id  NUMBER(10) not null,
  exa_ins_id  NUMBER(10) not null,
  mar         NUMBER(5,2),
  par         NUMBER(5,2),
  sta_dat     VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF123185 on UNICALL.C_EXA_MAR (EXA_MET_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF127186 on UNICALL.C_EXA_MAR (EX_ME_BY_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF137195 on UNICALL.C_EXA_MAR (EXA_INS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48183 on UNICALL.C_EXA_MAR (TO_USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48192 on UNICALL.C_EXA_MAR (FRO_USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_MAR
  add constraint PK131 primary key (EXA_MAR_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_MAR
  add constraint REFC_EXA_INS195 foreign key (EXA_INS_ID)
  references UNICALL.C_EXA_INS (EXA_INS_ID);
alter table UNICALL.C_EXA_MAR
  add constraint REFC_EXA_MET185 foreign key (EXA_MET_ID)
  references UNICALL.C_EXA_MET (EXA_MET_ID);
alter table UNICALL.C_EXA_MAR
  add constraint REFC_EX_ME_BY186 foreign key (EX_ME_BY_ID)
  references UNICALL.C_EX_ME_BY (EX_ME_BY_ID);
alter table UNICALL.C_EXA_MAR
  add constraint REFC_USE183 foreign key (TO_USE_ID)
  references UNICALL.C_USE (USE_ID);
alter table UNICALL.C_EXA_MAR
  add constraint REFC_USE192 foreign key (FRO_USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_EXA_MAR_TAS
prompt ============================
prompt
create table UNICALL.C_EXA_MAR_TAS
(
  tas_id     NUMBER(10) not null,
  exa_ins_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF137200 on UNICALL.C_EXA_MAR_TAS (EXA_INS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF33188 on UNICALL.C_EXA_MAR_TAS (TAS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_MAR_TAS
  add constraint PK134 primary key (TAS_ID, EXA_INS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_MAR_TAS
  add constraint REFC_EXA_INS200 foreign key (EXA_INS_ID)
  references UNICALL.C_EXA_INS (EXA_INS_ID);
alter table UNICALL.C_EXA_MAR_TAS
  add constraint REFC_TAS188 foreign key (TAS_ID)
  references UNICALL.C_TAS (TAS_ID);

prompt
prompt Creating table C_EXA_MET_TYP
prompt ============================
prompt
create table UNICALL.C_EXA_MET_TYP
(
  exa_met_id NUMBER(10) not null,
  cat_id     NUMBER(30) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF123174 on UNICALL.C_EXA_MET_TYP (EXA_MET_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF64175 on UNICALL.C_EXA_MET_TYP (CAT_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_MET_TYP
  add constraint PK124 primary key (EXA_MET_ID, CAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_MET_TYP
  add constraint REFC_EXA_MET174 foreign key (EXA_MET_ID)
  references UNICALL.C_EXA_MET (EXA_MET_ID);

prompt
prompt Creating table C_EXA_RUL
prompt ========================
prompt
create table UNICALL.C_EXA_RUL
(
  exa_rul_id     NUMBER(10) not null,
  tec_gro_id     NUMBER(30),
  sta_dat        VARCHAR2(20),
  end_dat        VARCHAR2(20),
  exa_met_sta_id NUMBER(5),
  exa_rul_typ_id NUMBER(30),
  val            VARCHAR2(64)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF125287 on UNICALL.C_EXA_RUL (EXA_MET_STA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF64286 on UNICALL.C_EXA_RUL (TEC_GRO_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF64288 on UNICALL.C_EXA_RUL (EXA_RUL_TYP_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_RUL
  add constraint PK193 primary key (EXA_RUL_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_RUL
  add constraint REFC_EXA_MET_STA287 foreign key (EXA_MET_STA_ID)
  references UNICALL.C_EXA_MET_STA (EXA_MET_STA_ID);

prompt
prompt Creating table C_EXA_USE
prompt ========================
prompt
create table UNICALL.C_EXA_USE
(
  use_id NUMBER(10) not null,
  cat_id NUMBER(30) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48181 on UNICALL.C_EXA_USE (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF64182 on UNICALL.C_EXA_USE (CAT_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_USE
  add constraint PK130 primary key (USE_ID, CAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EXA_USE
  add constraint REFC_USE181 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_EX_ME_BY_IT
prompt ============================
prompt
create table UNICALL.C_EX_ME_BY_IT
(
  ex_me_by_id    NUMBER(10) not null,
  ex_me_by_it_id NUMBER(5) not null,
  par            NUMBER(10,2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF127202 on UNICALL.C_EX_ME_BY_IT (EX_ME_BY_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EX_ME_BY_IT
  add constraint PK139 primary key (EX_ME_BY_ID, EX_ME_BY_IT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_EX_ME_BY_IT
  add constraint REFC_EX_ME_BY202 foreign key (EX_ME_BY_ID)
  references UNICALL.C_EX_ME_BY (EX_ME_BY_ID);

prompt
prompt Creating table C_GRO_INF
prompt ========================
prompt
create table UNICALL.C_GRO_INF
(
  gro_id     NUMBER(30),
  inf_id     NUMBER(10) not null,
  gro_inf_id NUMBER(10) not null,
  use_id     NUMBER(10),
  kno        VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48206 on UNICALL.C_GRO_INF (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF60147 on UNICALL.C_GRO_INF (INF_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF64148 on UNICALL.C_GRO_INF (GRO_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_GRO_INF
  add constraint PK113 primary key (GRO_INF_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_ID_BRO
prompt =======================
prompt
create table UNICALL.C_ID_BRO
(
  name      VARCHAR2(64) not null,
  cachesize NUMBER(10) not null,
  nextvalue NUMBER(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_ID_BRO
  add constraint PK_ID_BROKER primary key (NAME)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_IND_SET
prompt ========================
prompt
create table UNICALL.C_IND_SET
(
  cat_id NUMBER(30) not null,
  use_id NUMBER(10) not null,
  val    VARCHAR2(512)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF189 on UNICALL.C_IND_SET (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF2888 on UNICALL.C_IND_SET (CAT_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_IND_SET
  add constraint PK44 primary key (CAT_ID, USE_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_IND_SET
  add constraint REFC_CAT88 foreign key (CAT_ID)
  references UNICALL.C_CAT (CAT_ID);
alter table UNICALL.C_IND_SET
  add constraint REFC_USE89 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_INF_FIL_TYP
prompt ============================
prompt
create table UNICALL.C_INF_FIL_TYP
(
  inf_fil_typ_id  NUMBER(5) not null,
  inf_fil_typ_des VARCHAR2(64),
  is_del          VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_INF_FIL_TYP
  add constraint PKINF_FIL_TYP primary key (INF_FIL_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_INF_STA
prompt ========================
prompt
create table UNICALL.C_INF_STA
(
  inf_sta_id  NUMBER(5) not null,
  inf_sta_des VARCHAR2(64),
  is_del      VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_INF_STA
  add constraint PKINF_STA primary key (INF_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_INF
prompt ====================
prompt
create table UNICALL.C_INF
(
  inf_id         NUMBER(10) not null,
  path           VARCHAR2(512),
  title          VARCHAR2(1024),
  key_wor        VARCHAR2(2048),
  sta_dat        VARCHAR2(20),
  end_dat        VARCHAR2(20),
  inf_sta_id     NUMBER(5) not null,
  hint           VARCHAR2(2048),
  inf_typ_fil_id NUMBER(5) not null,
  inf_fil_typ_id NUMBER(5),
  use_id         NUMBER(10),
  acc_cou        NUMBER(10),
  cur_acc_cou    NUMBER(10),
  content        CLOB
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF48146 on UNICALL.C_INF (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF6163 on UNICALL.C_INF (INF_TYP_FIL_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF6264 on UNICALL.C_INF (INF_STA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_INF
  add constraint PKINF primary key (INF_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_INF
  add constraint REFC_INF_FIL_TYP63 foreign key (INF_FIL_TYP_ID)
  references UNICALL.C_INF_FIL_TYP (INF_FIL_TYP_ID);
alter table UNICALL.C_INF
  add constraint REFC_INF_STA64 foreign key (INF_STA_ID)
  references UNICALL.C_INF_STA (INF_STA_ID);

prompt
prompt Creating table C_INF_IND
prompt ========================
prompt
create table UNICALL.C_INF_IND
(
  use_id     NUMBER(10),
  ind_id     NUMBER(10) not null,
  operdat    VARCHAR2(20),
  runtime    VARCHAR2(20),
  succ_count NUMBER(5)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_INF_IND
  add constraint PKIND primary key (IND_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_INF_N
prompt ======================
prompt
create table UNICALL.C_INF_N
(
  inf_id         NUMBER(10) not null,
  path           VARCHAR2(512),
  title          VARCHAR2(1024),
  key_wor        VARCHAR2(2048),
  sta_dat        VARCHAR2(20),
  end_dat        VARCHAR2(20),
  inf_fil_typ_id NUMBER(5),
  inf_sta_id     NUMBER(5) not null,
  hint           VARCHAR2(2048),
  content        CLOB,
  use_id         NUMBER(10),
  acc_cou        NUMBER(10),
  inf_typ_fil_id NUMBER(5) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 19M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_INF_N
  add constraint PKINF_N primary key (INF_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_INF_N_PAT
prompt ==========================
prompt
create table UNICALL.C_INF_N_PAT
(
  inf_id  NUMBER(10) not null,
  pat_id  NUMBER(5) not null,
  pat     VARCHAR2(512),
  pat_nam VARCHAR2(256)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF135194 on UNICALL.C_INF_N_PAT (INF_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_INF_N_PAT
  add constraint PK136 primary key (INF_ID, PAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_INF_N_PAT
  add constraint REFC_INF_N194 foreign key (INF_ID)
  references UNICALL.C_INF_N (INF_ID);

prompt
prompt Creating table C_INF_PAT
prompt ========================
prompt
create table UNICALL.C_INF_PAT
(
  inf_id  NUMBER(10) not null,
  pat_id  NUMBER(10) not null,
  pat     VARCHAR2(512),
  pat_nam VARCHAR2(256)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF60118 on UNICALL.C_INF_PAT (INF_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_INF_PAT
  add constraint PKINF_PAT primary key (INF_ID, PAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_INF_REL
prompt ========================
prompt
create table UNICALL.C_INF_REL
(
  inf_id     NUMBER(10) not null,
  rel_inf_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF6070 on UNICALL.C_INF_REL (INF_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF6071 on UNICALL.C_INF_REL (REL_INF_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_INF_REL
  add constraint PKINF_REL primary key (INF_ID, REL_INF_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_INF_REM
prompt ========================
prompt
create table UNICALL.C_INF_REM
(
  inf_rem_id     NUMBER(10) not null,
  use_id         NUMBER(10) not null,
  rem_lev_id     NUMBER(30),
  par_inf_rem_id NUMBER(10),
  inf_rem        CLOB,
  inf_id         NUMBER(10) not null,
  sta_dat        VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF203315 on UNICALL.C_INF_REM (PAR_INF_REM_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF48317 on UNICALL.C_INF_REM (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF60313 on UNICALL.C_INF_REM (INF_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF64316 on UNICALL.C_INF_REM (REM_LEV_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_INF_REM
  add constraint PK203 primary key (INF_REM_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_INF_REM
  add constraint REFC_INF_REM315 foreign key (PAR_INF_REM_ID)
  references UNICALL.C_INF_REM (INF_REM_ID);
alter table UNICALL.C_INF_REM
  add constraint REFC_USE317 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_INF_TAS
prompt ========================
prompt
create table UNICALL.C_INF_TAS
(
  tas_id  NUMBER(10) not null,
  inf_id  NUMBER(10) not null,
  sta_dat VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_INF_TAS
  add constraint PKINF_TAS primary key (TAS_ID, INF_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_INF_TAS
  add constraint REFC_TAS203 foreign key (TAS_ID)
  references UNICALL.C_TAS (TAS_ID);

prompt
prompt Creating table C_INF_TMP
prompt ========================
prompt
create table UNICALL.C_INF_TMP
(
  inf_id         NUMBER(10) not null,
  path           VARCHAR2(512),
  title          VARCHAR2(1024),
  key_wor        VARCHAR2(2048),
  sta_dat        VARCHAR2(20),
  end_dat        VARCHAR2(20),
  inf_sta_id     NUMBER(5) not null,
  hint           VARCHAR2(2048),
  content        VARCHAR2(4000),
  inf_typ_fil_id NUMBER(5) not null,
  inf_fil_typ_id NUMBER(5),
  use_id         NUMBER(10),
  cat_name       VARCHAR2(512),
  sta            VARCHAR2(4000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_INSIDE_JOB
prompt ===========================
prompt
create table UNICALL.C_INSIDE_JOB
(
  id       NUMBER not null,
  ruletype NUMBER,
  ext1     VARCHAR2(20),
  ext2     VARCHAR2(20),
  ext3     VARCHAR2(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_INSIDE_JOB
  add constraint PK_C_INSIDE_JOB_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_KNO
prompt ====================
prompt
create table UNICALL.C_KNO
(
  kno     NUMBER(5) not null,
  kno_des VARCHAR2(64),
  is_del  VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_KNO
  add constraint PK172 primary key (KNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_LOG_AGE
prompt ========================
prompt
create table UNICALL.C_LOG_AGE
(
  log_id          NUMBER(20) not null,
  use_id          NUMBER(10),
  in_tim          VARCHAR2(20),
  out_tim         VARCHAR2(20),
  lea_num         NUMBER(10),
  lea_tim         VARCHAR2(20),
  n_rea_num       NUMBER(10),
  n_rea_tim       VARCHAR2(20),
  rea_num         NUMBER(10),
  rea_tim         VARCHAR2(20),
  tin_num         NUMBER(10),
  tin_tim         VARCHAR2(20),
  tin_tim_ave     VARCHAR2(20),
  aft_in_num      NUMBER(10),
  aft_in_tim      VARCHAR2(20),
  aft_in_tim_ave  VARCHAR2(20),
  tou_num         NUMBER(10),
  tou_tim         VARCHAR2(20),
  tou_tim_ave     VARCHAR2(20),
  aft_out_num     NUMBER(10),
  aft_out_tim     VARCHAR2(20),
  aft_out_tim_ave VARCHAR2(20),
  no_ans_num      NUMBER(10),
  hol_num         NUMBER(10),
  hol_tim         VARCHAR2(20),
  con_num         NUMBER(10),
  con_tim         VARCHAR2(20),
  sel_num         NUMBER(10),
  sel_tim         VARCHAR2(20),
  eff             VARCHAR2(10),
  rea_eff         VARCHAR2(10),
  log_tim         VARCHAR2(20),
  tra_num         NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_LOG_MAN
prompt ========================
prompt
create table UNICALL.C_LOG_MAN
(
  log_man_id NUMBER(10) not null,
  sta_dat    VARCHAR2(20),
  use_id     NUMBER(10) not null,
  man_des    CLOB,
  res        VARCHAR2(1),
  man_typ_id NUMBER(30) not null,
  ope_typ_id NUMBER(30) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 5M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_LOG_SYS
prompt ========================
prompt
create table UNICALL.C_LOG_SYS
(
  log_sys_id NUMBER(10) not null,
  use_id     NUMBER(10) not null,
  sta_dat    VARCHAR2(20),
  end_dat    VARCHAR2(20),
  ip         VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 41M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF48225 on UNICALL.C_LOG_SYS (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 12M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_LOG_SYS
  add constraint PK164 primary key (LOG_SYS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 12M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_LOG_SYS
  add constraint REFC_USE225 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_LOG_WAT
prompt ========================
prompt
create table UNICALL.C_LOG_WAT
(
  log_wat_id NUMBER(30) not null,
  use_id     NUMBER(10) not null,
  v1         VARCHAR2(20),
  v2         VARCHAR2(20),
  v3         NUMBER(10),
  v4         NUMBER(10),
  v5         NUMBER(10),
  v6         NUMBER(10),
  v7         NUMBER(10),
  v8         NUMBER(10),
  v9         NUMBER(10),
  v10        NUMBER(10),
  v11        NUMBER(10),
  v12        NUMBER(10),
  v13        NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_LOG_WAT
  add constraint PK183 primary key (LOG_WAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_LOG_WAT
  add constraint REFC_USE260 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_MAN_TYP
prompt ========================
prompt
create table UNICALL.C_MAN_TYP
(
  man_typ_id  NUMBER(5) not null,
  man_typ_des VARCHAR2(64),
  is_del      VARCHAR2(1),
  in_tre      VARCHAR2(1),
  target      VARCHAR2(512),
  path        VARCHAR2(512)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_MAN_TYP
  add constraint PKMAN_TYP primary key (MAN_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_OB_COM_STA
prompt ===========================
prompt
create table UNICALL.C_OB_COM_STA
(
  ob_com_sta_id  NUMBER(5) not null,
  ob_com_sta_des VARCHAR2(64),
  is_del         VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM_STA
  add constraint PK_OB_COM_STA primary key (OB_COM_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_OB_COM
prompt =======================
prompt
create table UNICALL.C_OB_COM
(
  ob_com_id        NUMBER(10) not null,
  ob_com_nam       VARCHAR2(1024) not null,
  ob_com_des       VARCHAR2(4000),
  sta_dat          VARCHAR2(20),
  end_dat          VARCHAR2(20),
  ob_com_sta_id    NUMBER(5) not null,
  use_id           NUMBER(10) not null,
  map_id           VARCHAR2(40),
  max_dia          NUMBER(2),
  company_id       NUMBER(10),
  region_code      VARCHAR2(30),
  c_operateuser_id NUMBER(10),
  early_late       VARCHAR2(10),
  prj_id           NUMBER(10),
  org_id           NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_OB_COM.prj_id
  is '项目ID';
comment on column UNICALL.C_OB_COM.org_id
  is '实现数据权限过滤';
alter table UNICALL.C_OB_COM
  add constraint PK_OB_COM primary key (OB_COM_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM
  add constraint C_OB_COM_STA_FK foreign key (OB_COM_STA_ID)
  references UNICALL.C_OB_COM_STA (OB_COM_STA_ID);
alter table UNICALL.C_OB_COM
  add constraint C_OB_COM_USE_FK foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_OB_CAL_LIS
prompt ===========================
prompt
create table UNICALL.C_OB_CAL_LIS
(
  ob_com_id  NUMBER(10) not null,
  cus_gro_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_CAL_LIS
  add constraint PK_OB_CAL_LIS primary key (OB_COM_ID, CUS_GRO_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_CAL_LIS
  add constraint C_OB_CAL_LIS_CG_FK foreign key (CUS_GRO_ID)
  references UNICALL.C_CUS_GRO (CUS_GRO_ID);
alter table UNICALL.C_OB_CAL_LIS
  add constraint C_OB_CAL_LIS_COM_FK foreign key (OB_COM_ID)
  references UNICALL.C_OB_COM (OB_COM_ID);

prompt
prompt Creating table C_OB_ITE_STA
prompt ===========================
prompt
create table UNICALL.C_OB_ITE_STA
(
  ob_ite_sta_id  NUMBER(5) not null,
  ob_ite_sta_des VARCHAR2(64),
  is_del         VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_ITE_STA
  add constraint PK_OB_ITE_STA primary key (OB_ITE_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_OB_ITE_TYP
prompt ===========================
prompt
create table UNICALL.C_OB_ITE_TYP
(
  ob_ite_typ_id  NUMBER(5) not null,
  ob_ite_typ_des VARCHAR2(64),
  is_del         VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_ITE_TYP
  add constraint PK_OB_ITE_TYP primary key (OB_ITE_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_OB_ITE
prompt =======================
prompt
create table UNICALL.C_OB_ITE
(
  ob_ite_id     NUMBER(10) not null,
  ob_ite_con    VARCHAR2(4000),
  ob_ite_typ_id NUMBER(5) not null,
  ob_ite_sta_id NUMBER(5) not null,
  use_id        NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_ITE
  add constraint PK_OB_ITE primary key (OB_ITE_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_ITE
  add constraint C_OB_ITE_STA_FK foreign key (OB_ITE_STA_ID)
  references UNICALL.C_OB_ITE_STA (OB_ITE_STA_ID);
alter table UNICALL.C_OB_ITE
  add constraint C_OB_ITE_TYP_FK foreign key (OB_ITE_TYP_ID)
  references UNICALL.C_OB_ITE_TYP (OB_ITE_TYP_ID);
alter table UNICALL.C_OB_ITE
  add constraint C_OB_ITE_USE_FK foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_OB_CAT
prompt =======================
prompt
create table UNICALL.C_OB_CAT
(
  ob_ite_id NUMBER(10) not null,
  cat_id    NUMBER(30) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_CAT
  add constraint PK_OB_CAT primary key (OB_ITE_ID, CAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_CAT
  add constraint C_OB_CAT_CAT_FK foreign key (CAT_ID)
  references UNICALL.C_CAT (CAT_ID);
alter table UNICALL.C_OB_CAT
  add constraint C_OB_CAT_ITE_FK foreign key (OB_ITE_ID)
  references UNICALL.C_OB_ITE (OB_ITE_ID);

prompt
prompt Creating table C_OB_COM_COMPANY
prompt ===============================
prompt
create table UNICALL.C_OB_COM_COMPANY
(
  id        NUMBER(10) not null,
  ob_com_id NUMBER(10) not null,
  comany_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_OB_COM_COMPANY.ob_com_id
  is '外拨活动ID';
comment on column UNICALL.C_OB_COM_COMPANY.comany_id
  is '公司ID';
alter table UNICALL.C_OB_COM_COMPANY
  add constraint PK_C_OB_COM_COMPANY primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_OB_COM_COMPANY_OPERATERUSER
prompt ============================================
prompt
create table UNICALL.C_OB_COM_COMPANY_OPERATERUSER
(
  id              NUMBER(10) not null,
  ob_com_id       NUMBER(10) not null,
  comany_id       NUMBER(10) not null,
  operateruser_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_OB_COM_COMPANY_OPERATERUSER.ob_com_id
  is '外拨活动ID';
comment on column UNICALL.C_OB_COM_COMPANY_OPERATERUSER.comany_id
  is '公司ID';
comment on column UNICALL.C_OB_COM_COMPANY_OPERATERUSER.operateruser_id
  is '业务员ID';
alter table UNICALL.C_OB_COM_COMPANY_OPERATERUSER
  add constraint PK_C_OB_COM_COM_OPER primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_OB_CUS_CON_STA
prompt ===============================
prompt
create table UNICALL.C_OB_CUS_CON_STA
(
  con_sta_id NUMBER(10) not null,
  parent_id  NUMBER(10),
  des        VARCHAR2(64),
  vis_typ    NUMBER(5)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_CUS_CON_STA
  add constraint PK_OB_CUS_CON_STA primary key (CON_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_OB_COM_CUS
prompt ===========================
prompt
create table UNICALL.C_OB_COM_CUS
(
  c_ob_com_cus_id NUMBER(10) not null,
  cus_id          NUMBER(10) not null,
  ob_com_id       NUMBER(10) not null,
  con_sta_id      NUMBER(18) not null,
  dia_cou         NUMBER(5) default 0 not null,
  cou             NUMBER(5) default 1 not null,
  del             NUMBER(5) default 0 not null,
  cre_dat         DATE default sysdate not null,
  las_mod_dat     DATE default sysdate not null,
  asg_dat         DATE default sysdate not null,
  bus_ite_id      VARCHAR2(32),
  bus_ite_typ     VARCHAR2(32),
  bra_id          VARCHAR2(32),
  bra_nam         VARCHAR2(128),
  poo_typ         NUMBER(5) default 0,
  cal_typ         CHAR(1) not null,
  use_id          NUMBER(10),
  cus_gro_id      NUMBER(10),
  ob_dis_rul_id   NUMBER(10),
  com_cus_di_id   NUMBER(10),
  org_id          NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 541M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_OB_COM_CUS.org_id
  is '实现数据权限过滤';
create index UNICALL.ADD_IDX_C_OB_COM_CUS_U_C_C on UNICALL.C_OB_COM_CUS (USE_ID, CON_STA_ID, CAL_TYP)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 160M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.C_OB_COM_CUS_COM_IDX on UNICALL.C_OB_COM_CUS (OB_COM_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 123M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.C_OB_COM_CUS_MOD_DAT_IDX on UNICALL.C_OB_COM_CUS (LAS_MOD_DAT DESC)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 178M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_C_OB_COM_CUS_USE_ID on UNICALL.C_OB_COM_CUS (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 108M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM_CUS
  add constraint PK_OB_COM_CUS primary key (C_OB_COM_CUS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 124M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM_CUS
  add constraint C_OB_COM_CUS_COM_FK foreign key (OB_COM_ID)
  references UNICALL.C_OB_COM (OB_COM_ID);
alter table UNICALL.C_OB_COM_CUS
  add constraint C_OB_COM_CUS_CON_STA_FK foreign key (CON_STA_ID)
  references UNICALL.C_OB_CUS_CON_STA (CON_STA_ID);
alter table UNICALL.C_OB_COM_CUS
  add constraint C_OB_COM_CUS_CUS_FK foreign key (CUS_ID)
  references UNICALL.C_CUS_BAS (CUS_ID);
alter table UNICALL.C_OB_COM_CUS
  add constraint C_OB_COM_CUS_CUS_GRO_FK foreign key (CUS_GRO_ID)
  references UNICALL.C_CUS_GRO (CUS_GRO_ID);
alter table UNICALL.C_OB_COM_CUS
  add constraint C_OB_COM_CUS_USE_FK foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_OB_COM_CUS_DI
prompt ==============================
prompt
create table UNICALL.C_OB_COM_CUS_DI
(
  com_cus_di_id   NUMBER(10) not null,
  con_sta_id      NUMBER(10) not null,
  c_ob_com_cus_id NUMBER(10) not null,
  use_id          NUMBER(10) not null,
  dia_tim         DATE not null,
  rem             VARCHAR2(2000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 362M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_OB_COM_CUS on UNICALL.C_OB_COM_CUS_DI (C_OB_COM_CUS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 186M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM_CUS_DI
  add constraint PK_OB_COM_CUS_DI primary key (COM_CUS_DI_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 180M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM_CUS_DI
  add constraint C_OB_COM_CUS_DI_COM_CUS_FK foreign key (C_OB_COM_CUS_ID)
  references UNICALL.C_OB_COM_CUS (C_OB_COM_CUS_ID);
alter table UNICALL.C_OB_COM_CUS_DI
  add constraint C_OB_COM_CUS_DI_CON_STA_FK foreign key (CON_STA_ID)
  references UNICALL.C_OB_CUS_CON_STA (CON_STA_ID);
alter table UNICALL.C_OB_COM_CUS_DI
  add constraint C_OB_COM_CUS_DI_USE_FK foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_OB_COM_CUS_BO
prompt ==============================
prompt
create table UNICALL.C_OB_COM_CUS_BO
(
  com_cus_bo_id   NUMBER(10) not null,
  c_ob_com_cus_id NUMBER(10) not null,
  com_cus_di_id   NUMBER(10),
  cha_id          NUMBER(10),
  boo_tim         DATE not null,
  cre_dat         DATE not null,
  las_mod_dat     DATE not null,
  has_dial        NUMBER(2) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 8M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_OB_COM_CUS_BO_CUS_ID on UNICALL.C_OB_COM_CUS_BO (C_OB_COM_CUS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM_CUS_BO
  add constraint PK_OB_COM_CUS_BO primary key (COM_CUS_BO_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM_CUS_BO
  add constraint C_OB_COM_CUS_BO_CHA_FK foreign key (CHA_ID)
  references UNICALL.C_CHA (CHA_ID);
alter table UNICALL.C_OB_COM_CUS_BO
  add constraint C_OB_COM_CUS_BO_COM_CUS_FK foreign key (C_OB_COM_CUS_ID)
  references UNICALL.C_OB_COM_CUS (C_OB_COM_CUS_ID);
alter table UNICALL.C_OB_COM_CUS_BO
  add constraint C_OB_COM_CUS_BO_DI_FK foreign key (COM_CUS_DI_ID)
  references UNICALL.C_OB_COM_CUS_DI (COM_CUS_DI_ID);

prompt
prompt Creating table C_OB_COM_CUS_DIA_OUT
prompt ===================================
prompt
create table UNICALL.C_OB_COM_CUS_DIA_OUT
(
  com_cus_dia_out_id NUMBER(10) not null,
  c_ob_com_cus_id    NUMBER(10) not null,
  cha_ins_id         NUMBER(10),
  contact            VARCHAR2(100) not null,
  use_id             NUMBER(10) not null,
  dia_out_tim        DATE not null,
  con_sta_id         NUMBER(10),
  call_id            VARCHAR2(100),
  c_dnis             VARCHAR2(100),
  talk_time          VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 513M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_OB_COM_CUS_DIA_OUT.call_id
  is '通话标识';
comment on column UNICALL.C_OB_COM_CUS_DIA_OUT.c_dnis
  is '被叫号码';
comment on column UNICALL.C_OB_COM_CUS_DIA_OUT.talk_time
  is '通话时长';
create index UNICALL.IDX_COM_CUS_DIA_OUT_CUSID on UNICALL.C_OB_COM_CUS_DIA_OUT (C_OB_COM_CUS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 179M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM_CUS_DIA_OUT
  add constraint PK_OB_COM_CUS_DIA_OUT primary key (COM_CUS_DIA_OUT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 168M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM_CUS_DIA_OUT
  add constraint C_DIA_OUT_COM_CUS_FK foreign key (C_OB_COM_CUS_ID)
  references UNICALL.C_OB_COM_CUS (C_OB_COM_CUS_ID);
alter table UNICALL.C_OB_COM_CUS_DIA_OUT
  add constraint C_OB_COM_CUS_DIA_OUT_USE_FK foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_OB_COM_CUS_DI_TAS
prompt ==================================
prompt
create table UNICALL.C_OB_COM_CUS_DI_TAS
(
  com_cus_di_id NUMBER(10) not null,
  tas_id        NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 49M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM_CUS_DI_TAS
  add constraint PK_OB_COM_CUS_DI_TAS primary key (COM_CUS_DI_ID, TAS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 73M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM_CUS_DI_TAS
  add constraint C_OB_COM_CUS_DI_TAS_DI_FK foreign key (COM_CUS_DI_ID)
  references UNICALL.C_OB_COM_CUS_DI (COM_CUS_DI_ID);
alter table UNICALL.C_OB_COM_CUS_DI_TAS
  add constraint C_OB_COM_CUS_DI_TAS_TAS_FK foreign key (TAS_ID)
  references UNICALL.C_TAS (TAS_ID);

prompt
prompt Creating table C_OB_COM_IVR
prompt ===========================
prompt
create table UNICALL.C_OB_COM_IVR
(
  ob_com_id NUMBER(10) not null,
  ivr_han   VARCHAR2(64) not null,
  par       VARCHAR2(4000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_COM_IVR
  add constraint PK_OB_COM_IVR primary key (OB_COM_ID, IVR_HAN)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_COM_IVR
  add constraint C_OB_COM_IVR_COM_FK foreign key (OB_COM_ID)
  references UNICALL.C_OB_COM (OB_COM_ID);

prompt
prompt Creating table C_OB_COM_RES_STA
prompt ===============================
prompt
create table UNICALL.C_OB_COM_RES_STA
(
  ob_com_id  NUMBER(10) not null,
  con_sta_id NUMBER(30) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_COM_RES_STA
  add constraint PK_OB_COM_RES_STA primary key (OB_COM_ID, CON_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_COM_RES_STA
  add constraint C_OB_COM_RES_STA_COM_FK foreign key (OB_COM_ID)
  references UNICALL.C_OB_COM (OB_COM_ID);
alter table UNICALL.C_OB_COM_RES_STA
  add constraint C_OB_COM_RES_STA_CON_STA_FK foreign key (CON_STA_ID)
  references UNICALL.C_OB_CUS_CON_STA (CON_STA_ID);

prompt
prompt Creating table C_OB_SCR_STA
prompt ===========================
prompt
create table UNICALL.C_OB_SCR_STA
(
  ob_scr_sta_id  NUMBER(5) not null,
  ob_scr_sta_des VARCHAR2(64),
  is_del         VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SCR_STA
  add constraint PK_OB_SCR_STA primary key (OB_SCR_STA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_OB_SCR
prompt =======================
prompt
create table UNICALL.C_OB_SCR
(
  ob_scr_id     NUMBER(10) not null,
  ob_scr_des    VARCHAR2(1024),
  ob_scr_nam    VARCHAR2(256),
  sta_dat       VARCHAR2(20),
  use_id        NUMBER(10) not null,
  ob_scr_sta_id NUMBER(5) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SCR
  add constraint PK_OB_SCR primary key (OB_SCR_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SCR
  add constraint C_OB_SCR_STA_FK foreign key (OB_SCR_STA_ID)
  references UNICALL.C_OB_SCR_STA (OB_SCR_STA_ID);
alter table UNICALL.C_OB_SCR
  add constraint C_OB_SCR_USE_FK foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_OB_COM_SCR
prompt ===========================
prompt
create table UNICALL.C_OB_COM_SCR
(
  ob_com_id NUMBER(10) not null,
  ob_scr_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_COM_SCR
  add constraint PKOB_COM_SCR primary key (OB_COM_ID, OB_SCR_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_COM_SCR
  add constraint C_OB_COM_SCR_COM_FK foreign key (OB_COM_ID)
  references UNICALL.C_OB_COM (OB_COM_ID);
alter table UNICALL.C_OB_COM_SCR
  add constraint C_OB_COM_SCR_SCR_FK foreign key (OB_SCR_ID)
  references UNICALL.C_OB_SCR (OB_SCR_ID);

prompt
prompt Creating table C_OB_COM_TYP
prompt ===========================
prompt
create table UNICALL.C_OB_COM_TYP
(
  ob_com_id NUMBER(10) not null,
  cat_id    NUMBER(30) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.C_OB_COM_TYP_IDX on UNICALL.C_OB_COM_TYP (OB_COM_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM_TYP
  add constraint PK_OB_COM_TYP primary key (OB_COM_ID, CAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OB_COM_TYP
  add constraint C_OB_COM_TYP_CAT_FK foreign key (CAT_ID)
  references UNICALL.C_CAT (CAT_ID);
alter table UNICALL.C_OB_COM_TYP
  add constraint C_OB_COM_TYP_COM_FK foreign key (OB_COM_ID)
  references UNICALL.C_OB_COM (OB_COM_ID);

prompt
prompt Creating table C_OB_DIS_RUL
prompt ===========================
prompt
create table UNICALL.C_OB_DIS_RUL
(
  ob_dis_rul_id  NUMBER(10) not null,
  ob_dis_rul_nam VARCHAR2(256),
  ob_com_id      NUMBER(10),
  cus_gro_id     NUMBER(10),
  sta_dat        VARCHAR2(20),
  end_dat        VARCHAR2(20),
  con            VARCHAR2(4000),
  pri            NUMBER(5),
  sql            VARCHAR2(4000),
  cat_id         NUMBER(30),
  use_id         NUMBER(10),
  pri_dot        NUMBER(3) default 000 not null,
  asg_use_id     NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_DIS_RUL
  add constraint PK_OB_DIS_RUL primary key (OB_DIS_RUL_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_DIS_RUL
  add constraint C_OB_DIS_RUL_CAT_FK foreign key (CAT_ID)
  references UNICALL.C_CAT (CAT_ID);
alter table UNICALL.C_OB_DIS_RUL
  add constraint C_OB_DIS_RUL_COM_FK foreign key (OB_COM_ID)
  references UNICALL.C_OB_COM (OB_COM_ID);
alter table UNICALL.C_OB_DIS_RUL
  add constraint C_OB_DIS_RUL_CUS_GRO_FK foreign key (CUS_GRO_ID)
  references UNICALL.C_CUS_GRO (CUS_GRO_ID);
alter table UNICALL.C_OB_DIS_RUL
  add constraint C_OB_DIS_RUL_USE_FK foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_OB_CSR_LIS
prompt ===========================
prompt
create table UNICALL.C_OB_CSR_LIS
(
  ob_csr_lis_id NUMBER(10) not null,
  use_id        NUMBER(10) not null,
  cus_id        NUMBER(10) not null,
  ob_com_id     NUMBER(10) not null,
  cus_gro_id    NUMBER(10) not null,
  ob_dis_rul_id NUMBER(10),
  con_sta_id    NUMBER(5) not null,
  dia_cou       NUMBER(3),
  sta_dat       VARCHAR2(20),
  rem           VARCHAR2(512)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_CSR_LIS
  add constraint PK_OB_CSR_LIS primary key (OB_CSR_LIS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_CSR_LIS
  add constraint C_OB_CSR_LIS_COM_CUS_FK foreign key (OB_COM_ID, CUS_GRO_ID)
  references UNICALL.C_OB_CAL_LIS (OB_COM_ID, CUS_GRO_ID);
alter table UNICALL.C_OB_CSR_LIS
  add constraint C_OB_CSR_LIS_CON_STA_FK foreign key (CON_STA_ID)
  references UNICALL.C_OB_CUS_CON_STA (CON_STA_ID);
alter table UNICALL.C_OB_CSR_LIS
  add constraint C_OB_CSR_LIS_CUS_FK foreign key (CUS_ID)
  references UNICALL.C_CUS_BAS (CUS_ID);
alter table UNICALL.C_OB_CSR_LIS
  add constraint C_OB_CSR_LIS_DIS_RUL_FK foreign key (OB_DIS_RUL_ID)
  references UNICALL.C_OB_DIS_RUL (OB_DIS_RUL_ID);
alter table UNICALL.C_OB_CSR_LIS
  add constraint C_OB_CSR_LIS_USE_FK foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_OB_CSR_LIS_TA
prompt ==============================
prompt
create table UNICALL.C_OB_CSR_LIS_TA
(
  ob_csr_lis_id NUMBER(10) not null,
  tas_id        NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF196309 on UNICALL.C_OB_CSR_LIS_TA (OB_CSR_LIS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF33310 on UNICALL.C_OB_CSR_LIS_TA (TAS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_CSR_LIS_TA
  add constraint PK200 primary key (OB_CSR_LIS_ID, TAS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_CSR_LIS_TA
  add constraint REFC_TAS310 foreign key (TAS_ID)
  references UNICALL.C_TAS (TAS_ID);

prompt
prompt Creating table C_OB_CS_LI_BO
prompt ============================
prompt
create table UNICALL.C_OB_CS_LI_BO
(
  ob_cs_li_bo   VARCHAR2(10) not null,
  ob_csr_lis_id NUMBER(10) not null,
  boo_tim       VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_CS_LI_BO
  add constraint PK_OB_CS_LI_BO primary key (OB_CS_LI_BO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_CS_LI_BO
  add constraint C_OB_CS_LI_BO_CSR_LIS_FK foreign key (OB_CSR_LIS_ID)
  references UNICALL.C_OB_CSR_LIS (OB_CSR_LIS_ID);

prompt
prompt Creating table C_OB_CS_LI_DI
prompt ============================
prompt
create table UNICALL.C_OB_CS_LI_DI
(
  ob_cs_li_di_id NUMBER(10) not null,
  ob_csr_lis_id  NUMBER(10) not null,
  dia_tim        VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_CS_LI_DI
  add constraint PK_OB_CS_LI_DI primary key (OB_CS_LI_DI_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_CS_LI_DI
  add constraint C_OB_CS_LI_DI_CSR_LIS_FK foreign key (OB_CSR_LIS_ID)
  references UNICALL.C_OB_CSR_LIS (OB_CSR_LIS_ID);

prompt
prompt Creating table C_OB_FOR_LIS
prompt ===========================
prompt
create table UNICALL.C_OB_FOR_LIS
(
  ob_for_lis_id NUMBER(10) not null,
  cus_id        NUMBER(10) not null,
  sta_dat       VARCHAR2(20),
  end_dat       VARCHAR2(20),
  use_id        NUMBER(10) not null,
  rem           VARCHAR2(512)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_FOR_LIS
  add constraint PK_OB_FOR_LIS primary key (OB_FOR_LIS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_FOR_LIS
  add constraint C_OB_FOR_LIS_CUS_FK foreign key (CUS_ID)
  references UNICALL.C_CUS_BAS (CUS_ID);
alter table UNICALL.C_OB_FOR_LIS
  add constraint C_OB_FOR_LIS_USE_FK foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_OB_FOR_LIS_DE
prompt ==============================
prompt
create table UNICALL.C_OB_FOR_LIS_DE
(
  ob_for_lis_id NUMBER(10) not null,
  cat_id        NUMBER(30) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_FOR_LIS_DE
  add constraint PK_OB_FOR_LIS_DE primary key (OB_FOR_LIS_ID, CAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_FOR_LIS_DE
  add constraint C_OB_FOR_LIS_DE_CAT_FK foreign key (CAT_ID)
  references UNICALL.C_CAT (CAT_ID);
alter table UNICALL.C_OB_FOR_LIS_DE
  add constraint C_OB_FOR_LIS_DE_LIS_FK foreign key (OB_FOR_LIS_ID)
  references UNICALL.C_OB_FOR_LIS (OB_FOR_LIS_ID);

prompt
prompt Creating table C_OB_IMPORTHISTORY
prompt =================================
prompt
create table UNICALL.C_OB_IMPORTHISTORY
(
  import_id         NUMBER(10) not null,
  import_date       VARCHAR2(20),
  import_successful NUMBER(10),
  import_failed     NUMBER(10),
  import_log_path   VARCHAR2(500),
  targetlist_name   VARCHAR2(512),
  use_name          VARCHAR2(512),
  org_id            NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 448K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_OB_IMPORTHISTORY.org_id
  is '实现数据权限过滤';
alter table UNICALL.C_OB_IMPORTHISTORY
  add primary key (IMPORT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_OB_ITE_D
prompt =========================
prompt
create table UNICALL.C_OB_ITE_D
(
  ob_ite_d_id  NUMBER(10) not null,
  ob_ite_id    NUMBER(10),
  ob_ite_d_con VARCHAR2(4000),
  dis_ord      NUMBER(5),
  std_ans      VARCHAR2(4000),
  pat          VARCHAR2(256),
  is_tts       VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_ITE_D
  add constraint PK_OB_ITE_D primary key (OB_ITE_D_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_ITE_D
  add constraint C_OB_ITE_D_ITE_FK foreign key (OB_ITE_ID)
  references UNICALL.C_OB_ITE (OB_ITE_ID);

prompt
prompt Creating table C_OB_PAR
prompt =======================
prompt
create table UNICALL.C_OB_PAR
(
  cat_id    NUMBER(30) not null,
  ob_com_id NUMBER(10) not null,
  val       VARCHAR2(4000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_PAR
  add constraint PK_OB_PAR primary key (CAT_ID, OB_COM_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_PAR
  add constraint C_C_OB_PAR_COM_FK foreign key (OB_COM_ID)
  references UNICALL.C_OB_COM (OB_COM_ID);
alter table UNICALL.C_OB_PAR
  add constraint C_OB_PAR_CAT_FK foreign key (CAT_ID)
  references UNICALL.C_CAT (CAT_ID);

prompt
prompt Creating table C_OB_POLICY
prompt ==========================
prompt
create table UNICALL.C_OB_POLICY
(
  policy_id                     NUMBER(10) not null,
  id_for_freepa                 NUMBER(10) not null,
  creation_date                 DATE,
  last_modification_date        DATE,
  order_date                    DATE,
  cancellation                  NUMBER(1),
  applicant_name                VARCHAR2(32),
  applicant_gender              NUMBER(1),
  applicant_identity_type       NUMBER(1),
  applicant_identity_number     VARCHAR2(32),
  applicant_birthday            DATE,
  applicant_insured_relation    VARCHAR2(32),
  applicant_address             VARCHAR2(128),
  applicant_home_tel            VARCHAR2(20),
  applicant_office_tel          VARCHAR2(20),
  applicant_mobile              VARCHAR2(20),
  applicant_postal_code         VARCHAR2(6),
  applicant_marriage_status     VARCHAR2(16),
  insured_name                  VARCHAR2(32),
  insured_gender                NUMBER(1),
  insured_identity_type         NUMBER(1),
  insured_identity_number       VARCHAR2(32),
  insured_birthday              DATE,
  insured_job                   VARCHAR2(64),
  insured_job_corp              VARCHAR2(64),
  insured_address               VARCHAR2(128),
  insured_marriage_status       VARCHAR2(16),
  heir_at_law                   NUMBER(1),
  beneficiary_name              VARCHAR2(32),
  beneficiary_insured_relation  VARCHAR2(32),
  beneficiary_percent           NUMBER(3),
  beneficiary_gender            NUMBER(1),
  beneficiary_identity_number   VARCHAR2(32),
  beneficiary2_name             VARCHAR2(32),
  beneficiary2_insured_relation VARCHAR2(32),
  beneficiary2_percent          NUMBER(3),
  beneficiary2_gender           NUMBER(1),
  beneficiary2_identity_number  VARCHAR2(32),
  beneficiary3_name             VARCHAR2(32),
  beneficiary3_insured_relation VARCHAR2(32),
  beneficiary3_percent          NUMBER(3),
  beneficiary3_gender           NUMBER(1),
  beneficiary3_identity_number  VARCHAR2(32),
  product_code                  VARCHAR2(32),
  fee_amount                    NUMBER(10),
  product_pay_mode              VARCHAR2(16),
  bank_name                     VARCHAR2(32),
  bank_account                  VARCHAR2(32),
  pay_mode                      VARCHAR2(16),
  booking_date                  DATE,
  remark                        VARCHAR2(512),
  buy_fpa                       NUMBER(1),
  auto_continue_pay             NUMBER(1),
  quality_assuranced            NUMBER(1) default 0 not null,
  accepted                      NUMBER(1) default 0 not null,
  freepa_accepted               NUMBER(1) default 0 not null,
  premium_status                VARCHAR2(32),
  policy_status                 VARCHAR2(32),
  valid_from_date               DATE,
  pieces                        NUMBER(3) default 1 not null,
  c_ob_com_cus_id               NUMBER(10) not null,
  ob_com_id                     NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_POLICY
  add constraint PK_OB_POLICY primary key (POLICY_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_OB_POLICY_FEE
prompt ==============================
prompt
create table UNICALL.C_OB_POLICY_FEE
(
  product_code VARCHAR2(16),
  age          NUMBER(2),
  gender       VARCHAR2(2),
  one_fee      NUMBER(10,2),
  year_fee     NUMBER(10,2),
  month_fee    NUMBER(10,2),
  item_id      NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_POLICY_FEE
  add constraint C_OB_POLICY_FEE_PK primary key (ITEM_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_OB_SCR_C_TYP
prompt =============================
prompt
create table UNICALL.C_OB_SCR_C_TYP
(
  ob_scr_c_typ_id NUMBER(5) not null,
  ob_scr_c_typ_de VARCHAR2(64),
  is_del          VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SCR_C_TYP
  add constraint PK_OB_SCR_C_TYP primary key (OB_SCR_C_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_OB_SCR_INS
prompt ===========================
prompt
create table UNICALL.C_OB_SCR_INS
(
  ob_scr_ins_id NUMBER(10) not null,
  ob_com_id     NUMBER(10) not null,
  ob_scr_id     NUMBER(10) not null,
  ob_ite_id     NUMBER(10) not null,
  use_id        NUMBER(10) not null,
  cus_id        NUMBER(10) not null,
  rem           VARCHAR2(4000),
  cre_dat       DATE not null,
  las_mod_dat   DATE not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.C_OB_SCR_INS_COM_IDX on UNICALL.C_OB_SCR_INS (OB_COM_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.C_OB_SCR_INS_CUS_IDX on UNICALL.C_OB_SCR_INS (CUS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.C_OB_SCR_INS_SCR_IDX on UNICALL.C_OB_SCR_INS (OB_SCR_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SCR_INS
  add constraint PK_OB_SCR_INS primary key (OB_SCR_INS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SCR_INS
  add constraint C_OB_SCR_INS_COM_CUS_FK foreign key (CUS_ID)
  references UNICALL.C_CUS_BAS (CUS_ID);
alter table UNICALL.C_OB_SCR_INS
  add constraint C_OB_SCR_INS_COM_ITE_FK foreign key (OB_ITE_ID)
  references UNICALL.C_OB_ITE (OB_ITE_ID);
alter table UNICALL.C_OB_SCR_INS
  add constraint C_OB_SCR_INS_COM_SCR_FK foreign key (OB_COM_ID, OB_SCR_ID)
  references UNICALL.C_OB_COM_SCR (OB_COM_ID, OB_SCR_ID);
alter table UNICALL.C_OB_SCR_INS
  add constraint C_OB_SCR_INS_COM_USE_FK foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_OB_SCR_INS_DI_SH
prompt =================================
prompt
create table UNICALL.C_OB_SCR_INS_DI_SH
(
  ob_scr_ins_id NUMBER(10) not null,
  com_cus_di_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SCR_INS_DI_SH
  add constraint PK_OB_SCR_INS_DI_SH primary key (OB_SCR_INS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SCR_INS_DI_SH
  add constraint C_OB_SCR_INS_DI_SH_DI_FK foreign key (COM_CUS_DI_ID)
  references UNICALL.C_OB_COM_CUS_DI (COM_CUS_DI_ID);
alter table UNICALL.C_OB_SCR_INS_DI_SH
  add constraint C_OB_SCR_INS_DI_SH_INS_FK foreign key (OB_SCR_INS_ID)
  references UNICALL.C_OB_SCR_INS (OB_SCR_INS_ID);

prompt
prompt Creating table C_OB_SCR_ITE
prompt ===========================
prompt
create table UNICALL.C_OB_SCR_ITE
(
  ob_scr_ite_id   NUMBER(10) not null,
  ob_scr_con_id   NUMBER(10),
  ob_scr_id       NUMBER(10),
  dis_ord         VARCHAR2(40),
  ob_scr_c_typ_id NUMBER(5) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SCR_ITE
  add constraint PK_OB_SCR_ITE primary key (OB_SCR_ITE_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SCR_ITE
  add constraint C_OB_SCR_ITE_C_TYP_FK foreign key (OB_SCR_C_TYP_ID)
  references UNICALL.C_OB_SCR_C_TYP (OB_SCR_C_TYP_ID);
alter table UNICALL.C_OB_SCR_ITE
  add constraint C_OB_SCR_ITE_SCR_FK foreign key (OB_SCR_ID)
  references UNICALL.C_OB_SCR (OB_SCR_ID);

prompt
prompt Creating table C_OB_SCR_RUL
prompt ===========================
prompt
create table UNICALL.C_OB_SCR_RUL
(
  ob_scr_rul_id NUMBER(10) not null,
  ob_scr_ite_id NUMBER(10) not null,
  con           VARCHAR2(4000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SCR_RUL
  add constraint PK_OB_SCR_RUL_ID primary key (OB_SCR_RUL_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SCR_RUL
  add constraint C_OB_SCR_RUL_ITE_FK foreign key (OB_SCR_ITE_ID)
  references UNICALL.C_OB_SCR_ITE (OB_SCR_ITE_ID);

prompt
prompt Creating table C_OB_SC_IN_AN
prompt ============================
prompt
create table UNICALL.C_OB_SC_IN_AN
(
  ob_sc_in_an_id NUMBER(10) not null,
  ob_ite_d_id    NUMBER(10) not null,
  ob_scr_ins_id  NUMBER(10) not null,
  ans            VARCHAR2(4000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SC_IN_AN
  add constraint PK_OB_SC_IN_AN primary key (OB_SC_IN_AN_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_SC_IN_AN
  add constraint C_OB_SC_IN_AN_ITE_D_FK foreign key (OB_ITE_D_ID)
  references UNICALL.C_OB_ITE_D (OB_ITE_D_ID);
alter table UNICALL.C_OB_SC_IN_AN
  add constraint C_OB_SC_IN_AN_S_INS_FK foreign key (OB_SCR_INS_ID)
  references UNICALL.C_OB_SCR_INS (OB_SCR_INS_ID);

prompt
prompt Creating table C_OB_TAS
prompt =======================
prompt
create table UNICALL.C_OB_TAS
(
  ob_com_id NUMBER(10) not null,
  tas_id    NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_TAS
  add constraint PKOB_TAS primary key (OB_COM_ID, TAS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_TAS
  add constraint C_OB_TAS_COM_FK foreign key (OB_COM_ID)
  references UNICALL.C_OB_COM (OB_COM_ID);
alter table UNICALL.C_OB_TAS
  add constraint C_OB_TAS_TAS_FK foreign key (TAS_ID)
  references UNICALL.C_TAS (TAS_ID);

prompt
prompt Creating table C_OB_TIM_BAN
prompt ===========================
prompt
create table UNICALL.C_OB_TIM_BAN
(
  ob_tim_ban_id NUMBER(10) not null,
  sta_tim_poi   VARCHAR2(20),
  end_tim_poi   VARCHAR2(20),
  ob_com_id     NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_TIM_BAN
  add constraint PK_OB_TIM_BAN primary key (OB_TIM_BAN_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_OB_TIM_BAN
  add constraint C_OB_TIM_BAN_COM_FK foreign key (OB_COM_ID)
  references UNICALL.C_OB_COM (OB_COM_ID);

prompt
prompt Creating table C_OPERATEUSER
prompt ============================
prompt
create table UNICALL.C_OPERATEUSER
(
  c_operateuser_id   NUMBER(10) not null,
  c_operateuser_code VARCHAR2(30) not null,
  c_operateuser_name VARCHAR2(60),
  c_operateuser_info VARCHAR2(100),
  company_id         NUMBER(10) not null,
  is_delete          VARCHAR2(2),
  org_id             NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_OPERATEUSER.c_operateuser_code
  is '业务员代码';
comment on column UNICALL.C_OPERATEUSER.c_operateuser_name
  is '业务员名称';
comment on column UNICALL.C_OPERATEUSER.c_operateuser_info
  is '备注';
comment on column UNICALL.C_OPERATEUSER.company_id
  is '中支公司';
comment on column UNICALL.C_OPERATEUSER.is_delete
  is '删除标识 1:删除';
alter table UNICALL.C_OPERATEUSER
  add constraint PK_C_OPERATEUSER primary key (C_OPERATEUSER_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_OPERATEUSER_AGENTCOMPANY
prompt =========================================
prompt
create table UNICALL.C_OPERATEUSER_AGENTCOMPANY
(
  id                NUMBER(10) not null,
  agentcompany_name VARCHAR2(100),
  agentcompany_code VARCHAR2(50),
  operateuser_code  VARCHAR2(50),
  company_id        NUMBER(10),
  is_verify         VARCHAR2(1),
  update_date       DATE,
  use_id            NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_OPERATEUSER_AGENTCOMPANY.agentcompany_name
  is '机构名称';
comment on column UNICALL.C_OPERATEUSER_AGENTCOMPANY.agentcompany_code
  is '机构代码';
comment on column UNICALL.C_OPERATEUSER_AGENTCOMPANY.operateuser_code
  is '业务员代码';
comment on column UNICALL.C_OPERATEUSER_AGENTCOMPANY.company_id
  is '分公司ID';
comment on column UNICALL.C_OPERATEUSER_AGENTCOMPANY.is_verify
  is '是否赠险0否,1是';
comment on column UNICALL.C_OPERATEUSER_AGENTCOMPANY.update_date
  is '更新时间';
comment on column UNICALL.C_OPERATEUSER_AGENTCOMPANY.use_id
  is '用户ID';
create index UNICALL.IDX_OPERATEUSER_CODE_01 on UNICALL.C_OPERATEUSER_AGENTCOMPANY (AGENTCOMPANY_CODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_OPERATEUSER_AGENTCOMPANY
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_PRO_SET
prompt ========================
prompt
create table UNICALL.C_PRO_SET
(
  id         NUMBER not null,
  campid     VARCHAR2(20) not null,
  proid      VARCHAR2(20) not null,
  drawage    VARCHAR2(50),
  modxyear   VARCHAR2(50),
  modx       VARCHAR2(20),
  policyyear VARCHAR2(50),
  ext1       VARCHAR2(50),
  ext2       VARCHAR2(50),
  ext3       VARCHAR2(50)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on column UNICALL.C_PRO_SET.id
  is 'ID';
comment on column UNICALL.C_PRO_SET.campid
  is '活动id';
comment on column UNICALL.C_PRO_SET.proid
  is '产品id';
comment on column UNICALL.C_PRO_SET.drawage
  is '领取年龄 45岁，50岁， 55岁，60岁，65岁， 70岁';
comment on column UNICALL.C_PRO_SET.modxyear
  is '缴费年限 99年限缴,20年限缴,30年限缴 ,10年限缴, 5年限缴 ';
comment on column UNICALL.C_PRO_SET.modx
  is '缴费方式 01～趸缴 10～月缴 11～季缴 12～半年缴 13～年缴 02～不定期';
comment on column UNICALL.C_PRO_SET.policyyear
  is '保险期间 88年  20年 15年 10年
88年仅用于金玉满堂
';
alter table UNICALL.C_PRO_SET
  add constraint C_POR_SET_PK primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_REL_TAS
prompt ========================
prompt
create table UNICALL.C_REL_TAS
(
  tas_id     NUMBER(10) not null,
  rel_tas_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF3343 on UNICALL.C_REL_TAS (TAS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF3344 on UNICALL.C_REL_TAS (REL_TAS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_REL_TAS
  add constraint PKREL_SER_REC primary key (TAS_ID, REL_TAS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_REL_TAS
  add constraint REFC_TAS43 foreign key (TAS_ID)
  references UNICALL.C_TAS (TAS_ID);
alter table UNICALL.C_REL_TAS
  add constraint REFC_TAS44 foreign key (REL_TAS_ID)
  references UNICALL.C_TAS (TAS_ID);

prompt
prompt Creating table C_ROL_FUN
prompt ========================
prompt
create table UNICALL.C_ROL_FUN
(
  rol_id     NUMBER(5) not null,
  cat_id     NUMBER(30) not null,
  man_typ_id NUMBER(5) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2651 on UNICALL.C_ROL_FUN (ROL_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2852 on UNICALL.C_ROL_FUN (CAT_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF4181 on UNICALL.C_ROL_FUN (MAN_TYP_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_ROL_FUN
  add constraint PKROL_FUN primary key (ROL_ID, CAT_ID, MAN_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_ROL_FUN
  add constraint REFC_ROL511 foreign key (ROL_ID)
  references UNICALL.C_ROL (ROL_ID);

prompt
prompt Creating table C_SEN_POO
prompt ========================
prompt
create table UNICALL.C_SEN_POO
(
  sen_poo_id     NUMBER not null,
  cha_ins_id     NUMBER,
  sen_poo_sta_id NUMBER,
  sen_tim        VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_SEN_POO_STA
prompt ============================
prompt
create table UNICALL.C_SEN_POO_STA
(
  sen_poo_sta_id  NUMBER not null,
  sen_poo_sta_des VARCHAR2(64),
  is_del          VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_STA_LOG
prompt ========================
prompt
create table UNICALL.C_STA_LOG
(
  log_id  NUMBER(20) not null,
  use_id  NUMBER(10),
  sta_id  VARCHAR2(10),
  beg_tim VARCHAR2(20),
  end_tim VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on column UNICALL.C_STA_LOG.log_id
  is '日志id';
comment on column UNICALL.C_STA_LOG.use_id
  is '用户id';
comment on column UNICALL.C_STA_LOG.sta_id
  is '状态id{2-空闲，3-未就绪，4-呼入，6-会议，7-事后处理，8-暂离，9-营销，10-候机，11-呼出}';
comment on column UNICALL.C_STA_LOG.beg_tim
  is '开始时间';
comment on column UNICALL.C_STA_LOG.end_tim
  is '结束时间';
alter table UNICALL.C_STA_LOG
  add constraint LOGID primary key (LOG_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_SUP
prompt ====================
prompt
create table UNICALL.C_SUP
(
  sup_id     NUMBER(10) not null,
  sup_ali_id VARCHAR2(40),
  sup_nam    VARCHAR2(1000),
  use_id     NUMBER(10) not null,
  sup_sta_id NUMBER(30) not null,
  sta_dat    VARCHAR2(20),
  art_per    VARCHAR2(40),
  pos        VARCHAR2(4000),
  con_per    VARCHAR2(40),
  tel        VARCHAR2(256),
  mob        VARCHAR2(256),
  fax        VARCHAR2(256),
  email      VARCHAR2(256),
  web        VARCHAR2(256),
  rem        VARCHAR2(4000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on column UNICALL.C_SUP.sup_ali_id
  is '第三方编号';
comment on column UNICALL.C_SUP.art_per
  is '法人代表';
comment on column UNICALL.C_SUP.pos
  is '注册地点';
comment on column UNICALL.C_SUP.con_per
  is '联系人';
alter table UNICALL.C_SUP
  add constraint PK17 primary key (SUP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_SUP
  add constraint REFC_CAT51 foreign key (SUP_STA_ID)
  references UNICALL.C_CAT (CAT_ID);
alter table UNICALL.C_SUP
  add constraint REFC_USE20 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_TAS_BUS
prompt ========================
prompt
create table UNICALL.C_TAS_BUS
(
  tas_id  NUMBER(10) not null,
  cat_id  NUMBER(30) not null,
  con     VARCHAR2(4000),
  sta_dat VARCHAR2(20),
  end_dat VARCHAR2(20),
  val     VARCHAR2(4000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_TAS_BUS
  add constraint PKTAS_BUS primary key (TAS_ID, CAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_TAS_BUS
  add constraint REFC_TAS243 foreign key (TAS_ID)
  references UNICALL.C_TAS (TAS_ID);

prompt
prompt Creating table C_TAS_CHA
prompt ========================
prompt
create table UNICALL.C_TAS_CHA
(
  tas_id NUMBER(10) not null,
  cha_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 39M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF1339 on UNICALL.C_TAS_CHA (CHA_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 44M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF3336 on UNICALL.C_TAS_CHA (TAS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 42M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_TAS_CHA
  add constraint PKTAS_CHA primary key (TAS_ID, CHA_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 53M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_TAS_CHA
  add constraint REFC_CHA39 foreign key (CHA_ID)
  references UNICALL.C_CHA (CHA_ID);
alter table UNICALL.C_TAS_CHA
  add constraint REFC_TAS36 foreign key (TAS_ID)
  references UNICALL.C_TAS (TAS_ID);

prompt
prompt Creating table C_TAS_CHA_INS
prompt ============================
prompt
create table UNICALL.C_TAS_CHA_INS
(
  tas_id     NUMBER(10) not null,
  cha_ins_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 39M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF3353 on UNICALL.C_TAS_CHA_INS (TAS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 43M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF4154 on UNICALL.C_TAS_CHA_INS (CHA_INS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 43M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_TAS_CHA_INS
  add constraint PKCH_IN_SE_RE primary key (TAS_ID, CHA_INS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 54M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_TAS_CHA_INS
  add constraint REFC_CHA_INS54 foreign key (CHA_INS_ID)
  references UNICALL.C_CHA_INS (CHA_INS_ID)
  disable;
alter table UNICALL.C_TAS_CHA_INS
  add constraint REFC_TAS53 foreign key (TAS_ID)
  references UNICALL.C_TAS (TAS_ID);

prompt
prompt Creating table C_TAS_CUS
prompt ========================
prompt
create table UNICALL.C_TAS_CUS
(
  tas_id NUMBER(10) not null,
  cus_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 23M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF177 on UNICALL.C_TAS_CUS (CUS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 24M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF3376 on UNICALL.C_TAS_CUS (TAS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 24M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_TAS_CUS
  add constraint PK73 primary key (TAS_ID, CUS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 31M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_TAS_CUS
  add constraint REFC_CUS_BAS77 foreign key (CUS_ID)
  references UNICALL.C_CUS_BAS (CUS_ID);
alter table UNICALL.C_TAS_CUS
  add constraint REFC_TAS76 foreign key (TAS_ID)
  references UNICALL.C_TAS (TAS_ID);

prompt
prompt Creating table C_TA_OP_IN_TY
prompt ============================
prompt
create table UNICALL.C_TA_OP_IN_TY
(
  ta_op_in_ty_id NUMBER(5) not null,
  han_key        VARCHAR2(256),
  is_del         VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_TA_OP_IN_TY
  add constraint PK174 primary key (TA_OP_IN_TY_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_TAS_OPE_INT
prompt ============================
prompt
create table UNICALL.C_TAS_OPE_INT
(
  tas_ope_int_id NUMBER(10) not null,
  ta_op_in_ty_id NUMBER(5) not null,
  tas_id         NUMBER(10) not null,
  ope_id         NUMBER(20),
  ope_ali_id     VARCHAR2(40),
  sta_dat        VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_TAS_OPE_INT
  add constraint PK173 primary key (TAS_OPE_INT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_TAS_OPE_INT
  add constraint REFC_TAS247 foreign key (TAS_ID)
  references UNICALL.C_TAS (TAS_ID);
alter table UNICALL.C_TAS_OPE_INT
  add constraint REFC_TA_OP_IN_TY246 foreign key (TA_OP_IN_TY_ID)
  references UNICALL.C_TA_OP_IN_TY (TA_OP_IN_TY_ID);

prompt
prompt Creating table C_TAS_SEA_MOD
prompt ============================
prompt
create table UNICALL.C_TAS_SEA_MOD
(
  tas_sea_mod_id  NUMBER(10) not null,
  ali_nam         VARCHAR2(1024),
  tas_sea_mod_des VARCHAR2(4000),
  use_id          NUMBER(10) not null,
  sea_con         VARCHAR2(4000),
  sta_dat         VARCHAR2(20),
  end_dat         VARCHAR2(20),
  is_exc          VARCHAR2(1),
  dat_mar         VARCHAR2(1),
  sta_con         VARCHAR2(4000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_TAS_SEA_MOD
  add constraint PK162 primary key (TAS_SEA_MOD_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_TAS_SEA_MOD
  add constraint REFC_USE223 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_TAS_TYP
prompt ========================
prompt
create table UNICALL.C_TAS_TYP
(
  tas_id NUMBER(10) not null,
  cat_id NUMBER(30) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF3341 on UNICALL.C_TAS_TYP (TAS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_TAS_TYP
  add constraint PKSER_TYP primary key (TAS_ID, CAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_TAS_TYP
  add constraint REFC_TAS41 foreign key (TAS_ID)
  references UNICALL.C_TAS (TAS_ID);

prompt
prompt Creating table C_TA_SE_MO_DI
prompt ============================
prompt
create table UNICALL.C_TA_SE_MO_DI
(
  ta_se_mo_di_id NUMBER(10) not null,
  use_id         NUMBER(10),
  tas_sea_mod_id NUMBER(10) not null,
  gro_id         NUMBER(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_TA_SE_MO_DI
  add constraint PKUSE_INF_REC_1 primary key (TA_SE_MO_DI_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_TA_SE_MO_DI
  add constraint REFC_TAS_SEA_MOD256 foreign key (TAS_SEA_MOD_ID)
  references UNICALL.C_TAS_SEA_MOD (TAS_SEA_MOD_ID);
alter table UNICALL.C_TA_SE_MO_DI
  add constraint REFC_USE257 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_TIF_JOB
prompt ========================
prompt
create table UNICALL.C_TIF_JOB
(
  tif_no      NUMBER not null,
  tif_nam     VARCHAR2(80),
  sen_dat_tim DATE,
  sen_tim     NUMBER,
  sen_poo_id  NUMBER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_TIME_CARD
prompt ==========================
prompt
create table UNICALL.C_TIME_CARD
(
  c_time_card_id  NUMBER(10) not null,
  c_user_id       NVARCHAR2(10) not null,
  c_user_sta      VARCHAR2(2) not null,
  c_sta_time      VARCHAR2(20),
  c_remark        VARCHAR2(500),
  c_ext1          VARCHAR2(20),
  c_ext2          VARCHAR2(20),
  c_flag          VARCHAR2(1),
  c_online        VARCHAR2(1),
  c_user_sta_name VARCHAR2(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.C_TIME_CARD.c_time_card_id
  is 'ID';
comment on column UNICALL.C_TIME_CARD.c_user_id
  is '用户id';
comment on column UNICALL.C_TIME_CARD.c_user_sta
  is '用户当前状态';
comment on column UNICALL.C_TIME_CARD.c_sta_time
  is '更新状态时间';
comment on column UNICALL.C_TIME_CARD.c_remark
  is '备注';
comment on column UNICALL.C_TIME_CARD.c_flag
  is '标志';
comment on column UNICALL.C_TIME_CARD.c_online
  is '是否在线  0 离线  1 在线';
comment on column UNICALL.C_TIME_CARD.c_user_sta_name
  is '状态名称';

prompt
prompt Creating table C_USE_CAT
prompt ========================
prompt
create table UNICALL.C_USE_CAT
(
  use_id     NUMBER(10) not null,
  cat_id     NUMBER(30) not null,
  man_typ_id NUMBER(5) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF139 on UNICALL.C_USE_CAT (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2874 on UNICALL.C_USE_CAT (CAT_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF4180 on UNICALL.C_USE_CAT (MAN_TYP_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE_CAT
  add constraint PKUSE_CAT primary key (USE_ID, CAT_ID, MAN_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_USE_CUS
prompt ========================
prompt
create table UNICALL.C_USE_CUS
(
  use_id NUMBER(10) not null,
  cus_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.REF147 on UNICALL.C_USE_CUS (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.C_USE_CUS
  add constraint PKUSE_CUS primary key (USE_ID, CUS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table C_USE_GRO
prompt ========================
prompt
create table UNICALL.C_USE_GRO
(
  gro_id NUMBER(30) not null,
  use_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF178 on UNICALL.C_USE_GRO (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2879 on UNICALL.C_USE_GRO (GRO_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE_GRO
  add constraint PKC_USE_GRO primary key (GRO_ID, USE_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 320K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_USE_GRO_FUN
prompt ============================
prompt
create table UNICALL.C_USE_GRO_FUN
(
  cat_id     NUMBER(30) not null,
  gro_id     NUMBER(30) not null,
  man_typ_id NUMBER(5) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2885 on UNICALL.C_USE_GRO_FUN (CAT_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2886 on UNICALL.C_USE_GRO_FUN (GRO_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE_GRO_FUN
  add constraint PKUSE_GRO_FUN primary key (CAT_ID, GRO_ID, MAN_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_USE_GRO_ROL
prompt ============================
prompt
create table UNICALL.C_USE_GRO_ROL
(
  gro_id NUMBER(30) not null,
  rol_id NUMBER(5) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2683 on UNICALL.C_USE_GRO_ROL (ROL_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2882 on UNICALL.C_USE_GRO_ROL (GRO_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE_GRO_ROL
  add constraint PKUSE_GRO_ROL primary key (GRO_ID, ROL_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE_GRO_ROL
  add constraint REFC_ROL83 foreign key (ROL_ID)
  references UNICALL.C_ROL (ROL_ID);

prompt
prompt Creating table C_USE_INF
prompt ========================
prompt
create table UNICALL.C_USE_INF
(
  use_id NUMBER(10) not null,
  inf_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF4866 on UNICALL.C_USE_INF (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF6065 on UNICALL.C_USE_INF (INF_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE_INF
  add constraint PKUSE_INF primary key (USE_ID, INF_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table C_USE_INF_REC
prompt ============================
prompt
create table UNICALL.C_USE_INF_REC
(
  inf_id         NUMBER(10) not null,
  use_id         NUMBER(10) not null,
  kno            VARCHAR2(1),
  use_inf_rec_id NUMBER(10) not null,
  gro_id         NUMBER(30),
  state          VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 9M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF48158 on UNICALL.C_USE_INF_REC (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 8M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF60157 on UNICALL.C_USE_INF_REC (INF_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 8M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF64207 on UNICALL.C_USE_INF_REC (GRO_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE_INF_REC
  add constraint PK118 primary key (USE_INF_REC_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 7M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE_INF_REC
  add constraint REFC_USE158 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_USE_PAR
prompt ========================
prompt
create table UNICALL.C_USE_PAR
(
  use_id NUMBER(10) not null,
  cat_id NUMBER(30) not null,
  val    VARCHAR2(256)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF48120 on UNICALL.C_USE_PAR (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF64121 on UNICALL.C_USE_PAR (CAT_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE_PAR
  add constraint PK99 primary key (USE_ID, CAT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 320K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE_PAR
  add constraint REFC_USE120 foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table C_USE_ROL
prompt ========================
prompt
create table UNICALL.C_USE_ROL
(
  use_id NUMBER(10) not null,
  rol_id NUMBER(5) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF150 on UNICALL.C_USE_ROL (USE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.REF2649 on UNICALL.C_USE_ROL (ROL_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE_ROL
  add constraint PKUSE_ROL primary key (USE_ID, ROL_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.C_USE_ROL
  add constraint REFC_ROL491 foreign key (ROL_ID)
  references UNICALL.C_ROL (ROL_ID);

prompt
prompt Creating table C_USE_TEMP_INVALID
prompt =================================
prompt
create table UNICALL.C_USE_TEMP_INVALID
(
  use_ali_id VARCHAR2(20),
  tmount     NUMBER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table DATA_IDS_HIST
prompt ============================
prompt
create table UNICALL.DATA_IDS_HIST
(
  sno      NUMBER(18) not null,
  policyno VARCHAR2(20) not null,
  ukey     VARCHAR2(35),
  remark   VARCHAR2(500),
  modifier VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on table UNICALL.DATA_IDS_HIST
  is 'IDS数据变更历史';
comment on column UNICALL.DATA_IDS_HIST.sno
  is '物理主键';
comment on column UNICALL.DATA_IDS_HIST.policyno
  is '保单号';
comment on column UNICALL.DATA_IDS_HIST.ukey
  is '更新业务唯一标识';
comment on column UNICALL.DATA_IDS_HIST.remark
  is '状态变更说明';
comment on column UNICALL.DATA_IDS_HIST.modifier
  is '变更者';
alter table UNICALL.DATA_IDS_HIST
  add constraint PK_DATA_IDS_HIST primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table DUNNING_REPORT
prompt =============================
prompt
create table UNICALL.DUNNING_REPORT
(
  sales_organization         VARCHAR2(100),
  the_workspace              VARCHAR2(100),
  project_name               VARCHAR2(100),
  branch                     VARCHAR2(100),
  empno                      VARCHAR2(100),
  policyno                   VARCHAR2(100),
  appno_no                   VARCHAR2(100),
  classcode                  VARCHAR2(50),
  classname                  VARCHAR2(50),
  tbr_name                   VARCHAR2(50),
  tbr_id                     VARCHAR2(50),
  bbr_name                   VARCHAR2(50),
  bbr_id                     VARCHAR2(50),
  policyno_status            VARCHAR2(20),
  ways_of_payment            VARCHAR2(50),
  debit_bank                 VARCHAR2(100),
  debit_no                   VARCHAR2(100),
  begdate                    VARCHAR2(50),
  nextdate                   VARCHAR2(50),
  payment_period             NUMBER,
  payment_count              VARCHAR2(100),
  a_single_period_of_payment VARCHAR2(100),
  prem_term                  VARCHAR2(20),
  hphone                     VARCHAR2(50),
  mphone                     VARCHAR2(50),
  pay_period                 NUMBER,
  outstanding_amount         VARCHAR2(100),
  zxgh                       VARCHAR2(50),
  zg                         VARCHAR2(50),
  opdate                     VARCHAR2(50)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.DUNNING_REPORT
  is '续期催缴报表';
comment on column UNICALL.DUNNING_REPORT.sales_organization
  is '销售机构';
comment on column UNICALL.DUNNING_REPORT.the_workspace
  is '所属职场';
comment on column UNICALL.DUNNING_REPORT.project_name
  is '项目名称';
comment on column UNICALL.DUNNING_REPORT.branch
  is '分公司';
comment on column UNICALL.DUNNING_REPORT.empno
  is '业务工号';
comment on column UNICALL.DUNNING_REPORT.policyno
  is '保单号';
comment on column UNICALL.DUNNING_REPORT.appno_no
  is '投保单号';
comment on column UNICALL.DUNNING_REPORT.classcode
  is '险种';
comment on column UNICALL.DUNNING_REPORT.classname
  is '险种名称';
comment on column UNICALL.DUNNING_REPORT.tbr_name
  is '投保人姓名';
comment on column UNICALL.DUNNING_REPORT.tbr_id
  is '投保人身份证号';
comment on column UNICALL.DUNNING_REPORT.bbr_name
  is '被保人姓名';
comment on column UNICALL.DUNNING_REPORT.bbr_id
  is '被保人证件号码';
comment on column UNICALL.DUNNING_REPORT.policyno_status
  is '保单状态';
comment on column UNICALL.DUNNING_REPORT.ways_of_payment
  is '缴费方式';
comment on column UNICALL.DUNNING_REPORT.debit_bank
  is '扣款银行';
comment on column UNICALL.DUNNING_REPORT.debit_no
  is '扣款账号';
comment on column UNICALL.DUNNING_REPORT.begdate
  is '责任起期';
comment on column UNICALL.DUNNING_REPORT.nextdate
  is '下次缴费日期';
comment on column UNICALL.DUNNING_REPORT.payment_period
  is '已交期次';
comment on column UNICALL.DUNNING_REPORT.payment_count
  is '累计缴费';
comment on column UNICALL.DUNNING_REPORT.a_single_period_of_payment
  is '单期缴费';
comment on column UNICALL.DUNNING_REPORT.prem_term
  is '缴费年限';
comment on column UNICALL.DUNNING_REPORT.hphone
  is '家庭电话';
comment on column UNICALL.DUNNING_REPORT.mphone
  is '投保人手机号';
comment on column UNICALL.DUNNING_REPORT.pay_period
  is '欠缴期次';
comment on column UNICALL.DUNNING_REPORT.outstanding_amount
  is '欠缴金额';
comment on column UNICALL.DUNNING_REPORT.zxgh
  is '坐席工号';
comment on column UNICALL.DUNNING_REPORT.zg
  is '主管';
comment on column UNICALL.DUNNING_REPORT.opdate
  is '保单成交日期';

prompt
prompt Creating table EMPNO
prompt ====================
prompt
create table UNICALL.EMPNO
(
  sno              NUMBER(20),
  typeid           NUMBER(7),
  empno_id         NUMBER(20),
  person_id        NUMBER(20),
  empno            VARCHAR2(20),
  status           CHAR(2),
  name             VARCHAR2(120),
  degreeno         CHAR(2),
  indate           DATE,
  outdate          DATE,
  regdate          DATE,
  degdate          DATE,
  pid              VARCHAR2(40),
  begdate          DATE,
  enddate          DATE,
  edu_level        CHAR(2),
  begtime          NUMBER(11),
  endtime          NUMBER(11),
  branch           CHAR(14),
  etl_time         TIMESTAMP(6),
  src_sys          VARCHAR2(20),
  c_agt_ind        CHAR(1),
  source_person_id VARCHAR2(20),
  agt_sub_type     CHAR(1),
  agt_sale_qualify NUMBER(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.EMPNO
  is '渠道工号信息';
comment on column UNICALL.EMPNO.sno
  is 'IAA物理主键';
comment on column UNICALL.EMPNO.typeid
  is '业务员类型';
comment on column UNICALL.EMPNO.empno_id
  is 'IAA锚点，Roleplayer';
comment on column UNICALL.EMPNO.person_id
  is '渠道相关个人信息IAA业务相关主键';
comment on column UNICALL.EMPNO.empno
  is '工号';
comment on column UNICALL.EMPNO.status
  is '状态';
comment on column UNICALL.EMPNO.name
  is '姓名';
comment on column UNICALL.EMPNO.degreeno
  is '职级';
comment on column UNICALL.EMPNO.indate
  is '入司日期';
comment on column UNICALL.EMPNO.outdate
  is '离司日期';
comment on column UNICALL.EMPNO.regdate
  is '注册日期';
comment on column UNICALL.EMPNO.degdate
  is '升级日期';
comment on column UNICALL.EMPNO.pid
  is '身份证号码';
comment on column UNICALL.EMPNO.begdate
  is '有效起始日期';
comment on column UNICALL.EMPNO.enddate
  is '有效终止日期';
comment on column UNICALL.EMPNO.edu_level
  is '代理人学历';
comment on column UNICALL.EMPNO.begtime
  is '开始日期';
comment on column UNICALL.EMPNO.endtime
  is '中止日期';
comment on column UNICALL.EMPNO.branch
  is '分公司代码';
comment on column UNICALL.EMPNO.etl_time
  is 'ETL处理时间';
comment on column UNICALL.EMPNO.src_sys
  is '来源系统';
comment on column UNICALL.EMPNO.c_agt_ind
  is '是否C人力';
comment on column UNICALL.EMPNO.source_person_id
  is '对应agt_person的源系统ID';
comment on column UNICALL.EMPNO.agt_sub_type
  is '业务员二级分类';
comment on column UNICALL.EMPNO.agt_sale_qualify
  is '业务员销售资格';

prompt
prompt Creating table FILE_LOG
prompt =======================
prompt
create table UNICALL.FILE_LOG
(
  id          NUMBER(10) not null,
  starttime   DATE,
  endtime     DATE,
  filename    VARCHAR2(100),
  filetype    NUMBER,
  succcount   NUMBER,
  failedcount NUMBER,
  state       NUMBER,
  batchdate   VARCHAR2(20),
  dataname    VARCHAR2(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 640K
    next 8K
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.FILE_LOG
  is '记录文件解析的日志';
comment on column UNICALL.FILE_LOG.id
  is '序号';
comment on column UNICALL.FILE_LOG.starttime
  is '开始时间';
comment on column UNICALL.FILE_LOG.endtime
  is '结束时间';
comment on column UNICALL.FILE_LOG.filename
  is '文件名';
comment on column UNICALL.FILE_LOG.filetype
  is '文件类型';
comment on column UNICALL.FILE_LOG.succcount
  is '成功数量';
comment on column UNICALL.FILE_LOG.failedcount
  is '失败数量';
comment on column UNICALL.FILE_LOG.state
  is '解析状态; 1解析中2全部成功3 部分成功4:全部失败';
comment on column UNICALL.FILE_LOG.batchdate
  is '批次日期';
comment on column UNICALL.FILE_LOG.dataname
  is '批次数据名';
alter table UNICALL.FILE_LOG
  add constraint PK_FILE_LOG primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table FAILED_DATA_LOG
prompt ==============================
prompt
create table UNICALL.FAILED_DATA_LOG
(
  id         NUMBER(10) not null,
  filelogid  NUMBER(10),
  linenumber NUMBER,
  datainfo   VARCHAR2(1024),
  createdate DATE,
  remark     VARCHAR2(255)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 4M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.FAILED_DATA_LOG
  is '失败数据日志表';
comment on column UNICALL.FAILED_DATA_LOG.id
  is '序号';
comment on column UNICALL.FAILED_DATA_LOG.filelogid
  is '解析文件日志ID';
comment on column UNICALL.FAILED_DATA_LOG.linenumber
  is '数据行号';
comment on column UNICALL.FAILED_DATA_LOG.datainfo
  is '数据';
comment on column UNICALL.FAILED_DATA_LOG.createdate
  is '创建时间';
comment on column UNICALL.FAILED_DATA_LOG.remark
  is '备注';
alter table UNICALL.FAILED_DATA_LOG
  add constraint PK_FAILED_DATA_LOG primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 384K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.FAILED_DATA_LOG
  add constraint FK_FAILED_D_REFERENCE_FILE_LOG foreign key (FILELOGID)
  references UNICALL.FILE_LOG (ID);

prompt
prompt Creating table FF_COMPANY
prompt =========================
prompt
create table UNICALL.FF_COMPANY
(
  ff_com_id  NUMBER(10) not null,
  orgcode    VARCHAR2(14),
  orgname    VARCHAR2(200),
  orgtype    VARCHAR2(10),
  branchid   VARCHAR2(14),
  bmdm       VARCHAR2(10),
  dx_orgcode VARCHAR2(18),
  rest1      VARCHAR2(200),
  rest2      VARCHAR2(200),
  rest3      VARCHAR2(200)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.FF_COMPANY
  is '机构信息';
comment on column UNICALL.FF_COMPANY.ff_com_id
  is 'ID 主键';
comment on column UNICALL.FF_COMPANY.orgcode
  is '机构编码';
comment on column UNICALL.FF_COMPANY.orgname
  is '机构名称';
comment on column UNICALL.FF_COMPANY.orgtype
  is '机构类型';
comment on column UNICALL.FF_COMPANY.branchid
  is '父机构编码';
comment on column UNICALL.FF_COMPANY.bmdm
  is '鉴定码';
comment on column UNICALL.FF_COMPANY.dx_orgcode
  is '电销机构编码';
comment on column UNICALL.FF_COMPANY.rest1
  is '保留1';
comment on column UNICALL.FF_COMPANY.rest2
  is '保留2';
comment on column UNICALL.FF_COMPANY.rest3
  is '保留3';
alter table UNICALL.FF_COMPANY
  add constraint PK_FF_COM_ID primary key (FF_COM_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.FF_COMPANY
  add constraint UK_FF_ORG_CODE unique (ORGCODE)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table INTORG
prompt =====================
prompt
create table UNICALL.INTORG
(
  sno              NUMBER(20),
  typeid           NUMBER(7) not null,
  intorg_id        NUMBER(20),
  intorgcode       VARCHAR2(20) not null,
  intorgname       VARCHAR2(240) not null,
  governid         VARCHAR2(20),
  direct_mng_ind   VARCHAR2(1),
  areatype         VARCHAR2(4),
  orgtype          VARCHAR2(4),
  statuscode       VARCHAR2(2),
  firstinsert      DATE,
  lastmodify       DATE,
  fullname         VARCHAR2(180),
  city             VARCHAR2(60),
  town             VARCHAR2(60),
  title            VARCHAR2(4),
  permit_date      DATE,
  license_date     DATE,
  busi_scope       VARCHAR2(4),
  license_status   VARCHAR2(2),
  regionalism_code VARCHAR2(6),
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         DATE not null,
  src_sys          VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.INTORG
  is '  行政和各类营销组织架构，采用办公室提供的行政机构';
comment on column UNICALL.INTORG.sno
  is '  IAA物理主键';
comment on column UNICALL.INTORG.typeid
  is '  ';
comment on column UNICALL.INTORG.intorg_id
  is '  IAA锚点，Roleplayer';
comment on column UNICALL.INTORG.intorgcode
  is '  业务机构代码';
comment on column UNICALL.INTORG.intorgname
  is '  机构名称';
comment on column UNICALL.INTORG.governid
  is '  办公室编制行政机构代码';
comment on column UNICALL.INTORG.direct_mng_ind
  is '  直辖标记（1 直辖， 0非直辖，2其他）';
comment on column UNICALL.INTORG.areatype
  is '  城镇/区县';
comment on column UNICALL.INTORG.orgtype
  is '  内部定义机构类型';
comment on column UNICALL.INTORG.statuscode
  is '  状态代码';
comment on column UNICALL.INTORG.firstinsert
  is '  机构加入日期';
comment on column UNICALL.INTORG.lastmodify
  is '  最后修改日期';
comment on column UNICALL.INTORG.fullname
  is '  机构证照名称';
comment on column UNICALL.INTORG.city
  is '  所在城市';
comment on column UNICALL.INTORG.town
  is '  所在乡镇';
comment on column UNICALL.INTORG.title
  is '  外部监管机构称谓';
comment on column UNICALL.INTORG.permit_date
  is '  许可证日期
';
comment on column UNICALL.INTORG.license_date
  is '  营业执照日期
';
comment on column UNICALL.INTORG.busi_scope
  is '  经营状况
';
comment on column UNICALL.INTORG.license_status
  is '  证照状态
';
comment on column UNICALL.INTORG.regionalism_code
  is '  行政区划代码
';
comment on column UNICALL.INTORG.begtime
  is '  开始日期';
comment on column UNICALL.INTORG.endtime
  is '  中止日期';
comment on column UNICALL.INTORG.branch
  is '  分公司代码';
comment on column UNICALL.INTORG.etl_time
  is '  ETL处理时间';
comment on column UNICALL.INTORG.src_sys
  is '  来源系统';

prompt
prompt Creating table INTORG_BAK
prompt =========================
prompt
create table UNICALL.INTORG_BAK
(
  sno              NUMBER(20),
  typeid           NUMBER(7) not null,
  intorg_id        NUMBER(20),
  intorgcode       VARCHAR2(20) not null,
  intorgname       VARCHAR2(240) not null,
  governid         VARCHAR2(20),
  direct_mng_ind   VARCHAR2(1),
  areatype         VARCHAR2(4),
  orgtype          VARCHAR2(4),
  statuscode       VARCHAR2(2),
  firstinsert      DATE,
  lastmodify       DATE,
  fullname         VARCHAR2(180),
  city             VARCHAR2(60),
  town             VARCHAR2(60),
  title            VARCHAR2(4),
  permit_date      DATE,
  license_date     DATE,
  busi_scope       VARCHAR2(4),
  license_status   VARCHAR2(2),
  regionalism_code VARCHAR2(6),
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         DATE not null,
  src_sys          VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ITF_INSURSTATE
prompt =============================
prompt
create table UNICALL.ITF_INSURSTATE
(
  app_no     VARCHAR2(18) not null,
  is_bankins CHAR(2) not null,
  status     VARCHAR2(3) not null,
  updatetime VARCHAR2(19) not null,
  note       VARCHAR2(400),
  policyno   VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.ITF_INSURSTATE.policyno
  is '保单号';
create index UNICALL.IDX_ITF_INSURSTATE_APP_NO on UNICALL.ITF_INSURSTATE (APP_NO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 640K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table ITF_INSURSTATE_BAK
prompt =================================
prompt
create table UNICALL.ITF_INSURSTATE_BAK
(
  app_no     VARCHAR2(15) not null,
  is_bankins CHAR(2) not null,
  status     VARCHAR2(3) not null,
  updatetime VARCHAR2(19) not null,
  note       VARCHAR2(400),
  policyno   VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table MONEYSCH
prompt =======================
prompt
create table UNICALL.MONEYSCH
(
  sno               NUMBER(20),
  typeid            NUMBER(7) not null,
  con_id            NUMBER(20),
  policyno          VARCHAR2(20) not null,
  classcode         CHAR(8) not null,
  paysch            CHAR(2) not null,
  delsch            CHAR(1),
  setcode           CHAR(1) not null,
  delfrm            CHAR(1),
  begdate           DATE not null,
  nretdate          DATE,
  pbdate            DATE not null,
  pedate            DATE not null,
  nextdate          DATE,
  benefit_inc       CHAR(1) not null,
  reczip            VARCHAR2(20),
  recaddr           VARCHAR2(500),
  rectele           VARCHAR2(30),
  appointed_bp_date DATE,
  prem_term         VARCHAR2(20),
  bp_option         VARCHAR2(20),
  begtime           NUMBER(11) not null,
  endtime           NUMBER(11) not null,
  branch            CHAR(14) not null,
  etl_time          TIMESTAMP(6) not null,
  src_sys           VARCHAR2(20) not null,
  o_classcode       VARCHAR2(8)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 6M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.MONEYSCH
  is '  缴费/给付计划';
comment on column UNICALL.MONEYSCH.sno
  is '  IAA物理主键';
comment on column UNICALL.MONEYSCH.typeid
  is '  IAA数据类型(缴费和给付2合1)';
comment on column UNICALL.MONEYSCH.con_id
  is '  保单IAA业务相关主键';
comment on column UNICALL.MONEYSCH.policyno
  is '  保单号';
comment on column UNICALL.MONEYSCH.classcode
  is '  险种代码';
comment on column UNICALL.MONEYSCH.paysch
  is '  缴费频率';
comment on column UNICALL.MONEYSCH.delsch
  is '  给付频率';
comment on column UNICALL.MONEYSCH.setcode
  is '  缴费方式';
comment on column UNICALL.MONEYSCH.delfrm
  is '  给付方式';
comment on column UNICALL.MONEYSCH.begdate
  is '  缴费周年日期';
comment on column UNICALL.MONEYSCH.nretdate
  is '  首次年金领取日期';
comment on column UNICALL.MONEYSCH.pbdate
  is '  缴费起始日期';
comment on column UNICALL.MONEYSCH.pedate
  is '  缴费终止日期';
comment on column UNICALL.MONEYSCH.nextdate
  is '  下次缴费日期';
comment on column UNICALL.MONEYSCH.benefit_inc
  is '  给付类型(平准/递增)';
comment on column UNICALL.MONEYSCH.reczip
  is '  收费邮政编码';
comment on column UNICALL.MONEYSCH.recaddr
  is '  收费地址信息';
comment on column UNICALL.MONEYSCH.rectele
  is '  收费联系电话';
comment on column UNICALL.MONEYSCH.appointed_bp_date
  is '  客户指定的领取日期（鸿鑫）';
comment on column UNICALL.MONEYSCH.prem_term
  is '  缴费期限（FF系统中客户选择的缴费期限，综意险直接按照riskcon.yearnum供数）';
comment on column UNICALL.MONEYSCH.bp_option
  is '  保险期限/领取年龄';
comment on column UNICALL.MONEYSCH.begtime
  is '  开始日期';
comment on column UNICALL.MONEYSCH.endtime
  is '  中止日期';
comment on column UNICALL.MONEYSCH.branch
  is '  分公司代码';
comment on column UNICALL.MONEYSCH.etl_time
  is '  ETL处理时间';
comment on column UNICALL.MONEYSCH.src_sys
  is '  来源系统';
comment on column UNICALL.MONEYSCH.o_classcode
  is 'IDS转换前的综意险系统6位险种代码';
create index UNICALL.MONEYSCH_INDEX on UNICALL.MONEYSCH (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.MONEYSCH
  add constraint PK_MONEYSCH_BK primary key (POLICYNO, CLASSCODE)
  disable;

prompt
prompt Creating table MONEYSCH_BAK
prompt ===========================
prompt
create table UNICALL.MONEYSCH_BAK
(
  sno               NUMBER(20),
  typeid            NUMBER(7) not null,
  con_id            NUMBER(20),
  policyno          VARCHAR2(20) not null,
  classcode         CHAR(8) not null,
  paysch            CHAR(2) not null,
  delsch            CHAR(1),
  setcode           CHAR(1) not null,
  delfrm            CHAR(1),
  begdate           DATE not null,
  nretdate          DATE,
  pbdate            DATE not null,
  pedate            DATE not null,
  nextdate          DATE,
  benefit_inc       CHAR(1) not null,
  reczip            VARCHAR2(20),
  recaddr           VARCHAR2(500),
  rectele           VARCHAR2(30),
  appointed_bp_date DATE,
  prem_term         VARCHAR2(20),
  bp_option         VARCHAR2(20),
  begtime           NUMBER(11) not null,
  endtime           NUMBER(11) not null,
  branch            CHAR(14) not null,
  etl_time          TIMESTAMP(6) not null,
  src_sys           VARCHAR2(20) not null,
  o_classcode       VARCHAR2(8)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table OCS
prompt ==================
prompt
create table UNICALL.OCS
(
  record_id         NUMBER not null,
  contact_info      VARCHAR2(128) not null,
  contact_info_type NUMBER not null,
  record_type       NUMBER not null,
  record_status     NUMBER not null,
  call_result       NUMBER,
  attempt           NUMBER not null,
  dial_sched_time   NUMBER,
  call_time         NUMBER,
  daily_from        NUMBER not null,
  daily_till        NUMBER not null,
  tz_dbid           NUMBER not null,
  campaign_id       NUMBER,
  agent_id          VARCHAR2(32),
  chain_id          NUMBER not null,
  chain_n           NUMBER not null,
  group_id          NUMBER,
  app_id            NUMBER,
  treatments        VARCHAR2(255),
  media_ref         NUMBER,
  email_subject     VARCHAR2(255),
  email_template_id NUMBER,
  switch_id         NUMBER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.OCS
  add constraint OCS_PK primary key (CHAIN_ID, CHAIN_N)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.OCS
  add unique (RECORD_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table OCSTYPE
prompt ======================
prompt
create table UNICALL.OCSTYPE
(
  record_id   NUMBER not null,
  type_value  VARCHAR2(10) not null,
  type_eng    VARCHAR2(256),
  type_chn    VARCHAR2(256),
  record_type VARCHAR2(50)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.OCSTYPE
  add constraint PK_OCS_TYPE primary key (RECORD_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table PERSON
prompt =====================
prompt
create table UNICALL.PERSON
(
  sno              NUMBER(20) not null,
  typeid           NUMBER(7) not null,
  person_id        NUMBER(20),
  persontype       NUMBER(20) not null,
  bthdate          DATE,
  diedate          DATE,
  edulevel         CHAR(2),
  sex              CHAR(1),
  income           NUMBER(20,6),
  company          VARCHAR2(180),
  marriage         CHAR(3),
  smoker           CHAR(1),
  blood            NUMBER(20),
  ethnicity        CHAR(2),
  hdesp            CHAR(1),
  customerid       VARCHAR2(40),
  name             VARCHAR2(120),
  job              CHAR(7),
  drvcard          VARCHAR2(2),
  country          CHAR(2),
  residence        VARCHAR2(90),
  id               VARCHAR2(40) not null,
  id15             VARCHAR2(40),
  idtype           CHAR(2),
  cust_id05        VARCHAR2(20),
  source_person_id VARCHAR2(20) not null,
  reg_date         DATE,
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         TIMESTAMP(6) not null,
  src_sys          VARCHAR2(20) not null,
  vehicle_ind      VARCHAR2(1),
  child_ind        VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.PERSON
  is '  个人客户';
comment on column UNICALL.PERSON.sno
  is 'IAA物理主键
';
comment on column UNICALL.PERSON.typeid
  is 'IAA数据类型
';
comment on column UNICALL.PERSON.person_id
  is 'IAA锚点，Roleplayer
';
comment on column UNICALL.PERSON.persontype
  is '人员主要角色（客户、营销员、联系人）
1015691Customer
1015692Channelrole';
comment on column UNICALL.PERSON.bthdate
  is '生日
';
comment on column UNICALL.PERSON.diedate
  is '死亡日期
';
comment on column UNICALL.PERSON.edulevel
  is '学历
';
comment on column UNICALL.PERSON.sex
  is '性别
';
comment on column UNICALL.PERSON.income
  is '年收入
';
comment on column UNICALL.PERSON.company
  is '服务单位名称
';
comment on column UNICALL.PERSON.marriage
  is '婚姻状态
';
comment on column UNICALL.PERSON.smoker
  is '是否吸烟
';
comment on column UNICALL.PERSON.blood
  is '血型
';
comment on column UNICALL.PERSON.ethnicity
  is '民族
';
comment on column UNICALL.PERSON.hdesp
  is '健康状况
0健康1死亡2有问题';
comment on column UNICALL.PERSON.customerid
  is '  客户号';
comment on column UNICALL.PERSON.name
  is '  姓名';
comment on column UNICALL.PERSON.job
  is '  全职职业代码';
comment on column UNICALL.PERSON.drvcard
  is '  驾照类型';
comment on column UNICALL.PERSON.country
  is '  国籍';
comment on column UNICALL.PERSON.residence
  is '  户籍所在地（县或市）';
comment on column UNICALL.PERSON.id
  is '  证件号码(18)';
comment on column UNICALL.PERSON.id15
  is '  15位身份证号码';
comment on column UNICALL.PERSON.idtype
  is '  证件类型';
comment on column UNICALL.PERSON.cust_id05
  is '  P05提供的团体客户号';
comment on column UNICALL.PERSON.source_person_id
  is '  源系统客户号';
comment on column UNICALL.PERSON.reg_date
  is '  该客户在业务系统的录入日期（实时横向迁移专用）';
comment on column UNICALL.PERSON.begtime
  is '  开始日期';
comment on column UNICALL.PERSON.endtime
  is '  中止日期';
comment on column UNICALL.PERSON.branch
  is '  分公司代码';
comment on column UNICALL.PERSON.etl_time
  is '  ETL处理时间';
comment on column UNICALL.PERSON.src_sys
  is '  来源系统';
comment on column UNICALL.PERSON.vehicle_ind
  is '是否拥有车辆';
comment on column UNICALL.PERSON.child_ind
  is '是否有子女';
create index UNICALL.PERSON_INDEX on UNICALL.PERSON (PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PERSON_QF
prompt ========================
prompt
create table UNICALL.PERSON_QF
(
  sno              NUMBER(20) not null,
  typeid           NUMBER(7) not null,
  person_id        NUMBER(20),
  persontype       NUMBER(20) not null,
  bthdate          DATE,
  diedate          DATE,
  edulevel         CHAR(2),
  sex              CHAR(1),
  income           NUMBER(20,6),
  company          VARCHAR2(90),
  marriage         CHAR(3),
  smoker           CHAR(1),
  blood            NUMBER(20),
  ethnicity        CHAR(2),
  hdesp            CHAR(1),
  customerid       VARCHAR2(40),
  name             VARCHAR2(120),
  job              CHAR(7),
  drvcard          VARCHAR2(2),
  country          CHAR(2),
  residence        VARCHAR2(90),
  id               VARCHAR2(40) not null,
  id15             VARCHAR2(40),
  idtype           CHAR(2) not null,
  cust_id05        VARCHAR2(20),
  source_person_id VARCHAR2(20) not null,
  reg_date         DATE,
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         TIMESTAMP(6) not null,
  src_sys          VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PERSON_TEMP
prompt ==========================
prompt
create table UNICALL.PERSON_TEMP
(
  sno              NUMBER(20) not null,
  typeid           NUMBER(7) not null,
  person_id        NUMBER(20),
  persontype       NUMBER(20) not null,
  bthdate          DATE,
  diedate          DATE,
  edulevel         CHAR(2),
  sex              CHAR(1),
  income           NUMBER(20,6),
  company          VARCHAR2(180),
  marriage         CHAR(3),
  smoker           CHAR(1),
  blood            NUMBER(20),
  ethnicity        CHAR(2),
  hdesp            CHAR(1),
  customerid       VARCHAR2(40),
  name             VARCHAR2(120),
  job              CHAR(7),
  drvcard          VARCHAR2(2),
  country          CHAR(2),
  residence        VARCHAR2(90),
  id               VARCHAR2(40) not null,
  id15             VARCHAR2(40),
  idtype           CHAR(2),
  cust_id05        VARCHAR2(20),
  source_person_id VARCHAR2(20) not null,
  reg_date         DATE,
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         DATE not null,
  src_sys          VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX1_PERSON_TEMP_BEGTIME on UNICALL.PERSON_TEMP (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ALL_ID_ID_SID on UNICALL.PERSON_TEMP (ID, ID15, SOURCE_PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ALL_PERSON_ID on UNICALL.PERSON_TEMP (ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ALL_PERSON_ID15 on UNICALL.PERSON_TEMP (ID15)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ALL_P_S_P_ID on UNICALL.PERSON_TEMP (SOURCE_PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PHONE
prompt ====================
prompt
create table UNICALL.PHONE
(
  sno                NUMBER(20),
  typeid             NUMBER(7) not null,
  areacode           VARCHAR2(20),
  countrycode        VARCHAR2(20),
  tel                VARCHAR2(20),
  ext                VARCHAR2(20),
  type               CHAR(1) not null,
  telnumber          VARCHAR2(100) not null,
  usage              CHAR(1) not null,
  person_id          NUMBER(20),
  pid                VARCHAR2(40) not null,
  idtype             CHAR(2),
  purpose            CHAR(1) not null,
  seq                VARCHAR2(10) not null,
  source_person_id   VARCHAR2(20) not null,
  id15               VARCHAR2(40),
  begtime            NUMBER(11) not null,
  endtime            NUMBER(11) not null,
  branch             CHAR(14) not null,
  etl_time           TIMESTAMP(6) not null,
  src_sys            VARCHAR2(20) not null,
  workday_cntct_time VARCHAR2(17),
  weekend_cntct_time VARCHAR2(17)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.PHONE
  is '  电话';
comment on column UNICALL.PHONE.sno
  is 'IAA物理主键
';
comment on column UNICALL.PHONE.typeid
  is 'IAA数据类型
';
comment on column UNICALL.PHONE.areacode
  is '电话区号
';
comment on column UNICALL.PHONE.countrycode
  is '国家
';
comment on column UNICALL.PHONE.tel
  is '电话号码（总机）
';
comment on column UNICALL.PHONE.ext
  is '电话号码（分机）
';
comment on column UNICALL.PHONE.type
  is '类型（电话、传真）
';
comment on column UNICALL.PHONE.telnumber
  is '联系电话
';
comment on column UNICALL.PHONE.usage
  is '类型（家庭、工作单位）
';
comment on column UNICALL.PHONE.person_id
  is '客户IAA业务相关主键
';
comment on column UNICALL.PHONE.pid
  is '身份证号/团体客户号
';
comment on column UNICALL.PHONE.idtype
  is '证件类型
';
comment on column UNICALL.PHONE.purpose
  is '属性（主要、非主要）
';
comment on column UNICALL.PHONE.seq
  is '序号
';
comment on column UNICALL.PHONE.source_person_id
  is '源系统客户号(人员系统供应empno,FF供应客户内部ID)
';
comment on column UNICALL.PHONE.id15
  is '15位身份证号码
';
comment on column UNICALL.PHONE.begtime
  is '开始日期
';
comment on column UNICALL.PHONE.endtime
  is '中止日期
';
comment on column UNICALL.PHONE.branch
  is '分公司代码
';
comment on column UNICALL.PHONE.etl_time
  is 'ETL处理时间
';
comment on column UNICALL.PHONE.src_sys
  is '来源系统
';
comment on column UNICALL.PHONE.workday_cntct_time
  is '工作日联络时间（示例：08:00:00-12:00:00，空表示不便联络）';
comment on column UNICALL.PHONE.weekend_cntct_time
  is '周末联络时间（示例：08:00:00-12:00:00，空表示不便联络）';
create index UNICALL.PHONE_INDEX on UNICALL.PHONE (PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PHONE_QF
prompt =======================
prompt
create table UNICALL.PHONE_QF
(
  sno              NUMBER(20),
  typeid           NUMBER(7) not null,
  areacode         VARCHAR2(20),
  countrycode      VARCHAR2(20),
  tel              VARCHAR2(20),
  ext              VARCHAR2(20),
  type             CHAR(1) not null,
  telnumber        VARCHAR2(100) not null,
  usage            CHAR(1) not null,
  person_id        NUMBER(20),
  pid              VARCHAR2(40) not null,
  idtype           CHAR(2) not null,
  purpose          CHAR(1) not null,
  seq              VARCHAR2(10) not null,
  source_person_id VARCHAR2(20) not null,
  id15             VARCHAR2(40),
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         TIMESTAMP(6) not null,
  src_sys          VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PHONE_TEMP
prompt =========================
prompt
create table UNICALL.PHONE_TEMP
(
  sno              NUMBER(20),
  typeid           NUMBER(7) not null,
  areacode         VARCHAR2(20),
  countrycode      VARCHAR2(20),
  tel              VARCHAR2(20),
  ext              VARCHAR2(20),
  type             CHAR(1) not null,
  telnumber        VARCHAR2(100) not null,
  usage            CHAR(1) not null,
  person_id        NUMBER(20),
  pid              VARCHAR2(40) not null,
  idtype           CHAR(2),
  purpose          CHAR(1) not null,
  seq              VARCHAR2(10) not null,
  source_person_id VARCHAR2(20) not null,
  id15             VARCHAR2(40),
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         DATE not null,
  src_sys          VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ALL_PHONE_ID15 on UNICALL.PHONE_TEMP (ID15)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ALL_PHONE_PID on UNICALL.PHONE_TEMP (PID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ALL_PHONE_SOURCE_P_ID on UNICALL.PHONE_TEMP (SOURCE_PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PHONE_TEMP_BEGTIME on UNICALL.PHONE_TEMP (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PHONE_TEMP_ZH on UNICALL.PHONE_TEMP (USAGE, SOURCE_PERSON_ID, SEQ)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PLAN_TABLE
prompt =========================
prompt
create table UNICALL.PLAN_TABLE
(
  statement_id    VARCHAR2(30),
  timestamp       DATE,
  remarks         VARCHAR2(80),
  operation       VARCHAR2(30),
  options         VARCHAR2(30),
  object_node     VARCHAR2(128),
  object_owner    VARCHAR2(30),
  object_name     VARCHAR2(30),
  object_instance INTEGER,
  object_type     VARCHAR2(30),
  optimizer       VARCHAR2(255),
  search_columns  NUMBER,
  id              INTEGER,
  parent_id       INTEGER,
  position        INTEGER,
  cost            INTEGER,
  cardinality     INTEGER,
  bytes           INTEGER,
  other_tag       VARCHAR2(255),
  partition_start VARCHAR2(255),
  partition_stop  VARCHAR2(255),
  partition_id    INTEGER,
  other           LONG,
  distribution    VARCHAR2(30),
  cpu_cost        INTEGER,
  io_cost         INTEGER,
  temp_space      INTEGER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PLC_PRM_TRANS_ACCT
prompt =================================
prompt
create table UNICALL.PLC_PRM_TRANS_ACCT
(
  plc_prm_trans_acct_id NUMBER(20),
  sno                   NUMBER(20) not null,
  policy_no             VARCHAR2(20) not null,
  account_usage         VARCHAR2(1) not null,
  account_no            VARCHAR2(120) not null,
  bank_code             VARCHAR2(20) not null,
  bank_name             VARCHAR2(80),
  owner_id              VARCHAR2(40) not null,
  currency              VARCHAR2(3) not null,
  open_date             DATE,
  oper_date             DATE,
  oper_no               VARCHAR2(20),
  begtime               NUMBER(11) not null,
  endtime               NUMBER(11) not null,
  branch                CHAR(14) not null,
  etl_time              DATE not null,
  src_sys               VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.PLC_PRM_TRANS_ACCT
  is '保单缴费帐号';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.plc_prm_trans_acct_id
  is '物理主键';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.sno
  is '记录行号';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.policy_no
  is '保单号（续期账号）/投保单号（首期账号）';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.account_usage
  is '账户用途';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.account_no
  is '银行账户号';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.bank_code
  is '银行账户开户行代码';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.bank_name
  is '银行账户开户行名称';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.owner_id
  is '账户所有人证件号（个人或团体客户）';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.currency
  is '币种代码';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.open_date
  is '开户日期';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.oper_date
  is '录入日期';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.oper_no
  is '操作员';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.begtime
  is '开始日期';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.endtime
  is '中止日期';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.branch
  is '分公司代码';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.etl_time
  is 'ETL处理时间';
comment on column UNICALL.PLC_PRM_TRANS_ACCT.src_sys
  is '来源系统';

prompt
prompt Creating table POLICY_SEND
prompt ==========================
prompt
create table UNICALL.POLICY_SEND
(
  sno          NUMBER(20),
  typeid       NUMBER(7),
  policyno     VARCHAR2(20),
  empno        VARCHAR2(20),
  senddate     DATE,
  canceldate   DATE,
  process_date DATE,
  sendoperno   VARCHAR2(20),
  canceloperno VARCHAR2(20),
  begtime      NUMBER(11),
  endtime      NUMBER(11),
  branch       CHAR(14),
  etl_time     TIMESTAMP(6),
  src_sys      VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.POLICY_SEND
  is '保单回执情况';
comment on column UNICALL.POLICY_SEND.sno
  is 'IAA物理主键';
comment on column UNICALL.POLICY_SEND.typeid
  is 'IAA数据类型';
comment on column UNICALL.POLICY_SEND.policyno
  is '保单号';
comment on column UNICALL.POLICY_SEND.empno
  is '业务员代码';
comment on column UNICALL.POLICY_SEND.senddate
  is '派发日期';
comment on column UNICALL.POLICY_SEND.canceldate
  is '客户签收日期';
comment on column UNICALL.POLICY_SEND.process_date
  is '回执录入系统日期';
comment on column UNICALL.POLICY_SEND.sendoperno
  is '派发人';
comment on column UNICALL.POLICY_SEND.canceloperno
  is '销号人';
comment on column UNICALL.POLICY_SEND.begtime
  is '开始日期';
comment on column UNICALL.POLICY_SEND.endtime
  is '中止日期';
comment on column UNICALL.POLICY_SEND.branch
  is '分公司代码';
comment on column UNICALL.POLICY_SEND.etl_time
  is 'ETL处理时间';
comment on column UNICALL.POLICY_SEND.src_sys
  is '来源系统';

prompt
prompt Creating table POLICY_TRACK_HISTORY
prompt ===================================
prompt
create table UNICALL.POLICY_TRACK_HISTORY
(
  id                  NUMBER(10) not null,
  policy_id           VARCHAR2(18) not null,
  policy_report_scope VARCHAR2(500),
  report_date         DATE,
  report_path         VARCHAR2(500),
  remark              VARCHAR2(500)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.POLICY_TRACK_HISTORY
  is '保单追踪历史表';
comment on column UNICALL.POLICY_TRACK_HISTORY.id
  is 'ID';
comment on column UNICALL.POLICY_TRACK_HISTORY.policy_id
  is '投保单ID';
comment on column UNICALL.POLICY_TRACK_HISTORY.policy_report_scope
  is '导出保单追踪范围';
comment on column UNICALL.POLICY_TRACK_HISTORY.report_date
  is '导出时间';
comment on column UNICALL.POLICY_TRACK_HISTORY.report_path
  is '导出路径';
comment on column UNICALL.POLICY_TRACK_HISTORY.remark
  is '备注';
alter table UNICALL.POLICY_TRACK_HISTORY
  add constraint PK_POLICY_TRACK_HISTORY primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PREREC
prompt =====================
prompt
create table UNICALL.PREREC
(
  sno                    NUMBER(20),
  typeid                 NUMBER(7) not null,
  con_id                 NUMBER(20),
  policyno               VARCHAR2(20) not null,
  classcode              CHAR(8) not null,
  check_id               NUMBER(20),
  checkno                VARCHAR2(40),
  amount                 NUMBER(20,4) not null,
  stdrate                NUMBER(20,6) not null,
  unstdrate              NUMBER(20,6) not null,
  currency               CHAR(3) not null,
  yearnum                NUMBER(20) not null,
  paycode                CHAR(2) not null,
  setcode                CHAR(1) not null,
  movewhy                VARCHAR2(120),
  pcode                  CHAR(1) not null,
  paydate                DATE not null,
  oper_id                NUMBER(20),
  operno                 VARCHAR2(20) not null,
  empno_id               NUMBER(20),
  empno                  VARCHAR2(20) not null,
  csr_id                 NUMBER(20),
  csrno                  VARCHAR2(20),
  deptno                 VARCHAR2(20) not null,
  years                  NUMBER(20) not null,
  cover1                 DATE not null,
  cover2                 DATE not null,
  seckey                 VARCHAR2(20),
  source_payin_actvty_id VARCHAR2(35) not null,
  inner_settle_ind       CHAR(1),
  begtime                NUMBER(11) not null,
  endtime                NUMBER(11) not null,
  branch                 CHAR(14) not null,
  etl_time               TIMESTAMP(6) not null,
  src_sys                VARCHAR2(20) not null,
  sale_mode              CHAR(4),
  the_thrdprt            CHAR(4),
  job                    CHAR(8),
  busi_branch            CHAR(14),
  fin_proc_type          NUMBER(7),
  insrnc_rate            NUMBER(7,4),
  third_order_no         VARCHAR2(20),
  pos_no                 VARCHAR2(20),
  paid_terminal_id       VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 9M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.PREREC
  is '	财务实收信息';
comment on column UNICALL.PREREC.sno
  is '	IAA物理主键';
comment on column UNICALL.PREREC.typeid
  is '	IAA数据类型（实收实付）';
comment on column UNICALL.PREREC.con_id
  is '	保单IAA业务相关主键';
comment on column UNICALL.PREREC.policyno
  is '	保单号';
comment on column UNICALL.PREREC.classcode
  is '	险种代码';
comment on column UNICALL.PREREC.check_id
  is '	支票IAA相关业务主键';
comment on column UNICALL.PREREC.checkno
  is '	支票号';
comment on column UNICALL.PREREC.amount
  is '	缴费/领款金额';
comment on column UNICALL.PREREC.stdrate
  is '	标准加费';
comment on column UNICALL.PREREC.unstdrate
  is '	非标准加费';
comment on column UNICALL.PREREC.currency
  is '	币种代码';
comment on column UNICALL.PREREC.yearnum
  is '	缴费年限';
comment on column UNICALL.PREREC.paycode
  is '	缴费频率';
comment on column UNICALL.PREREC.setcode
  is '	缴费/领款方式';
comment on column UNICALL.PREREC.movewhy
  is '	红冲原因';
comment on column UNICALL.PREREC.pcode
  is '	交易财务类型';
comment on column UNICALL.PREREC.paydate
  is '	交易生效日期';
comment on column UNICALL.PREREC.oper_id
  is '	操作员IAA相关业务主键';
comment on column UNICALL.PREREC.operno
  is '	操作员工号';
comment on column UNICALL.PREREC.empno_id
  is '	业务员IAA业务相关主键';
comment on column UNICALL.PREREC.empno
  is '	业务员代码';
comment on column UNICALL.PREREC.csr_id
  is '	收展员IAA业务相关主键';
comment on column UNICALL.PREREC.csrno
  is '	收展员代码';
comment on column UNICALL.PREREC.deptno
  is '	业务操作部门';
comment on column UNICALL.PREREC.years
  is '	期次';
comment on column UNICALL.PREREC.cover1
  is '	财务交易责任起始日期';
comment on column UNICALL.PREREC.cover2
  is '	财务交易责任终止日期';
comment on column UNICALL.PREREC.seckey
  is '	业务归属部门';
comment on column UNICALL.PREREC.source_payin_actvty_id
  is '	实收应收关联id';
comment on column UNICALL.PREREC.inner_settle_ind
  is '  内部结算标记';
comment on column UNICALL.PREREC.begtime
  is '  开始日期';
comment on column UNICALL.PREREC.endtime
  is '  中止日期';
comment on column UNICALL.PREREC.branch
  is '  分公司代码';
comment on column UNICALL.PREREC.etl_time
  is '  ETL处理时间';
comment on column UNICALL.PREREC.src_sys
  is '  来源系统';
comment on column UNICALL.PREREC.sale_mode
  is '结算模式';
comment on column UNICALL.PREREC.the_thrdprt
  is '第三方结算机构';
comment on column UNICALL.PREREC.job
  is '被保人全职代码';
comment on column UNICALL.PREREC.busi_branch
  is '保单对应机构（到4级机构）';
comment on column UNICALL.PREREC.fin_proc_type
  is '财务处理类型，主要针对款别变更的流水，财务不进行处理';
comment on column UNICALL.PREREC.insrnc_rate
  is '共保比例（指太保主承担时的共保承担比例，非共保和太保非主承担时取值100）（存放百分数，70%放70）';
comment on column UNICALL.PREREC.third_order_no
  is '第三方支付订单号';
comment on column UNICALL.PREREC.pos_no
  is '批单号（保全业务导致的收费放批单号）';
comment on column UNICALL.PREREC.paid_terminal_id
  is '支付设备号（神行太保POS刷卡设备号）';
create index UNICALL.PREREC_INDEX on UNICALL.PREREC (POLICYNO, SOURCE_PAYIN_ACTVTY_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table PRINT_ACTVTY
prompt ===========================
prompt
create table UNICALL.PRINT_ACTVTY
(
  print_actvty_id     NUMBER(20),
  sno                 NUMBER(20),
  print_job_name      VARCHAR2(100),
  print_type          CHAR(1),
  oper_type           CHAR(1),
  print_busi_no       VARCHAR2(60),
  status              CHAR(1),
  create_date         DATE,
  print_date          DATE,
  dispatch_date       DATE,
  receive_date        DATE,
  begtime             NUMBER(11),
  endtime             NUMBER(11),
  branch              CHAR(14),
  etl_time            TIMESTAMP(6),
  src_sys             VARCHAR2(20),
  oper_no             VARCHAR2(20),
  print_pieces        NUMBER(10),
  print_desc          VARCHAR2(1024),
  commit_date         DATE,
  print_center        VARCHAR2(20),
  busi_branch         VARCHAR2(20),
  dispatch_branch_lv4 VARCHAR2(14)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.PRINT_ACTVTY
  is '打印记录';
comment on column UNICALL.PRINT_ACTVTY.print_actvty_id
  is '物理主键';
comment on column UNICALL.PRINT_ACTVTY.sno
  is '记录行号';
comment on column UNICALL.PRINT_ACTVTY.print_job_name
  is '打印作业名称';
comment on column UNICALL.PRINT_ACTVTY.print_type
  is '打印类型';
comment on column UNICALL.PRINT_ACTVTY.oper_type
  is '打印操作类型';
comment on column UNICALL.PRINT_ACTVTY.print_busi_no
  is '打印业务单号（集中出单个险存放个人保单号，集中出单团险存放团体保单号）';
comment on column UNICALL.PRINT_ACTVTY.status
  is '状态';
comment on column UNICALL.PRINT_ACTVTY.create_date
  is '打印任务创建日期';
comment on column UNICALL.PRINT_ACTVTY.print_date
  is '打印日期';
comment on column UNICALL.PRINT_ACTVTY.dispatch_date
  is '分发日期';
comment on column UNICALL.PRINT_ACTVTY.receive_date
  is '邮包收发岗签收保单的日期';
comment on column UNICALL.PRINT_ACTVTY.begtime
  is '开始日期';
comment on column UNICALL.PRINT_ACTVTY.endtime
  is '中止日期';
comment on column UNICALL.PRINT_ACTVTY.branch
  is '分公司代码';
comment on column UNICALL.PRINT_ACTVTY.etl_time
  is 'ETL处理时间';
comment on column UNICALL.PRINT_ACTVTY.src_sys
  is '"来源系统';
comment on column UNICALL.PRINT_ACTVTY.oper_no
  is '操作员工号';
comment on column UNICALL.PRINT_ACTVTY.print_pieces
  is '打印份数';
comment on column UNICALL.PRINT_ACTVTY.print_desc
  is '打印报告描述';
comment on column UNICALL.PRINT_ACTVTY.commit_date
  is '打印提交日期（精确到秒）';
comment on column UNICALL.PRINT_ACTVTY.print_center
  is '制单中心代码';
comment on column UNICALL.PRINT_ACTVTY.busi_branch
  is '业务归属中支（存放集中出单的7位机构代码）';
comment on column UNICALL.PRINT_ACTVTY.dispatch_branch_lv4
  is '县区代码（14位机构代码）不为空，表示该作业采取区县直递，如果为空，表示不是区县直递';

prompt
prompt Creating table PROPOSAL_FORM_RESULT_HIS
prompt =======================================
prompt
create table UNICALL.PROPOSAL_FORM_RESULT_HIS
(
  id                     NUMBER(20) not null,
  insure_name            VARCHAR2(20),
  relation               VARCHAR2(100),
  insure_sex             VARCHAR2(1),
  insure_birthday        VARCHAR2(32),
  insure_pass_type       VARCHAR2(100),
  insure_pass_code       VARCHAR2(32),
  insure_post_code       VARCHAR2(32),
  insure_address         VARCHAR2(200),
  insure_employment      VARCHAR2(32),
  insure_mobile          VARCHAR2(20),
  insure_family_pho      VARCHAR2(20),
  insure_com_pho         VARCHAR2(20),
  d_insure_name          VARCHAR2(20),
  d_insure_sex           VARCHAR2(1),
  d_insure_birthday      VARCHAR2(32),
  d_insure_pass_type     VARCHAR2(100),
  d_insure_pass_code     VARCHAR2(32),
  d_insure_post_code     VARCHAR2(32),
  d_insure_address       VARCHAR2(200),
  d_insure_employment    VARCHAR2(32),
  d_insure_mobile        VARCHAR2(20),
  d_insure_family_pho    VARCHAR2(20),
  d_insure_com_pho       VARCHAR2(20),
  price                  VARCHAR2(30),
  counts                 NUMBER(6,1),
  ben_type               VARCHAR2(20),
  bank_name              VARCHAR2(200),
  bank_code              VARCHAR2(50),
  bank_account           VARCHAR2(50),
  audit_status           VARCHAR2(2),
  c_ob_com_cus_id        NUMBER(10) not null,
  user_id                NUMBER(10),
  createtime             VARCHAR2(20),
  sale_code              VARCHAR2(20),
  appno                  VARCHAR2(18),
  policyno               VARCHAR2(18),
  id_checkpoint_type     VARCHAR2(4),
  companyname            VARCHAR2(100),
  insure_email           VARCHAR2(50),
  d_insure_email         VARCHAR2(50),
  pay_type               VARCHAR2(1),
  app_latest_status      VARCHAR2(10),
  app_latest_time        VARCHAR2(20),
  app_accept_status      VARCHAR2(10),
  app_accept_time        VARCHAR2(20),
  app_quit_status        VARCHAR2(10),
  app_quit_time          VARCHAR2(20),
  total_pay_des          VARCHAR2(2000),
  cus_gro_id             NUMBER(10),
  check_user_id          NUMBER(10),
  insure_con_addr_type   VARCHAR2(1),
  d_insure_con_addr_type VARCHAR2(1),
  companycode            VARCHAR2(18),
  insurance_sum          VARCHAR2(100),
  audittime              VARCHAR2(20),
  d_insure_weight        VARCHAR2(32),
  d_insure_height        VARCHAR2(32),
  r_pay_type             VARCHAR2(1),
  auto_charge_date       VARCHAR2(30),
  auto_charge_flag       VARCHAR2(2),
  charge_amount          VARCHAR2(50),
  charge_ret             VARCHAR2(200),
  confirm_ret            VARCHAR2(200),
  uwr_ret                VARCHAR2(200),
  chatge_state_code      VARCHAR2(30),
  tradeseq               VARCHAR2(30),
  org_id                 NUMBER(10),
  backup_time            DATE default SYSDATE not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.PROPOSAL_FORM_RESULT_HIS
  is '备份核保不通过的保单';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.id
  is '主键ID';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insure_name
  is '投保人姓名';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.relation
  is '投保人与被保人关系';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insure_sex
  is '投保人性别';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insure_birthday
  is '投保人生日';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insure_pass_type
  is '投保人证件类型';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insure_pass_code
  is '投保人证件号码';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insure_post_code
  is '投保人邮政编码';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insure_address
  is '投保人地址';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insure_employment
  is '投保人职业';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insure_mobile
  is '投保人手机';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insure_family_pho
  is '投保人家庭电话';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insure_com_pho
  is '投保人办公电话';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_name
  is '被保人姓名';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_sex
  is '被保人性别';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_birthday
  is '被保人生日';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_pass_type
  is '被保人证件类型';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_pass_code
  is '被保人证件号码';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_post_code
  is '被保人邮政编码';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_address
  is '被保人地址';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_employment
  is '被保人职业';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_mobile
  is '被保人手机';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_family_pho
  is '被保人电话';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_com_pho
  is '被保人办公电话';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.price
  is '总金额';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.counts
  is '份数';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.ben_type
  is '收益人的收益方式';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.bank_name
  is '开户行名称';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.bank_code
  is '开户行代码';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.bank_account
  is '帐号';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.audit_status
  is '0:待审核 1:通过 2:不通过 3:撤销4:实时核保成功5:实时扣款成功6:保费确认成功';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.c_ob_com_cus_id
  is '我的名单ID';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.user_id
  is '投保单生成时当前座席ID';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.createtime
  is '创建时间';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.sale_code
  is '销售代码';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.appno
  is '投保单号';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.policyno
  is '保单号';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.id_checkpoint_type
  is '环节类型 1001'',''投保单建立''  ''1002'',''扣款成功''  ''1003'',''扣款成功'' ''1004'',''生效'' ''1005'',''退保''';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.companyname
  is '公司名称';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insure_email
  is '投保人邮箱';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_email
  is '被保人邮箱';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.pay_type
  is '首期支付方式:现金''1'',支票''2'',转账''3'',POS''7''';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.app_latest_status
  is '投保单最新状态';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.app_latest_time
  is '投保单最新状态更新时间';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.app_accept_status
  is '投保单承保状态';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.app_accept_time
  is '投保单承保时间';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.app_quit_status
  is '投保单退保状态';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.app_quit_time
  is '投保单退保时间';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.total_pay_des
  is '投保单总金额明细描述';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.cus_gro_id
  is '客户组ID';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.check_user_id
  is '审核人ID';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insure_con_addr_type
  is '投保人联系地址类型 1 家庭地址 2 服务单位 3 其他';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_con_addr_type
  is '被投保人联系地址类型 1 家庭地址 2 服务单位 3 其他';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.companycode
  is '中支公司编码';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.insurance_sum
  is '保额';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.audittime
  is '审核时间';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_weight
  is '被保人体重';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.d_insure_height
  is '被保人身高';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.r_pay_type
  is '续期支付方式:现金''1'',支票''2'',转账''3'',POS''7''';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.auto_charge_date
  is '实时扣款日期';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.auto_charge_flag
  is '实时扣款标志 01：是；02：否';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.charge_amount
  is '实时扣款金额';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.charge_ret
  is '实时扣款结果';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.confirm_ret
  is '保费确认结果';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.uwr_ret
  is '实时核保结果';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.chatge_state_code
  is '扣款状态码';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.tradeseq
  is '交易序列号 ';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.org_id
  is '实现数据权限过滤';
comment on column UNICALL.PROPOSAL_FORM_RESULT_HIS.backup_time
  is '备份时间';
alter table UNICALL.PROPOSAL_FORM_RESULT_HIS
  add constraint PROPOSAL_FORM_RESULT_HIS_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table P_DEAL_BIZ_DAY_LOG
prompt =================================
prompt
create table UNICALL.P_DEAL_BIZ_DAY_LOG
(
  statetime DATE,
  endtime   DATE,
  remark    VARCHAR2(100),
  ex        NVARCHAR2(4000),
  code      VARCHAR2(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table QUEST_SL_TEMP_EXPLAIN1
prompt =====================================
prompt
create global temporary table UNICALL.QUEST_SL_TEMP_EXPLAIN1
(
  statement_id      VARCHAR2(30),
  plan_id           NUMBER,
  timestamp         DATE,
  remarks           VARCHAR2(80),
  operation         VARCHAR2(30),
  options           VARCHAR2(255),
  object_node       VARCHAR2(128),
  object_owner      VARCHAR2(30),
  object_name       VARCHAR2(30),
  object_alias      VARCHAR2(65),
  object_instance   NUMBER,
  object_type       VARCHAR2(30),
  optimizer         VARCHAR2(255),
  search_columns    NUMBER,
  id                NUMBER,
  parent_id         NUMBER,
  depth             NUMBER,
  position          NUMBER,
  cost              NUMBER,
  cardinality       NUMBER,
  bytes             NUMBER,
  other_tag         VARCHAR2(255),
  partition_start   VARCHAR2(255),
  partition_stop    VARCHAR2(255),
  partition_id      NUMBER,
  other             LONG,
  distribution      VARCHAR2(30),
  cpu_cost          NUMBER(38),
  io_cost           NUMBER(38),
  temp_space        NUMBER(38),
  access_predicates VARCHAR2(4000),
  filter_predicates VARCHAR2(4000)
)
on commit preserve rows;

prompt
prompt Creating table REALPAYRC
prompt ========================
prompt
create table UNICALL.REALPAYRC
(
  sno                     NUMBER(20),
  typeid                  NUMBER(7) not null,
  con_id                  NUMBER(20),
  policyno                VARCHAR2(20) not null,
  classcode               CHAR(8) not null,
  check_id                NUMBER(20),
  checkno                 VARCHAR2(40),
  amount                  NUMBER(20,4) not null,
  currency                CHAR(3) not null,
  gendate                 DATE not null,
  delfrm                  CHAR(1) not null,
  setcode                 CHAR(1) not null,
  movewhy                 VARCHAR2(120),
  delcode                 CHAR(3) not null,
  typeno                  CHAR(2) not null,
  regdate                 DATE not null,
  agent_id                NUMBER(20),
  agentno                 VARCHAR2(20) not null,
  oper_id                 NUMBER(20),
  operno                  VARCHAR2(20) not null,
  deptno                  VARCHAR2(20) not null,
  docpro                  CHAR(1),
  docno                   VARCHAR2(20),
  person_id               NUMBER(20),
  pid                     VARCHAR2(40) not null,
  idtype                  CHAR(2) not null,
  paytime                 NUMBER(20) not null,
  seckey                  VARCHAR2(20),
  source_payout_actvty_id VARCHAR2(35) not null,
  begtime                 NUMBER(11) not null,
  endtime                 NUMBER(11) not null,
  branch                  CHAR(14) not null,
  etl_time                TIMESTAMP(6) not null,
  src_sys                 VARCHAR2(20) not null,
  sale_mode               CHAR(4),
  the_thrdprt             CHAR(4),
  empno                   VARCHAR2(20),
  csrno                   VARCHAR2(20),
  job                     CHAR(8),
  busi_branch             CHAR(14),
  fin_proc_type           NUMBER(7),
  insrnc_rate             NUMBER(7,4)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.REALPAYRC.sno
  is 'IAA物理主键';
comment on column UNICALL.REALPAYRC.typeid
  is 'IAA数据类型（实收实付）';
comment on column UNICALL.REALPAYRC.con_id
  is '保单IAA业务相关主键';
comment on column UNICALL.REALPAYRC.policyno
  is '保单号';
comment on column UNICALL.REALPAYRC.classcode
  is '险种代码';
comment on column UNICALL.REALPAYRC.check_id
  is '支票IAA相关业务主键';
comment on column UNICALL.REALPAYRC.checkno
  is '支票号';
comment on column UNICALL.REALPAYRC.amount
  is '缴费/领款金额';
comment on column UNICALL.REALPAYRC.currency
  is '币种代码';
comment on column UNICALL.REALPAYRC.gendate
  is '应付日期';
comment on column UNICALL.REALPAYRC.delfrm
  is '给付频率';
comment on column UNICALL.REALPAYRC.setcode
  is '领款方式';
comment on column UNICALL.REALPAYRC.movewhy
  is '红冲原因';
comment on column UNICALL.REALPAYRC.delcode
  is '交易财务类型';
comment on column UNICALL.REALPAYRC.typeno
  is '交易子类型（给付的基础定义在riskpay中；理赔的基础定义在clmprefunc中，其它责任都是00）';
comment on column UNICALL.REALPAYRC.regdate
  is '交易生效日期';
comment on column UNICALL.REALPAYRC.agent_id
  is '经办人IAA相关业务主键';
comment on column UNICALL.REALPAYRC.agentno
  is '经办人代码';
comment on column UNICALL.REALPAYRC.oper_id
  is '操作员IAA相关业务主键';
comment on column UNICALL.REALPAYRC.operno
  is '操作员工号';
comment on column UNICALL.REALPAYRC.deptno
  is '业务操作部门';
comment on column UNICALL.REALPAYRC.docpro
  is '单证类型2批改单号3赔案号4给付证号5报案号6通融给付';
comment on column UNICALL.REALPAYRC.docno
  is '单证号';
comment on column UNICALL.REALPAYRC.person_id
  is '缴费/领款人IAA业务相关主键';
comment on column UNICALL.REALPAYRC.pid
  is '领款人身份证号';
comment on column UNICALL.REALPAYRC.idtype
  is '领款人身份证件类型';
comment on column UNICALL.REALPAYRC.paytime
  is '期次';
comment on column UNICALL.REALPAYRC.seckey
  is '业务归属部门';
comment on column UNICALL.REALPAYRC.source_payout_actvty_id
  is '应付实付关联id';
comment on column UNICALL.REALPAYRC.begtime
  is '开始日期';
comment on column UNICALL.REALPAYRC.endtime
  is '中止日期';
comment on column UNICALL.REALPAYRC.branch
  is '分公司代码';
comment on column UNICALL.REALPAYRC.etl_time
  is 'ETL处理时间';
comment on column UNICALL.REALPAYRC.src_sys
  is '来源系统';
comment on column UNICALL.REALPAYRC.sale_mode
  is '结算模式';
comment on column UNICALL.REALPAYRC.the_thrdprt
  is '第三方结算机构';
comment on column UNICALL.REALPAYRC.empno
  is '业务员代码';
comment on column UNICALL.REALPAYRC.csrno
  is '收展员代码';
comment on column UNICALL.REALPAYRC.job
  is '被保人全职代码';
comment on column UNICALL.REALPAYRC.busi_branch
  is '保单对应机构（到4级机构）';
comment on column UNICALL.REALPAYRC.fin_proc_type
  is '财务处理类型，主要针对款别变更的流水，财务不进行处理';
comment on column UNICALL.REALPAYRC.insrnc_rate
  is '共保比例（指太保主承担时的共保承担比例，非共保和太保非主承担时取值100）（存放百分数，70%放70）';

prompt
prompt Creating table RISKCLASS
prompt ========================
prompt
create table UNICALL.RISKCLASS
(
  o_classcode VARCHAR2(8) not null,
  classcode   CHAR(8) not null,
  permdays    NUMBER(20) not null,
  riskattr    CHAR(1) not null,
  riskcode    CHAR(8) not null,
  classname   VARCHAR2(120) not null,
  timestr     CHAR(1) not null,
  grpattr     CHAR(1) not null,
  appflag     NUMBER(20),
  apptype     NUMBER(20),
  deldays     NUMBER(20),
  prttype     NUMBER(20),
  clmcode     CHAR(3),
  riskname    VARCHAR2(120),
  end_date    DATE,
  begtime     NUMBER(11) not null,
  endtime     NUMBER(11) not null,
  branch      CHAR(14) not null,
  etl_time    DATE not null,
  src_sys     VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.RISKCLASS.o_classcode
  is '6位险种代码
';
comment on column UNICALL.RISKCLASS.classcode
  is '8位险种代码
';
comment on column UNICALL.RISKCLASS.permdays
  is '宽限期天数
';
comment on column UNICALL.RISKCLASS.riskattr
  is '险种类型
';
comment on column UNICALL.RISKCLASS.riskcode
  is '险种代码
';
comment on column UNICALL.RISKCLASS.classname
  is '险种名称（老系统CBS 6位代码对应的classname）
';
comment on column UNICALL.RISKCLASS.timestr
  is '长短险标志
';
comment on column UNICALL.RISKCLASS.grpattr
  is '团个险标志
';
comment on column UNICALL.RISKCLASS.appflag
  is '续保类型
';
comment on column UNICALL.RISKCLASS.apptype
  is '续保类型
';
comment on column UNICALL.RISKCLASS.deldays
  is '宽限期延长天数
';
comment on column UNICALL.RISKCLASS.prttype
  is '保单续保打印标准
';
comment on column UNICALL.RISKCLASS.clmcode
  is '保额计算的责任
';
comment on column UNICALL.RISKCLASS.riskname
  is '险种款式名称（老系统CBS 6位代码对应的riskname）
';
comment on column UNICALL.RISKCLASS.end_date
  is '停售日期（目前只有综意险有这个字段）
';
comment on column UNICALL.RISKCLASS.begtime
  is '开始日期
';
comment on column UNICALL.RISKCLASS.endtime
  is '中止日期
';
comment on column UNICALL.RISKCLASS.branch
  is '分公司代码
';
comment on column UNICALL.RISKCLASS.etl_time
  is 'ETL处理时间
';
comment on column UNICALL.RISKCLASS.src_sys
  is '来源系统
';
create index UNICALL.RISKCLASS_INDEX on UNICALL.RISKCLASS (CLASSCODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RISKCLASS_BAK
prompt ============================
prompt
create table UNICALL.RISKCLASS_BAK
(
  o_classcode VARCHAR2(8) not null,
  classcode   CHAR(8) not null,
  permdays    NUMBER(20) not null,
  riskattr    CHAR(1) not null,
  riskcode    CHAR(8) not null,
  classname   VARCHAR2(120) not null,
  timestr     CHAR(1) not null,
  grpattr     CHAR(1) not null,
  appflag     NUMBER(20),
  apptype     NUMBER(20),
  deldays     NUMBER(20),
  prttype     NUMBER(20),
  clmcode     CHAR(3),
  riskname    VARCHAR2(120),
  end_date    DATE,
  begtime     NUMBER(11) not null,
  endtime     NUMBER(11) not null,
  branch      CHAR(14) not null,
  etl_time    DATE not null,
  src_sys     VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RISKCLASS_TEMP
prompt =============================
prompt
create table UNICALL.RISKCLASS_TEMP
(
  o_classcode VARCHAR2(8) not null,
  classcode   CHAR(8) not null,
  permdays    NUMBER(20) not null,
  riskattr    CHAR(1) not null,
  riskcode    CHAR(8) not null,
  classname   VARCHAR2(120) not null,
  timestr     CHAR(1) not null,
  grpattr     CHAR(1) not null,
  appflag     NUMBER(20),
  apptype     NUMBER(20),
  deldays     NUMBER(20),
  prttype     NUMBER(20),
  clmcode     CHAR(3),
  riskname    VARCHAR2(120),
  end_date    DATE,
  begtime     NUMBER(11) not null,
  endtime     NUMBER(11) not null,
  branch      CHAR(14) not null,
  etl_time    DATE not null,
  src_sys     VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.RISKCLASS_TEMP.o_classcode
  is '6位险种代码
';
comment on column UNICALL.RISKCLASS_TEMP.classcode
  is '8位险种代码
';
comment on column UNICALL.RISKCLASS_TEMP.permdays
  is '宽限期天数
';
comment on column UNICALL.RISKCLASS_TEMP.riskattr
  is '险种类型
';
comment on column UNICALL.RISKCLASS_TEMP.riskcode
  is '险种代码
';
comment on column UNICALL.RISKCLASS_TEMP.classname
  is '险种名称（老系统CBS 6位代码对应的classname）
';
comment on column UNICALL.RISKCLASS_TEMP.timestr
  is '长短险标志
';
comment on column UNICALL.RISKCLASS_TEMP.grpattr
  is '团个险标志
';
comment on column UNICALL.RISKCLASS_TEMP.appflag
  is '续保类型
';
comment on column UNICALL.RISKCLASS_TEMP.apptype
  is '续保类型
';
comment on column UNICALL.RISKCLASS_TEMP.deldays
  is '宽限期延长天数
';
comment on column UNICALL.RISKCLASS_TEMP.prttype
  is '保单续保打印标准
';
comment on column UNICALL.RISKCLASS_TEMP.clmcode
  is '保额计算的责任
';
comment on column UNICALL.RISKCLASS_TEMP.riskname
  is '险种款式名称（老系统CBS 6位代码对应的riskname）
';
comment on column UNICALL.RISKCLASS_TEMP.end_date
  is '停售日期（目前只有综意险有这个字段）
';
comment on column UNICALL.RISKCLASS_TEMP.begtime
  is '开始日期
';
comment on column UNICALL.RISKCLASS_TEMP.endtime
  is '中止日期
';
comment on column UNICALL.RISKCLASS_TEMP.branch
  is '分公司代码
';
comment on column UNICALL.RISKCLASS_TEMP.etl_time
  is 'ETL处理时间
';
comment on column UNICALL.RISKCLASS_TEMP.src_sys
  is '来源系统
';
create index UNICALL.IDX_RISKCLASS_TEMP_CLASSCODE on UNICALL.RISKCLASS_TEMP (CLASSCODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RISKCON
prompt ======================
prompt
create table UNICALL.RISKCON
(
  sno               NUMBER(20),
  typeid            NUMBER(7),
  aperson_id        NUMBER(20),
  apid              VARCHAR2(40),
  aidtype           CHAR(2),
  riskcon_id        NUMBER(20),
  gcon_id           NUMBER(20),
  gpolicyno         VARCHAR2(20),
  deskpay           CHAR(1),
  saleattr          CHAR(2),
  renewid           CHAR(1),
  renewdate         DATE,
  begdate           DATE,
  stopdate          DATE,
  polist            CHAR(1),
  reason            VARCHAR2(200),
  policyno          VARCHAR2(20),
  appno             VARCHAR2(20),
  currency          CHAR(3),
  pieces            NUMBER(20,6),
  appf              CHAR(1),
  opdate            DATE,
  tmount            NUMBER(16,2),
  oper_id           NUMBER(20),
  operno            VARCHAR2(20),
  empno_id          NUMBER(20),
  empno             VARCHAR2(20),
  csr_id            NUMBER(20),
  csrno             VARCHAR2(20),
  classcode         CHAR(8),
  appdate           DATE,
  comnum            NUMBER(20),
  person_id         NUMBER(20),
  idtype            CHAR(2),
  pid               VARCHAR2(40),
  job               CHAR(8),
  sharetype         CHAR(2),
  specagr           VARCHAR2(2048),
  discount          NUMBER(20,6),
  iscard            CHAR(1),
  npaylen           NUMBER(20,6),
  stdrate           NUMBER(10,2),
  unstdrate         NUMBER(10,2),
  dcdm              CHAR(2),
  prelname          CHAR(3),
  bankflag          CHAR(2),
  payseq            VARCHAR2(2048),
  benparam          NUMBER(20),
  sale_prod_code    VARCHAR2(8),
  owner_source_id   VARCHAR2(20),
  insured_source_id VARCHAR2(20),
  workno            VARCHAR2(20),
  comb_policy_no    VARCHAR2(20),
  app_age           NUMBER(3),
  begtime           NUMBER(11),
  endtime           NUMBER(11),
  branch            CHAR(14),
  etl_time          TIMESTAMP(6),
  src_sys           VARCHAR2(20),
  sub_agt_no        VARCHAR2(20),
  o_classcode       VARCHAR2(8),
  cross_sale_ind    VARCHAR2(1),
  prem_rate_level   VARCHAR2(2),
  ill_score         NUMBER(10,2),
  group_no          VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 12M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.RISKCON.sno
  is 'IAA物理主键';
comment on column UNICALL.RISKCON.typeid
  is 'IAA数据类型';
comment on column UNICALL.RISKCON.aperson_id
  is '投保人信息IAA业务相关主键';
comment on column UNICALL.RISKCON.apid
  is '投保人身份证件号/团体客户号';
comment on column UNICALL.RISKCON.aidtype
  is '投保人证件类型';
comment on column UNICALL.RISKCON.riskcon_id
  is 'IAA锚点，Agreement';
comment on column UNICALL.RISKCON.gcon_id
  is '所属团体保单IAA业务相关主键';
comment on column UNICALL.RISKCON.gpolicyno
  is '团单号';
comment on column UNICALL.RISKCON.deskpay
  is '垫缴条款选择（保单是否可以垫缴）';
comment on column UNICALL.RISKCON.saleattr
  is '销售渠道';
comment on column UNICALL.RISKCON.renewid
  is '续保标志';
comment on column UNICALL.RISKCON.renewdate
  is '续保日期';
comment on column UNICALL.RISKCON.begdate
  is '责任起始日期';
comment on column UNICALL.RISKCON.stopdate
  is '责任终止日期';
comment on column UNICALL.RISKCON.polist
  is '投保单/保单状态';
comment on column UNICALL.RISKCON.reason
  is '投保单/保单状态原因';
comment on column UNICALL.RISKCON.policyno
  is '保单号';
comment on column UNICALL.RISKCON.appno
  is '投保单号';
comment on column UNICALL.RISKCON.currency
  is '币种';
comment on column UNICALL.RISKCON.pieces
  is '份数';
comment on column UNICALL.RISKCON.appf
  is '主附加险标志';
comment on column UNICALL.RISKCON.opdate
  is '生效日期';
comment on column UNICALL.RISKCON.tmount
  is '总保费';
comment on column UNICALL.RISKCON.oper_id
  is '操作员IAA相关业务主键';
comment on column UNICALL.RISKCON.operno
  is '操作员工号';
comment on column UNICALL.RISKCON.empno_id
  is '业务员信息IAA业务相关主键';
comment on column UNICALL.RISKCON.empno
  is '业务员代码';
comment on column UNICALL.RISKCON.csr_id
  is '收展员信息IAA业务相关主键';
comment on column UNICALL.RISKCON.csrno
  is '收展员代码';
comment on column UNICALL.RISKCON.classcode
  is '险种';
comment on column UNICALL.RISKCON.appdate
  is '投保日期';
comment on column UNICALL.RISKCON.comnum
  is '共同被保险人人数';
comment on column UNICALL.RISKCON.person_id
  is '被保险人IAA业务相关主键';
comment on column UNICALL.RISKCON.idtype
  is '被保险人证件类型';
comment on column UNICALL.RISKCON.pid
  is '被保险人证件号';
comment on column UNICALL.RISKCON.job
  is '被保险人职业类型';
comment on column UNICALL.RISKCON.sharetype
  is '红利分配方式';
comment on column UNICALL.RISKCON.specagr
  is '特别约定';
comment on column UNICALL.RISKCON.discount
  is '豁免后缴费比率 0（全免）-1（全额）';
comment on column UNICALL.RISKCON.iscard
  is '卡式业务标志';
comment on column UNICALL.RISKCON.npaylen
  is '每份缴费标准';
comment on column UNICALL.RISKCON.stdrate
  is '每份标准加费额/职业加费金额';
comment on column UNICALL.RISKCON.unstdrate
  is '每份非标准加费额/综合加费金额';
comment on column UNICALL.RISKCON.dcdm
  is '保单档次';
comment on column UNICALL.RISKCON.prelname
  is '投被保人关系';
comment on column UNICALL.RISKCON.bankflag
  is '银保通标志';
comment on column UNICALL.RISKCON.payseq
  is '受益人';
comment on column UNICALL.RISKCON.benparam
  is '受益人条件数';
comment on column UNICALL.RISKCON.sale_prod_code
  is '销售产品代码（例如福宝宝产品代码）';
comment on column UNICALL.RISKCON.owner_source_id
  is 'FF中投保人内部ID，对应PERSON.SOURCE_PERSON_ID';
comment on column UNICALL.RISKCON.insured_source_id
  is 'FF中被保人内部ID，对应PERSON.SOURCE_PERSON_ID';
comment on column UNICALL.RISKCON.workno
  is '团体保单中个人的单位工号';
comment on column UNICALL.RISKCON.comb_policy_no
  is '多主险组合保单号';
comment on column UNICALL.RISKCON.app_age
  is '投保年龄';
comment on column UNICALL.RISKCON.begtime
  is '开始日期';
comment on column UNICALL.RISKCON.endtime
  is '中止日期';
comment on column UNICALL.RISKCON.branch
  is '分公司代码';
comment on column UNICALL.RISKCON.etl_time
  is 'ETL处理时间';
comment on column UNICALL.RISKCON.src_sys
  is '来源系统';
comment on column UNICALL.RISKCON.sub_agt_no
  is '二级业务员代码（目前存放电销坐席工号）';
comment on column UNICALL.RISKCON.o_classcode
  is 'IDS转换前的综意险系统6位险种代码';
comment on column UNICALL.RISKCON.cross_sale_ind
  is '是否交叉销售标示';
comment on column UNICALL.RISKCON.prem_rate_level
  is '吉祥人生费率等级';
comment on column UNICALL.RISKCON.ill_score
  is '团体重疾评点（综意险提供）';
comment on column UNICALL.RISKCON.group_no
  is '组别号';
create index UNICALL.IDX_RISKCON_POLICYNO on UNICALL.RISKCON (APPNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.RISKCON_INDEX on UNICALL.RISKCON (POLICYNO, APERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RISKCON_BAK
prompt ==========================
prompt
create table UNICALL.RISKCON_BAK
(
  sno               NUMBER(20),
  typeid            NUMBER(7),
  aperson_id        NUMBER(20),
  apid              VARCHAR2(40),
  aidtype           CHAR(2),
  riskcon_id        NUMBER(20),
  gcon_id           NUMBER(20),
  gpolicyno         VARCHAR2(20),
  deskpay           CHAR(1),
  saleattr          CHAR(2),
  renewid           CHAR(1),
  renewdate         DATE,
  begdate           DATE,
  stopdate          DATE,
  polist            CHAR(1),
  reason            VARCHAR2(200),
  policyno          VARCHAR2(20),
  appno             VARCHAR2(20),
  currency          CHAR(3),
  pieces            NUMBER(20,6),
  appf              CHAR(1),
  opdate            DATE,
  tmount            NUMBER(16,2),
  oper_id           NUMBER(20),
  operno            VARCHAR2(20),
  empno_id          NUMBER(20),
  empno             VARCHAR2(20),
  csr_id            NUMBER(20),
  csrno             VARCHAR2(20),
  classcode         CHAR(8),
  appdate           DATE,
  comnum            NUMBER(20),
  person_id         NUMBER(20),
  idtype            CHAR(2),
  pid               VARCHAR2(40),
  job               CHAR(8),
  sharetype         CHAR(2),
  specagr           VARCHAR2(2048),
  discount          NUMBER(20,6),
  iscard            CHAR(1),
  npaylen           NUMBER(20,6),
  stdrate           NUMBER(10,2),
  unstdrate         NUMBER(10,2),
  dcdm              CHAR(2),
  prelname          CHAR(3),
  bankflag          CHAR(2),
  payseq            VARCHAR2(2048),
  benparam          NUMBER(20),
  sale_prod_code    VARCHAR2(8),
  owner_source_id   VARCHAR2(20),
  insured_source_id VARCHAR2(20),
  workno            VARCHAR2(20),
  comb_policy_no    VARCHAR2(20),
  app_age           NUMBER(3),
  begtime           NUMBER(11),
  endtime           NUMBER(11),
  branch            CHAR(14),
  etl_time          TIMESTAMP(6),
  src_sys           VARCHAR2(20),
  sub_agt_no        VARCHAR2(20),
  o_classcode       VARCHAR2(8),
  cross_sale_ind    VARCHAR2(1),
  prem_rate_level   VARCHAR2(2),
  ill_score         NUMBER(10,2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RISKCON_TEMP
prompt ===========================
prompt
create table UNICALL.RISKCON_TEMP
(
  sno               NUMBER(20),
  typeid            NUMBER(7),
  aperson_id        NUMBER(20),
  apid              VARCHAR2(40),
  aidtype           CHAR(2),
  riskcon_id        NUMBER(20),
  gcon_id           NUMBER(20),
  gpolicyno         VARCHAR2(20),
  deskpay           CHAR(1),
  saleattr          CHAR(2),
  renewid           CHAR(1),
  renewdate         DATE,
  begdate           DATE,
  stopdate          DATE,
  polist            CHAR(1),
  reason            VARCHAR2(200),
  policyno          VARCHAR2(20),
  appno             VARCHAR2(20),
  currency          CHAR(3),
  pieces            NUMBER(20,6),
  appf              CHAR(1),
  opdate            DATE,
  tmount            NUMBER(16,2),
  oper_id           NUMBER(20),
  operno            VARCHAR2(20),
  empno_id          NUMBER(20),
  empno             VARCHAR2(20),
  csr_id            NUMBER(20),
  csrno             VARCHAR2(20),
  classcode         CHAR(8),
  appdate           DATE,
  comnum            NUMBER(20),
  person_id         NUMBER(20),
  idtype            CHAR(2),
  pid               VARCHAR2(40),
  job               CHAR(8),
  sharetype         CHAR(2),
  specagr           VARCHAR2(2048),
  discount          NUMBER(20,6),
  iscard            CHAR(1),
  npaylen           NUMBER(20,6),
  stdrate           NUMBER(10,2),
  unstdrate         NUMBER(10,2),
  dcdm              CHAR(2),
  prelname          CHAR(3),
  bankflag          CHAR(2),
  payseq            VARCHAR2(2048),
  benparam          NUMBER(20),
  sale_prod_code    VARCHAR2(8),
  owner_source_id   VARCHAR2(20),
  insured_source_id VARCHAR2(20),
  workno            VARCHAR2(20),
  comb_policy_no    VARCHAR2(20),
  app_age           NUMBER(3),
  begtime           NUMBER(11),
  endtime           NUMBER(11),
  branch            CHAR(14),
  etl_time          TIMESTAMP(6),
  src_sys           VARCHAR2(20),
  sub_agt_no        VARCHAR2(20),
  o_classcode       VARCHAR2(8),
  cross_sale_ind    VARCHAR2(1),
  prem_rate_level   VARCHAR2(2),
  ill_score         NUMBER(10,2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255;
create index UNICALL.RISKCON_TEMP_APERSON_ID_INDEX on UNICALL.RISKCON_TEMP (APERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255;
create index UNICALL.RISKCON_TEMP_INDEX on UNICALL.RISKCON_TEMP (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255;
create index UNICALL.RISKCON_TEMP_PERSON_ID_INDEX on UNICALL.RISKCON_TEMP (PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table RPT_ACCEPT_INS_DAY
prompt =================================
prompt
create table UNICALL.RPT_ACCEPT_INS_DAY
(
  useid         VARCHAR2(50),
  usename       VARCHAR2(50),
  event         VARCHAR2(50),
  payway        VARCHAR2(50),
  first_fare    VARCHAR2(50),
  year_fare     VARCHAR2(50),
  policyno      VARCHAR2(50),
  d_insure_name VARCHAR2(50),
  create_time   VARCHAR2(20),
  accept_time   VARCHAR2(20),
  product_id    VARCHAR2(50),
  product_name  VARCHAR2(50),
  campaign_id   VARCHAR2(50),
  campaign_name VARCHAR2(50),
  t_archive     VARCHAR2(20),
  appno         VARCHAR2(18)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.RPT_ACCEPT_INS_DAY.useid
  is '座席ID';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.usename
  is '座席姓名';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.event
  is '事件';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.payway
  is '缴费方式';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.first_fare
  is '首期保费';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.year_fare
  is '年保费';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.policyno
  is '保单号';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.d_insure_name
  is '被保人姓名';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.create_time
  is '受理日期';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.accept_time
  is '承保日期';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.product_id
  is '产品ID';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.product_name
  is '产品名称';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.campaign_id
  is '活动ID';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.campaign_name
  is '活动名称';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.t_archive
  is '存档日期';
comment on column UNICALL.RPT_ACCEPT_INS_DAY.appno
  is '投保单号';

prompt
prompt Creating table RPT_ACCEPT_INS_MONTH
prompt ===================================
prompt
create table UNICALL.RPT_ACCEPT_INS_MONTH
(
  id NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table RPT_DEAL_BIZ_DAY
prompt ===============================
prompt
create table UNICALL.RPT_DEAL_BIZ_DAY
(
  campaign_id     NUMBER(10),
  campaign_nam    VARCHAR2(1024),
  cus_list_nam    VARCHAR2(1024),
  n_list          NUMBER(10),
  n_dial          NUMBER(10),
  n_deal          NUMBER(10),
  n_deal_m        NUMBER(10),
  n_deal_y        NUMBER(10),
  pc_deal_list    VARCHAR2(20),
  sum_deal        NUMBER(12,2),
  sum_deal_m      NUMBER(12,2),
  sum_deal_y      NUMBER(12,2),
  n_accept        NUMBER(10),
  n_accept_m      NUMBER(10),
  n_accept_y      NUMBER(10),
  pc_accept_list  VARCHAR2(20),
  sum_accept      NUMBER(12,2),
  sum_accept_m    NUMBER(12,2),
  sum_accept_y    NUMBER(12,2),
  n_contact       NUMBER(10),
  pc_contact_list VARCHAR2(20),
  t_archive       VARCHAR2(20),
  use_id          NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 73M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.RPT_DEAL_BIZ_DAY.campaign_id
  is '活动id';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.campaign_nam
  is '活动名称';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.cus_list_nam
  is '名单列表名称';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.n_list
  is '名单总数';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.n_dial
  is '拨打总数';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.n_deal
  is '成交数';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.pc_deal_list
  is '成交比例';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.sum_deal
  is '成交总额';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.n_accept
  is '承保数 ';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.pc_accept_list
  is '承保比例';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.sum_accept
  is '承保总额';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.n_contact
  is '接触数';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.pc_contact_list
  is '接触率 ';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.t_archive
  is '存档时间';
comment on column UNICALL.RPT_DEAL_BIZ_DAY.use_id
  is '用户id';

prompt
prompt Creating table RPT_INVALID_LIST
prompt ===============================
prompt
create table UNICALL.RPT_INVALID_LIST
(
  n_list          NUMBER(10),
  n_dial          NUMBER(10),
  n_untouch       NUMBER(10),
  n_tel_error     NUMBER(10),
  campaign_nam    VARCHAR2(50),
  pc_untouch_dial VARCHAR2(20),
  pc_error_dial   VARCHAR2(20),
  t_archive       VARCHAR2(20),
  cus_list_nam    VARCHAR2(50),
  campaign_id     NUMBER(10),
  use_id          NUMBER(10),
  n_invalid       NUMBER(10),
  n_hang_up       NUMBER(10),
  pc_hang_up      VARCHAR2(20),
  n_unconnect     NUMBER(10),
  pc_unconnect    VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 8M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.RPT_INVALID_LIST.n_list
  is '名单总数';
comment on column UNICALL.RPT_INVALID_LIST.n_dial
  is '拨打总数';
comment on column UNICALL.RPT_INVALID_LIST.n_untouch
  is '未找到人';
comment on column UNICALL.RPT_INVALID_LIST.n_tel_error
  is '电话错误';
comment on column UNICALL.RPT_INVALID_LIST.campaign_nam
  is '活动名称';
comment on column UNICALL.RPT_INVALID_LIST.pc_untouch_dial
  is '未找到人/拨打总数';
comment on column UNICALL.RPT_INVALID_LIST.pc_error_dial
  is '电话错误/拨打总数';
comment on column UNICALL.RPT_INVALID_LIST.t_archive
  is '存档时间';
comment on column UNICALL.RPT_INVALID_LIST.cus_list_nam
  is '目标名称';
comment on column UNICALL.RPT_INVALID_LIST.campaign_id
  is '活动ID';
comment on column UNICALL.RPT_INVALID_LIST.use_id
  is '座席ID';
comment on column UNICALL.RPT_INVALID_LIST.n_invalid
  is '无效名单数';
comment on column UNICALL.RPT_INVALID_LIST.n_hang_up
  is '直接挂机';
comment on column UNICALL.RPT_INVALID_LIST.pc_hang_up
  is '直接挂机率';
comment on column UNICALL.RPT_INVALID_LIST.n_unconnect
  is '3次以上联系不到本人';
comment on column UNICALL.RPT_INVALID_LIST.pc_unconnect
  is '3次以上联系不到本人率';

prompt
prompt Creating table RPT_QUIT_INS_DAY
prompt ===============================
prompt
create table UNICALL.RPT_QUIT_INS_DAY
(
  id            NUMBER(10),
  useid         VARCHAR2(50),
  usename       VARCHAR2(50),
  event         VARCHAR2(50),
  payway        VARCHAR2(50),
  first_fare    VARCHAR2(50),
  year_fare     VARCHAR2(50),
  policyno      VARCHAR2(50),
  d_insure_name VARCHAR2(50),
  quit_time     VARCHAR2(20),
  effect_time   VARCHAR2(20),
  product_id    VARCHAR2(50),
  product_name  VARCHAR2(50),
  campaign_id   VARCHAR2(50),
  campaign_name VARCHAR2(50),
  t_archive     VARCHAR2(20),
  appno         VARCHAR2(18)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.RPT_QUIT_INS_DAY.useid
  is '座席ID';
comment on column UNICALL.RPT_QUIT_INS_DAY.usename
  is '座席姓名';
comment on column UNICALL.RPT_QUIT_INS_DAY.event
  is '事件';
comment on column UNICALL.RPT_QUIT_INS_DAY.payway
  is '缴费方式';
comment on column UNICALL.RPT_QUIT_INS_DAY.first_fare
  is '已交期数';
comment on column UNICALL.RPT_QUIT_INS_DAY.year_fare
  is '年化保费';
comment on column UNICALL.RPT_QUIT_INS_DAY.policyno
  is '保单号';
comment on column UNICALL.RPT_QUIT_INS_DAY.d_insure_name
  is '被保人姓名';
comment on column UNICALL.RPT_QUIT_INS_DAY.quit_time
  is '退保日期';
comment on column UNICALL.RPT_QUIT_INS_DAY.effect_time
  is '合同生效日';
comment on column UNICALL.RPT_QUIT_INS_DAY.product_id
  is '产品ID';
comment on column UNICALL.RPT_QUIT_INS_DAY.product_name
  is '产品名称';
comment on column UNICALL.RPT_QUIT_INS_DAY.campaign_id
  is '活动ID';
comment on column UNICALL.RPT_QUIT_INS_DAY.campaign_name
  is '活动名称';
comment on column UNICALL.RPT_QUIT_INS_DAY.appno
  is '投保单号';

prompt
prompt Creating table RPT_REFUSE_LIST
prompt ==============================
prompt
create table UNICALL.RPT_REFUSE_LIST
(
  campaign_nam        VARCHAR2(50),
  cus_list_nam        VARCHAR2(50),
  n_list              NUMBER(10),
  n_dial              NUMBER(10),
  n_market_reason     NUMBER(10),
  pc_market_dial      VARCHAR2(20),
  n_individual_reason NUMBER(10),
  pc_individual_dial  VARCHAR2(20),
  t_archive           VARCHAR2(20),
  n_other             NUMBER(10),
  pc_other_dial       VARCHAR2(20),
  campaign_id         NUMBER(10),
  use_id              NUMBER(10),
  n_refuse            NUMBER(10),
  n_unqual            NUMBER(10),
  pc_unqual           VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 10M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.RPT_REFUSE_LIST.campaign_nam
  is '--活动名称';
comment on column UNICALL.RPT_REFUSE_LIST.cus_list_nam
  is '--名单列表名称';
comment on column UNICALL.RPT_REFUSE_LIST.n_list
  is '名单总数';
comment on column UNICALL.RPT_REFUSE_LIST.n_dial
  is '拨打总数';
comment on column UNICALL.RPT_REFUSE_LIST.n_market_reason
  is '市场原因个数';
comment on column UNICALL.RPT_REFUSE_LIST.pc_market_dial
  is '市场原因个数/拨打总数';
comment on column UNICALL.RPT_REFUSE_LIST.n_individual_reason
  is '个人原因个数';
comment on column UNICALL.RPT_REFUSE_LIST.pc_individual_dial
  is '个人原因个数/拨打总数';
comment on column UNICALL.RPT_REFUSE_LIST.t_archive
  is '存档时间';
comment on column UNICALL.RPT_REFUSE_LIST.campaign_id
  is '活动id';
comment on column UNICALL.RPT_REFUSE_LIST.use_id
  is '座席ID';
comment on column UNICALL.RPT_REFUSE_LIST.n_refuse
  is '拒绝名单数';
comment on column UNICALL.RPT_REFUSE_LIST.n_unqual
  is '不符合条件';
comment on column UNICALL.RPT_REFUSE_LIST.pc_unqual
  is '不符合条件率';

prompt
prompt Creating table RPT_SATISFY_TOTAL
prompt ================================
prompt
create table UNICALL.RPT_SATISFY_TOTAL
(
  agent_name     VARCHAR2(20),
  agent_no       VARCHAR2(10),
  timekey        VARCHAR2(8),
  noutbound      NUMBER(5),
  satisfycount   NUMBER(5),
  use_id         NUMBER(10),
  satisfycount_1 NUMBER(5),
  satisfycount_2 NUMBER(5),
  satisfycount_3 NUMBER(5),
  use_ali_id     VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.RPT_SATISFY_TOTAL.satisfycount
  is '总评价次数';
comment on column UNICALL.RPT_SATISFY_TOTAL.satisfycount_1
  is '非常满意';
comment on column UNICALL.RPT_SATISFY_TOTAL.satisfycount_2
  is '满意';
comment on column UNICALL.RPT_SATISFY_TOTAL.satisfycount_3
  is '不满意';
comment on column UNICALL.RPT_SATISFY_TOTAL.use_ali_id
  is '座席别名';
create index UNICALL.RPT_SATISFY_INDEX1 on UNICALL.RPT_SATISFY_TOTAL (AGENT_NO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.RPT_SATISFY_INDEX3 on UNICALL.RPT_SATISFY_TOTAL (TIMEKEY)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RPT_TIME_CARD_RECORD
prompt ===================================
prompt
create table UNICALL.RPT_TIME_CARD_RECORD
(
  userid         VARCHAR2(50),
  username       VARCHAR2(50),
  minonlinetime  VARCHAR2(50),
  maxofflinetime VARCHAR2(50),
  relaxtime      VARCHAR2(50),
  recorddate     VARCHAR2(50),
  ext1           VARCHAR2(50),
  ext2           VARCHAR2(50),
  ext3           VARCHAR2(50),
  ext4           VARCHAR2(50),
  ext5           VARCHAR2(50)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 896K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table RPT_USE_LIST_DAY
prompt ===============================
prompt
create table UNICALL.RPT_USE_LIST_DAY
(
  use_id     NUMBER,
  un_con_cnt NUMBER,
  t_archive  DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 8M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.RPT_USE_LIST_DAY
  is '每天下班后统计所有座席当天剩余未拨打的名单数';
comment on column UNICALL.RPT_USE_LIST_DAY.un_con_cnt
  is '未拨打的名单数';

prompt
prompt Creating table SHCPIC_APP_PAUSE_RESUME
prompt ======================================
prompt
create table UNICALL.SHCPIC_APP_PAUSE_RESUME
(
  id            NUMBER(10) not null,
  app_no        VARCHAR2(18),
  shield_reason INTEGER,
  status        INTEGER,
  pause_use_id  NUMBER(10),
  pause_time    TIMESTAMP(6),
  resume_use_id NUMBER(10),
  resume_time   TIMESTAMP(6),
  audit_use_id  NUMBER(10),
  audit_time    TIMESTAMP(6),
  appid         VARCHAR2(18)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 384K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.SHCPIC_APP_PAUSE_RESUME
  is '保单扣款暂停与恢复';
comment on column UNICALL.SHCPIC_APP_PAUSE_RESUME.shield_reason
  is '0:撤单, 1:退保';
comment on column UNICALL.SHCPIC_APP_PAUSE_RESUME.status
  is '0:暂停,1:恢复待审核,2:已恢复';
alter table UNICALL.SHCPIC_APP_PAUSE_RESUME
  add constraint PK_SHCPIC_APP_PAUSE_RESUME primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_AUDI_STATUS
prompt =================================
prompt
create table UNICALL.SHCPIC_AUDI_STATUS
(
  id   NUMBER(10) not null,
  name VARCHAR2(50),
  des  VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_AUDI_STATUS.name
  is '投保单状态名称';
alter table UNICALL.SHCPIC_AUDI_STATUS
  add constraint PK_AUDI_STATUS primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_BANK
prompt ==========================
prompt
create table UNICALL.SHCPIC_BANK
(
  id         NUMBER(10) not null,
  bank_code  VARCHAR2(50),
  bank_name  VARCHAR2(200),
  company_id NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_BANK
  add constraint PK_BANK primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_BANK
  add constraint FK_COMPANYID foreign key (COMPANY_ID)
  references UNICALL.SHCPIC_COMPANY (ID);

prompt
prompt Creating table SHCPIC_BANK_INFO
prompt ===============================
prompt
create table UNICALL.SHCPIC_BANK_INFO
(
  id           NUMBER(10) not null,
  bank_code    VARCHAR2(100),
  bank_name    VARCHAR2(200),
  child_com_id VARCHAR2(100),
  com_id       VARCHAR2(100),
  sub_com_id   VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_BANK_INFO.id
  is '物理主键';
comment on column UNICALL.SHCPIC_BANK_INFO.bank_code
  is '银行代码';
comment on column UNICALL.SHCPIC_BANK_INFO.bank_name
  is '银行名称';
comment on column UNICALL.SHCPIC_BANK_INFO.child_com_id
  is '分公司代码';
comment on column UNICALL.SHCPIC_BANK_INFO.com_id
  is '所属机构';
comment on column UNICALL.SHCPIC_BANK_INFO.sub_com_id
  is '中支机构代码';
alter table UNICALL.SHCPIC_BANK_INFO
  add constraint PK_BANK_INFO primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_BANK_TRANSFER_RULE
prompt ========================================
prompt
create table UNICALL.SHCPIC_BANK_TRANSFER_RULE
(
  id               NUMBER(10) not null,
  account_type     VARCHAR2(50),
  start_characters VARCHAR2(50),
  num              NUMBER(5),
  bank_id          NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_BANK_TRANSFER_RULE
  add constraint PK_BANK_TRANSFER_RULE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_BENEFICLARY
prompt =================================
prompt
create table UNICALL.SHCPIC_BENEFICLARY
(
  id               NUMBER(10) not null,
  proposal_form_id NUMBER(10) not null,
  benefit_name     VARCHAR2(200),
  benefit_sex      VARCHAR2(1),
  benefit_relation VARCHAR2(100),
  benefit_sort     VARCHAR2(40),
  benefit_code_num VARCHAR2(32),
  benefit_percent  VARCHAR2(8)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 320K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_BENEFICLARY
  add constraint BENEFICLARY_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_BENE_TYPE
prompt ===============================
prompt
create table UNICALL.SHCPIC_BENE_TYPE
(
  id   NUMBER(20) not null,
  name VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_CI_UCID
prompt =============================
prompt
create table UNICALL.SHCPIC_CI_UCID
(
  cha_ins_id NUMBER(10) not null,
  ucid       VARCHAR2(25) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on table UNICALL.SHCPIC_CI_UCID
  is 'Channel Instance, UCID relation';
comment on column UNICALL.SHCPIC_CI_UCID.cha_ins_id
  is 'channel instance id with foreign reference';
comment on column UNICALL.SHCPIC_CI_UCID.ucid
  is 'UCID generated by CMS';
alter table UNICALL.SHCPIC_CI_UCID
  add primary key (CHA_INS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.SHCPIC_CI_UCID
  add constraint FK_CIUCID_TAS foreign key (CHA_INS_ID)
  references UNICALL.C_CHA_INS (CHA_INS_ID);

prompt
prompt Creating table SHCPIC_COMMISION
prompt ===============================
prompt
create table UNICALL.SHCPIC_COMMISION
(
  id                NUMBER(10) not null,
  latest_status     VARCHAR2(2),
  is_allow_add      VARCHAR2(2),
  is_allow_subtract VARCHAR2(2),
  calculate_status  VARCHAR2(2),
  add_time          VARCHAR2(20),
  subtract_time     VARCHAR2(20),
  proposal_id       NUMBER(10),
  update_time       VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on column UNICALL.SHCPIC_COMMISION.latest_status
  is '保单最新状态';
comment on column UNICALL.SHCPIC_COMMISION.is_allow_add
  is '是否可以加佣金';
comment on column UNICALL.SHCPIC_COMMISION.is_allow_subtract
  is '是否可以减佣金';
comment on column UNICALL.SHCPIC_COMMISION.calculate_status
  is '佣金计算状态';
comment on column UNICALL.SHCPIC_COMMISION.add_time
  is '加佣金更新时间';
comment on column UNICALL.SHCPIC_COMMISION.subtract_time
  is '减佣金更新时间';
comment on column UNICALL.SHCPIC_COMMISION.proposal_id
  is '投保单ID';
comment on column UNICALL.SHCPIC_COMMISION.update_time
  is '更新时间';
alter table UNICALL.SHCPIC_COMMISION
  add constraint PK_COMMISION primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table SHCPIC_CREDIT_CARD
prompt =================================
prompt
create table UNICALL.SHCPIC_CREDIT_CARD
(
  cc_id              NUMBER(10) not null,
  appno              VARCHAR2(18),
  credit_card_id     VARCHAR2(32),
  credit_expire_date VARCHAR2(4),
  credit_card_cvv2   VARCHAR2(4),
  create_date        VARCHAR2(32)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.SHCPIC_CREDIT_CARD
  add constraint PK_SHCPIC_CREDIT_CARD primary key (CC_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table SHCPIC_ELEMENT
prompt =============================
prompt
create table UNICALL.SHCPIC_ELEMENT
(
  id     NUMBER(20) not null,
  name   VARCHAR2(50),
  code   VARCHAR2(50),
  type   VARCHAR2(10),
  sort   NUMBER(10),
  remark VARCHAR2(100),
  is_del VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_ELEMENT.type
  is '元素类型：0，文本；1，列表';
comment on column UNICALL.SHCPIC_ELEMENT.is_del
  is '是否删除：0，否；1，是';
alter table UNICALL.SHCPIC_ELEMENT
  add constraint PRI_KEY primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_INSURANCE
prompt ===============================
prompt
create table UNICALL.SHCPIC_INSURANCE
(
  id        NUMBER(20) not null,
  name      VARCHAR2(100),
  type      VARCHAR2(2),
  remark    VARCHAR2(200),
  is_del    VARCHAR2(2),
  ins_sum   VARCHAR2(20),
  term_type VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_INSURANCE.type
  is '险种类型：0，主险；1，辅险';
comment on column UNICALL.SHCPIC_INSURANCE.is_del
  is '是否删除：0，否；1，是';
comment on column UNICALL.SHCPIC_INSURANCE.ins_sum
  is '保额';
comment on column UNICALL.SHCPIC_INSURANCE.term_type
  is '保险期间类型: 0，定期年；1，定期岁；2，终身';
alter table UNICALL.SHCPIC_INSURANCE
  add constraint PK_SHCPIC_INSURANCE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
grant select on UNICALL.SHCPIC_INSURANCE to SXDXETL;

prompt
prompt Creating table SHCPIC_ELEMENT_INSURANCE
prompt =======================================
prompt
create table UNICALL.SHCPIC_ELEMENT_INSURANCE
(
  id            NUMBER(20) not null,
  element_id    NUMBER(20) not null,
  insurance_id  NUMBER(20) not null,
  default_value VARCHAR2(500),
  is_hidden     VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_ELEMENT_INSURANCE
  add constraint PK_ELEMENT_INSURANCE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_ELEMENT_INSURANCE
  add constraint FK_ELEMENT_ID_2 foreign key (ELEMENT_ID)
  references UNICALL.SHCPIC_ELEMENT (ID);
alter table UNICALL.SHCPIC_ELEMENT_INSURANCE
  add constraint FK_INSURANCE_ID_1 foreign key (INSURANCE_ID)
  references UNICALL.SHCPIC_INSURANCE (ID);

prompt
prompt Creating table SHCPIC_ELEMENT_VALUE
prompt ===================================
prompt
create table UNICALL.SHCPIC_ELEMENT_VALUE
(
  id     NUMBER(20) not null,
  name   VARCHAR2(20),
  value  VARCHAR2(20),
  remark VARCHAR2(100),
  is_del VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_ELEMENT_VALUE.is_del
  is '是否删除：0，否；1，是';
alter table UNICALL.SHCPIC_ELEMENT_VALUE
  add constraint PK_ELEMENT_VALUE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_ELEMENT_VALUE_INSURANCE
prompt =============================================
prompt
create table UNICALL.SHCPIC_ELEMENT_VALUE_INSURANCE
(
  id               NUMBER(20) not null,
  element_id       NUMBER(20) not null,
  element_value_id NUMBER(20) not null,
  insurance_id     NUMBER(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_ELEMENT_VALUE_INSURANCE
  add constraint PK_ELEMENT_VALUE_INSURANCE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_ELEMENT_VALUE_INSURANCE
  add constraint FK_ELEMENT_ID_3 foreign key (ELEMENT_ID)
  references UNICALL.SHCPIC_ELEMENT (ID);
alter table UNICALL.SHCPIC_ELEMENT_VALUE_INSURANCE
  add constraint FK_ELEMENT_VALUE_ID_2 foreign key (ELEMENT_VALUE_ID)
  references UNICALL.SHCPIC_ELEMENT_VALUE (ID);
alter table UNICALL.SHCPIC_ELEMENT_VALUE_INSURANCE
  add constraint FK_INSURANCE_ID_2 foreign key (INSURANCE_ID)
  references UNICALL.SHCPIC_INSURANCE (ID);

prompt
prompt Creating table SHCPIC_ELE_ELEMENT_VALUE
prompt =======================================
prompt
create table UNICALL.SHCPIC_ELE_ELEMENT_VALUE
(
  id               NUMBER(20) not null,
  element_value_id NUMBER(20) not null,
  element_id       NUMBER(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_ELE_ELEMENT_VALUE
  add constraint PK_ELE_ELEMENT_VALUE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_ELE_ELEMENT_VALUE
  add constraint FK_ELEMENT_ID_1 foreign key (ELEMENT_ID)
  references UNICALL.SHCPIC_ELEMENT (ID);
alter table UNICALL.SHCPIC_ELE_ELEMENT_VALUE
  add constraint FK_ELEMENT_VALUE_ID_1 foreign key (ELEMENT_VALUE_ID)
  references UNICALL.SHCPIC_ELEMENT_VALUE (ID);

prompt
prompt Creating table SHCPIC_INSURANCE_INS
prompt ===================================
prompt
create table UNICALL.SHCPIC_INSURANCE_INS
(
  id                      NUMBER(10) not null,
  main_flag               VARCHAR2(20),
  insurance_code          VARCHAR2(20),
  insurance_sum           VARCHAR2(20),
  insurance_count         VARCHAR2(20),
  insurance_criterion     VARCHAR2(20),
  occupation_ap           VARCHAR2(20),
  pay_way                 VARCHAR2(20),
  pay_year_limit          VARCHAR2(20),
  year_len                VARCHAR2(20),
  year_len_type           VARCHAR2(20),
  draw_way                VARCHAR2(20),
  draw_age                VARCHAR2(20),
  policy_no               VARCHAR2(20),
  proposal_form_result_id NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on column UNICALL.SHCPIC_INSURANCE_INS.main_flag
  is '主附险标志';
comment on column UNICALL.SHCPIC_INSURANCE_INS.insurance_code
  is '险种代码(或定额保单代码)';
comment on column UNICALL.SHCPIC_INSURANCE_INS.insurance_sum
  is '保额';
comment on column UNICALL.SHCPIC_INSURANCE_INS.insurance_count
  is '份数(或档次)';
comment on column UNICALL.SHCPIC_INSURANCE_INS.insurance_criterion
  is '缴费标准';
comment on column UNICALL.SHCPIC_INSURANCE_INS.occupation_ap
  is '职业加费';
comment on column UNICALL.SHCPIC_INSURANCE_INS.pay_way
  is '缴费方式';
comment on column UNICALL.SHCPIC_INSURANCE_INS.pay_year_limit
  is '缴费年限';
comment on column UNICALL.SHCPIC_INSURANCE_INS.year_len
  is '保险期间(年)';
comment on column UNICALL.SHCPIC_INSURANCE_INS.year_len_type
  is '保险期间类型';
comment on column UNICALL.SHCPIC_INSURANCE_INS.draw_way
  is '领取方式';
comment on column UNICALL.SHCPIC_INSURANCE_INS.draw_age
  is '领取年龄';
comment on column UNICALL.SHCPIC_INSURANCE_INS.policy_no
  is '定额保单序号(默认00)';
comment on column UNICALL.SHCPIC_INSURANCE_INS.proposal_form_result_id
  is '投保单ID';
alter table UNICALL.SHCPIC_INSURANCE_INS
  add constraint PK_INSURANCE_INS primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table SHCPIC_PRODUCT
prompt =============================
prompt
create table UNICALL.SHCPIC_PRODUCT
(
  id                    NUMBER(20) not null,
  name                  VARCHAR2(50),
  introduction          VARCHAR2(4000),
  remark                VARCHAR2(2000),
  is_del                VARCHAR2(2),
  minage                VARCHAR2(5),
  maxage                VARCHAR2(5),
  feemax                VARCHAR2(2000),
  bene_type             NUMBER(20),
  first_pay_month_total NUMBER(20) default 1 not null,
  isff                  VARCHAR2(2),
  product_type          VARCHAR2(5)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_PRODUCT.is_del
  is '是否删除：0，否；1，是';
comment on column UNICALL.SHCPIC_PRODUCT.first_pay_month_total
  is '当产品按月缴时第一期要缴的月数，如吉利宝按月缴时第一期要交两个月';
comment on column UNICALL.SHCPIC_PRODUCT.isff
  is '配送保单时辅助判断是否长险：1 是，0 否';
comment on column UNICALL.SHCPIC_PRODUCT.product_type
  is '款别';
alter table UNICALL.SHCPIC_PRODUCT
  add constraint PK_PRODUCT primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
grant select on UNICALL.SHCPIC_PRODUCT to SXDXETL;

prompt
prompt Creating table SHCPIC_INSURANCE_PRODUCT
prompt =======================================
prompt
create table UNICALL.SHCPIC_INSURANCE_PRODUCT
(
  id           NUMBER(20) not null,
  insurance_id NUMBER(20) not null,
  product_id   NUMBER(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_INSURANCE_PRODUCT
  add constraint PK_INSURANCE_PRODUCT primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_INSURANCE_PRODUCT
  add constraint FK_INSURANCE_ID_3 foreign key (INSURANCE_ID)
  references UNICALL.SHCPIC_INSURANCE (ID);
alter table UNICALL.SHCPIC_INSURANCE_PRODUCT
  add constraint FK_PRODUCT_ID_1 foreign key (PRODUCT_ID)
  references UNICALL.SHCPIC_PRODUCT (ID);
grant select on UNICALL.SHCPIC_INSURANCE_PRODUCT to SXDXETL;

prompt
prompt Creating table SHCPIC_INSURANCE_RELATION
prompt ========================================
prompt
create table UNICALL.SHCPIC_INSURANCE_RELATION
(
  id            NUMBER(10) not null,
  relation_code VARCHAR2(20),
  relation_name VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_INSURANCE_TERM_CODE
prompt =========================================
prompt
create table UNICALL.SHCPIC_INSURANCE_TERM_CODE
(
  insurance_id   NUMBER(10),
  term           VARCHAR2(10),
  insurance_code VARCHAR2(50)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_LIMIT_METIER_PRODUCT
prompt ==========================================
prompt
create table UNICALL.SHCPIC_LIMIT_METIER_PRODUCT
(
  id         NUMBER(20) not null,
  metier_id  NUMBER(20) not null,
  product_id NUMBER(20) not null,
  flag       VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_LIMIT_METIER_PRODUCT.metier_id
  is '职业名称ID，或职业类型ID';
comment on column UNICALL.SHCPIC_LIMIT_METIER_PRODUCT.flag
  is '1.为产品名称  2。为职业类型';
alter table UNICALL.SHCPIC_LIMIT_METIER_PRODUCT
  add constraint PK_SHCPIC_METIER_PRODUCT primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_LIMIT_METIER_PRODUCT
  add constraint FK_PRODUCT_ID_2 foreign key (PRODUCT_ID)
  references UNICALL.SHCPIC_PRODUCT (ID);

prompt
prompt Creating table SHCPIC_METIER
prompt ============================
prompt
create table UNICALL.SHCPIC_METIER
(
  id     NUMBER(20) not null,
  name   VARCHAR2(200),
  code   VARCHAR2(50),
  parent NUMBER(20),
  typ    VARCHAR2(50),
  lev    VARCHAR2(2),
  is_del VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_METIER.typ
  is '职业类别';
comment on column UNICALL.SHCPIC_METIER.is_del
  is '是否删除：0，否；1，是';
alter table UNICALL.SHCPIC_METIER
  add constraint PK_SHCPIC_METIER primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_METIER_BAK
prompt ================================
prompt
create table UNICALL.SHCPIC_METIER_BAK
(
  id     NUMBER(20) not null,
  name   VARCHAR2(200),
  code   VARCHAR2(50),
  parent NUMBER(20),
  typ    VARCHAR2(50),
  lev    VARCHAR2(2),
  is_del VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_METIER_TYP
prompt ================================
prompt
create table UNICALL.SHCPIC_METIER_TYP
(
  id   NUMBER(10) not null,
  name VARCHAR2(10),
  des  VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_METIER_TYP.name
  is '职业类别名称';
comment on column UNICALL.SHCPIC_METIER_TYP.des
  is '职业类别描述';
alter table UNICALL.SHCPIC_METIER_TYP
  add constraint PK_METIER_TYP primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_OB_PRODUCT
prompt ================================
prompt
create table UNICALL.SHCPIC_OB_PRODUCT
(
  product_id NUMBER(10) not null,
  ob_com_id  NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.SHCPIC_OB_PRODUCT
  is 'outbound campaign and product reference table';
comment on column UNICALL.SHCPIC_OB_PRODUCT.product_id
  is 'product id';
comment on column UNICALL.SHCPIC_OB_PRODUCT.ob_com_id
  is 'outbound campaign id';
alter table UNICALL.SHCPIC_OB_PRODUCT
  add constraint PK_OB_PRODUCT primary key (PRODUCT_ID, OB_COM_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_OB_PRODUCT
  add constraint FK_OB_OB_COM_ID foreign key (OB_COM_ID)
  references UNICALL.C_OB_COM (OB_COM_ID);
alter table UNICALL.SHCPIC_OB_PRODUCT
  add constraint FK_OB_PRO_PRO foreign key (PRODUCT_ID)
  references UNICALL.SHCPIC_PRODUCT (ID);

prompt
prompt Creating table SHCPIC_OB_USER
prompt =============================
prompt
create table UNICALL.SHCPIC_OB_USER
(
  id        NUMBER(10) not null,
  ob_com_id NUMBER(10) not null,
  use_id    NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_OB_USER
  add constraint PK_OB_USER primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_OB_USER
  add constraint FK_OB_USER_COM_ID foreign key (OB_COM_ID)
  references UNICALL.C_OB_COM (OB_COM_ID);
alter table UNICALL.SHCPIC_OB_USER
  add constraint FK_OB_USER_USE_ID foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);

prompt
prompt Creating table SHCPIC_OUTDATA
prompt =============================
prompt
create table UNICALL.SHCPIC_OUTDATA
(
  out_id   VARCHAR2(20) not null,
  phonenum VARCHAR2(30) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 24M
  );

prompt
prompt Creating table SHCPIC_OUTPERIOD
prompt ===============================
prompt
create table UNICALL.SHCPIC_OUTPERIOD
(
  starttime VARCHAR2(10),
  endtime   VARCHAR2(10),
  c_date    VARCHAR2(3)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_OUTRESULT
prompt ===============================
prompt
create table UNICALL.SHCPIC_OUTRESULT
(
  custom_id  VARCHAR2(20) not null,
  out_id     VARCHAR2(20),
  phonenum   VARCHAR2(30),
  out_result VARCHAR2(3),
  out_time   DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_OUTRESULT
  add constraint CUSTOM_ID primary key (CUSTOM_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 512K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_PREINS_PRODUCT_CODE
prompt =========================================
prompt
create table UNICALL.SHCPIC_PREINS_PRODUCT_CODE
(
  id                  NUMBER(10) not null,
  code                VARCHAR2(6) not null,
  name                VARCHAR2(100) not null,
  expired             NUMBER(3) not null,
  status              NUMBER(1) not null,
  insured_period      NUMBER(5),
  insured_period_unit VARCHAR2(2),
  insurance_ident     NUMBER(1),
  composite_ins_code  VARCHAR2(6),
  pay_stad            NUMBER(7,2),
  fs                  NUMBER(2),
  bxzr                VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_PREINS_PRODUCT_CODE.status
  is '0:正常,1:删除';
comment on column UNICALL.SHCPIC_PREINS_PRODUCT_CODE.insured_period
  is '保障期限';
comment on column UNICALL.SHCPIC_PREINS_PRODUCT_CODE.insured_period_unit
  is '保障期限单位';
comment on column UNICALL.SHCPIC_PREINS_PRODUCT_CODE.insurance_ident
  is '险种标识';
comment on column UNICALL.SHCPIC_PREINS_PRODUCT_CODE.composite_ins_code
  is '综意险代码';
comment on column UNICALL.SHCPIC_PREINS_PRODUCT_CODE.pay_stad
  is '缴费标准';
comment on column UNICALL.SHCPIC_PREINS_PRODUCT_CODE.fs
  is '分数';
comment on column UNICALL.SHCPIC_PREINS_PRODUCT_CODE.bxzr
  is '保险责任';
create unique index UNICALL.IDX_UNI_PRODUCT_CODE on UNICALL.SHCPIC_PREINS_PRODUCT_CODE (CODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PREINS_PRODUCT_CODE
  add constraint PK_SHCPIC_PREINS_PRODUCT_CODE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_PREINS_CUS_LIST
prompt =====================================
prompt
create table UNICALL.SHCPIC_PREINS_CUS_LIST
(
  id             NUMBER(10) not null,
  name           VARCHAR2(32) not null,
  import_user_id NUMBER(10),
  import_time    TIMESTAMP(6),
  company_id     NUMBER(10) not null,
  status         NUMBER(1),
  sms_send_time  TIMESTAMP(6)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.SHCPIC_PREINS_CUS_LIST
  is '赠险客户信息导入列表';
comment on column UNICALL.SHCPIC_PREINS_CUS_LIST.status
  is '0:初始导入;1:已申请;2:已分配;3:已匹配;4:已发送';
alter table UNICALL.SHCPIC_PREINS_CUS_LIST
  add constraint PK_SHCPIC_PREINS_CUS_LIST primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_PREINS_APPLY
prompt ==================================
prompt
create table UNICALL.SHCPIC_PREINS_APPLY
(
  id              NUMBER(10) not null,
  product_code_id NUMBER(10) not null,
  apply_user_id   NUMBER(10) not null,
  apply_time      TIMESTAMP(6) not null,
  company_id      NUMBER(10) not null,
  amount          INTEGER not null,
  is_distributed  NUMBER(1) default 0 not null,
  cus_list_id     NUMBER(10),
  memo            VARCHAR2(256),
  status          NUMBER(1) default 0
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.SHCPIC_PREINS_APPLY
  is '赠险激活码申请';
comment on column UNICALL.SHCPIC_PREINS_APPLY.is_distributed
  is '0:未分配,1:已分配';
alter table UNICALL.SHCPIC_PREINS_APPLY
  add constraint PK_SHCPIC_PREINS_APPLY primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PREINS_APPLY
  add constraint FK_PREINS_APPLY_CODE foreign key (PRODUCT_CODE_ID)
  references UNICALL.SHCPIC_PREINS_PRODUCT_CODE (ID);
alter table UNICALL.SHCPIC_PREINS_APPLY
  add constraint FK_PREINS_APPLY_LIST foreign key (CUS_LIST_ID)
  references UNICALL.SHCPIC_PREINS_CUS_LIST (ID);

prompt
prompt Creating table SHCPIC_PREINS_DISTRIBUTE
prompt =======================================
prompt
create table UNICALL.SHCPIC_PREINS_DISTRIBUTE
(
  id                 NUMBER(10) not null,
  distribute_user_id NUMBER(10) not null,
  distribute_time    TIMESTAMP(6) not null,
  apply_id           NUMBER(10),
  amount             INTEGER not null,
  memo               VARCHAR2(256),
  status             NUMBER(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.SHCPIC_PREINS_DISTRIBUTE
  is '赠险激活码分配';
comment on column UNICALL.SHCPIC_PREINS_DISTRIBUTE.status
  is '0:已分配,1:已匹配';
alter table UNICALL.SHCPIC_PREINS_DISTRIBUTE
  add constraint PK_SHCPIC_PREINS_DISTRIBUTE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PREINS_DISTRIBUTE
  add constraint FK_PREINS_DISTRIBUTE_APPLY foreign key (APPLY_ID)
  references UNICALL.SHCPIC_PREINS_APPLY (ID);

prompt
prompt Creating table SHCPIC_PREINS_ACTIVE_CODE
prompt ========================================
prompt
create table UNICALL.SHCPIC_PREINS_ACTIVE_CODE
(
  id              NUMBER(10) not null,
  active_code     VARCHAR2(32) not null,
  password        VARCHAR2(32) not null,
  import_time     TIMESTAMP(6) not null,
  company_id      NUMBER(10) not null,
  import_user_id  NUMBER(10) not null,
  distribute_id   NUMBER(10),
  product_code_id NUMBER(10),
  is_sent         NUMBER(1) default 0
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 566M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_PREINS_ACTIVE_CODE.is_sent
  is '0:未发送;1:已发送';
create index UNICALL.COMPANY_PRODUCT_DISTRI on UNICALL.SHCPIC_PREINS_ACTIVE_CODE (COMPANY_ID, PRODUCT_CODE_ID, DISTRIBUTE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 192M
    next 1M
    minextents 1
    maxextents unlimited
  );
create unique index UNICALL.IDX_UNIQUE_ACTIVE_CODE on UNICALL.SHCPIC_PREINS_ACTIVE_CODE (ACTIVE_CODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 254M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PREINS_ACTIVE_CODE
  add constraint PK_SHCPIC_PREINS_ACTIVE_CODE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 145M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PREINS_ACTIVE_CODE
  add constraint FK_PREINS_CODE_DISTR foreign key (DISTRIBUTE_ID)
  references UNICALL.SHCPIC_PREINS_DISTRIBUTE (ID);
alter table UNICALL.SHCPIC_PREINS_ACTIVE_CODE
  add constraint FK_PREINS_CODE_PRODUCT foreign key (PRODUCT_CODE_ID)
  references UNICALL.SHCPIC_PREINS_PRODUCT_CODE (ID);

prompt
prompt Creating table SHCPIC_PREINS_CUSTOMER_DATA
prompt ==========================================
prompt
create table UNICALL.SHCPIC_PREINS_CUSTOMER_DATA
(
  id                 NUMBER(22) not null,
  active_code        VARCHAR2(32),
  customer_name      VARCHAR2(10),
  credentials_type   VARCHAR2(12),
  credentials_number VARCHAR2(30),
  birthday           VARCHAR2(15),
  sex                VARCHAR2(4),
  email              VARCHAR2(20),
  beneficiary        VARCHAR2(10),
  ensure_date        VARCHAR2(10),
  import_time        TIMESTAMP(6),
  import_user_id     NUMBER(22),
  present_cus_id     NUMBER(22)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
create index UNICALL.IDX_PRESENT_CUS_ID on UNICALL.SHCPIC_PREINS_CUSTOMER_DATA (PRESENT_CUS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.SHCPIC_PREINS_CUSTOMER_DATA
  add constraint PK_SHCPIC_PREINS_CUSTOMER_DATA primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table SHCPIC_PREINS_CUS_INF
prompt ====================================
prompt
create table UNICALL.SHCPIC_PREINS_CUS_INF
(
  id          NUMBER(10) not null,
  name        VARCHAR2(64) not null,
  mobile      VARCHAR2(16) not null,
  agency      VARCHAR2(64) not null,
  cus_list_id NUMBER(10) not null,
  ext_1       DATE,
  ext_2       DATE,
  ext_3       DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 96M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.SHCPIC_PREINS_CUS_INF
  is '赠险客户信息';
alter table UNICALL.SHCPIC_PREINS_CUS_INF
  add constraint PK_SHCPIC_PREINS_CUS_INF primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 30M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PREINS_CUS_INF
  add constraint FK_CUS_INF_LIST foreign key (CUS_LIST_ID)
  references UNICALL.SHCPIC_PREINS_CUS_LIST (ID);

prompt
prompt Creating table SHCPIC_PREINS_IVR_ACTIVE_CODE
prompt ============================================
prompt
create table UNICALL.SHCPIC_PREINS_IVR_ACTIVE_CODE
(
  id           CHAR(18) not null,
  idorg        VARCHAR2(18),
  ctype        CHAR(4),
  val          VARCHAR2(254),
  lastupdate   DATE,
  recordstatus CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 512M
    next 1M
    minextents 1
    maxextents unlimited
  );
create unique index UNICALL.IDX_SHCPIC_PREINS_01 on UNICALL.SHCPIC_PREINS_IVR_ACTIVE_CODE (ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 254M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_SHCPIC_PREINS_02 on UNICALL.SHCPIC_PREINS_IVR_ACTIVE_CODE (IDORG)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 248M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_PREINS_MATCH
prompt ==================================
prompt
create table UNICALL.SHCPIC_PREINS_MATCH
(
  id             NUMBER(10) not null,
  match_user_id  NUMBER(10) not null,
  match_time     TIMESTAMP(6) not null,
  active_code_id NUMBER(10) not null,
  match_cus_id   NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 72M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.SHCPIC_PREINS_MATCH
  is '赠险激活码匹配';
create unique index UNICALL.IDX_PREINS_MATCH_CODE_ID on UNICALL.SHCPIC_PREINS_MATCH (ACTIVE_CODE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 28M
    next 1M
    minextents 1
    maxextents unlimited
  );
create unique index UNICALL.IDX_PREINS_MATCH_CUSID on UNICALL.SHCPIC_PREINS_MATCH (MATCH_CUS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 28M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PREINS_MATCH
  add constraint PK_SHCPIC_PREINS_MATCH primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 28M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PREINS_MATCH
  add constraint FK_PREINS_MATCH_CODE foreign key (ACTIVE_CODE_ID)
  references UNICALL.SHCPIC_PREINS_ACTIVE_CODE (ID);
alter table UNICALL.SHCPIC_PREINS_MATCH
  add constraint FK_PREINS_MATCH_CUS foreign key (MATCH_CUS_ID)
  references UNICALL.SHCPIC_PREINS_CUS_INF (ID);

prompt
prompt Creating table SHCPIC_PREINS_SMS_HISTORY
prompt ========================================
prompt
create table UNICALL.SHCPIC_PREINS_SMS_HISTORY
(
  id            NUMBER(10) not null,
  content       VARCHAR2(512),
  send_user_id  NUMBER(10),
  send_time     TIMESTAMP(6),
  receiver_name VARCHAR2(64),
  receiver_no   VARCHAR2(16),
  cus_id        NUMBER(10),
  sms_type      NUMBER(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 698M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_PREINS_SMS_HISTORY.cus_id
  is '只在常规短信时有效';
comment on column UNICALL.SHCPIC_PREINS_SMS_HISTORY.sms_type
  is '0:赠险短信;1:常规短信';
create index UNICALL.IDX_SHCPIC_PREINS_SMS_HIS_01 on UNICALL.SHCPIC_PREINS_SMS_HISTORY (RECEIVER_NO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 46M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PREINS_SMS_HISTORY
  add constraint PK_SHCPIC_PREINS_SMS_HISTORY primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 31M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_PREINS_SMS_ORG_CODE
prompt =========================================
prompt
create table UNICALL.SHCPIC_PREINS_SMS_ORG_CODE
(
  id             NUMBER(10) not null,
  branch_id      NUMBER(10),
  og_code        VARCHAR2(32),
  og_smextendnum VARCHAR2(32),
  og_name        VARCHAR2(32),
  sms_type       VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_PREINS_SMS_ORG_CODE.branch_id
  is '分支公司ID,与shcpic_company表中ID对应';
comment on column UNICALL.SHCPIC_PREINS_SMS_ORG_CODE.og_code
  is '分支公司CODE';
comment on column UNICALL.SHCPIC_PREINS_SMS_ORG_CODE.og_smextendnum
  is '扩展尾码';
comment on column UNICALL.SHCPIC_PREINS_SMS_ORG_CODE.og_name
  is '分支公司名称';
comment on column UNICALL.SHCPIC_PREINS_SMS_ORG_CODE.sms_type
  is '短信类型（SMS_TYPE）赠险：01，实时：02';
alter table UNICALL.SHCPIC_PREINS_SMS_ORG_CODE
  add constraint PK_SHCPIC_PREINS_SMS_ORG_CODE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_PREINS_SMS_TEMPLATE
prompt =========================================
prompt
create table UNICALL.SHCPIC_PREINS_SMS_TEMPLATE
(
  id             NUMBER(10) not null,
  content        VARCHAR2(512),
  create_user_id NUMBER(10),
  create_time    TIMESTAMP(6),
  modify_user_id NUMBER(10),
  modify_time    TIMESTAMP(6),
  name           VARCHAR2(32)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PREINS_SMS_TEMPLATE
  add constraint PK_SHCPIC_PREINS_SMS_TEMPLATE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_PREMIUM
prompt =============================
prompt
create table UNICALL.SHCPIC_PREMIUM
(
  id           NUMBER(20) not null,
  insurance_id NUMBER(20),
  age          VARCHAR2(10),
  sex          VARCHAR2(10),
  term         VARCHAR2(10),
  price        VARCHAR2(10),
  is_del       VARCHAR2(10),
  pay_way      VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 320K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_PREMIUM.is_del
  is '是否删除：0，否；1，是';
alter table UNICALL.SHCPIC_PREMIUM
  add constraint PK_SHCPIC_PREMIUM primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_PRODUCT_FAQ
prompt =================================
prompt
create table UNICALL.SHCPIC_PRODUCT_FAQ
(
  id             NUMBER(10) not null,
  faq_product_id NUMBER(10),
  faq_id         NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PRODUCT_FAQ
  add constraint PK_PRODUCT_FAQ_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PRODUCT_FAQ
  add constraint FK_PF_FAQ_ID foreign key (FAQ_ID)
  references UNICALL.C_INF (INF_ID);
alter table UNICALL.SHCPIC_PRODUCT_FAQ
  add constraint FK_PF_PRODUCT_ID foreign key (FAQ_PRODUCT_ID)
  references UNICALL.SHCPIC_PRODUCT (ID);

prompt
prompt Creating table SHCPIC_PRODUCT_INS
prompt =================================
prompt
create table UNICALL.SHCPIC_PRODUCT_INS
(
  id                    NUMBER(10) not null,
  policy_type           VARCHAR2(20),
  policy_code           VARCHAR2(20),
  ph_name               VARCHAR2(20),
  ph_marriage           VARCHAR2(20),
  ph_id_type            VARCHAR2(20),
  ph_id_code            VARCHAR2(20),
  ph_birthday           VARCHAR2(20),
  ph_sex                VARCHAR2(20),
  ph_nationality        VARCHAR2(20),
  ph_home_addr          VARCHAR2(20),
  ph_home_code          VARCHAR2(20),
  ph_residence          VARCHAR2(20),
  ph_service_adrr       VARCHAR2(20),
  ph_service_code       VARCHAR2(20),
  crm_zone_id           VARCHAR2(20),
  ph_contact_addr_type  VARCHAR2(20),
  ph_contact_addr       VARCHAR2(20),
  ph_contact_code       VARCHAR2(20),
  ph_contact_tel        VARCHAR2(20),
  ph_contact_email      VARCHAR2(20),
  ph_contact_mobile     VARCHAR2(20),
  ph_is_autobike        VARCHAR2(20),
  ph_work_code          VARCHAR2(20),
  ph_sidework_code      VARCHAR2(20),
  ph_rcg_relation       VARCHAR2(20),
  rcg_name              VARCHAR2(20),
  rcg_marriage          VARCHAR2(20),
  rcg_birthday          VARCHAR2(20),
  rcg_sex               VARCHAR2(20),
  rcg_nationality       VARCHAR2(20),
  rcg_id_type           VARCHAR2(20),
  rcg_id_code           VARCHAR2(20),
  rcg_home_addr         VARCHAR2(20),
  rcg_home_code         VARCHAR2(20),
  rcg_residence         VARCHAR2(20),
  rcg_service_adrr      VARCHAR2(20),
  rcg_service_code      VARCHAR2(20),
  rcg_contact_addr_type VARCHAR2(20),
  rcg_contact_addr      VARCHAR2(20),
  rcg_contact_code      VARCHAR2(20),
  rcg_contact_tel       VARCHAR2(20),
  rcg_contact_email     VARCHAR2(20),
  rcg_contact_mobile    VARCHAR2(20),
  rcg_is_autobike       VARCHAR2(20),
  rcg_work_code         VARCHAR2(20),
  rcg_sidework_code     VARCHAR2(20),
  beneficiary_info      VARCHAR2(20),
  product_info          VARCHAR2(20),
  addition_fare         VARCHAR2(20),
  total_fare            VARCHAR2(20),
  temp_receipt_code     VARCHAR2(20),
  first_porposal_code   VARCHAR2(20),
  first_pay_way         VARCHAR2(20),
  second_pay_way        VARCHAR2(20),
  substitute_pay_way    VARCHAR2(20),
  bank_code             VARCHAR2(20),
  account_name          VARCHAR2(20),
  account_code          VARCHAR2(20),
  fare_overdue          VARCHAR2(20),
  bonus_draw_way        VARCHAR2(20),
  die_function          VARCHAR2(20),
  dispute_dispose_way   VARCHAR2(20),
  operation_code        VARCHAR2(20),
  assessor_code         VARCHAR2(20),
  sell_channel          VARCHAR2(20),
  proposal_day          VARCHAR2(20),
  is_auto_proposal      VARCHAR2(20),
  health_inform         VARCHAR2(20),
  special_faith         VARCHAR2(20),
  return_info           VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on column UNICALL.SHCPIC_PRODUCT_INS.policy_type
  is '投保类型
0:投保单
1:定额保单';
comment on column UNICALL.SHCPIC_PRODUCT_INS.policy_code
  is '投保单号/定额保单号';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_name
  is '投保人(policy_holder)姓名';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_marriage
  is '投保人(policy_holder)婚姻状况
201|已 婚 202|未 婚
203|离 婚 204|鳏 寡
205|分 居';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_id_type
  is '有效证件类型
0:身份证 1:军人证  2:护照 3:驾照 4:其他';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_id_code
  is '投保人证件号';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_birthday
  is '投保人出生日期';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_sex
  is '投保人性别
1: 男
2: 女';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_nationality
  is '投保人国籍';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_home_addr
  is '投保人家庭地址';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_home_code
  is '投保人家庭邮编';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_residence
  is '投保人户口所在地';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_service_adrr
  is '投保人服务单位地址';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_service_code
  is '投保人单位邮编';
comment on column UNICALL.SHCPIC_PRODUCT_INS.crm_zone_id
  is '区域编码';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_contact_addr_type
  is '联系地址类别 1: 家庭地址
2: 服务单位 3: 其他';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_contact_addr
  is '投保人联系地址';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_contact_code
  is '投保人联系邮编';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_contact_tel
  is '投保人联系电话';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_contact_email
  is '投保人E_mail';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_contact_mobile
  is '	投保人手机';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_is_autobike
  is '是否以摩托车
为交通工具
0: 否
1: 是';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_work_code
  is '投保人职业代码
可以提供对应表
profclas.professno';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_sidework_code
  is '兼职职业代码
可以提供对应表
profclas.professno';
comment on column UNICALL.SHCPIC_PRODUCT_INS.ph_rcg_relation
  is '投保人和被保人关系代码 如果是301,即被保人就是
投保人本人的话,被保人
信息不填
可以提供对应表concisno';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_name
  is '被保人姓名';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_marriage
  is '被保人婚姻状况';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_birthday
  is '被保人出生日期';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_sex
  is '被保人性别';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_nationality
  is '被保人国籍';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_id_type
  is '有效证件类型 0:身份证 1:军人证  2:护照 3:驾照 4:其他';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_id_code
  is '被保人证件号';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_home_addr
  is '被保人家庭地址';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_home_code
  is '被保人家庭邮编';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_residence
  is '被保人户口所在地';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_service_adrr
  is '被保人服务单位或就读学校';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_service_code
  is '被保人服务单位邮编';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_contact_addr_type
  is '联系地址类别 1: 家庭地址
2: 服务单位
3: 其他';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_contact_addr
  is '被保人联系地址';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_contact_code
  is '被保人联系邮编';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_contact_tel
  is '被保人联系电话';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_contact_email
  is '被保人E_mail';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_contact_mobile
  is '被保人手机';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_is_autobike
  is '被保人是否
以摩托车为
交通工具
0: 否
1: 是';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_work_code
  is '被保人职业代码';
comment on column UNICALL.SHCPIC_PRODUCT_INS.rcg_sidework_code
  is '兼职职业代码';
comment on column UNICALL.SHCPIC_PRODUCT_INS.beneficiary_info
  is '受益人信息
受益人格式：
 第一位是受益分配方式： 1 顺位  2 均分   3 比例  4 法定 5 本人  6其他
 后面开始是逐个受益人排列方式，以 & 隔开
 其中每一段中不同项以 @ 隔开
 项目依次为：身份证号 +  姓名  + 受益顺序 +  与被保人关系 + 受益比例';
comment on column UNICALL.SHCPIC_PRODUCT_INS.product_info
  is '格式：
 逐个投保产品排列方式，以 & 隔开
 每一产品中不同项以 @ 隔开
 项目依次为：主附险标志+险种代码(或定额保单代码)+保额+份数(或档次)
             +缴费标准+职业加费+缴费方式+缴费年限+保险期间(年)+保险期间类型
             +领取方式+领取年龄+定额保单序号(默认00)
 缴费方式:01～趸缴 10～月缴 11～季缴 12～半年缴 13～年缴 02～不定期
保险期间类型: 0: 定期年  1: 定期岁  2: 终身';
comment on column UNICALL.SHCPIC_PRODUCT_INS.addition_fare
  is '追加保费';
comment on column UNICALL.SHCPIC_PRODUCT_INS.total_fare
  is '总保费';
comment on column UNICALL.SHCPIC_PRODUCT_INS.temp_receipt_code
  is '暂收费收据号';
comment on column UNICALL.SHCPIC_PRODUCT_INS.first_porposal_code
  is '主险保单号';
comment on column UNICALL.SHCPIC_PRODUCT_INS.first_pay_way
  is '首期支付方式 1:现金
2:支票
3:转帐';
comment on column UNICALL.SHCPIC_PRODUCT_INS.second_pay_way
  is '续期支付方式';
comment on column UNICALL.SHCPIC_PRODUCT_INS.substitute_pay_way
  is '代缴形式';
comment on column UNICALL.SHCPIC_PRODUCT_INS.bank_code
  is '开户银行代码';
comment on column UNICALL.SHCPIC_PRODUCT_INS.account_name
  is '开户名称';
comment on column UNICALL.SHCPIC_PRODUCT_INS.account_code
  is '帐号';
comment on column UNICALL.SHCPIC_PRODUCT_INS.fare_overdue
  is '保费逾期选择 1:自动垫缴
0:中止合同';
comment on column UNICALL.SHCPIC_PRODUCT_INS.bonus_draw_way
  is '红利领取方式
11:现金领取
12:累积生息
13:抵缴保费
14:缴清增额
10:无';
comment on column UNICALL.SHCPIC_PRODUCT_INS.die_function
  is '身故保险金功能选择
0:  一次性领取(默认)
1: 转换子女教育金
2: 转换成配偶养老金';
comment on column UNICALL.SHCPIC_PRODUCT_INS.dispute_dispose_way
  is '争议处理方式 1: 提交仲裁
2:提起诉讼';
comment on column UNICALL.SHCPIC_PRODUCT_INS.operation_code
  is '业务员代码';
comment on column UNICALL.SHCPIC_PRODUCT_INS.assessor_code
  is '初审人员代码';
comment on column UNICALL.SHCPIC_PRODUCT_INS.sell_channel
  is '销售渠道 10:个险
20:团险
31:银行邮政
32:非银行邮政
33:专业代理
34:电话销售
40:交叉销售';
comment on column UNICALL.SHCPIC_PRODUCT_INS.proposal_day
  is '投保日期';
comment on column UNICALL.SHCPIC_PRODUCT_INS.is_auto_proposal
  is '是否自动续保 0: 否
1: 是';
comment on column UNICALL.SHCPIC_PRODUCT_INS.health_inform
  is '健康告知
规则:
每个告知项排列方式，以 & 隔开
每一告知项中以 @ 隔开
项目依次为：告知类型（1－投保人，2-被保人）＋告知代码+描述(数值或者文字说明)';
comment on column UNICALL.SHCPIC_PRODUCT_INS.special_faith
  is '特别约定';
comment on column UNICALL.SHCPIC_PRODUCT_INS.return_info
  is '返回信息';
alter table UNICALL.SHCPIC_PRODUCT_INS
  add constraint PK_PRODUCT_INS_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table SHCPIC_QUESTION
prompt ==============================
prompt
create table UNICALL.SHCPIC_QUESTION
(
  id          NUMBER(10) not null,
  name        VARCHAR2(500) not null,
  value       VARCHAR2(2),
  remark      VARCHAR2(100),
  is_del      VARCHAR2(2),
  parent      VARCHAR2(100),
  lev         VARCHAR2(2),
  inform_code VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.SHCPIC_QUESTION
  is '问题表，包含了需要提示外拨客户的问题';
comment on column UNICALL.SHCPIC_QUESTION.name
  is '问题的名称';
comment on column UNICALL.SHCPIC_QUESTION.value
  is '可以通过该问题的答案，仅有可能是Y,N，不符合该答案则对该客户营销活动失败，不能为该客户完成保单';
comment on column UNICALL.SHCPIC_QUESTION.lev
  is '标识级别';
comment on column UNICALL.SHCPIC_QUESTION.inform_code
  is '告知代码';
alter table UNICALL.SHCPIC_QUESTION
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_PRODUCT_QUESTION
prompt ======================================
prompt
create table UNICALL.SHCPIC_PRODUCT_QUESTION
(
  product_id  NUMBER(10) not null,
  question_id NUMBER(10) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.SHCPIC_PRODUCT_QUESTION
  is '产品、问题对照关系表';
alter table UNICALL.SHCPIC_PRODUCT_QUESTION
  add constraint FK_PRO_QUE_PRO foreign key (PRODUCT_ID)
  references UNICALL.SHCPIC_PRODUCT (ID);
alter table UNICALL.SHCPIC_PRODUCT_QUESTION
  add constraint FK_PRO_QUE_QUE foreign key (QUESTION_ID)
  references UNICALL.SHCPIC_QUESTION (ID);

prompt
prompt Creating table SHCPIC_PRODUCT_RESULT
prompt ====================================
prompt
create table UNICALL.SHCPIC_PRODUCT_RESULT
(
  id                  NUMBER(20) not null,
  pro_product_id      NUMBER(20) not null,
  proposal_form_id    NUMBER(20) not null,
  insurance_id        NUMBER(20),
  element_id          NUMBER(20),
  element_value_value VARCHAR2(20),
  element_value_name  VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 6M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PRODUCT_RESULT
  add constraint PRODUCT_RESULT_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_PRODUCT_RESULT_LOG
prompt ========================================
prompt
create table UNICALL.SHCPIC_PRODUCT_RESULT_LOG
(
  id       NUMBER(10) not null,
  ttime    DATE,
  idsort   VARCHAR2(4),
  idresult VARCHAR2(18),
  content  VARCHAR2(2048)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.SHCPIC_PRODUCT_RESULT_LOG
  is '实时代扣流程日志表';
comment on column UNICALL.SHCPIC_PRODUCT_RESULT_LOG.ttime
  is '创建时间';
comment on column UNICALL.SHCPIC_PRODUCT_RESULT_LOG.idsort
  is '日志类型:0101 FF实时核保，0102 综意险实时核保，0201 FF实时扣款，0202 综意险实时扣款，0301 FF保费确认，0302 综意险保费确认';
comment on column UNICALL.SHCPIC_PRODUCT_RESULT_LOG.idresult
  is 'SHCPIC_PRODUCT_RESULT_ID';
comment on column UNICALL.SHCPIC_PRODUCT_RESULT_LOG.content
  is '接口返回日志内容';
alter table UNICALL.SHCPIC_PRODUCT_RESULT_LOG
  add constraint PK_SHCPIC_PRODUCT_RESULT_LOG primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_PROPOSAL_FORM_RESULT
prompt ==========================================
prompt
create table UNICALL.SHCPIC_PROPOSAL_FORM_RESULT
(
  id                     NUMBER(20) not null,
  insure_name            VARCHAR2(200),
  relation               VARCHAR2(100),
  insure_sex             VARCHAR2(1),
  insure_birthday        VARCHAR2(32),
  insure_pass_type       VARCHAR2(100),
  insure_pass_code       VARCHAR2(32),
  insure_post_code       VARCHAR2(32),
  insure_address         VARCHAR2(200),
  insure_employment      VARCHAR2(32),
  insure_mobile          VARCHAR2(20),
  insure_family_pho      VARCHAR2(20),
  insure_com_pho         VARCHAR2(20),
  d_insure_name          VARCHAR2(200),
  d_insure_sex           VARCHAR2(1),
  d_insure_birthday      VARCHAR2(32),
  d_insure_pass_type     VARCHAR2(100),
  d_insure_pass_code     VARCHAR2(32),
  d_insure_post_code     VARCHAR2(32),
  d_insure_address       VARCHAR2(200),
  d_insure_employment    VARCHAR2(32),
  d_insure_mobile        VARCHAR2(20),
  d_insure_family_pho    VARCHAR2(20),
  d_insure_com_pho       VARCHAR2(20),
  price                  VARCHAR2(30),
  counts                 NUMBER(6,1),
  ben_type               VARCHAR2(20),
  bank_name              VARCHAR2(200),
  bank_code              VARCHAR2(50),
  bank_account           VARCHAR2(50),
  audit_status           VARCHAR2(2),
  c_ob_com_cus_id        NUMBER(10) not null,
  user_id                NUMBER(10),
  createtime             VARCHAR2(20),
  sale_code              VARCHAR2(20),
  appno                  VARCHAR2(18),
  policyno               VARCHAR2(18),
  id_checkpoint_type     VARCHAR2(4),
  companyname            VARCHAR2(100),
  insure_email           VARCHAR2(50),
  d_insure_email         VARCHAR2(50),
  pay_type               VARCHAR2(1),
  app_latest_status      VARCHAR2(10),
  app_latest_time        VARCHAR2(20),
  app_accept_status      VARCHAR2(10),
  app_accept_time        VARCHAR2(20),
  app_quit_status        VARCHAR2(10),
  app_quit_time          VARCHAR2(20),
  total_pay_des          VARCHAR2(2000),
  cus_gro_id             NUMBER(10),
  check_user_id          NUMBER(10),
  insure_con_addr_type   VARCHAR2(1),
  d_insure_con_addr_type VARCHAR2(1),
  companycode            VARCHAR2(18),
  insurance_sum          VARCHAR2(100),
  audittime              VARCHAR2(20),
  d_insure_weight        VARCHAR2(32),
  d_insure_height        VARCHAR2(32),
  r_pay_type             VARCHAR2(1),
  auto_charge_date       VARCHAR2(30),
  auto_charge_flag       VARCHAR2(2),
  charge_amount          VARCHAR2(50),
  charge_ret             VARCHAR2(200),
  confirm_ret            VARCHAR2(200),
  uwr_ret                VARCHAR2(200),
  chatge_state_code      VARCHAR2(2),
  tradeseq               VARCHAR2(30),
  org_id                 NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 40M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.price
  is '总金额';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.counts
  is '份数';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.audit_status
  is '0:待审核 1:通过 2:不通过 3:撤销4:实时核保成功5:实时扣款成功6:保费确认成功';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.c_ob_com_cus_id
  is '我的名单ID';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.user_id
  is '投保单生成时当前座席ID';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.sale_code
  is '销售代码';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.appno
  is '投保单号';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.policyno
  is '保单号';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.id_checkpoint_type
  is '环节类型 1001'',''投保单建立''  ''1002'',''扣款成功''  ''1003'',''扣款成功'' ''1004'',''生效'' ''1005'',''退保''';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.pay_type
  is '现金''1'',支票''2'',转账''3''';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.app_latest_status
  is '投保单最新状态';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.app_latest_time
  is '投保单最新状态更新时间';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.app_accept_status
  is '投保单承保状态';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.app_accept_time
  is '投保单承保时间';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.app_quit_status
  is '投保单退保状态';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.app_quit_time
  is '投保单退保时间';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.total_pay_des
  is '投保单总金额明细描述';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.cus_gro_id
  is '客户组ID';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.check_user_id
  is '审核人ID';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.insure_con_addr_type
  is '投保人联系地址类型 1 家庭地址 2 服务单位 3 其他';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.d_insure_con_addr_type
  is '被投保人联系地址类型 1 家庭地址 2 服务单位 3 其他';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.companycode
  is '中支公司编码';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.insurance_sum
  is '保额';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.auto_charge_date
  is '实时扣款日期';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.auto_charge_flag
  is '实时扣款标志 01：是；02：否';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.charge_amount
  is '实时扣款金额';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.charge_ret
  is '实时扣款结果';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.confirm_ret
  is '保费确认结果';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.uwr_ret
  is '实时核保结果';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.chatge_state_code
  is '扣款状态码';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.tradeseq
  is '交易序列号';
comment on column UNICALL.SHCPIC_PROPOSAL_FORM_RESULT.org_id
  is '实现数据权限过滤';
create index UNICALL.IDX_C_OB_COM_CUS_ID on UNICALL.SHCPIC_PROPOSAL_FORM_RESULT (C_OB_COM_CUS_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_PROPOSAL_FORM_RESULT
  add constraint PROPOSAL_FORM_RESULT_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 960K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_SATISFY
prompt =============================
prompt
create table UNICALL.SHCPIC_SATISFY
(
  agent_no   VARCHAR2(6),
  phone_no   VARCHAR2(15),
  is_satisfy VARCHAR2(1),
  datetime   VARCHAR2(25),
  satisfyid  NUMBER(15) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.SHCPIC_SATISFY_INDEX1 on UNICALL.SHCPIC_SATISFY (AGENT_NO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.SHCPIC_SATISFY_INDEX2 on UNICALL.SHCPIC_SATISFY (IS_SATISFY)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.SHCPIC_SATISFY_INDEX3 on UNICALL.SHCPIC_SATISFY (DATETIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_SATISFY
  add constraint PK_SHCPIC_SATISFY primary key (SATISFYID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_TB_APP
prompt ============================
prompt
create table UNICALL.SHCPIC_TB_APP
(
  id           VARCHAR2(18) not null,
  iddmsystem   VARCHAR2(18),
  iddmtype     VARCHAR2(4),
  idorg        VARCHAR2(18),
  appno        VARCHAR2(18),
  policyno     VARCHAR2(18),
  firstcreate  DATE,
  lastupdate   DATE,
  contents     VARCHAR2(4000),
  iana         CHAR(1),
  ierror       CHAR(1),
  isubmit      CHAR(1),
  iaccept      CHAR(1),
  recordstatus CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_TB_APP_BAK
prompt ================================
prompt
create table UNICALL.SHCPIC_TB_APP_BAK
(
  id           VARCHAR2(18) not null,
  iddmsystem   VARCHAR2(18),
  iddmtype     VARCHAR2(4),
  idorg        VARCHAR2(18),
  appno        VARCHAR2(18),
  policyno     VARCHAR2(18),
  firstcreate  DATE,
  lastupdate   DATE,
  contents     VARCHAR2(4000),
  iana         CHAR(1),
  ierror       CHAR(1),
  isubmit      CHAR(1),
  iaccept      CHAR(1),
  recordstatus CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_TB_APP_CHECKPOINT
prompt =======================================
prompt
create table UNICALL.SHCPIC_TB_APP_CHECKPOINT
(
  id                 VARCHAR2(18) not null,
  idapp              VARCHAR2(18),
  id_checkpoint_type VARCHAR2(4),
  checkpointtime     DATE,
  lastupdate         DATE,
  recordstatus       CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on column UNICALL.SHCPIC_TB_APP_CHECKPOINT.idapp
  is '电销系统id';
comment on column UNICALL.SHCPIC_TB_APP_CHECKPOINT.id_checkpoint_type
  is '环节类型 1001'',''投保单建立''  ''1002'',''扣款成功''  ''1003'',''扣款成功'' ''1004'',''生效'' ''1005'',''退保''';
comment on column UNICALL.SHCPIC_TB_APP_CHECKPOINT.checkpointtime
  is '环节时间';
comment on column UNICALL.SHCPIC_TB_APP_CHECKPOINT.lastupdate
  is '更新时间';
comment on column UNICALL.SHCPIC_TB_APP_CHECKPOINT.recordstatus
  is '{记录状态:0-已删除,1-未删除。}';
alter table UNICALL.SHCPIC_TB_APP_CHECKPOINT
  add constraint PK_TB_APP_CHECKPOINT primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table SHCPIC_TB_APP_CHECKPOINT_TYP
prompt ===========================================
prompt
create table UNICALL.SHCPIC_TB_APP_CHECKPOINT_TYP
(
  id   NUMBER(10) not null,
  name VARCHAR2(50),
  des  VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.SHCPIC_TB_APP_CHECKPOINT_TYP.name
  is '投保单状态名称';
alter table UNICALL.SHCPIC_TB_APP_CHECKPOINT_TYP
  add constraint PK_APP_CHECKPOINT_TYP primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_BANK_FILENO
prompt =============================
prompt
create table UNICALL.TB_BANK_FILENO
(
  id         NUMBER(10) not null,
  trans_date VARCHAR2(8),
  seq        NUMBER(10),
  bank_id    VARCHAR2(4)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_BANK_FILENO
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SHCPIC_TRANS_FILTER
prompt ==================================
prompt
create table UNICALL.SHCPIC_TRANS_FILTER
(
  id              NUMBER(10) not null,
  bank_fileno_id  NUMBER(10),
  pause_resume_id NUMBER(10),
  app_no          VARCHAR2(15),
  account         VARCHAR2(20),
  money           VARCHAR2(13),
  id_card         VARCHAR2(18),
  name            VARCHAR2(20),
  transfer_date   VARCHAR2(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.SHCPIC_TRANS_FILTER
  is '报盘过虑文件';
alter table UNICALL.SHCPIC_TRANS_FILTER
  add constraint PK_SHCPIC_TRANS_FILTER primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 384K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.SHCPIC_TRANS_FILTER
  add constraint FK_TRANS_FILTER_APPNO foreign key (PAUSE_RESUME_ID)
  references UNICALL.SHCPIC_APP_PAUSE_RESUME (ID);
alter table UNICALL.SHCPIC_TRANS_FILTER
  add constraint FK_TRANS_FILTER_FILENO foreign key (BANK_FILENO_ID)
  references UNICALL.TB_BANK_FILENO (ID);

prompt
prompt Creating table SPREREC
prompt ======================
prompt
create table UNICALL.SPREREC
(
  sno                    NUMBER(20),
  typeid                 NUMBER(7),
  con_id                 NUMBER(20),
  policyno               VARCHAR2(20) not null,
  classcode              CHAR(8) not null,
  amount                 NUMBER(20,4) not null,
  stdrate                NUMBER(20,6) not null,
  unstdrate              NUMBER(20,6) not null,
  currency               CHAR(3) not null,
  prndate                DATE not null,
  yearnum                NUMBER(20) not null,
  paycode                CHAR(2) not null,
  setcode                CHAR(1) not null,
  status                 CHAR(1) not null,
  movewhy                VARCHAR2(120),
  pcode                  CHAR(1) not null,
  verdate                DATE,
  cover1                 DATE not null,
  cover2                 DATE not null,
  oper_id                NUMBER(20),
  operno                 VARCHAR2(20) not null,
  empno_id               NUMBER(20),
  empno                  VARCHAR2(20) not null,
  deptno                 VARCHAR2(20),
  person_id              NUMBER(20),
  apid                   VARCHAR2(40) not null,
  idtype                 CHAR(2) not null,
  years                  NUMBER(20) not null,
  source_payin_actvty_id VARCHAR2(35) not null,
  begtime                NUMBER(11) not null,
  endtime                NUMBER(11) not null,
  branch                 CHAR(14) not null,
  etl_time               TIMESTAMP(6) not null,
  src_sys                VARCHAR2(20) not null,
  pos_no                 VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 8M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.SPREREC
  is '  财务应收信息';
comment on column UNICALL.SPREREC.sno
  is 'IAA物理主键
';
comment on column UNICALL.SPREREC.typeid
  is 'IAA数据类型（实收实付）
';
comment on column UNICALL.SPREREC.con_id
  is '保单IAA业务相关主键
';
comment on column UNICALL.SPREREC.policyno
  is '保单号
';
comment on column UNICALL.SPREREC.classcode
  is '险种代码
';
comment on column UNICALL.SPREREC.amount
  is '缴费/领款金额
';
comment on column UNICALL.SPREREC.stdrate
  is '标准加费
';
comment on column UNICALL.SPREREC.unstdrate
  is '非标准加费
';
comment on column UNICALL.SPREREC.currency
  is '币种代码
';
comment on column UNICALL.SPREREC.prndate
  is '生成日期
';
comment on column UNICALL.SPREREC.yearnum
  is '保单约定缴费年限
';
comment on column UNICALL.SPREREC.paycode
  is '本次缴费对应缴费频率
';
comment on column UNICALL.SPREREC.setcode
  is '缴费/领款方式
';
comment on column UNICALL.SPREREC.status
  is '状态
';
comment on column UNICALL.SPREREC.movewhy
  is '红冲原因
';
comment on column UNICALL.SPREREC.pcode
  is '交易财务类型
';
comment on column UNICALL.SPREREC.verdate
  is '交易生效日期
';
comment on column UNICALL.SPREREC.cover1
  is '财务交易责任起始日期
';
comment on column UNICALL.SPREREC.cover2
  is '财务交易责任终止日期
';
comment on column UNICALL.SPREREC.oper_id
  is '操作员IAA相关业务主键
';
comment on column UNICALL.SPREREC.operno
  is '操作员工号
';
comment on column UNICALL.SPREREC.empno_id
  is '业务员IAA业务相关主键
';
comment on column UNICALL.SPREREC.empno
  is '业务员代码
';
comment on column UNICALL.SPREREC.deptno
  is '收费部门代码
';
comment on column UNICALL.SPREREC.person_id
  is '缴费/领款人IAA业务相关主键
';
comment on column UNICALL.SPREREC.apid
  is '投保人身份证件号
';
comment on column UNICALL.SPREREC.idtype
  is '投保人身份证件类型
';
comment on column UNICALL.SPREREC.years
  is '期次
';
comment on column UNICALL.SPREREC.source_payin_actvty_id
  is '应收数据唯一标识
';
comment on column UNICALL.SPREREC.begtime
  is '开始日期
';
comment on column UNICALL.SPREREC.endtime
  is '中止日期
';
comment on column UNICALL.SPREREC.branch
  is '分公司代码
';
comment on column UNICALL.SPREREC.etl_time
  is 'ETL处理时间
';
comment on column UNICALL.SPREREC.src_sys
  is '来源系统
';
comment on column UNICALL.SPREREC.pos_no
  is '批单号（保全业务导致的收费放批单号）';
create index UNICALL.SPREREC_INDEX on UNICALL.SPREREC (POLICYNO, SOURCE_PAYIN_ACTVTY_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SPREREC_BAK
prompt ==========================
prompt
create table UNICALL.SPREREC_BAK
(
  sno                    NUMBER(20),
  typeid                 NUMBER(7),
  con_id                 NUMBER(20),
  policyno               VARCHAR2(20) not null,
  classcode              CHAR(8) not null,
  amount                 NUMBER(20,4) not null,
  stdrate                NUMBER(20,6) not null,
  unstdrate              NUMBER(20,6) not null,
  currency               CHAR(3) not null,
  prndate                DATE not null,
  yearnum                NUMBER(20) not null,
  paycode                CHAR(2) not null,
  setcode                CHAR(1) not null,
  status                 CHAR(1) not null,
  movewhy                VARCHAR2(120),
  pcode                  CHAR(1) not null,
  verdate                DATE,
  cover1                 DATE not null,
  cover2                 DATE not null,
  oper_id                NUMBER(20),
  operno                 VARCHAR2(20) not null,
  empno_id               NUMBER(20),
  empno                  VARCHAR2(20) not null,
  deptno                 VARCHAR2(20),
  person_id              NUMBER(20),
  apid                   VARCHAR2(40) not null,
  idtype                 CHAR(2) not null,
  years                  NUMBER(20) not null,
  source_payin_actvty_id VARCHAR2(35) not null,
  begtime                NUMBER(11) not null,
  endtime                NUMBER(11) not null,
  branch                 CHAR(14) not null,
  etl_time               TIMESTAMP(6) not null,
  src_sys                VARCHAR2(20) not null,
  pos_no                 VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table SYS_TASK_USERS_TMP
prompt =================================
prompt
create table UNICALL.SYS_TASK_USERS_TMP
(
  user_ali_id  VARCHAR2(20),
  amount       NUMBER(20,6),
  assigned_amt NUMBER(20,6) default 0
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T1
prompt =================
prompt
create table UNICALL.T1
(
  branch         CHAR(14),
  initial_amount NUMBER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T2
prompt =================
prompt
create table UNICALL.T2
(
  branch         CHAR(14),
  initial_amount NUMBER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_APP
prompt =====================
prompt
create table UNICALL.TB_APP
(
  id             VARCHAR2(18) not null,
  iddmsystem     VARCHAR2(24),
  iddmtype       VARCHAR2(4),
  idorg          VARCHAR2(18),
  appno          VARCHAR2(18),
  policyno       VARCHAR2(18),
  firstcreate    DATE,
  lastupdate     DATE,
  contents       VARCHAR2(4000),
  iana           CHAR(1),
  ierror         CHAR(1),
  isubmit        CHAR(1),
  iaccept        CHAR(1),
  recordstatus   CHAR(1),
  tsrid          VARCHAR2(10),
  last_log       VARCHAR2(18),
  prodetc_name   VARCHAR2(50),
  campaign_name  VARCHAR2(1024),
  vaildaty       VARCHAR2(10),
  ialter         VARCHAR2(2),
  irepeal        VARCHAR2(2),
  iupdate        VARCHAR2(2),
  app_status     VARCHAR2(3),
  prj_id         NUMBER(10),
  outbound_usrid VARCHAR2(30),
  site_status    VARCHAR2(2),
  pro_status     VARCHAR2(2),
  org_id         NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 235M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.TB_APP.id
  is '投保单ID';
comment on column UNICALL.TB_APP.iddmsystem
  is '流水号';
comment on column UNICALL.TB_APP.iddmtype
  is '数据来源类型';
comment on column UNICALL.TB_APP.idorg
  is '中支公司编码';
comment on column UNICALL.TB_APP.appno
  is '投保单号';
comment on column UNICALL.TB_APP.policyno
  is '保单号';
comment on column UNICALL.TB_APP.firstcreate
  is '创建时间';
comment on column UNICALL.TB_APP.lastupdate
  is '修改时间';
comment on column UNICALL.TB_APP.contents
  is '保单信息';
comment on column UNICALL.TB_APP.iana
  is '是否解析';
comment on column UNICALL.TB_APP.ierror
  is '解析是否正确';
comment on column UNICALL.TB_APP.isubmit
  is '是否提交';
comment on column UNICALL.TB_APP.iaccept
  is '是否同意';
comment on column UNICALL.TB_APP.ialter
  is '是否已修改 1是';
comment on column UNICALL.TB_APP.irepeal
  is '是否撤销  1是';
comment on column UNICALL.TB_APP.iupdate
  is '是否更新  1是';
comment on column UNICALL.TB_APP.app_status
  is '投保单状态';
comment on column UNICALL.TB_APP.prj_id
  is '项目ID';
comment on column UNICALL.TB_APP.outbound_usrid
  is '坐席工号';
comment on column UNICALL.TB_APP.site_status
  is '是否退回现场（00-自留处理，01-已经退回现场）';
comment on column UNICALL.TB_APP.pro_status
  is '是否在审核中（00-审核中，审核通过和审核不通过为NULL）';
comment on column UNICALL.TB_APP.org_id
  is '实现数据权限过滤';
create index UNICALL.IDX_TSRID on UNICALL.TB_APP (TSRID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 5M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 8M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_APPLICATION
prompt =============================
prompt
create table UNICALL.TB_APPLICATION
(
  application_id  VARCHAR2(18) not null,
  appno           VARCHAR2(18) not null,
  policyno        VARCHAR2(18),
  idorg           VARCHAR2(18),
  iddmsystem      VARCHAR2(24),
  iddmtype        VARCHAR2(4),
  firstcreate     DATE,
  lastupdate      DATE,
  isubmit         VARCHAR2(1),
  iaccept         VARCHAR2(1),
  recordstatus    VARCHAR2(2),
  tsrid           VARCHAR2(20),
  last_log        NUMBER(10),
  product_name    VARCHAR2(50),
  campaign_name   VARCHAR2(1024),
  vaildaty        VARCHAR2(10),
  ialter          VARCHAR2(1),
  irepeal         VARCHAR2(1),
  iupdate         VARCHAR2(1),
  app_status      VARCHAR2(3),
  prj_id          NUMBER(10),
  ai_rel          VARCHAR2(3),
  acus_licno      VARCHAR2(50),
  acus_mob        VARCHAR2(50),
  acus_gender     VARCHAR2(2),
  acus_name       VARCHAR2(200),
  icus_licno      VARCHAR2(50),
  icus_mob        VARCHAR2(50),
  icus_gender     VARCHAR2(2),
  icus_name       VARCHAR2(200),
  agent_id        VARCHAR2(50),
  total_fee       NUMBER(20,4),
  org_id          NUMBER(10),
  site_status     VARCHAR2(2),
  pro_status      VARCHAR2(2),
  is_del          VARCHAR2(1) default '0' not null,
  reserv_status   VARCHAR2(4),
  is_epolicy      VARCHAR2(2) default '0',
  epolicy_status  CHAR(2),
  is_realtime     VARCHAR2(2),
  tsrname         VARCHAR2(30),
  supervisor_id   VARCHAR2(20),
  supervisor_name VARCHAR2(30),
  product_type    VARCHAR2(5)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 18M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_APPLICATION
  is '投保单基本信息表';
comment on column UNICALL.TB_APPLICATION.application_id
  is '投保单ID';
comment on column UNICALL.TB_APPLICATION.appno
  is '投保单号';
comment on column UNICALL.TB_APPLICATION.policyno
  is '保单号';
comment on column UNICALL.TB_APPLICATION.idorg
  is '中支公司编码';
comment on column UNICALL.TB_APPLICATION.iddmsystem
  is '外部系统投保单ID';
comment on column UNICALL.TB_APPLICATION.iddmtype
  is '数据来源类型';
comment on column UNICALL.TB_APPLICATION.firstcreate
  is '创建时间';
comment on column UNICALL.TB_APPLICATION.lastupdate
  is '修改时间';
comment on column UNICALL.TB_APPLICATION.isubmit
  is '是否提交';
comment on column UNICALL.TB_APPLICATION.iaccept
  is '是否落地成功';
comment on column UNICALL.TB_APPLICATION.tsrid
  is '录单座席工号';
comment on column UNICALL.TB_APPLICATION.product_name
  is '产品名称';
comment on column UNICALL.TB_APPLICATION.campaign_name
  is '活动名称';
comment on column UNICALL.TB_APPLICATION.ialter
  is '是否已修改 1是';
comment on column UNICALL.TB_APPLICATION.irepeal
  is '是否撤销  1是';
comment on column UNICALL.TB_APPLICATION.iupdate
  is '是否更新  1是';
comment on column UNICALL.TB_APPLICATION.app_status
  is '投保单状态';
comment on column UNICALL.TB_APPLICATION.prj_id
  is '项目ID';
comment on column UNICALL.TB_APPLICATION.ai_rel
  is '投保人和被保人关系';
comment on column UNICALL.TB_APPLICATION.acus_licno
  is '投保人证件号';
comment on column UNICALL.TB_APPLICATION.acus_mob
  is '投保手机';
comment on column UNICALL.TB_APPLICATION.acus_gender
  is '投保人性别';
comment on column UNICALL.TB_APPLICATION.acus_name
  is '投保人姓名';
comment on column UNICALL.TB_APPLICATION.icus_licno
  is '被保人证件号';
comment on column UNICALL.TB_APPLICATION.icus_mob
  is '被保人投保手机';
comment on column UNICALL.TB_APPLICATION.icus_gender
  is '被保人性别';
comment on column UNICALL.TB_APPLICATION.icus_name
  is '被保人姓名';
comment on column UNICALL.TB_APPLICATION.agent_id
  is '业务员工号';
comment on column UNICALL.TB_APPLICATION.total_fee
  is '总保费';
comment on column UNICALL.TB_APPLICATION.org_id
  is '实现数据权限过滤';
comment on column UNICALL.TB_APPLICATION.site_status
  is '是否退回现场（00-自留处理，01-已经退回现场）';
comment on column UNICALL.TB_APPLICATION.pro_status
  is '00-审核中，审核通过和审核不通过为NULL';
comment on column UNICALL.TB_APPLICATION.is_del
  is '是否删除（0为否，1为是）';
comment on column UNICALL.TB_APPLICATION.reserv_status
  is '预约状态';
comment on column UNICALL.TB_APPLICATION.is_epolicy
  is '是否电子保单 0:否 1:是';
comment on column UNICALL.TB_APPLICATION.epolicy_status
  is '01 : 验证请求者身份失败;02:  处理电子保单失败;00:  表示生成电子保单成功;';
comment on column UNICALL.TB_APPLICATION.is_realtime
  is '是否是实时提交(0为否，1为是)';
comment on column UNICALL.TB_APPLICATION.tsrname
  is '坐席姓名';
comment on column UNICALL.TB_APPLICATION.supervisor_id
  is '主管工号';
comment on column UNICALL.TB_APPLICATION.supervisor_name
  is '主管姓名';
comment on column UNICALL.TB_APPLICATION.product_type
  is '款别';
create index UNICALL.ADD_IDX_TB_APPLICATION_COM2 on UNICALL.TB_APPLICATION (IDORG, APP_STATUS)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.ADD_IDX_TB_APPLICATION_IDDMS on UNICALL.TB_APPLICATION (IDDMSYSTEM)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_AGENT_ID on UNICALL.TB_APPLICATION (IDDMTYPE, AGENT_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
create unique index UNICALL.IDX_UNIQ_APPNO on UNICALL.TB_APPLICATION (APPNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APPLICATION
  add constraint PK_TB_APPLICATION primary key (APPLICATION_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 4M
    next 1M
    minextents 1
    maxextents unlimited
  );
grant select on UNICALL.TB_APPLICATION to SXDXETL;

prompt
prompt Creating table TB_CUSTOMER
prompt ==========================
prompt
create table UNICALL.TB_CUSTOMER
(
  customer_id  NUMBER(20) not null,
  name         VARCHAR2(50),
  mari         VARCHAR2(2),
  lic_typ      VARCHAR2(2),
  lic_no       VARCHAR2(50),
  birthday     VARCHAR2(30),
  gender       VARCHAR2(2),
  nation       VARCHAR2(50),
  huk          VARCHAR2(50),
  moto_flag    VARCHAR2(2),
  job_code     VARCHAR2(10),
  job_code_sec VARCHAR2(10),
  rev          VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on table UNICALL.TB_CUSTOMER
  is '客户基本信息表';
comment on column UNICALL.TB_CUSTOMER.name
  is '姓名';
comment on column UNICALL.TB_CUSTOMER.mari
  is '婚姻状况';
comment on column UNICALL.TB_CUSTOMER.lic_typ
  is '证件类型';
comment on column UNICALL.TB_CUSTOMER.lic_no
  is '证件号';
comment on column UNICALL.TB_CUSTOMER.birthday
  is '出生日期';
comment on column UNICALL.TB_CUSTOMER.gender
  is '性别';
comment on column UNICALL.TB_CUSTOMER.nation
  is '国籍';
comment on column UNICALL.TB_CUSTOMER.huk
  is '户口所在地';
comment on column UNICALL.TB_CUSTOMER.moto_flag
  is '是否以摩托车为交通工具';
comment on column UNICALL.TB_CUSTOMER.job_code
  is '职业代码';
comment on column UNICALL.TB_CUSTOMER.job_code_sec
  is '兼职职业代码';
create unique index UNICALL.IDX_UNIQ_CUSTOMER on UNICALL.TB_CUSTOMER (NAME, GENDER, BIRTHDAY, LIC_TYP, LIC_NO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.TB_CUSTOMER
  add constraint PK_TB_CUSTOMER primary key (CUSTOMER_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table TB_APPLICATION_CUSTOMER
prompt ======================================
prompt
create table UNICALL.TB_APPLICATION_CUSTOMER
(
  app_customer_id NUMBER(20) not null,
  customer_id     NUMBER(20),
  name            VARCHAR2(200),
  mari            VARCHAR2(3),
  lic_typ         VARCHAR2(2),
  lic_no          VARCHAR2(50),
  birthday        VARCHAR2(30),
  gender          VARCHAR2(2),
  nation          VARCHAR2(50),
  huk             VARCHAR2(300),
  moto_flag       VARCHAR2(2),
  job_code        VARCHAR2(10),
  job_code_sec    VARCHAR2(10),
  rev             VARCHAR2(100),
  height          NUMBER(6,2),
  weight          NUMBER(6,2),
  customer_typ    VARCHAR2(2) not null,
  con_addr_typ_id NUMBER(5),
  salary          NUMBER(20,4),
  company_name    VARCHAR2(100),
  id_start_date   DATE,
  id_end_date     DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 13M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_APPLICATION_CUSTOMER
  is '投保客户基本信息表';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.app_customer_id
  is '投保客户ID';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.customer_id
  is '客户ID';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.name
  is '姓名';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.mari
  is '婚姻状况';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.lic_typ
  is '证件类型';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.lic_no
  is '证件号';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.birthday
  is '出生日期';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.gender
  is '性别';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.nation
  is '国籍';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.huk
  is '户口所在地';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.moto_flag
  is '是否以摩托车为交通工具';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.job_code
  is '职业代码';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.job_code_sec
  is '兼职职业代码';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.height
  is '身高';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.weight
  is '体重';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.customer_typ
  is '投保客户类型 01：投保人；02：被保人';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.con_addr_typ_id
  is '联系地址类别';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.salary
  is '薪水';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.company_name
  is '单位名称';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.id_start_date
  is '证件有效起始日期';
comment on column UNICALL.TB_APPLICATION_CUSTOMER.id_end_date
  is '证件有效截止日期';
alter table UNICALL.TB_APPLICATION_CUSTOMER
  add constraint PK_TB_APPLICATION_CUSTOMER primary key (APP_CUSTOMER_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 4M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APPLICATION_CUSTOMER
  add constraint FK_TB_APPLI_REFERENCE_TB_CUSTO foreign key (CUSTOMER_ID)
  references UNICALL.TB_CUSTOMER (CUSTOMER_ID);

prompt
prompt Creating table TB_APPLINKTYPE
prompt =============================
prompt
create table UNICALL.TB_APPLINKTYPE
(
  id           VARCHAR2(4) not null,
  name         VARCHAR2(1024),
  recordstatus CHAR(1),
  a_order      CHAR(3),
  o_order      CHAR(3)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APPLINKTYPE
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_APPNO
prompt =======================
prompt
create table UNICALL.TB_APPNO
(
  id           VARCHAR2(18) not null,
  idorg        VARCHAR2(18),
  appdate      DATE,
  appcounter   INTEGER,
  lastupdate   DATE,
  recordstatus CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 640K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APPNO
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_APP_CHECKPOINT
prompt ================================
prompt
create table UNICALL.TB_APP_CHECKPOINT
(
  id                 VARCHAR2(18) not null,
  idapp              VARCHAR2(18),
  id_checkpoint_type VARCHAR2(4),
  checkpointtime     DATE,
  lastupdate         DATE,
  recordstatus       CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 21M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP_CHECKPOINT
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 7M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_CUSTOMER_ADDS_TYP
prompt ===================================
prompt
create table UNICALL.TB_CUSTOMER_ADDS_TYP
(
  cus_adds_typ_id NUMBER(5) not null,
  con_typ_nam     VARCHAR2(50),
  addr_typ_desc   VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_CUSTOMER_ADDS_TYP
  is '客户地址类型表';
comment on column UNICALL.TB_CUSTOMER_ADDS_TYP.cus_adds_typ_id
  is '地址类型ID';
comment on column UNICALL.TB_CUSTOMER_ADDS_TYP.con_typ_nam
  is '地址类型名';
comment on column UNICALL.TB_CUSTOMER_ADDS_TYP.addr_typ_desc
  is '地址类型描述';
alter table UNICALL.TB_CUSTOMER_ADDS_TYP
  add constraint PK_TB_CUSTOMER_ADDS_TYP primary key (CUS_ADDS_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_APP_CUSTOMER_ADDS
prompt ===================================
prompt
create table UNICALL.TB_APP_CUSTOMER_ADDS
(
  adds_id         NUMBER(10) not null,
  app_customer_id NUMBER(20),
  cus_adds_typ_id NUMBER(5),
  adds_contry     VARCHAR2(50),
  adds_province   VARCHAR2(50),
  adds_city       VARCHAR2(50),
  adds_detail     VARCHAR2(300),
  adds_note       VARCHAR2(100),
  adds_postcode   VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 20M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_APP_CUSTOMER_ADDS
  is '投保客户地址信息表';
comment on column UNICALL.TB_APP_CUSTOMER_ADDS.adds_id
  is '联系地址ID';
comment on column UNICALL.TB_APP_CUSTOMER_ADDS.app_customer_id
  is '投保客户ID';
comment on column UNICALL.TB_APP_CUSTOMER_ADDS.cus_adds_typ_id
  is '联系地址类型ID';
comment on column UNICALL.TB_APP_CUSTOMER_ADDS.adds_contry
  is '国家';
comment on column UNICALL.TB_APP_CUSTOMER_ADDS.adds_province
  is '省';
comment on column UNICALL.TB_APP_CUSTOMER_ADDS.adds_city
  is '市';
comment on column UNICALL.TB_APP_CUSTOMER_ADDS.adds_detail
  is '地址详细信息';
comment on column UNICALL.TB_APP_CUSTOMER_ADDS.adds_note
  is '地址备注';
comment on column UNICALL.TB_APP_CUSTOMER_ADDS.adds_postcode
  is '邮政编码';
create index UNICALL.IDX_CUSTOMER_ADDS_CUST_ID on UNICALL.TB_APP_CUSTOMER_ADDS (APP_CUSTOMER_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 11M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP_CUSTOMER_ADDS
  add constraint PK_TB_APP_CUSTOMER_ADDS primary key (ADDS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 11M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP_CUSTOMER_ADDS
  add constraint FK_TB_APP_C_REFERENCE_TB_APPL2 foreign key (APP_CUSTOMER_ID)
  references UNICALL.TB_APPLICATION_CUSTOMER (APP_CUSTOMER_ID);
alter table UNICALL.TB_APP_CUSTOMER_ADDS
  add constraint FK_TB_APP_C_REFERENCE_TB_CUST2 foreign key (CUS_ADDS_TYP_ID)
  references UNICALL.TB_CUSTOMER_ADDS_TYP (CUS_ADDS_TYP_ID);

prompt
prompt Creating table TB_CUSTOMER_CON_TYP
prompt ==================================
prompt
create table UNICALL.TB_CUSTOMER_CON_TYP
(
  cus_con_typ_id NUMBER(5) not null,
  con_typ_nam    VARCHAR2(50),
  con_typ_desc   VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_CUSTOMER_CON_TYP
  is '联系方式类别表';
comment on column UNICALL.TB_CUSTOMER_CON_TYP.cus_con_typ_id
  is '联系方式ID';
comment on column UNICALL.TB_CUSTOMER_CON_TYP.con_typ_nam
  is '联系方式名';
comment on column UNICALL.TB_CUSTOMER_CON_TYP.con_typ_desc
  is '联系方式描述';
alter table UNICALL.TB_CUSTOMER_CON_TYP
  add constraint PK_TB_CUSTOMER_CON_TYP primary key (CUS_CON_TYP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_APP_CUSTOMER_CONTACT
prompt ======================================
prompt
create table UNICALL.TB_APP_CUSTOMER_CONTACT
(
  cus_con_id      NUMBER(10) not null,
  app_customer_id NUMBER(20),
  cus_con_typ_id  NUMBER(5),
  con_value       VARCHAR2(50),
  con_note        VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 12M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_APP_CUSTOMER_CONTACT
  is '投保客户联系方式表';
comment on column UNICALL.TB_APP_CUSTOMER_CONTACT.cus_con_id
  is '联系方式ID';
comment on column UNICALL.TB_APP_CUSTOMER_CONTACT.app_customer_id
  is '投保客户ID';
comment on column UNICALL.TB_APP_CUSTOMER_CONTACT.cus_con_typ_id
  is '联系方式类型ID';
comment on column UNICALL.TB_APP_CUSTOMER_CONTACT.con_value
  is '联系方式值';
comment on column UNICALL.TB_APP_CUSTOMER_CONTACT.con_note
  is '联系方式备注';
create index UNICALL.IDX_CUSTOMER_CONTACT_CUST_ID on UNICALL.TB_APP_CUSTOMER_CONTACT (APP_CUSTOMER_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 11M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP_CUSTOMER_CONTACT
  add constraint PK_TB_APP_CUSTOMER_CONTACT primary key (CUS_CON_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 11M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP_CUSTOMER_CONTACT
  add constraint FK_TB_APP_C_REFERENCE_TB_APPLI foreign key (APP_CUSTOMER_ID)
  references UNICALL.TB_APPLICATION_CUSTOMER (APP_CUSTOMER_ID);
alter table UNICALL.TB_APP_CUSTOMER_CONTACT
  add constraint FK_TB_APP_C_REFERENCE_TB_CUSTO foreign key (CUS_CON_TYP_ID)
  references UNICALL.TB_CUSTOMER_CON_TYP (CUS_CON_TYP_ID);

prompt
prompt Creating table TB_APP_DTL
prompt =========================
prompt
create table UNICALL.TB_APP_DTL
(
  application_id VARCHAR2(18) not null,
  appno          VARCHAR2(18),
  policyno       VARCHAR2(18),
  app_typ        VARCHAR2(2),
  region_code    VARCHAR2(30),
  benefit_info   VARCHAR2(2048),
  add_fee        NUMBER(20,4),
  tmp_fee_no     VARCHAR2(24),
  main_plc_no    VARCHAR2(20),
  fst_pay_typ    VARCHAR2(2),
  oth_pay_typ    VARCHAR2(2),
  fee_agt_typ    VARCHAR2(2),
  fee_acc_bank   VARCHAR2(20),
  fee_acc_nam    VARCHAR2(200),
  fee_acc_no     VARCHAR2(50),
  late_choice    VARCHAR2(2),
  bonus_recv_typ VARCHAR2(2),
  death_func     VARCHAR2(2),
  argue_typ      VARCHAR2(2),
  trial_code     VARCHAR2(20),
  sale_cha       VARCHAR2(2),
  app_date       VARCHAR2(30),
  renewal_flag   VARCHAR2(2),
  back_info      VARCHAR2(512),
  special_clause VARCHAR2(1024),
  data_source    VARCHAR2(10),
  status         VARCHAR2(2) default '0' not null,
  app_operator   VARCHAR2(10),
  app_slip_typ   VARCHAR2(2) default 'D' not null,
  sale_src       VARCHAR2(2),
  pay_mod        VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 12M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_APP_DTL
  is '投保单详细信息表';
comment on column UNICALL.TB_APP_DTL.application_id
  is '投保单ID';
comment on column UNICALL.TB_APP_DTL.appno
  is '投保单号';
comment on column UNICALL.TB_APP_DTL.policyno
  is '保单号';
comment on column UNICALL.TB_APP_DTL.app_typ
  is '投保类型(1000)';
comment on column UNICALL.TB_APP_DTL.region_code
  is '区域编码';
comment on column UNICALL.TB_APP_DTL.benefit_info
  is '受益人信息';
comment on column UNICALL.TB_APP_DTL.add_fee
  is '追加保费（备用）';
comment on column UNICALL.TB_APP_DTL.tmp_fee_no
  is '暂收据号';
comment on column UNICALL.TB_APP_DTL.main_plc_no
  is '主险保单号';
comment on column UNICALL.TB_APP_DTL.fst_pay_typ
  is '首期支付方式';
comment on column UNICALL.TB_APP_DTL.oth_pay_typ
  is '续期支付方式';
comment on column UNICALL.TB_APP_DTL.fee_agt_typ
  is '缴费代缴形式';
comment on column UNICALL.TB_APP_DTL.fee_acc_bank
  is '缴费开户银行代码';
comment on column UNICALL.TB_APP_DTL.fee_acc_nam
  is '缴费开户名称';
comment on column UNICALL.TB_APP_DTL.fee_acc_no
  is '缴费账户';
comment on column UNICALL.TB_APP_DTL.late_choice
  is '保费逾期选择';
comment on column UNICALL.TB_APP_DTL.bonus_recv_typ
  is '红利领取方式';
comment on column UNICALL.TB_APP_DTL.death_func
  is '身故保险金功能选择';
comment on column UNICALL.TB_APP_DTL.argue_typ
  is '争议处理方式';
comment on column UNICALL.TB_APP_DTL.trial_code
  is '初审人员代码';
comment on column UNICALL.TB_APP_DTL.sale_cha
  is '销售渠道';
comment on column UNICALL.TB_APP_DTL.app_date
  is '投保日期';
comment on column UNICALL.TB_APP_DTL.renewal_flag
  is '是否自动续保';
comment on column UNICALL.TB_APP_DTL.back_info
  is '返回信息';
comment on column UNICALL.TB_APP_DTL.special_clause
  is '特别约定';
comment on column UNICALL.TB_APP_DTL.data_source
  is '数据来源';
comment on column UNICALL.TB_APP_DTL.status
  is 'P10报文状态';
comment on column UNICALL.TB_APP_DTL.app_operator
  is '操作员';
comment on column UNICALL.TB_APP_DTL.app_slip_typ
  is '投保单类型(2023)';
comment on column UNICALL.TB_APP_DTL.sale_src
  is '销售来源';
comment on column UNICALL.TB_APP_DTL.pay_mod
  is '收付模式';
alter table UNICALL.TB_APP_DTL
  add constraint PK_TB_APP_DTL primary key (APPLICATION_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 4M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP_DTL
  add constraint FK_TB_APP_D_REFERENCE_TB_APPLI foreign key (APPLICATION_ID)
  references UNICALL.TB_APPLICATION (APPLICATION_ID);

prompt
prompt Creating table TB_APP_EPOLICY_LOG
prompt =================================
prompt
create table UNICALL.TB_APP_EPOLICY_LOG
(
  id          VARCHAR2(20) not null,
  submit_time DATE,
  return_res  CHAR(2),
  policyno    VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.TB_APP_EPOLICY_LOG.return_res
  is '01 : 验证请求者身份失败;02:  处理电子保单失败;00:  表示生成电子保单成功;';
alter table UNICALL.TB_APP_EPOLICY_LOG
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_APP_LINK
prompt ==========================
prompt
create table UNICALL.TB_APP_LINK
(
  id              VARCHAR2(18) not null,
  idapp           VARCHAR2(18),
  id_appdata_type VARCHAR2(4),
  appdata         VARCHAR2(1024),
  lastupdate      DATE,
  recordstatus    CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 1300M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_TB_APP_LINK_IDAPP on UNICALL.TB_APP_LINK (IDAPP)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 689M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP_LINK
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 429M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_APP_LINK_HISTORY
prompt ==================================
prompt
create table UNICALL.TB_APP_LINK_HISTORY
(
  id              VARCHAR2(18) not null,
  idapp           VARCHAR2(18),
  id_appdata_type VARCHAR2(4),
  appdata         VARCHAR2(1024),
  lastupdate      DATE,
  recordstatus    CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 400M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_APP_LINK_HISTORY
  is 'tb_app_link归档表';
comment on column UNICALL.TB_APP_LINK_HISTORY.id
  is '序列号，主键';
comment on column UNICALL.TB_APP_LINK_HISTORY.idapp
  is 'tb_app主键';
comment on column UNICALL.TB_APP_LINK_HISTORY.id_appdata_type
  is '报文类型';
comment on column UNICALL.TB_APP_LINK_HISTORY.appdata
  is '报文数据';
comment on column UNICALL.TB_APP_LINK_HISTORY.lastupdate
  is '最后更新时间';
comment on column UNICALL.TB_APP_LINK_HISTORY.recordstatus
  is '状态';
create index UNICALL.IDX_TB_APP_LINK_HISTORY_IDAPP on UNICALL.TB_APP_LINK_HISTORY (IDAPP)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 223M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP_LINK_HISTORY
  add constraint PK_TB_APP_LINK_HISTORY primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 138M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_APP_LINK_RESULT
prompt =================================
prompt
create table UNICALL.TB_APP_LINK_RESULT
(
  id                           NUMBER(18) not null,
  idapp                        VARCHAR2(18),
  lastupdate                   DATE,
  recordstatus                 CHAR(1),
  app_type                     VARCHAR2(100),
  app_no                       VARCHAR2(100),
  app_nm                       VARCHAR2(30),
  marital_status               VARCHAR2(30),
  id_type                      VARCHAR2(30),
  id_no                        VARCHAR2(30),
  birthdate                    VARCHAR2(30),
  gender                       VARCHAR2(30),
  nationality                  VARCHAR2(30),
  family_addr                  VARCHAR2(200),
  family_post                  VARCHAR2(30),
  resident_area                VARCHAR2(200),
  work_unit_addr               VARCHAR2(200),
  work_unit_post               VARCHAR2(30),
  area_code                    VARCHAR2(30),
  address_type                 VARCHAR2(30),
  contact_addr                 VARCHAR2(200),
  contact_post                 VARCHAR2(30),
  contact_tel                  VARCHAR2(30),
  app_email                    VARCHAR2(100),
  app_mobile                   VARCHAR2(30),
  motorbike                    VARCHAR2(30),
  occupation_code              VARCHAR2(30),
  part_occupation_code         VARCHAR2(30),
  relationship_code            VARCHAR2(30),
  insured_nm                   VARCHAR2(30),
  insured_marital              VARCHAR2(30),
  insured_birthdate            VARCHAR2(30),
  insured_gender               VARCHAR2(30),
  insured_nationality          VARCHAR2(30),
  insured_id_type              VARCHAR2(30),
  insured_id_no                VARCHAR2(30),
  insured_family_addr          VARCHAR2(200),
  insured_family_post          VARCHAR2(30),
  insured_resident_area        VARCHAR2(200),
  insured_work_unit            VARCHAR2(200),
  insured_work_unit_post       VARCHAR2(30),
  insured_address_type         VARCHAR2(30),
  insured_contact_addr         VARCHAR2(200),
  insured_contact_post         VARCHAR2(30),
  insured_contact_tel          VARCHAR2(30),
  insured_email                VARCHAR2(100),
  insured_mobile               VARCHAR2(30),
  insured_motorbike            VARCHAR2(30),
  insured_occupation_code      VARCHAR2(30),
  insured_part_occupation_code VARCHAR2(30),
  bnfcry_info                  VARCHAR2(1024),
  product_info                 VARCHAR2(1024),
  cvrg_prem1                   VARCHAR2(30),
  ttl_prem                     VARCHAR2(30),
  temp_vouch_no                VARCHAR2(30),
  master_id                    VARCHAR2(30),
  first_payment_method         VARCHAR2(30),
  payment_method               VARCHAR2(30),
  payment_type                 VARCHAR2(30),
  payment_accout_bankcode      VARCHAR2(30),
  payment_accout_name          VARCHAR2(100),
  payment_accout               VARCHAR2(30),
  nfo_type                     VARCHAR2(30),
  bonus_option                 VARCHAR2(30),
  die_option                   VARCHAR2(30),
  doubt_method                 VARCHAR2(30),
  distributor_info             VARCHAR2(1024),
  first_confirm_code           VARCHAR2(30),
  sale_channel                 VARCHAR2(30),
  submit_date                  VARCHAR2(30),
  cvrg_auto                    VARCHAR2(30),
  health_notice                VARCHAR2(1024),
  special_content              VARCHAR2(1024),
  return_info                  VARCHAR2(1024),
  data_source                  VARCHAR2(30),
  sale_unit_num                VARCHAR2(30),
  sale_source                  VARCHAR2(30),
  ration_no                    VARCHAR2(30),
  health_notice2               VARCHAR2(1024),
  health_notice3               VARCHAR2(1024),
  health_notice4               VARCHAR2(1024),
  health_notice5               VARCHAR2(1024),
  health_notice6               VARCHAR2(1024),
  is_special1                  VARCHAR2(30),
  is_special2                  VARCHAR2(30),
  is_special3                  VARCHAR2(30),
  is_special4                  VARCHAR2(30),
  is_special5                  VARCHAR2(30),
  is_check_error               VARCHAR2(30),
  save_field1                  VARCHAR2(30),
  save_field2                  VARCHAR2(30),
  save_field3                  VARCHAR2(30),
  save_field4                  VARCHAR2(30),
  status                       VARCHAR2(30),
  pay_mode                     VARCHAR2(30),
  oper_id                      VARCHAR2(30),
  insurance_type               VARCHAR2(30),
  work_tel                     VARCHAR2(30),
  work_unit_nm                 VARCHAR2(100),
  insured_unit_tel             VARCHAR2(30),
  insured_unit_nm              VARCHAR2(100),
  family_tel                   VARCHAR2(30),
  insured_family_tel           VARCHAR2(30),
  audit_sta                    VARCHAR2(2),
  app_status                   VARCHAR2(3)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 120M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_APP_LINK_RESULT
  is '投保单改造后的横表';
comment on column UNICALL.TB_APP_LINK_RESULT.app_type
  is '投保类型';
comment on column UNICALL.TB_APP_LINK_RESULT.app_no
  is '投保单号/定额保单号';
comment on column UNICALL.TB_APP_LINK_RESULT.app_nm
  is '投保人姓名';
comment on column UNICALL.TB_APP_LINK_RESULT.marital_status
  is '投保人婚姻状况';
comment on column UNICALL.TB_APP_LINK_RESULT.id_type
  is '有效证件类型';
comment on column UNICALL.TB_APP_LINK_RESULT.id_no
  is '投保人证件号';
comment on column UNICALL.TB_APP_LINK_RESULT.birthdate
  is '投保人出生日期';
comment on column UNICALL.TB_APP_LINK_RESULT.gender
  is '投保人性别';
comment on column UNICALL.TB_APP_LINK_RESULT.nationality
  is '投保人国籍';
comment on column UNICALL.TB_APP_LINK_RESULT.family_addr
  is '投保人家庭地址';
comment on column UNICALL.TB_APP_LINK_RESULT.family_post
  is '投保人家庭邮编';
comment on column UNICALL.TB_APP_LINK_RESULT.resident_area
  is '投保人户口所在地';
comment on column UNICALL.TB_APP_LINK_RESULT.work_unit_addr
  is '投保人服务单位地址';
comment on column UNICALL.TB_APP_LINK_RESULT.work_unit_post
  is '投保人单位邮编';
comment on column UNICALL.TB_APP_LINK_RESULT.area_code
  is '区域编码';
comment on column UNICALL.TB_APP_LINK_RESULT.address_type
  is '联系地址类别';
comment on column UNICALL.TB_APP_LINK_RESULT.contact_addr
  is '投保人联系地址';
comment on column UNICALL.TB_APP_LINK_RESULT.contact_post
  is '投保人联系邮编';
comment on column UNICALL.TB_APP_LINK_RESULT.contact_tel
  is '投保人联系电话';
comment on column UNICALL.TB_APP_LINK_RESULT.app_email
  is '投保人E_mail';
comment on column UNICALL.TB_APP_LINK_RESULT.app_mobile
  is '投保人手机';
comment on column UNICALL.TB_APP_LINK_RESULT.motorbike
  is '是否以摩托车为交通工具';
comment on column UNICALL.TB_APP_LINK_RESULT.occupation_code
  is '投保人职业代码';
comment on column UNICALL.TB_APP_LINK_RESULT.part_occupation_code
  is '兼职职业代码';
comment on column UNICALL.TB_APP_LINK_RESULT.relationship_code
  is '投保人和被保人关系代码';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_nm
  is '被保人姓名';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_marital
  is '被保人婚姻状况';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_birthdate
  is '被保人出生日期';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_gender
  is '被保人性别';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_nationality
  is '被保人国籍';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_id_type
  is '有效证件类型';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_id_no
  is '被保人证件号';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_family_addr
  is '被保人家庭地址';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_family_post
  is '被保人家庭邮编';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_resident_area
  is '被保人户口所在地';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_work_unit
  is '被保人服务单位或就读学校';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_work_unit_post
  is '被保人服务单位邮编';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_address_type
  is '联系地址类别';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_contact_addr
  is '被保人联系地址';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_contact_post
  is '被保人联系邮编';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_contact_tel
  is '被保人联系电话';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_email
  is '被保人E_mail';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_mobile
  is '被保人手机';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_motorbike
  is '被保人是否以摩托车为交通工具';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_occupation_code
  is '被保人职业代码';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_part_occupation_code
  is '兼职职业代码';
comment on column UNICALL.TB_APP_LINK_RESULT.bnfcry_info
  is '受益人信息';
comment on column UNICALL.TB_APP_LINK_RESULT.product_info
  is '产品信息';
comment on column UNICALL.TB_APP_LINK_RESULT.cvrg_prem1
  is '追加保费';
comment on column UNICALL.TB_APP_LINK_RESULT.ttl_prem
  is '总保费';
comment on column UNICALL.TB_APP_LINK_RESULT.temp_vouch_no
  is '暂收费收据号';
comment on column UNICALL.TB_APP_LINK_RESULT.master_id
  is '主险保单号';
comment on column UNICALL.TB_APP_LINK_RESULT.first_payment_method
  is '首期支付方式';
comment on column UNICALL.TB_APP_LINK_RESULT.payment_method
  is '续期支付方式';
comment on column UNICALL.TB_APP_LINK_RESULT.payment_type
  is '缴费代缴形式';
comment on column UNICALL.TB_APP_LINK_RESULT.payment_accout_bankcode
  is '缴费开户银行代码';
comment on column UNICALL.TB_APP_LINK_RESULT.payment_accout_name
  is '缴费开户名称';
comment on column UNICALL.TB_APP_LINK_RESULT.payment_accout
  is '缴费账户';
comment on column UNICALL.TB_APP_LINK_RESULT.nfo_type
  is '保费逾期选择';
comment on column UNICALL.TB_APP_LINK_RESULT.bonus_option
  is '红利领取方式';
comment on column UNICALL.TB_APP_LINK_RESULT.die_option
  is '身故保险金功能选择';
comment on column UNICALL.TB_APP_LINK_RESULT.doubt_method
  is '争议处理方式';
comment on column UNICALL.TB_APP_LINK_RESULT.distributor_info
  is '业务员信息';
comment on column UNICALL.TB_APP_LINK_RESULT.first_confirm_code
  is '初审人员代码';
comment on column UNICALL.TB_APP_LINK_RESULT.sale_channel
  is '销售渠道';
comment on column UNICALL.TB_APP_LINK_RESULT.submit_date
  is '投保日期';
comment on column UNICALL.TB_APP_LINK_RESULT.cvrg_auto
  is '是否自动续保';
comment on column UNICALL.TB_APP_LINK_RESULT.health_notice
  is '健康告知';
comment on column UNICALL.TB_APP_LINK_RESULT.special_content
  is '特别约定';
comment on column UNICALL.TB_APP_LINK_RESULT.return_info
  is '返回信息';
comment on column UNICALL.TB_APP_LINK_RESULT.data_source
  is '数据来源';
comment on column UNICALL.TB_APP_LINK_RESULT.sale_unit_num
  is '销售单位投保序号';
comment on column UNICALL.TB_APP_LINK_RESULT.sale_source
  is '销售来源';
comment on column UNICALL.TB_APP_LINK_RESULT.ration_no
  is '定额保单号';
comment on column UNICALL.TB_APP_LINK_RESULT.health_notice2
  is '是否有健康告知2';
comment on column UNICALL.TB_APP_LINK_RESULT.health_notice3
  is '是否有健康告知3';
comment on column UNICALL.TB_APP_LINK_RESULT.health_notice4
  is '是否有健康告知4';
comment on column UNICALL.TB_APP_LINK_RESULT.health_notice5
  is '是否有健康告知5';
comment on column UNICALL.TB_APP_LINK_RESULT.health_notice6
  is '是否有健康告知6';
comment on column UNICALL.TB_APP_LINK_RESULT.is_special1
  is '是否有特约';
comment on column UNICALL.TB_APP_LINK_RESULT.is_special2
  is '是否有特约';
comment on column UNICALL.TB_APP_LINK_RESULT.is_special3
  is '是否有特约';
comment on column UNICALL.TB_APP_LINK_RESULT.is_special4
  is '是否有特约';
comment on column UNICALL.TB_APP_LINK_RESULT.is_special5
  is '是否有特约';
comment on column UNICALL.TB_APP_LINK_RESULT.is_check_error
  is '是否有校验代码错误';
comment on column UNICALL.TB_APP_LINK_RESULT.save_field1
  is '保留字段';
comment on column UNICALL.TB_APP_LINK_RESULT.save_field2
  is '保留字段';
comment on column UNICALL.TB_APP_LINK_RESULT.save_field3
  is '保留字段';
comment on column UNICALL.TB_APP_LINK_RESULT.save_field4
  is '保留字段';
comment on column UNICALL.TB_APP_LINK_RESULT.status
  is '状态';
comment on column UNICALL.TB_APP_LINK_RESULT.pay_mode
  is '收付模式';
comment on column UNICALL.TB_APP_LINK_RESULT.oper_id
  is '操作员';
comment on column UNICALL.TB_APP_LINK_RESULT.insurance_type
  is '投保类型';
comment on column UNICALL.TB_APP_LINK_RESULT.work_tel
  is '投保人单位电话';
comment on column UNICALL.TB_APP_LINK_RESULT.work_unit_nm
  is '投保人单位名称';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_unit_tel
  is '被保险人单位电话';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_unit_nm
  is '被保人单位名称';
comment on column UNICALL.TB_APP_LINK_RESULT.family_tel
  is '投保人家庭电话';
comment on column UNICALL.TB_APP_LINK_RESULT.insured_family_tel
  is '被保人家庭电话';
comment on column UNICALL.TB_APP_LINK_RESULT.audit_sta
  is '审核状态';
comment on column UNICALL.TB_APP_LINK_RESULT.app_status
  is '投保单状态';
alter table UNICALL.TB_APP_LINK_RESULT
  add constraint PID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_APP_PROBLEM_REQ
prompt =================================
prompt
create table UNICALL.TB_APP_PROBLEM_REQ
(
  id          NUMBER(18) not null,
  appid       VARCHAR2(18) not null,
  result1     VARCHAR2(2),
  remark2     VARCHAR2(300),
  input_date  DATE,
  input_user  VARCHAR2(20),
  remark1     VARCHAR2(4000),
  update_date DATE,
  update_user VARCHAR2(20),
  result2     VARCHAR2(2) default 00,
  remark3     VARCHAR2(255)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_APP_PROBLEM_REQ
  is '问题件处理申请';
comment on column UNICALL.TB_APP_PROBLEM_REQ.id
  is '申请处理流水号';
comment on column UNICALL.TB_APP_PROBLEM_REQ.appid
  is '投保单ID';
comment on column UNICALL.TB_APP_PROBLEM_REQ.result1
  is '申请处理结果(00-客户来电撤单,01-撤单,02-重新核保,03-继续扣款,04-重新递送)';
comment on column UNICALL.TB_APP_PROBLEM_REQ.remark2
  is '申请处理备注';
comment on column UNICALL.TB_APP_PROBLEM_REQ.input_date
  is '创建时间';
comment on column UNICALL.TB_APP_PROBLEM_REQ.input_user
  is '创建用户';
comment on column UNICALL.TB_APP_PROBLEM_REQ.remark1
  is '程序处理备注';
comment on column UNICALL.TB_APP_PROBLEM_REQ.update_date
  is '更新时间';
comment on column UNICALL.TB_APP_PROBLEM_REQ.update_user
  is '更新用户';
comment on column UNICALL.TB_APP_PROBLEM_REQ.result2
  is '电销处理结果(00-审核中,01-审核通过,02-审核不通过)';
comment on column UNICALL.TB_APP_PROBLEM_REQ.remark3
  is '电销处理备注';
create index UNICALL.IDX_PROBLEM_REQ_APP_ID on UNICALL.TB_APP_PROBLEM_REQ (APPID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP_PROBLEM_REQ
  add constraint PK_TB_APP_PROBLEM_REQ_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP_PROBLEM_REQ
  add constraint FK_TB_APP_PROBLEM_REQ_01 foreign key (APPID)
  references UNICALL.TB_APPLICATION (APPLICATION_ID);

prompt
prompt Creating table TB_APP_LINK_RESULT_REQ
prompt =====================================
prompt
create table UNICALL.TB_APP_LINK_RESULT_REQ
(
  id                           NUMBER(18) not null,
  idapp                        VARCHAR2(18),
  lastupdate                   DATE,
  recordstatus                 CHAR(1),
  app_type                     VARCHAR2(100),
  app_no                       VARCHAR2(100),
  app_nm                       VARCHAR2(30),
  marital_status               VARCHAR2(30),
  id_type                      VARCHAR2(30),
  id_no                        VARCHAR2(30),
  birthdate                    VARCHAR2(30),
  gender                       VARCHAR2(30),
  nationality                  VARCHAR2(30),
  family_addr                  VARCHAR2(200),
  family_post                  VARCHAR2(30),
  resident_area                VARCHAR2(200),
  work_unit_addr               VARCHAR2(200),
  work_unit_post               VARCHAR2(30),
  area_code                    VARCHAR2(30),
  address_type                 VARCHAR2(30),
  contact_addr                 VARCHAR2(200),
  contact_post                 VARCHAR2(30),
  contact_tel                  VARCHAR2(30),
  app_email                    VARCHAR2(100),
  app_mobile                   VARCHAR2(30),
  motorbike                    VARCHAR2(30),
  occupation_code              VARCHAR2(30),
  part_occupation_code         VARCHAR2(30),
  relationship_code            VARCHAR2(30),
  insured_nm                   VARCHAR2(30),
  insured_marital              VARCHAR2(30),
  insured_birthdate            VARCHAR2(30),
  insured_gender               VARCHAR2(30),
  insured_nationality          VARCHAR2(30),
  insured_id_type              VARCHAR2(30),
  insured_id_no                VARCHAR2(30),
  insured_family_addr          VARCHAR2(200),
  insured_family_post          VARCHAR2(30),
  insured_resident_area        VARCHAR2(200),
  insured_work_unit            VARCHAR2(200),
  insured_work_unit_post       VARCHAR2(30),
  insured_address_type         VARCHAR2(30),
  insured_contact_addr         VARCHAR2(200),
  insured_contact_post         VARCHAR2(30),
  insured_contact_tel          VARCHAR2(30),
  insured_email                VARCHAR2(100),
  insured_mobile               VARCHAR2(30),
  insured_motorbike            VARCHAR2(30),
  insured_occupation_code      VARCHAR2(30),
  insured_part_occupation_code VARCHAR2(30),
  bnfcry_info                  VARCHAR2(1024),
  product_info                 VARCHAR2(1024),
  cvrg_prem1                   VARCHAR2(30),
  ttl_prem                     VARCHAR2(30),
  temp_vouch_no                VARCHAR2(30),
  master_id                    VARCHAR2(30),
  first_payment_method         VARCHAR2(30),
  payment_method               VARCHAR2(30),
  payment_type                 VARCHAR2(30),
  payment_accout_bankcode      VARCHAR2(30),
  payment_accout_name          VARCHAR2(100),
  payment_accout               VARCHAR2(30),
  nfo_type                     VARCHAR2(30),
  bonus_option                 VARCHAR2(30),
  die_option                   VARCHAR2(30),
  doubt_method                 VARCHAR2(30),
  distributor_info             VARCHAR2(1024),
  first_confirm_code           VARCHAR2(30),
  sale_channel                 VARCHAR2(30),
  submit_date                  VARCHAR2(30),
  cvrg_auto                    VARCHAR2(30),
  health_notice                VARCHAR2(1024),
  special_content              VARCHAR2(1024),
  return_info                  VARCHAR2(1024),
  data_source                  VARCHAR2(30),
  sale_unit_num                VARCHAR2(30),
  sale_source                  VARCHAR2(30),
  ration_no                    VARCHAR2(30),
  health_notice2               VARCHAR2(1024),
  health_notice3               VARCHAR2(1024),
  health_notice4               VARCHAR2(1024),
  health_notice5               VARCHAR2(1024),
  health_notice6               VARCHAR2(1024),
  is_special1                  VARCHAR2(30),
  is_special2                  VARCHAR2(30),
  is_special3                  VARCHAR2(30),
  is_special4                  VARCHAR2(30),
  is_special5                  VARCHAR2(30),
  is_check_error               VARCHAR2(30),
  save_field1                  VARCHAR2(30),
  save_field2                  VARCHAR2(30),
  save_field3                  VARCHAR2(30),
  save_field4                  VARCHAR2(30),
  status                       VARCHAR2(30),
  pay_mode                     VARCHAR2(30),
  oper_id                      VARCHAR2(30),
  insurance_type               VARCHAR2(30),
  work_tel                     VARCHAR2(30),
  work_unit_nm                 VARCHAR2(100),
  insured_unit_tel             VARCHAR2(30),
  insured_unit_nm              VARCHAR2(100),
  family_tel                   VARCHAR2(30),
  insured_family_tel           VARCHAR2(30),
  audit_sta                    VARCHAR2(2),
  app_status                   VARCHAR2(3),
  reqid                        NUMBER(18),
  lastlog                      VARCHAR2(30),
  iddmsystem                   VARCHAR2(30),
  idorg                        VARCHAR2(30),
  idno_stadate                 DATE,
  idno_enddate                 DATE,
  insidno_stadate              DATE,
  insidno_enddate              DATE,
  is_epolicy                   VARCHAR2(2),
  product_type                 VARCHAR2(5),
  tsrname                      VARCHAR2(30),
  supervisor_id                VARCHAR2(20),
  supervisor_name              VARCHAR2(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.TB_APP_LINK_RESULT_REQ.product_type
  is '款别';
comment on column UNICALL.TB_APP_LINK_RESULT_REQ.tsrname
  is '坐席姓名';
comment on column UNICALL.TB_APP_LINK_RESULT_REQ.supervisor_id
  is '主管工号';
comment on column UNICALL.TB_APP_LINK_RESULT_REQ.supervisor_name
  is '主管姓名';
alter table UNICALL.TB_APP_LINK_RESULT_REQ
  add constraint PK_TB_APP_LINK_RESULT_REQ primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP_LINK_RESULT_REQ
  add constraint FK_TB_APP_LINK_RESULT_REQ_01 foreign key (REQID)
  references UNICALL.TB_APP_PROBLEM_REQ (ID);

prompt
prompt Creating table TB_APP_LINK_TEMP
prompt ===============================
prompt
create table UNICALL.TB_APP_LINK_TEMP
(
  id                           VARCHAR2(18),
  idapp                        VARCHAR2(18),
  lastupdate                   DATE,
  recordstatus                 CHAR(1),
  app_type                     VARCHAR2(500),
  app_no                       VARCHAR2(500),
  app_nm                       VARCHAR2(500),
  marital_status               VARCHAR2(500),
  id_type                      VARCHAR2(500),
  id_no                        VARCHAR2(500),
  birthdate                    VARCHAR2(500),
  gender                       VARCHAR2(500),
  nationality                  VARCHAR2(500),
  family_addr                  VARCHAR2(500),
  family_post                  VARCHAR2(500),
  resident_area                VARCHAR2(500),
  work_unit_addr               VARCHAR2(500),
  work_unit_post               VARCHAR2(500),
  area_code                    VARCHAR2(500),
  address_type                 VARCHAR2(500),
  contact_addr                 VARCHAR2(500),
  contact_post                 VARCHAR2(500),
  contact_tel                  VARCHAR2(500),
  app_email                    VARCHAR2(500),
  app_mobile                   VARCHAR2(500),
  motorbike                    VARCHAR2(500),
  occupation_code              VARCHAR2(500),
  part_occupation_code         VARCHAR2(500),
  relationship_code            VARCHAR2(500),
  insured_nm                   VARCHAR2(500),
  insured_marital              VARCHAR2(500),
  insured_birthdate            VARCHAR2(500),
  insured_gender               VARCHAR2(500),
  insured_nationality          VARCHAR2(500),
  insured_id_type              VARCHAR2(500),
  insured_id_no                VARCHAR2(500),
  insured_family_addr          VARCHAR2(500),
  insured_family_post          VARCHAR2(500),
  insured_resident_area        VARCHAR2(500),
  insured_work_unit            VARCHAR2(500),
  insured_work_unit_post       VARCHAR2(500),
  insured_address_type         VARCHAR2(500),
  insured_contact_addr         VARCHAR2(500),
  insured_contact_post         VARCHAR2(500),
  insured_contact_tel          VARCHAR2(500),
  insured_email                VARCHAR2(500),
  insured_mobile               VARCHAR2(500),
  insured_motorbike            VARCHAR2(500),
  insured_occupation_code      VARCHAR2(500),
  insured_part_occupation_code VARCHAR2(500),
  bnfcry_info                  VARCHAR2(500),
  product_info                 VARCHAR2(500),
  cvrg_prem1                   VARCHAR2(500),
  ttl_prem                     VARCHAR2(500),
  temp_vouch_no                VARCHAR2(500),
  master_id                    VARCHAR2(500),
  first_payment_method         VARCHAR2(500),
  payment_method               VARCHAR2(500),
  payment_type                 VARCHAR2(500),
  payment_accout_bankcode      VARCHAR2(500),
  payment_accout_name          VARCHAR2(500),
  payment_accout               VARCHAR2(500),
  nfo_type                     VARCHAR2(500),
  bonus_option                 VARCHAR2(500),
  die_option                   VARCHAR2(500),
  doubt_method                 VARCHAR2(500),
  distributor_info             VARCHAR2(500),
  first_confirm_code           VARCHAR2(500),
  sale_channel                 VARCHAR2(500),
  submit_date                  VARCHAR2(500),
  cvrg_auto                    VARCHAR2(500),
  health_notice                VARCHAR2(500),
  special_content              VARCHAR2(500),
  return_info                  VARCHAR2(500),
  data_source                  VARCHAR2(500),
  sale_unit_num                VARCHAR2(500),
  sale_source                  VARCHAR2(500),
  ration_no                    VARCHAR2(500),
  health_notice2               VARCHAR2(500),
  health_notice3               VARCHAR2(500),
  health_notice4               VARCHAR2(500),
  health_notice5               VARCHAR2(500),
  health_notice6               VARCHAR2(500),
  is_special1                  VARCHAR2(500),
  is_special2                  VARCHAR2(500),
  is_special3                  VARCHAR2(500),
  is_special4                  VARCHAR2(500),
  is_special5                  VARCHAR2(500),
  is_check_error               VARCHAR2(500),
  save_field1                  VARCHAR2(500),
  save_field2                  VARCHAR2(500),
  save_field3                  VARCHAR2(500),
  save_field4                  VARCHAR2(500),
  status                       VARCHAR2(500),
  pay_mode                     VARCHAR2(500),
  oper_id                      VARCHAR2(500),
  insurance_type               VARCHAR2(500),
  work_tel                     VARCHAR2(500),
  work_unit_nm                 VARCHAR2(500),
  insured_unit_tel             VARCHAR2(500),
  insured_unit_nm              VARCHAR2(500),
  family_tel                   VARCHAR2(500),
  insured_family_tel           VARCHAR2(500)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table TB_APP_PRD_INFO
prompt ==============================
prompt
create table UNICALL.TB_APP_PRD_INFO
(
  app_prd_id     NUMBER(20) not null,
  application_id VARCHAR2(18),
  ins_code       VARCHAR2(8),
  main_flag      VARCHAR2(1),
  amount         NUMBER(20,4),
  pay_lev        NUMBER(20,4),
  job_fee        NUMBER(20,4),
  pay_typ        VARCHAR2(2),
  pay_period     VARCHAR2(2),
  ins_period     VARCHAR2(10),
  ins_perd_typ   VARCHAR2(3),
  recv_typ       VARCHAR2(3),
  recv_age       NUMBER(3),
  fixed_plc_no   VARCHAR2(18),
  pieces         NUMBER(6,1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 9M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_APP_PRD_INFO
  is '投保单产品信息表';
comment on column UNICALL.TB_APP_PRD_INFO.application_id
  is '投保单ID';
comment on column UNICALL.TB_APP_PRD_INFO.ins_code
  is '险种代码';
comment on column UNICALL.TB_APP_PRD_INFO.main_flag
  is '主附险标志';
comment on column UNICALL.TB_APP_PRD_INFO.amount
  is '保额';
comment on column UNICALL.TB_APP_PRD_INFO.pay_lev
  is '缴费标准';
comment on column UNICALL.TB_APP_PRD_INFO.job_fee
  is '职业加费';
comment on column UNICALL.TB_APP_PRD_INFO.pay_typ
  is '缴费方式';
comment on column UNICALL.TB_APP_PRD_INFO.pay_period
  is '缴费年限';
comment on column UNICALL.TB_APP_PRD_INFO.ins_period
  is '保险期间';
comment on column UNICALL.TB_APP_PRD_INFO.ins_perd_typ
  is '保险期间类型';
comment on column UNICALL.TB_APP_PRD_INFO.recv_typ
  is '领取方式';
comment on column UNICALL.TB_APP_PRD_INFO.recv_age
  is '领取年龄';
comment on column UNICALL.TB_APP_PRD_INFO.fixed_plc_no
  is '定额保单序号(默认00)';
comment on column UNICALL.TB_APP_PRD_INFO.pieces
  is '份数';
create index UNICALL.IDX_PRD_APP_ID on UNICALL.TB_APP_PRD_INFO (APPLICATION_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 6M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_TB_APP_PRD_INFO_INS_CODE on UNICALL.TB_APP_PRD_INFO (INS_CODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP_PRD_INFO
  add constraint PK_TB_APP_PRD_INFO primary key (APP_PRD_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_APP_PRD_INFO
  add constraint FK_TB_APP_P_REFERENCE_TB_APPLI foreign key (APPLICATION_ID)
  references UNICALL.TB_APPLICATION (APPLICATION_ID);
grant select on UNICALL.TB_APP_PRD_INFO to SXDXETL;

prompt
prompt Creating table TB_AUTO_BATCH_LOG
prompt ================================
prompt
create table UNICALL.TB_AUTO_BATCH_LOG
(
  id          NUMBER(18) not null,
  file_name   VARCHAR2(1024) not null,
  total_count NUMBER(10),
  succ_count  NUMBER(10),
  fail_count  NUMBER(10),
  log_type    NUMBER(1) not null,
  comments    VARCHAR2(1024),
  log_time    DATE not null,
  mod_typ     NUMBER(2) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_AUTO_BATCH_LOG
  is '数据接口日志表';
comment on column UNICALL.TB_AUTO_BATCH_LOG.file_name
  is '文件名';
comment on column UNICALL.TB_AUTO_BATCH_LOG.total_count
  is '总数据量';
comment on column UNICALL.TB_AUTO_BATCH_LOG.succ_count
  is '成功数量';
comment on column UNICALL.TB_AUTO_BATCH_LOG.fail_count
  is '失败数量';
comment on column UNICALL.TB_AUTO_BATCH_LOG.log_type
  is '文件传输类型：1：接收  2：发送';
comment on column UNICALL.TB_AUTO_BATCH_LOG.comments
  is '备注';
comment on column UNICALL.TB_AUTO_BATCH_LOG.log_time
  is '日志记录时间';
comment on column UNICALL.TB_AUTO_BATCH_LOG.mod_typ
  is '功能模块：1：行销赠险导入  2：赠险供数  3：禁拨供数  4:营销供数';
alter table UNICALL.TB_AUTO_BATCH_LOG
  add constraint PK_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_BANK
prompt ======================
prompt
create table UNICALL.TB_BANK
(
  id           VARCHAR2(4) not null,
  name         VARCHAR2(1024),
  recordstatus CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_BANK
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_BANKCOMM_EMPNO
prompt ================================
prompt
create table UNICALL.TB_BANKCOMM_EMPNO
(
  id              NUMBER(18) not null,
  cha             VARCHAR2(20) not null,
  empno           VARCHAR2(20) not null,
  careate_user_id NUMBER(10),
  update_user_id  NUMBER(10),
  create_time     DATE,
  update_time     DATE,
  is_del          NUMBER(1) default 0
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_BANKCOMM_EMPNO
  is '银保通业务员工号';
comment on column UNICALL.TB_BANKCOMM_EMPNO.id
  is 'ID';
comment on column UNICALL.TB_BANKCOMM_EMPNO.cha
  is '渠道';
comment on column UNICALL.TB_BANKCOMM_EMPNO.empno
  is '业务员工号';
comment on column UNICALL.TB_BANKCOMM_EMPNO.careate_user_id
  is '创建人ID';
comment on column UNICALL.TB_BANKCOMM_EMPNO.update_user_id
  is '更新人ID';
comment on column UNICALL.TB_BANKCOMM_EMPNO.create_time
  is '创建时间';
comment on column UNICALL.TB_BANKCOMM_EMPNO.update_time
  is '更新时间';
comment on column UNICALL.TB_BANKCOMM_EMPNO.is_del
  is '0：正常 1：删除';
alter table UNICALL.TB_BANKCOMM_EMPNO
  add constraint PK_BANKCOMM_EMPNO primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_BATCH_FILE_LOG
prompt ================================
prompt
create table UNICALL.TB_BATCH_FILE_LOG
(
  id                NUMBER(10) not null,
  ob_com_name       VARCHAR2(1024),
  ob_com_id         NUMBER(10),
  cus_gro_id        NUMBER(10),
  use_ali_id        VARCHAR2(20),
  cus_file_name     VARCHAR2(1000),
  btch_file_name    VARCHAR2(1000),
  ana_flag          CHAR(1),
  err_log           VARCHAR2(1024),
  is_submit         CHAR(1),
  submit_date       DATE,
  submit_flag       CHAR(1),
  cus_rar_file_name VARCHAR2(1000),
  create_time       DATE,
  log_type          NUMBER(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_BATCH_FILE_LOG
  is '名单自动上载日志表';
comment on column UNICALL.TB_BATCH_FILE_LOG.ob_com_name
  is '活动名称';
comment on column UNICALL.TB_BATCH_FILE_LOG.ob_com_id
  is '活动ID';
comment on column UNICALL.TB_BATCH_FILE_LOG.cus_gro_id
  is '名单列表ID';
comment on column UNICALL.TB_BATCH_FILE_LOG.use_ali_id
  is '上载人';
comment on column UNICALL.TB_BATCH_FILE_LOG.cus_file_name
  is '客户名单文件名称';
comment on column UNICALL.TB_BATCH_FILE_LOG.btch_file_name
  is '批次文件名称';
comment on column UNICALL.TB_BATCH_FILE_LOG.ana_flag
  is '批次数据是否正确 0:否，1:是';
comment on column UNICALL.TB_BATCH_FILE_LOG.err_log
  is '批次数据失败原因';
comment on column UNICALL.TB_BATCH_FILE_LOG.is_submit
  is '客户名单是否已解析 0:否，1:是';
comment on column UNICALL.TB_BATCH_FILE_LOG.submit_date
  is '客户名单上载时间';
comment on column UNICALL.TB_BATCH_FILE_LOG.submit_flag
  is '客户名单上载结果 0:失败，1:成功';
comment on column UNICALL.TB_BATCH_FILE_LOG.cus_rar_file_name
  is '客户名单压缩包文件名称';
comment on column UNICALL.TB_BATCH_FILE_LOG.create_time
  is '创建时间';
comment on column UNICALL.TB_BATCH_FILE_LOG.log_type
  is '1:批次数据，2：错误日志数据';
alter table UNICALL.TB_BATCH_FILE_LOG
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_BIZ_NO
prompt ========================
prompt
create table UNICALL.TB_BIZ_NO
(
  id             NUMBER(10) not null,
  bank_id        VARCHAR2(4),
  ins_code       VARCHAR2(10),
  biz_no         VARCHAR2(50),
  biz_product_no VARCHAR2(50)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_BIZ_NO
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_BRANCH_ABBRE
prompt ==============================
prompt
create table UNICALL.TB_BRANCH_ABBRE
(
  id           NUMBER(10) not null,
  branch_code  VARCHAR2(32),
  abbreviation VARCHAR2(8)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_BRANCH_ABBRE
  add constraint PK_TB_BRANCH_ABBRE primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_CHECKPOINTTYPE
prompt ================================
prompt
create table UNICALL.TB_CHECKPOINTTYPE
(
  id           VARCHAR2(4) not null,
  name         VARCHAR2(1024),
  recordstatus CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_CHECKPOINTTYPE
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_CUSTOMER_ADDS
prompt ===============================
prompt
create table UNICALL.TB_CUSTOMER_ADDS
(
  adds_id         NUMBER(10) not null,
  customer_id     NUMBER(20),
  cus_adds_typ_id NUMBER(5),
  adds_contry     VARCHAR2(50),
  adds_province   VARCHAR2(50),
  adds_city       VARCHAR2(50),
  adds_detail     VARCHAR2(200),
  adds_note       VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on table UNICALL.TB_CUSTOMER_ADDS
  is '客户地址信息表';
comment on column UNICALL.TB_CUSTOMER_ADDS.adds_id
  is '联系地址ID';
comment on column UNICALL.TB_CUSTOMER_ADDS.customer_id
  is '客户ID';
comment on column UNICALL.TB_CUSTOMER_ADDS.cus_adds_typ_id
  is '联系地址类型ID';
comment on column UNICALL.TB_CUSTOMER_ADDS.adds_contry
  is '国家';
comment on column UNICALL.TB_CUSTOMER_ADDS.adds_province
  is '省';
comment on column UNICALL.TB_CUSTOMER_ADDS.adds_city
  is '市';
comment on column UNICALL.TB_CUSTOMER_ADDS.adds_detail
  is '地址详细信息';
comment on column UNICALL.TB_CUSTOMER_ADDS.adds_note
  is '地址备注';
alter table UNICALL.TB_CUSTOMER_ADDS
  add constraint PK_TB_CUSTOMER_ADDS primary key (ADDS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.TB_CUSTOMER_ADDS
  add constraint FK_TB_CUSTO_REFERENCE_TB_CUST2 foreign key (CUS_ADDS_TYP_ID)
  references UNICALL.TB_CUSTOMER_ADDS_TYP (CUS_ADDS_TYP_ID);
alter table UNICALL.TB_CUSTOMER_ADDS
  add constraint FK_TB_CUSTO_REFERENCE_TB_CUST3 foreign key (CUSTOMER_ID)
  references UNICALL.TB_CUSTOMER (CUSTOMER_ID);

prompt
prompt Creating table TB_CUSTOMER_APP_REL
prompt ==================================
prompt
create table UNICALL.TB_CUSTOMER_APP_REL
(
  application_id  VARCHAR2(18) not null,
  app_customer_id NUMBER(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 5M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_CUSTOMER_APP_REL
  is '投保客户与投保单关系表';
comment on column UNICALL.TB_CUSTOMER_APP_REL.application_id
  is '投保单ID';
comment on column UNICALL.TB_CUSTOMER_APP_REL.app_customer_id
  is '投保客户ID';
alter table UNICALL.TB_CUSTOMER_APP_REL
  add constraint PK_TB_APP_REL primary key (APPLICATION_ID, APP_CUSTOMER_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 7M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_CUSTOMER_APP_REL
  add constraint FK_TB_CUSTO_REFERENCE_TB_APPL1 foreign key (APP_CUSTOMER_ID)
  references UNICALL.TB_APPLICATION_CUSTOMER (APP_CUSTOMER_ID);
alter table UNICALL.TB_CUSTOMER_APP_REL
  add constraint FK_TB_CUSTO_REFERENCE_TB_APPL2 foreign key (APPLICATION_ID)
  references UNICALL.TB_APPLICATION (APPLICATION_ID);

prompt
prompt Creating table TB_CUSTOMER_CONTACT
prompt ==================================
prompt
create table UNICALL.TB_CUSTOMER_CONTACT
(
  cus_con_id     NUMBER(10) not null,
  customer_id    NUMBER(20),
  cus_con_typ_id NUMBER(5),
  con_value      VARCHAR2(50),
  con_note       VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on table UNICALL.TB_CUSTOMER_CONTACT
  is '客户联系方式表';
comment on column UNICALL.TB_CUSTOMER_CONTACT.cus_con_id
  is '联系方式ID';
comment on column UNICALL.TB_CUSTOMER_CONTACT.customer_id
  is '客户ID';
comment on column UNICALL.TB_CUSTOMER_CONTACT.cus_con_typ_id
  is '联系方式类型ID';
comment on column UNICALL.TB_CUSTOMER_CONTACT.con_value
  is '联系方式值';
comment on column UNICALL.TB_CUSTOMER_CONTACT.con_note
  is '联系方式备注';
alter table UNICALL.TB_CUSTOMER_CONTACT
  add constraint PK_TB_CUSTOMER_CONTACT primary key (CUS_CON_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.TB_CUSTOMER_CONTACT
  add constraint FK_TB_CUSTO_REFERENCE_TB_CUST4 foreign key (CUS_CON_TYP_ID)
  references UNICALL.TB_CUSTOMER_CON_TYP (CUS_CON_TYP_ID);
alter table UNICALL.TB_CUSTOMER_CONTACT
  add constraint FK_TB_CUSTO_REFERENCE_TB_CUSTO foreign key (CUSTOMER_ID)
  references UNICALL.TB_CUSTOMER (CUSTOMER_ID);

prompt
prompt Creating table TB_DATATASK
prompt ==========================
prompt
create table UNICALL.TB_DATATASK
(
  id         CHAR(18) not null,
  idtasksort VARCHAR2(4),
  ttask      DATE,
  icomplete  CHAR(1),
  tcomplete  DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_DATATASK
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_DATATASKTYPE
prompt ==============================
prompt
create table UNICALL.TB_DATATASKTYPE
(
  id           VARCHAR2(4) not null,
  name         VARCHAR2(1024),
  recordstatus CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_DATATASKTYPE
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_DICT
prompt ======================
prompt
create table UNICALL.TB_DICT
(
  id        NUMBER(10) not null,
  parent_id NUMBER(10) not null,
  item_name VARCHAR2(50),
  item_code VARCHAR2(50),
  is_delete CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_DICT
  is '字典表';
comment on column UNICALL.TB_DICT.id
  is '数据字典ID';
comment on column UNICALL.TB_DICT.parent_id
  is '父ID';
comment on column UNICALL.TB_DICT.item_name
  is '名称';
comment on column UNICALL.TB_DICT.item_code
  is '编码';
comment on column UNICALL.TB_DICT.is_delete
  is '1：删除，0：正常';
alter table UNICALL.TB_DICT
  add constraint PK_DICT_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_DMTYPE
prompt ========================
prompt
create table UNICALL.TB_DMTYPE
(
  id           VARCHAR2(4) not null,
  name         VARCHAR2(1024),
  recordstatus CHAR(1),
  src          CHAR(2),
  pay_mode     CHAR(2),
  use_ali_id   VARCHAR2(16)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_DMTYPE
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
grant select on UNICALL.TB_DMTYPE to SXDXETL;

prompt
prompt Creating table TB_DOCUMENTORG
prompt =============================
prompt
create table UNICALL.TB_DOCUMENTORG
(
  id           VARCHAR2(18) not null,
  documentno   VARCHAR2(64),
  idorg        VARCHAR2(18),
  lastupdate   DATE,
  recordstatus CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 567M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_TB_DOCUMENTORG_01 on UNICALL.TB_DOCUMENTORG (DOCUMENTNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 247M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_DOCUMENTORG
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 235M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_INTORG
prompt ========================
prompt
create table UNICALL.TB_INTORG
(
  sno              NUMBER(20) not null,
  typeid           NUMBER(7) not null,
  intorg_id        NUMBER(20),
  intorgcode       VARCHAR2(20) not null,
  intorgname       VARCHAR2(240) not null,
  governid         VARCHAR2(20),
  direct_mng_ind   VARCHAR2(1),
  areatype         VARCHAR2(4),
  orgtype          VARCHAR2(4),
  statuscode       VARCHAR2(2),
  firstinsert      DATE,
  lastmodify       DATE,
  fullname         VARCHAR2(180),
  city             VARCHAR2(60),
  town             VARCHAR2(60),
  title            VARCHAR2(4),
  permit_date      DATE,
  license_date     DATE,
  busi_scope       VARCHAR2(4),
  license_status   VARCHAR2(2),
  regionalism_code VARCHAR2(6),
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         DATE not null,
  src_sys          VARCHAR2(20) not null,
  create_date      DATE,
  update_date      DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_INTORG
  is '  行政和各类营销组织架构，采用办公室提供的行政机构';
comment on column UNICALL.TB_INTORG.sno
  is '  IAA物理主键';
comment on column UNICALL.TB_INTORG.typeid
  is '  ';
comment on column UNICALL.TB_INTORG.intorg_id
  is '  IAA锚点，Roleplayer';
comment on column UNICALL.TB_INTORG.intorgcode
  is '  业务机构代码';
comment on column UNICALL.TB_INTORG.intorgname
  is '  机构名称';
comment on column UNICALL.TB_INTORG.governid
  is '  办公室编制行政机构代码';
comment on column UNICALL.TB_INTORG.direct_mng_ind
  is '  直辖标记（1 直辖， 0非直辖，2其他）';
comment on column UNICALL.TB_INTORG.areatype
  is '  城镇/区县';
comment on column UNICALL.TB_INTORG.orgtype
  is '  内部定义机构类型';
comment on column UNICALL.TB_INTORG.statuscode
  is '  状态代码';
comment on column UNICALL.TB_INTORG.firstinsert
  is '  机构加入日期';
comment on column UNICALL.TB_INTORG.lastmodify
  is '  最后修改日期';
comment on column UNICALL.TB_INTORG.fullname
  is '  机构证照名称';
comment on column UNICALL.TB_INTORG.city
  is '  所在城市';
comment on column UNICALL.TB_INTORG.town
  is '  所在乡镇';
comment on column UNICALL.TB_INTORG.title
  is '  外部监管机构称谓';
comment on column UNICALL.TB_INTORG.permit_date
  is '  许可证日期
';
comment on column UNICALL.TB_INTORG.license_date
  is '  营业执照日期
';
comment on column UNICALL.TB_INTORG.busi_scope
  is '  经营状况
';
comment on column UNICALL.TB_INTORG.license_status
  is '  证照状态
';
comment on column UNICALL.TB_INTORG.regionalism_code
  is '  行政区划代码
';
comment on column UNICALL.TB_INTORG.begtime
  is '  开始日期';
comment on column UNICALL.TB_INTORG.endtime
  is '  中止日期';
comment on column UNICALL.TB_INTORG.branch
  is '  分公司代码';
comment on column UNICALL.TB_INTORG.etl_time
  is '  ETL处理时间';
comment on column UNICALL.TB_INTORG.src_sys
  is '  来源系统';
comment on column UNICALL.TB_INTORG.create_date
  is ' 创建时间';
comment on column UNICALL.TB_INTORG.update_date
  is ' 更新时间';
alter table UNICALL.TB_INTORG
  add constraint PK_TB_INTORG_SNO primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_INTORG
  add constraint UK_TB_INTORG_INTORGCODE unique (INTORGCODE)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_LOG
prompt =====================
prompt
create table UNICALL.TB_LOG
(
  id      VARCHAR2(18) not null,
  ttime   DATE,
  idsort  CHAR(4),
  idobj   VARCHAR2(18),
  content VARCHAR2(254)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 320K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_LOG
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 192K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_LOGTYPE
prompt =========================
prompt
create table UNICALL.TB_LOGTYPE
(
  id           CHAR(4) not null,
  name         VARCHAR2(1024),
  recordstatus CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_LOGTYPE
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_LOG_EBI
prompt =========================
prompt
create table UNICALL.TB_LOG_EBI
(
  id      NUMBER(10) not null,
  ttime   DATE,
  idsort  VARCHAR2(4),
  idobj   VARCHAR2(18),
  content VARCHAR2(1024)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 4096M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_TB_LOG_EBI_IDOBJ on UNICALL.TB_LOG_EBI (IDOBJ)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 336M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_LOG_EBI
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 184M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_OPER_PARAMETER
prompt ================================
prompt
create table UNICALL.TB_OPER_PARAMETER
(
  id            NUMBER(20) not null,
  oper_code     VARCHAR2(30),
  month_pay     VARCHAR2(1),
  season_pay    VARCHAR2(1),
  half_year_pay VARCHAR2(1),
  year_pay      VARCHAR2(1),
  single_pay    VARCHAR2(1),
  is_del        VARCHAR2(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.TB_OPER_PARAMETER.id
  is 'PK';
comment on column UNICALL.TB_OPER_PARAMETER.oper_code
  is '出单工号';
comment on column UNICALL.TB_OPER_PARAMETER.month_pay
  is '是否允许导入月缴投保单0.是 1.否';
comment on column UNICALL.TB_OPER_PARAMETER.season_pay
  is '是否允许导入季缴投保单0.是 1.否';
comment on column UNICALL.TB_OPER_PARAMETER.half_year_pay
  is '是否允许导入半年缴投保单0.是 1.否';
comment on column UNICALL.TB_OPER_PARAMETER.year_pay
  is '是否允许导入年缴投保单0.是 1.否';
comment on column UNICALL.TB_OPER_PARAMETER.single_pay
  is '是否允许导入趸缴投保单0.是 1.否';
comment on column UNICALL.TB_OPER_PARAMETER.is_del
  is '状态 0.正常 1.删除';
alter table UNICALL.TB_OPER_PARAMETER
  add constraint PK_TB_OPER_PARAMETER primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_OPER_PRO_PARAMETER
prompt ====================================
prompt
create table UNICALL.TB_OPER_PRO_PARAMETER
(
  id             NUMBER(10) not null,
  oper_code      VARCHAR2(30),
  insurance_code VARCHAR2(30),
  is_del         VARCHAR2(1),
  create_time    DATE,
  update_time    DATE,
  create_user_id NUMBER(10),
  update_user_id NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_OPER_PRO_PARAMETER
  is '工号出单产品管理';
comment on column UNICALL.TB_OPER_PRO_PARAMETER.id
  is '主键';
comment on column UNICALL.TB_OPER_PRO_PARAMETER.oper_code
  is '出单工号';
comment on column UNICALL.TB_OPER_PRO_PARAMETER.insurance_code
  is '主险代码';
comment on column UNICALL.TB_OPER_PRO_PARAMETER.is_del
  is '状态 0.正常 1.删除';
comment on column UNICALL.TB_OPER_PRO_PARAMETER.create_time
  is '创建时间';
comment on column UNICALL.TB_OPER_PRO_PARAMETER.update_time
  is '更新时间';
comment on column UNICALL.TB_OPER_PRO_PARAMETER.create_user_id
  is '创建人ID';
comment on column UNICALL.TB_OPER_PRO_PARAMETER.update_user_id
  is '更新人ID';
alter table UNICALL.TB_OPER_PRO_PARAMETER
  add constraint PK_TB_OPER_PRO_PARAMETER primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_OPER_PRO_PARAMETER
  add constraint UK_TB_OPER_PRO_PARAMETER unique (OPER_CODE, INSURANCE_CODE)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_ORGANIZATION
prompt ==============================
prompt
create table UNICALL.TB_ORGANIZATION
(
  org_id        NUMBER(10) not null,
  org_name      VARCHAR2(64) not null,
  company_id    NUMBER(10),
  parent_org_id NUMBER(10) not null,
  org_level     NUMBER(2) not null,
  org_desc      VARCHAR2(500),
  org_type      CHAR(2),
  org_code      VARCHAR2(20),
  is_del        CHAR(1) not null,
  create_user   VARCHAR2(24) not null,
  create_time   DATE not null,
  update_user   VARCHAR2(24),
  update_time   DATE,
  binding_user  VARCHAR2(24) default 0
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_ORGANIZATION
  is '组织机构';
comment on column UNICALL.TB_ORGANIZATION.org_id
  is '机构流水号';
comment on column UNICALL.TB_ORGANIZATION.org_name
  is '机构名称';
comment on column UNICALL.TB_ORGANIZATION.company_id
  is '业务机构ID';
comment on column UNICALL.TB_ORGANIZATION.parent_org_id
  is '上级机构ID';
comment on column UNICALL.TB_ORGANIZATION.org_level
  is '机构级别  0:总公司 1:电销总中心 2:电销分中心 3:项目 4:团队';
comment on column UNICALL.TB_ORGANIZATION.org_desc
  is '机构备注';
comment on column UNICALL.TB_ORGANIZATION.org_type
  is '机构类型';
comment on column UNICALL.TB_ORGANIZATION.org_code
  is '机构代码';
comment on column UNICALL.TB_ORGANIZATION.is_del
  is '删除标志';
comment on column UNICALL.TB_ORGANIZATION.create_user
  is '创建人';
comment on column UNICALL.TB_ORGANIZATION.create_time
  is '创建时间';
comment on column UNICALL.TB_ORGANIZATION.update_user
  is '修改人';
comment on column UNICALL.TB_ORGANIZATION.update_time
  is '修改时间';
alter table UNICALL.TB_ORGANIZATION
  add constraint PK_TB_ORGANIZATION primary key (ORG_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_ORGANIZATION_BAK
prompt ==================================
prompt
create table UNICALL.TB_ORGANIZATION_BAK
(
  org_id        NUMBER(10) not null,
  org_name      VARCHAR2(64) not null,
  company_id    NUMBER(10),
  parent_org_id NUMBER(10) not null,
  org_level     NUMBER(2) not null,
  org_desc      VARCHAR2(500),
  org_type      CHAR(2),
  org_code      VARCHAR2(20),
  is_del        CHAR(1) not null,
  create_user   VARCHAR2(24) not null,
  create_time   DATE not null,
  update_user   VARCHAR2(24),
  update_time   DATE,
  binding_user  VARCHAR2(24)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_ORGINFO
prompt =========================
prompt
create table UNICALL.TB_ORGINFO
(
  id           VARCHAR2(18) not null,
  orgname      VARCHAR2(64),
  levelcode    CHAR(4),
  idsuborg     VARCHAR2(18),
  idbranchorg  VARCHAR2(18),
  firstcreate  DATE,
  lastupdate   DATE,
  recordstatus CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 320K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_ORGINFO
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_ORG_LINK
prompt ==========================
prompt
create table UNICALL.TB_ORG_LINK
(
  id           CHAR(18) not null,
  idorg        VARCHAR2(18),
  ctype        CHAR(4),
  val          VARCHAR2(254),
  lastupdate   DATE,
  recordstatus CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 5M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_ORG_LINK
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_ORG_LINK_TYPE
prompt ===============================
prompt
create table UNICALL.TB_ORG_LINK_TYPE
(
  id           VARCHAR2(4) not null,
  name         VARCHAR2(1024),
  recordstatus CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_ORG_LINK_TYPE
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_POLICYNO_TEMP_DATA
prompt ====================================
prompt
create table UNICALL.TB_POLICYNO_TEMP_DATA
(
  appno    VARCHAR2(20) not null,
  policyno VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on table UNICALL.TB_POLICYNO_TEMP_DATA
  is '历史保单缺失临时表';
comment on column UNICALL.TB_POLICYNO_TEMP_DATA.appno
  is '投保单号';
comment on column UNICALL.TB_POLICYNO_TEMP_DATA.policyno
  is '保单号';
alter table UNICALL.TB_POLICYNO_TEMP_DATA
  add constraint TB_POLICYNO_TEMP_DATA_PRIMARY primary key (APPNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table TB_PROBLEM
prompt =========================
prompt
create table UNICALL.TB_PROBLEM
(
  id              NUMBER(18) not null,
  application_id  VARCHAR2(18),
  reserve_task_id NUMBER(18),
  appno           VARCHAR2(18) not null,
  pro_type        NUMBER(10),
  cre_time        DATE,
  deal_result     NUMBER(10),
  deal_time       DATE,
  write_back_time DATE,
  status          VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_PROBLEM
  is '问题件表';
comment on column UNICALL.TB_PROBLEM.id
  is '主键';
comment on column UNICALL.TB_PROBLEM.application_id
  is '保单ID';
comment on column UNICALL.TB_PROBLEM.reserve_task_id
  is '预约任务ID';
comment on column UNICALL.TB_PROBLEM.appno
  is '投保单号';
comment on column UNICALL.TB_PROBLEM.pro_type
  is '问题件类型（关联字典表）';
comment on column UNICALL.TB_PROBLEM.cre_time
  is '创建时间';
comment on column UNICALL.TB_PROBLEM.deal_result
  is '处理结果（关联字典表）';
comment on column UNICALL.TB_PROBLEM.deal_time
  is '处理时间';
comment on column UNICALL.TB_PROBLEM.write_back_time
  is '回写时间';
comment on column UNICALL.TB_PROBLEM.status
  is '状态（3处理中、9关闭）';
alter table UNICALL.TB_PROBLEM
  add constraint PK_PROBLEM_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_RESALLOCAT_LOG
prompt ================================
prompt
create table UNICALL.TB_RESALLOCAT_LOG
(
  id           NUMBER(18) not null,
  task_id      NUMBER(18) not null,
  task_date    DATE,
  task_use_ali VARCHAR2(20),
  old_use_ali  VARCHAR2(20),
  new_use_ali  VARCHAR2(20),
  remark       VARCHAR2(500)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_RESALLOCAT_LOG
  is '预约任务分配记录表';
comment on column UNICALL.TB_RESALLOCAT_LOG.task_id
  is '预约任务ID';
comment on column UNICALL.TB_RESALLOCAT_LOG.task_date
  is '分配时间';
comment on column UNICALL.TB_RESALLOCAT_LOG.task_use_ali
  is '分配坐席工号';
comment on column UNICALL.TB_RESALLOCAT_LOG.old_use_ali
  is '原坐席工号';
comment on column UNICALL.TB_RESALLOCAT_LOG.new_use_ali
  is '新坐席工号';
comment on column UNICALL.TB_RESALLOCAT_LOG.remark
  is '备注';
alter table UNICALL.TB_RESALLOCAT_LOG
  add constraint PK_RESALLOCAT_LOG_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_RESERVETASK_LIST
prompt ==================================
prompt
create table UNICALL.TB_RESERVETASK_LIST
(
  app_date       VARCHAR2(40),
  appno          VARCHAR2(200) not null,
  app_typ        VARCHAR2(20),
  policyno       VARCHAR2(200),
  company_name   VARCHAR2(200),
  prj_name       VARCHAR2(200),
  insurance_name VARCHAR2(200),
  tsrid          VARCHAR2(20),
  acus_name      VARCHAR2(200),
  acus_licno     VARCHAR2(200),
  adds_detail    VARCHAR2(2000),
  con_value      VARCHAR2(100),
  total_fee      NUMBER(20,4),
  year_fee       NUMBER(20,4),
  cha_result     VARCHAR2(100),
  cha_time       VARCHAR2(100),
  next_call_time VARCHAR2(100),
  reserve_result VARCHAR2(100),
  call_count     NUMBER(10),
  use_ali_id     VARCHAR2(100),
  task_cre_date  VARCHAR2(100),
  handle_result  VARCHAR2(100),
  res_remark     VARCHAR2(2000),
  cre_time       DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.TB_RESERVETASK_LIST.app_date
  is '成交时间';
comment on column UNICALL.TB_RESERVETASK_LIST.appno
  is '投保单号';
comment on column UNICALL.TB_RESERVETASK_LIST.app_typ
  is '保单类型';
comment on column UNICALL.TB_RESERVETASK_LIST.policyno
  is '保单号';
comment on column UNICALL.TB_RESERVETASK_LIST.company_name
  is '地区';
comment on column UNICALL.TB_RESERVETASK_LIST.prj_name
  is '项目名称';
comment on column UNICALL.TB_RESERVETASK_LIST.insurance_name
  is '险种名称';
comment on column UNICALL.TB_RESERVETASK_LIST.tsrid
  is '坐席工号';
comment on column UNICALL.TB_RESERVETASK_LIST.acus_name
  is '投保人';
comment on column UNICALL.TB_RESERVETASK_LIST.acus_licno
  is '投保人证件号码';
comment on column UNICALL.TB_RESERVETASK_LIST.adds_detail
  is '地址';
comment on column UNICALL.TB_RESERVETASK_LIST.con_value
  is '联系方式';
comment on column UNICALL.TB_RESERVETASK_LIST.total_fee
  is '首期保费';
comment on column UNICALL.TB_RESERVETASK_LIST.year_fee
  is '年华保费';
comment on column UNICALL.TB_RESERVETASK_LIST.cha_result
  is '扣款结果';
comment on column UNICALL.TB_RESERVETASK_LIST.cha_time
  is '扣款日期';
comment on column UNICALL.TB_RESERVETASK_LIST.next_call_time
  is '下次预约时间';
comment on column UNICALL.TB_RESERVETASK_LIST.reserve_result
  is '预约结果';
comment on column UNICALL.TB_RESERVETASK_LIST.call_count
  is '拨打次数';
comment on column UNICALL.TB_RESERVETASK_LIST.use_ali_id
  is '预约坐席';
comment on column UNICALL.TB_RESERVETASK_LIST.task_cre_date
  is '预约任务创建日期';
comment on column UNICALL.TB_RESERVETASK_LIST.handle_result
  is '问题件处理结果';
comment on column UNICALL.TB_RESERVETASK_LIST.res_remark
  is '预约备注';
comment on column UNICALL.TB_RESERVETASK_LIST.cre_time
  is '创建时间';
alter table UNICALL.TB_RESERVETASK_LIST
  add constraint PK_APPNO primary key (APPNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_RESERVE_DIA_OUT
prompt =================================
prompt
create table UNICALL.TB_RESERVE_DIA_OUT
(
  id         NUMBER(18) not null,
  task_id    NUMBER(18),
  contact    VARCHAR2(50),
  status     NUMBER(10),
  call_time  DATE,
  use_ali_id VARCHAR2(20),
  remark     VARCHAR2(400),
  sendbj     CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_RESERVE_DIA_OUT
  is '预约拨打记录表';
comment on column UNICALL.TB_RESERVE_DIA_OUT.id
  is '主键';
comment on column UNICALL.TB_RESERVE_DIA_OUT.task_id
  is '外键(TB_RESERVE_TASK)';
comment on column UNICALL.TB_RESERVE_DIA_OUT.contact
  is '呼叫号码';
comment on column UNICALL.TB_RESERVE_DIA_OUT.status
  is '预约状态（关联字典表）';
comment on column UNICALL.TB_RESERVE_DIA_OUT.call_time
  is '拨打时间';
comment on column UNICALL.TB_RESERVE_DIA_OUT.use_ali_id
  is '预约坐席工号';
comment on column UNICALL.TB_RESERVE_DIA_OUT.remark
  is '备注';
comment on column UNICALL.TB_RESERVE_DIA_OUT.sendbj
  is '是否发送到新系统  0:未发送   1:已经发送';
alter table UNICALL.TB_RESERVE_DIA_OUT
  add constraint PK_DIA_OUT_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_RESERVE_TASK
prompt ==============================
prompt
create table UNICALL.TB_RESERVE_TASK
(
  id             NUMBER(18) not null,
  application_id VARCHAR2(18),
  appno          VARCHAR2(18),
  policyno       VARCHAR2(18),
  cre_time       DATE,
  use_ali_id     VARCHAR2(20),
  sale_src       VARCHAR2(2),
  sale_cha       VARCHAR2(2),
  status         NUMBER(10),
  task_date      DATE,
  task_use_ali   VARCHAR2(20),
  last_call_time DATE,
  is_pro         VARCHAR2(2) default 0,
  res_remark     VARCHAR2(400),
  app_remark     VARCHAR2(400),
  is_close       VARCHAR2(2) default 0,
  next_call_time VARCHAR2(20),
  dx_org_id      NUMBER(10),
  prj_org_id     NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_RESERVE_TASK
  is '预约任务表';
comment on column UNICALL.TB_RESERVE_TASK.application_id
  is '保单ID';
comment on column UNICALL.TB_RESERVE_TASK.appno
  is '投保单号';
comment on column UNICALL.TB_RESERVE_TASK.policyno
  is '保单号';
comment on column UNICALL.TB_RESERVE_TASK.cre_time
  is '创建时间';
comment on column UNICALL.TB_RESERVE_TASK.use_ali_id
  is '预约坐席工号';
comment on column UNICALL.TB_RESERVE_TASK.sale_src
  is '保单属性(04先收费；05先出单)';
comment on column UNICALL.TB_RESERVE_TASK.sale_cha
  is '销售渠道61、63';
comment on column UNICALL.TB_RESERVE_TASK.status
  is '预约状态（关联字典表）';
comment on column UNICALL.TB_RESERVE_TASK.task_date
  is '分配时间';
comment on column UNICALL.TB_RESERVE_TASK.task_use_ali
  is '分配人';
comment on column UNICALL.TB_RESERVE_TASK.last_call_time
  is '最近一次拨打时间';
comment on column UNICALL.TB_RESERVE_TASK.is_pro
  is '是否问题件(0否；1是)';
comment on column UNICALL.TB_RESERVE_TASK.res_remark
  is '预约备注';
comment on column UNICALL.TB_RESERVE_TASK.app_remark
  is '保全备注';
comment on column UNICALL.TB_RESERVE_TASK.is_close
  is '是否关闭（0否；1是）';
comment on column UNICALL.TB_RESERVE_TASK.next_call_time
  is '下次预约时间';
comment on column UNICALL.TB_RESERVE_TASK.dx_org_id
  is '电销中心';
comment on column UNICALL.TB_RESERVE_TASK.prj_org_id
  is '所属项目';
create unique index UNICALL.IDX_APPNO on UNICALL.TB_RESERVE_TASK (APPNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_RESERVE_TASK
  add constraint PK_RESERVE_TASK_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_USER
prompt ======================
prompt
create table UNICALL.TB_USER
(
  id           VARCHAR2(18) not null,
  username     VARCHAR2(64),
  useroa       VARCHAR2(64),
  name         VARCHAR2(64),
  passwd       VARCHAR2(16),
  idorg        VARCHAR2(18),
  recordstatus CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.TB_USER
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TB_ZYX_COMPANY_INFO
prompt ==================================
prompt
create table UNICALL.TB_ZYX_COMPANY_INFO
(
  dx_company_code  VARCHAR2(200),
  dx_company_name  VARCHAR2(200) not null,
  zyx_company_code VARCHAR2(200),
  zyx_company_name VARCHAR2(200),
  zyx_post_code    VARCHAR2(200),
  zyx_address      VARCHAR2(1000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TB_ZYX_COMPANY_INFO
  is '电销与综意险分公司对应机构编码';
comment on column UNICALL.TB_ZYX_COMPANY_INFO.dx_company_code
  is '电销分公司机构代码';
comment on column UNICALL.TB_ZYX_COMPANY_INFO.dx_company_name
  is '电销公司分公司';
comment on column UNICALL.TB_ZYX_COMPANY_INFO.zyx_company_code
  is '综意险分公司机构代码';
comment on column UNICALL.TB_ZYX_COMPANY_INFO.zyx_company_name
  is '综意险分公司';
comment on column UNICALL.TB_ZYX_COMPANY_INFO.zyx_post_code
  is '综意险分公司邮编';
comment on column UNICALL.TB_ZYX_COMPANY_INFO.zyx_address
  is '综意险分公司地址';
alter table UNICALL.TB_ZYX_COMPANY_INFO
  add primary key (DX_COMPANY_NAME)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_CUSTOMER
prompt ============================
prompt
create table UNICALL.TEMP_CUSTOMER
(
  branch_abbreviation    VARCHAR2(20),
  source_type_code       NUMBER(3),
  customer_id            CHAR(18) not null,
  copy_id                CHAR(40),
  customer_name          VARCHAR2(120),
  birthday               DATE,
  age                    NUMBER(3),
  marital_status         VARCHAR2(10),
  death_critical_illness VARCHAR2(6),
  fax                    VARCHAR2(30),
  family_zip_code        VARCHAR2(10),
  company_zip_code       VARCHAR2(10),
  family_address         VARCHAR2(508),
  company_address        VARCHAR2(508),
  company                VARCHAR2(508),
  job_name               VARCHAR2(40),
  education_level        VARCHAR2(40),
  income                 NUMBER(12,2),
  email                  VARCHAR2(40),
  zone_code              VARCHAR2(20),
  govern_id              VARCHAR2(30),
  city                   VARCHAR2(120),
  province               VARCHAR2(120),
  bank_name              VARCHAR2(120),
  bank_account           CHAR(40),
  policy_no              VARCHAR2(40),
  note                   VARCHAR2(2000),
  tel_code               VARCHAR2(20),
  any_date               DATE,
  other_info_1           VARCHAR2(100),
  other_info_2           VARCHAR2(100),
  other_info_3           VARCHAR2(100),
  other_info_5           VARCHAR2(100),
  other_info_4           VARCHAR2(100),
  contact_address        VARCHAR2(508),
  gender_code            NUMBER(3),
  family_phone           VARCHAR2(30),
  office_phone           VARCHAR2(30),
  mobile_phone           VARCHAR2(30),
  charge_phone           VARCHAR2(30),
  other_phone            VARCHAR2(30),
  is_id_null             NUMBER(1),
  is_accept_donation     NUMBER(1),
  partition_col          NUMBER(6) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 1152M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_DEAL_POLICY
prompt ===============================
prompt
create table UNICALL.TEMP_DEAL_POLICY
(
  branch_govern_id        VARCHAR2(30),
  policy_no               VARCHAR2(30),
  policy_holder_id        CHAR(18),
  application_no          VARCHAR2(30),
  application_create_time DATE,
  product_code            VARCHAR2(20),
  partition_col           NUMBER(6)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_DIAL_ACTIVITY
prompt =================================
prompt
create table UNICALL.TEMP_DIAL_ACTIVITY
(
  child_branch_code   VARCHAR2(30),
  activity_id         VARCHAR2(20),
  activity_name       VARCHAR2(200),
  product_code        VARCHAR2(30),
  product_name        VARCHAR2(200),
  policy_holder_id    CHAR(18),
  activity_start_time DATE,
  activity_end_time   DATE,
  partition_col       NUMBER(6)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 368M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_DIAL_RESULT
prompt ===============================
prompt
create table UNICALL.TEMP_DIAL_RESULT
(
  activity_id      VARCHAR2(20),
  customer_id      CHAR(18),
  mobile_phone     VARCHAR2(20),
  family_phone     VARCHAR2(20),
  office_phone     VARCHAR2(20),
  other_phone      VARCHAR2(20),
  status           NUMBER,
  passed_phone     VARCHAR2(20),
  dial_time_length NUMBER,
  dial_time        DATE,
  partition_col    NUMBER(6)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 232M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_FXQD
prompt ========================
prompt
create table UNICALL.TEMP_FXQD
(
  curr_data     VARCHAR2(20),
  task_month    VARCHAR2(10),
  task_date     VARCHAR2(20),
  use_nam       VARCHAR2(30),
  use_ali_id    VARCHAR2(20),
  gro_id        NUMBER(30),
  cat_nam       VARCHAR2(2000),
  policyno      VARCHAR2(20),
  policynum     NUMBER,
  appno         VARCHAR2(20),
  classcode     CHAR(8),
  classname     VARCHAR2(120),
  appname       VARCHAR2(120),
  polist_ids    CHAR(2),
  polist_name   VARCHAR2(50),
  paycode       NUMBER,
  payname       VARCHAR2(50),
  begdate       DATE,
  nextdate      DATE,
  one_amount    NUMBER,
  yearnum       NUMBER(20),
  invalid_date  DATE,
  reinstate     VARCHAR2(2),
  reinname      VARCHAR2(6),
  paydate       DATE,
  acc_amount    NUMBER,
  call_use_ali  VARCHAR2(20),
  call_date     DATE,
  item_name     VARCHAR2(50),
  remark        VARCHAR2(400),
  empno         VARCHAR2(20),
  sales_organ   VARCHAR2(400),
  sales_project VARCHAR2(400)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TEMP_FXQD
  is '复效统计清单';
comment on column UNICALL.TEMP_FXQD.curr_data
  is '当前月';
comment on column UNICALL.TEMP_FXQD.task_month
  is '所属分单月份';
comment on column UNICALL.TEMP_FXQD.task_date
  is '所属分单时间';
comment on column UNICALL.TEMP_FXQD.use_nam
  is '分配人员名称';
comment on column UNICALL.TEMP_FXQD.use_ali_id
  is '分配人员工号';
comment on column UNICALL.TEMP_FXQD.gro_id
  is '组ID';
comment on column UNICALL.TEMP_FXQD.cat_nam
  is '组别';
comment on column UNICALL.TEMP_FXQD.policyno
  is '保单号';
comment on column UNICALL.TEMP_FXQD.policynum
  is '件数';
comment on column UNICALL.TEMP_FXQD.appno
  is '投保单号';
comment on column UNICALL.TEMP_FXQD.classcode
  is '险种';
comment on column UNICALL.TEMP_FXQD.classname
  is '险种名称';
comment on column UNICALL.TEMP_FXQD.appname
  is '投保人姓名';
comment on column UNICALL.TEMP_FXQD.polist_ids
  is '保单状态标示';
comment on column UNICALL.TEMP_FXQD.polist_name
  is '保单状态';
comment on column UNICALL.TEMP_FXQD.paycode
  is '缴费方式标示';
comment on column UNICALL.TEMP_FXQD.payname
  is '缴费方式';
comment on column UNICALL.TEMP_FXQD.begdate
  is '责任起期';
comment on column UNICALL.TEMP_FXQD.nextdate
  is '下次缴费日期';
comment on column UNICALL.TEMP_FXQD.one_amount
  is '单期缴费';
comment on column UNICALL.TEMP_FXQD.yearnum
  is '缴费年限';
comment on column UNICALL.TEMP_FXQD.invalid_date
  is '失效日期';
comment on column UNICALL.TEMP_FXQD.reinstate
  is '是否复效标示';
comment on column UNICALL.TEMP_FXQD.reinname
  is '是否复效';
comment on column UNICALL.TEMP_FXQD.paydate
  is '复效成功日期';
comment on column UNICALL.TEMP_FXQD.acc_amount
  is '复效补缴保费';
comment on column UNICALL.TEMP_FXQD.call_use_ali
  is '回访坐席工号';
comment on column UNICALL.TEMP_FXQD.call_date
  is '回访时间';
comment on column UNICALL.TEMP_FXQD.item_name
  is '回访结果';
comment on column UNICALL.TEMP_FXQD.remark
  is '回访备注';

prompt
prompt Creating table TEMP_FXQD_01
prompt ===========================
prompt
create table UNICALL.TEMP_FXQD_01
(
  curr_data     DATE,
  task_date     DATE,
  use_nam       VARCHAR2(30),
  use_ali_id    VARCHAR2(20),
  gro_id        NUMBER(30),
  cat_nam       VARCHAR2(2000),
  policyno      VARCHAR2(20),
  appno         VARCHAR2(20),
  classcode     CHAR(8),
  classname     VARCHAR2(120),
  appname       VARCHAR2(120),
  polist_ids    CHAR(2),
  polist_name   VARCHAR2(50),
  paycode       NUMBER,
  payname       VARCHAR2(50),
  begdate       DATE,
  nextdate      DATE,
  one_amount    NUMBER,
  yearnum       NUMBER(20),
  invalid_date  DATE,
  reinstate     VARCHAR2(2),
  reinname      VARCHAR2(6),
  paydate       DATE,
  acc_amount    NUMBER,
  call_use_ali  VARCHAR2(20),
  call_date     DATE,
  item_name     VARCHAR2(50),
  remark        VARCHAR2(400),
  empno         VARCHAR2(20),
  sales_organ   VARCHAR2(400),
  sales_project VARCHAR2(400)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TEMP_FXQD_01
  is '复效统计临时清单';
comment on column UNICALL.TEMP_FXQD_01.curr_data
  is '当前月';
comment on column UNICALL.TEMP_FXQD_01.task_date
  is '所属分单月份';
comment on column UNICALL.TEMP_FXQD_01.use_nam
  is '分配人员名称';
comment on column UNICALL.TEMP_FXQD_01.use_ali_id
  is '分配人员工号';
comment on column UNICALL.TEMP_FXQD_01.gro_id
  is '组ID';
comment on column UNICALL.TEMP_FXQD_01.cat_nam
  is '组别';
comment on column UNICALL.TEMP_FXQD_01.policyno
  is '保单号';
comment on column UNICALL.TEMP_FXQD_01.appno
  is '投保单号';
comment on column UNICALL.TEMP_FXQD_01.classcode
  is '险种';
comment on column UNICALL.TEMP_FXQD_01.classname
  is '险种名称';
comment on column UNICALL.TEMP_FXQD_01.appname
  is '投保人姓名';
comment on column UNICALL.TEMP_FXQD_01.polist_ids
  is '保单状态标示';
comment on column UNICALL.TEMP_FXQD_01.polist_name
  is '保单状态';
comment on column UNICALL.TEMP_FXQD_01.paycode
  is '缴费方式标示';
comment on column UNICALL.TEMP_FXQD_01.payname
  is '缴费方式';
comment on column UNICALL.TEMP_FXQD_01.begdate
  is '责任起期';
comment on column UNICALL.TEMP_FXQD_01.nextdate
  is '下次缴费日期';
comment on column UNICALL.TEMP_FXQD_01.one_amount
  is '单期缴费';
comment on column UNICALL.TEMP_FXQD_01.yearnum
  is '缴费年限';
comment on column UNICALL.TEMP_FXQD_01.invalid_date
  is '失效日期';
comment on column UNICALL.TEMP_FXQD_01.reinstate
  is '是否复效标示';
comment on column UNICALL.TEMP_FXQD_01.reinname
  is '是否复效';
comment on column UNICALL.TEMP_FXQD_01.paydate
  is '复效成功日期';
comment on column UNICALL.TEMP_FXQD_01.acc_amount
  is '复效补缴保费';
comment on column UNICALL.TEMP_FXQD_01.call_use_ali
  is '回访坐席工号';
comment on column UNICALL.TEMP_FXQD_01.call_date
  is '回访时间';
comment on column UNICALL.TEMP_FXQD_01.item_name
  is '回访结果';
comment on column UNICALL.TEMP_FXQD_01.remark
  is '回访备注';

prompt
prompt Creating table TEMP_FXQD_BACK
prompt =============================
prompt
create table UNICALL.TEMP_FXQD_BACK
(
  curr_data     VARCHAR2(20),
  task_month    VARCHAR2(10),
  task_date     VARCHAR2(20),
  use_nam       VARCHAR2(30),
  use_ali_id    VARCHAR2(20),
  gro_id        NUMBER(30),
  cat_nam       VARCHAR2(2000),
  policyno      VARCHAR2(20),
  policynum     NUMBER,
  appno         VARCHAR2(20),
  classcode     CHAR(8),
  classname     VARCHAR2(120),
  appname       VARCHAR2(120),
  polist_ids    CHAR(2),
  polist_name   VARCHAR2(50),
  paycode       NUMBER,
  payname       VARCHAR2(50),
  begdate       DATE,
  nextdate      DATE,
  one_amount    NUMBER,
  yearnum       NUMBER(20),
  invalid_date  DATE,
  reinstate     VARCHAR2(2),
  reinname      VARCHAR2(6),
  paydate       DATE,
  acc_amount    NUMBER,
  call_use_ali  VARCHAR2(20),
  call_date     DATE,
  item_name     VARCHAR2(50),
  remark        VARCHAR2(400),
  empno         VARCHAR2(20),
  sales_organ   VARCHAR2(400),
  sales_project VARCHAR2(400)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_FXTJ
prompt ========================
prompt
create table UNICALL.TEMP_FXTJ
(
  curr_data    DATE,
  use_ali_id   VARCHAR2(20),
  use_nam      VARCHAR2(20),
  policyno     VARCHAR2(20),
  task_date    DATE,
  reinstate    VARCHAR2(2),
  one_amount   NUMBER,
  acc_amount   NUMBER,
  paydate      DATE,
  gro_id       NUMBER(30),
  cat_nam      VARCHAR2(2000),
  invalid_date DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TEMP_FXTJ
  is '复效统计报表';
comment on column UNICALL.TEMP_FXTJ.curr_data
  is '当天日期';
comment on column UNICALL.TEMP_FXTJ.use_ali_id
  is '续期代表工号';
comment on column UNICALL.TEMP_FXTJ.use_nam
  is '续期代表姓名';
comment on column UNICALL.TEMP_FXTJ.policyno
  is '保单号';
comment on column UNICALL.TEMP_FXTJ.task_date
  is '分单时间';
comment on column UNICALL.TEMP_FXTJ.reinstate
  is '复效情况 1：成功 0：失败';
comment on column UNICALL.TEMP_FXTJ.one_amount
  is '单期保费';
comment on column UNICALL.TEMP_FXTJ.acc_amount
  is '缴费/领款金额（不含利息）';
comment on column UNICALL.TEMP_FXTJ.paydate
  is '交易生效日期';
comment on column UNICALL.TEMP_FXTJ.gro_id
  is '组ID';
comment on column UNICALL.TEMP_FXTJ.cat_nam
  is '组名称';
comment on column UNICALL.TEMP_FXTJ.invalid_date
  is '失效日期';

prompt
prompt Creating table TEMP_INVALID_APP
prompt ===============================
prompt
create table UNICALL.TEMP_INVALID_APP
(
  task_date    DATE,
  use_ali_id   VARCHAR2(20),
  policyno     VARCHAR2(20),
  appno        VARCHAR2(20),
  invalid_date DATE,
  reinstate    VARCHAR2(2),
  reinname     VARCHAR2(6),
  paydate      DATE,
  acc_amount   NUMBER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.TEMP_INVALID_APP.task_date
  is '分单日期';
comment on column UNICALL.TEMP_INVALID_APP.use_ali_id
  is '分配人员工号';
comment on column UNICALL.TEMP_INVALID_APP.policyno
  is '保单号';
comment on column UNICALL.TEMP_INVALID_APP.appno
  is '投保单号';
comment on column UNICALL.TEMP_INVALID_APP.invalid_date
  is '失效日期';
comment on column UNICALL.TEMP_INVALID_APP.reinstate
  is '是否复效名称';
comment on column UNICALL.TEMP_INVALID_APP.paydate
  is '缴费日期';
comment on column UNICALL.TEMP_INVALID_APP.acc_amount
  is '缴费金额（不含利息）';
create index UNICALL.IDX_T_I_APP_POC on UNICALL.TEMP_INVALID_APP (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_INVALID_APP_01
prompt ==================================
prompt
create table UNICALL.TEMP_INVALID_APP_01
(
  task_date    DATE,
  use_ali_id   VARCHAR2(20),
  policyno     VARCHAR2(20),
  appno        VARCHAR2(20),
  invalid_date DATE,
  reinstate    VARCHAR2(2),
  reinname     VARCHAR2(6)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.TEMP_INVALID_APP_01.task_date
  is '分单日期';
comment on column UNICALL.TEMP_INVALID_APP_01.use_ali_id
  is '分配人员工号';
comment on column UNICALL.TEMP_INVALID_APP_01.policyno
  is '保单号';
comment on column UNICALL.TEMP_INVALID_APP_01.appno
  is '投保单号';
comment on column UNICALL.TEMP_INVALID_APP_01.invalid_date
  is '失效日期';
comment on column UNICALL.TEMP_INVALID_APP_01.reinstate
  is '是否复效标示';
comment on column UNICALL.TEMP_INVALID_APP_01.reinname
  is '是否复效名称';
create index UNICALL.IDX_T_I_APP_01_POC on UNICALL.TEMP_INVALID_APP_01 (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_INVALID_APP_02
prompt ==================================
prompt
create table UNICALL.TEMP_INVALID_APP_02
(
  policyno     VARCHAR2(20),
  invalid_date DATE,
  row_now      NUMBER,
  row_next     NUMBER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.TEMP_INVALID_APP_02.policyno
  is '保单号';
comment on column UNICALL.TEMP_INVALID_APP_02.invalid_date
  is '失效日期';
create index UNICALL.IDX_T_I_APP_02_POC on UNICALL.TEMP_INVALID_APP_02 (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_INVALID_APP_03
prompt ==================================
prompt
create table UNICALL.TEMP_INVALID_APP_03
(
  policyno          VARCHAR2(20),
  invalid_date      DATE,
  next_invalid_date DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.TEMP_INVALID_APP_03.policyno
  is '保单号';
comment on column UNICALL.TEMP_INVALID_APP_03.invalid_date
  is '失效日期';
comment on column UNICALL.TEMP_INVALID_APP_03.next_invalid_date
  is '下一次失效日期';
create index UNICALL.IDX_T_I_APP_03_POC on UNICALL.TEMP_INVALID_APP_03 (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_INVALID_APP_04
prompt ==================================
prompt
create table UNICALL.TEMP_INVALID_APP_04
(
  policyno     VARCHAR2(20),
  invalid_date DATE,
  paydate      DATE,
  acc_amount   NUMBER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.TEMP_INVALID_APP_04.policyno
  is '保单号';
comment on column UNICALL.TEMP_INVALID_APP_04.invalid_date
  is '失效日期';
comment on column UNICALL.TEMP_INVALID_APP_04.paydate
  is '缴费日期';
comment on column UNICALL.TEMP_INVALID_APP_04.acc_amount
  is '缴费金额（不含利息）';
create index UNICALL.IDX_T_I_APP_04_POC on UNICALL.TEMP_INVALID_APP_04 (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_M_FXQD
prompt ==========================
prompt
create table UNICALL.TEMP_M_FXQD
(
  curr_month    VARCHAR2(20),
  task_month    VARCHAR2(10),
  task_date     VARCHAR2(20),
  use_nam       VARCHAR2(30),
  use_ali_id    VARCHAR2(20),
  gro_id        NUMBER(30),
  cat_nam       VARCHAR2(2000),
  policyno      VARCHAR2(20),
  policynum     NUMBER,
  appno         VARCHAR2(20),
  classcode     CHAR(8),
  classname     VARCHAR2(120),
  appname       VARCHAR2(120),
  polist_ids    CHAR(2),
  polist_name   VARCHAR2(50),
  paycode       NUMBER,
  payname       VARCHAR2(50),
  begdate       DATE,
  nextdate      DATE,
  one_amount    NUMBER,
  yearnum       NUMBER(20),
  invalid_date  DATE,
  reinstate     VARCHAR2(2),
  reinname      VARCHAR2(6),
  paydate       DATE,
  acc_amount    NUMBER,
  call_use_ali  VARCHAR2(20),
  call_date     DATE,
  item_name     VARCHAR2(50),
  remark        VARCHAR2(400),
  create_data   DATE,
  empno         VARCHAR2(20),
  sales_organ   VARCHAR2(400),
  sales_project VARCHAR2(400)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TEMP_M_FXQD
  is '复效统计清单';
comment on column UNICALL.TEMP_M_FXQD.curr_month
  is '当前月';
comment on column UNICALL.TEMP_M_FXQD.task_month
  is '所属分单月份';
comment on column UNICALL.TEMP_M_FXQD.task_date
  is '所属分单时间';
comment on column UNICALL.TEMP_M_FXQD.use_nam
  is '分配人员名称';
comment on column UNICALL.TEMP_M_FXQD.use_ali_id
  is '分配人员工号';
comment on column UNICALL.TEMP_M_FXQD.gro_id
  is '组ID';
comment on column UNICALL.TEMP_M_FXQD.cat_nam
  is '组别';
comment on column UNICALL.TEMP_M_FXQD.policyno
  is '保单号';
comment on column UNICALL.TEMP_M_FXQD.policynum
  is '件数';
comment on column UNICALL.TEMP_M_FXQD.appno
  is '投保单号';
comment on column UNICALL.TEMP_M_FXQD.classcode
  is '险种';
comment on column UNICALL.TEMP_M_FXQD.classname
  is '险种名称';
comment on column UNICALL.TEMP_M_FXQD.appname
  is '投保人姓名';
comment on column UNICALL.TEMP_M_FXQD.polist_ids
  is '保单状态标示';
comment on column UNICALL.TEMP_M_FXQD.polist_name
  is '保单状态';
comment on column UNICALL.TEMP_M_FXQD.paycode
  is '缴费方式标示';
comment on column UNICALL.TEMP_M_FXQD.payname
  is '缴费方式';
comment on column UNICALL.TEMP_M_FXQD.begdate
  is '责任起期';
comment on column UNICALL.TEMP_M_FXQD.nextdate
  is '下次缴费日期';
comment on column UNICALL.TEMP_M_FXQD.one_amount
  is '单期缴费';
comment on column UNICALL.TEMP_M_FXQD.yearnum
  is '缴费年限';
comment on column UNICALL.TEMP_M_FXQD.invalid_date
  is '失效日期';
comment on column UNICALL.TEMP_M_FXQD.reinstate
  is '是否复效标示';
comment on column UNICALL.TEMP_M_FXQD.reinname
  is '是否复效';
comment on column UNICALL.TEMP_M_FXQD.paydate
  is '复效成功日期';
comment on column UNICALL.TEMP_M_FXQD.acc_amount
  is '复效补缴保费';
comment on column UNICALL.TEMP_M_FXQD.call_use_ali
  is '回访坐席工号';
comment on column UNICALL.TEMP_M_FXQD.call_date
  is '回访时间';
comment on column UNICALL.TEMP_M_FXQD.item_name
  is '回访结果';
comment on column UNICALL.TEMP_M_FXQD.remark
  is '回访备注';
comment on column UNICALL.TEMP_M_FXQD.create_data
  is '创建日期';
create index UNICALL.IDX_T_M_FXQD_01 on UNICALL.TEMP_M_FXQD (CURR_MONTH)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_M_FXTJ
prompt ==========================
prompt
create table UNICALL.TEMP_M_FXTJ
(
  currdate    VARCHAR2(20),
  task_month  VARCHAR2(7),
  use_ali_id  VARCHAR2(20),
  use_nam     VARCHAR2(20),
  dyfdjs      NUMBER,
  dyfdbf      NUMBER,
  dyfxjs      NUMBER,
  dyfxbf      NUMBER,
  dyjslv      NUMBER,
  dybflv      NUMBER,
  dyssjs      NUMBER,
  dyssbf      NUMBER,
  dnfdjs      NUMBER,
  dnfdbf      NUMBER,
  dnfxjs      NUMBER,
  dnfxbf      NUMBER,
  dnjslv      NUMBER,
  dnbflv      NUMBER,
  dnssjs      NUMBER,
  dnssbf      NUMBER,
  gro_id      NUMBER,
  cat_nam     VARCHAR2(2000),
  create_date DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_T_M_FXTJ_01 on UNICALL.TEMP_M_FXTJ (CURRDATE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_T_M_FXTJ_02 on UNICALL.TEMP_M_FXTJ (TASK_MONTH)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_M_TO_Y
prompt ==========================
prompt
create table UNICALL.TEMP_M_TO_Y
(
  policyno VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_ONE_AMOUNT
prompt ==============================
prompt
create table UNICALL.TEMP_ONE_AMOUNT
(
  policyno   VARCHAR2(20),
  one_amount NUMBER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.TEMP_ONE_AMOUNT.policyno
  is '保单号';
comment on column UNICALL.TEMP_ONE_AMOUNT.one_amount
  is '单期保费';
create index UNICALL.IDX_T_ONE_AMOUNT on UNICALL.TEMP_ONE_AMOUNT (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_PREREC
prompt ==========================
prompt
create table UNICALL.TEMP_PREREC
(
  policyno   VARCHAR2(20),
  paydate    DATE,
  acc_amount NUMBER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.TEMP_PREREC.policyno
  is '保单号';
comment on column UNICALL.TEMP_PREREC.paydate
  is '缴费日期';
comment on column UNICALL.TEMP_PREREC.acc_amount
  is '缴费金额（不含利息）';
create index UNICALL.IDX_T_PREREC_POC on UNICALL.TEMP_PREREC (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TEMP_XSHDGL
prompt ==========================
prompt
create table UNICALL.TEMP_XSHDGL
(
  curr_data      DATE,
  use_ali_id     VARCHAR2(20),
  use_nam        VARCHAR2(20),
  policyno       VARCHAR2(20),
  returnvist_sta NUMBER(10),
  amount         NUMBER(20,6),
  is_success     VARCHAR2(2),
  task_date      DATE,
  gro_id         NUMBER(30),
  cat_nam        VARCHAR2(2000),
  cover1         DATE,
  day_flag       NUMBER(4)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TEMP_XSHDGL
  is '续收活动管理表';
comment on column UNICALL.TEMP_XSHDGL.curr_data
  is '当天日期';
comment on column UNICALL.TEMP_XSHDGL.use_ali_id
  is '续期代表工号';
comment on column UNICALL.TEMP_XSHDGL.use_nam
  is '续期代表姓名';
comment on column UNICALL.TEMP_XSHDGL.policyno
  is '保单号';
comment on column UNICALL.TEMP_XSHDGL.returnvist_sta
  is '回访状态';
comment on column UNICALL.TEMP_XSHDGL.amount
  is '缴费金额';
comment on column UNICALL.TEMP_XSHDGL.is_success
  is '1:成功 0:失败';
comment on column UNICALL.TEMP_XSHDGL.task_date
  is '任务分配时间';
comment on column UNICALL.TEMP_XSHDGL.gro_id
  is '组ID';
comment on column UNICALL.TEMP_XSHDGL.cat_nam
  is '组名称';
comment on column UNICALL.TEMP_XSHDGL.cover1
  is '财务交易责任起始日期';
comment on column UNICALL.TEMP_XSHDGL.day_flag
  is '间隔标志位（10/20/30/40/50/60）';

prompt
prompt Creating table TEMP_XSHFMX
prompt ==========================
prompt
create table UNICALL.TEMP_XSHFMX
(
  use_ali_id     VARCHAR2(20),
  use_nam        VARCHAR2(20),
  policyno       VARCHAR2(20),
  call_date      DATE,
  returnvist_sta NUMBER(10),
  amount         NUMBER(20,6),
  task_date      DATE,
  begdate        DATE,
  gro_id         NUMBER(30),
  cat_nam        VARCHAR2(2000)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.TEMP_XSHFMX
  is '续收回访情况分析表';
comment on column UNICALL.TEMP_XSHFMX.use_ali_id
  is '续期代表工号';
comment on column UNICALL.TEMP_XSHFMX.use_nam
  is '续期代表姓名';
comment on column UNICALL.TEMP_XSHFMX.policyno
  is '保单号';
comment on column UNICALL.TEMP_XSHFMX.call_date
  is '拨打时间';
comment on column UNICALL.TEMP_XSHFMX.returnvist_sta
  is '回访状态';
comment on column UNICALL.TEMP_XSHFMX.amount
  is '缴费金额';
comment on column UNICALL.TEMP_XSHFMX.task_date
  is '任务分配时间';
comment on column UNICALL.TEMP_XSHFMX.begdate
  is '责任起始日期';
comment on column UNICALL.TEMP_XSHFMX.gro_id
  is '组ID';
comment on column UNICALL.TEMP_XSHFMX.cat_nam
  is '组名称';

prompt
prompt Creating table TEMP_Y_PREREC
prompt ============================
prompt
create table UNICALL.TEMP_Y_PREREC
(
  sno      NUMBER(18) not null,
  policyno VARCHAR2(20),
  amount   NUMBER(20,4) not null,
  paydate  DATE not null,
  rn       NUMBER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TMP1
prompt ===================
prompt
create table UNICALL.TMP1
(
  org_id CHAR(14),
  n4     NUMBER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TMP2
prompt ===================
prompt
create table UNICALL.TMP2
(
  org_id CHAR(14),
  n4     NUMBER
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TMPCOD1
prompt ======================
prompt
create table UNICALL.TMPCOD1
(
  branch CHAR(14)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TMPCOD2
prompt ======================
prompt
create table UNICALL.TMPCOD2
(
  orgcode CHAR(14)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TT
prompt =================
prompt
create table UNICALL.TT
(
  id             NUMBER(18) not null,
  application_id VARCHAR2(18),
  appno          VARCHAR2(18),
  policyno       VARCHAR2(18),
  cre_time       DATE,
  use_ali_id     VARCHAR2(20),
  sale_src       VARCHAR2(2),
  sale_cha       VARCHAR2(2),
  status         NUMBER(10),
  task_date      DATE,
  task_use_ali   VARCHAR2(20),
  last_call_time DATE,
  is_pro         VARCHAR2(2),
  res_remark     VARCHAR2(400),
  app_remark     VARCHAR2(400),
  is_close       VARCHAR2(2),
  next_call_time VARCHAR2(20),
  dx_org_id      NUMBER(10),
  prj_org_id     NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table TY_CUS_USE_ROL
prompt =============================
prompt
create table UNICALL.TY_CUS_USE_ROL
(
  id     NUMBER(30) not null,
  cus_id NUMBER(30) not null,
  use_id NUMBER(30) not null,
  rol    NUMBER(30) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table T_APP_STATUS
prompt ===========================
prompt
create table UNICALL.T_APP_STATUS
(
  status_code VARCHAR2(3) not null,
  status_desc VARCHAR2(100),
  status_ord  VARCHAR2(3) not null,
  status_type VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_APP_STATUS
  is '投保单状态表';
comment on column UNICALL.T_APP_STATUS.status_code
  is '状态码';
comment on column UNICALL.T_APP_STATUS.status_type
  is '状态类型{01:电销状态 02:业务系统状态}';
alter table UNICALL.T_APP_STATUS
  add constraint PK_T_APP_STATUS primary key (STATUS_ORD)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
grant select on UNICALL.T_APP_STATUS to SXDXETL;

prompt
prompt Creating table T_BILLING_INFO
prompt =============================
prompt
create table UNICALL.T_BILLING_INFO
(
  app_no                  VARCHAR2(18) not null,
  policyno                VARCHAR2(20),
  polist                  CHAR(1),
  payment_type            VARCHAR2(30),
  app_nm                  VARCHAR2(30),
  contact_tel             VARCHAR2(30),
  app_mobile              VARCHAR2(30),
  insurance_name          VARCHAR2(100),
  rig_sta_des             VARCHAR2(64),
  tsrid                   VARCHAR2(10),
  payment_account_name    VARCHAR2(30),
  payment_accout_bankcode VARCHAR2(30),
  payment_account         VARCHAR2(30),
  id_no                   VARCHAR2(30),
  prj_id                  NUMBER(10),
  opdate                  DATE,
  submit_date             DATE,
  coverage                VARCHAR2(20),
  years                   NUMBER(20),
  cover1                  DATE,
  cover2                  DATE,
  amount                  NUMBER(20,4),
  nextdate                DATE,
  rectele                 VARCHAR2(30),
  sprerec_years           NUMBER(20),
  pay_sum                 NUMBER(20),
  insurance_code          VARCHAR2(50),
  company_id              NUMBER(10),
  owed                    NUMBER,
  owed_amount             NUMBER(20,4),
  appdate                 DATE,
  charge_status           CHAR(2),
  reason                  VARCHAR2(200),
  owed_status             CHAR(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 6M
    next 8K
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_BILLING_INFO
  is '续期账单信息表';
comment on column UNICALL.T_BILLING_INFO.app_no
  is '投保单号';
comment on column UNICALL.T_BILLING_INFO.policyno
  is '保单号';
comment on column UNICALL.T_BILLING_INFO.polist
  is '保单状态';
comment on column UNICALL.T_BILLING_INFO.payment_type
  is '缴费方式';
comment on column UNICALL.T_BILLING_INFO.app_nm
  is '投保人姓名';
comment on column UNICALL.T_BILLING_INFO.contact_tel
  is '投保人固定电话';
comment on column UNICALL.T_BILLING_INFO.app_mobile
  is '投保人手机';
comment on column UNICALL.T_BILLING_INFO.insurance_name
  is '险种名称';
comment on column UNICALL.T_BILLING_INFO.rig_sta_des
  is '销售坐席状态';
comment on column UNICALL.T_BILLING_INFO.tsrid
  is '销售坐席';
comment on column UNICALL.T_BILLING_INFO.payment_account_name
  is '缴费账户名';
comment on column UNICALL.T_BILLING_INFO.payment_accout_bankcode
  is '开户银行';
comment on column UNICALL.T_BILLING_INFO.payment_account
  is '缴费账号';
comment on column UNICALL.T_BILLING_INFO.id_no
  is '投保人证件号';
comment on column UNICALL.T_BILLING_INFO.prj_id
  is '所属项目';
comment on column UNICALL.T_BILLING_INFO.opdate
  is '保单生效时间';
comment on column UNICALL.T_BILLING_INFO.submit_date
  is '投保时间';
comment on column UNICALL.T_BILLING_INFO.coverage
  is '保额';
comment on column UNICALL.T_BILLING_INFO.years
  is '缴费期次';
comment on column UNICALL.T_BILLING_INFO.cover1
  is '缴费年限';
comment on column UNICALL.T_BILLING_INFO.cover2
  is '缴费中止期';
comment on column UNICALL.T_BILLING_INFO.amount
  is '单期保费';
comment on column UNICALL.T_BILLING_INFO.nextdate
  is '下一缴费日期';
comment on column UNICALL.T_BILLING_INFO.rectele
  is '投保人缴费电话';
comment on column UNICALL.T_BILLING_INFO.sprerec_years
  is '应缴期数';
comment on column UNICALL.T_BILLING_INFO.pay_sum
  is '已缴期数';
comment on column UNICALL.T_BILLING_INFO.insurance_code
  is '险种代码';
comment on column UNICALL.T_BILLING_INFO.company_id
  is '外包公司ID';
comment on column UNICALL.T_BILLING_INFO.owed
  is '欠缴期数';
comment on column UNICALL.T_BILLING_INFO.owed_amount
  is '累计欠缴保费';
comment on column UNICALL.T_BILLING_INFO.appdate
  is '最近一次扣费时间';
comment on column UNICALL.T_BILLING_INFO.charge_status
  is '最近一次扣费结果';
comment on column UNICALL.T_BILLING_INFO.reason
  is '最近一次扣费失败原因';
comment on column UNICALL.T_BILLING_INFO.owed_status
  is '缴费状态';
create index UNICALL.IDX_BILLING_INFO_POLICYNO on UNICALL.T_BILLING_INFO (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.T_BILLING_INFO
  add constraint PK_T_BILLING_INFO primary key (APP_NO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 512K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_BILLING_INFO_TEMP
prompt ==================================
prompt
create table UNICALL.T_BILLING_INFO_TEMP
(
  app_no                  VARCHAR2(18) not null,
  policyno                VARCHAR2(20),
  polist                  CHAR(1),
  payment_type            VARCHAR2(30),
  app_nm                  VARCHAR2(30),
  contact_tel             VARCHAR2(30),
  app_mobile              VARCHAR2(30),
  insurance_name          VARCHAR2(100),
  rig_sta_des             VARCHAR2(64),
  tsrid                   VARCHAR2(10),
  payment_account_name    VARCHAR2(30),
  payment_accout_bankcode VARCHAR2(30),
  payment_account         VARCHAR2(30),
  id_no                   VARCHAR2(50),
  prj_id                  NUMBER(10),
  opdate                  DATE,
  submit_date             DATE,
  coverage                VARCHAR2(20),
  years                   NUMBER(20),
  cover1                  DATE,
  cover2                  DATE,
  amount                  NUMBER(20,4),
  nextdate                DATE,
  rectele                 VARCHAR2(30),
  sprerec_years           NUMBER(20),
  pay_sum                 NUMBER(20),
  insurance_code          VARCHAR2(50),
  company_id              NUMBER(10),
  owed                    NUMBER,
  owed_amount             NUMBER(20,4),
  appdate                 DATE,
  charge_status           CHAR(2),
  reason                  VARCHAR2(200),
  owed_status             CHAR(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_BILLING_INFO_TEMP
  is '续期账单信息表';
comment on column UNICALL.T_BILLING_INFO_TEMP.app_no
  is '投保单号';
comment on column UNICALL.T_BILLING_INFO_TEMP.policyno
  is '保单号';
comment on column UNICALL.T_BILLING_INFO_TEMP.polist
  is '保单状态';
comment on column UNICALL.T_BILLING_INFO_TEMP.payment_type
  is '缴费方式';
comment on column UNICALL.T_BILLING_INFO_TEMP.app_nm
  is '投保人姓名';
comment on column UNICALL.T_BILLING_INFO_TEMP.contact_tel
  is '投保人固定电话';
comment on column UNICALL.T_BILLING_INFO_TEMP.app_mobile
  is '投保人手机';
comment on column UNICALL.T_BILLING_INFO_TEMP.insurance_name
  is '险种名称';
comment on column UNICALL.T_BILLING_INFO_TEMP.rig_sta_des
  is '销售坐席状态';
comment on column UNICALL.T_BILLING_INFO_TEMP.tsrid
  is '销售坐席';
comment on column UNICALL.T_BILLING_INFO_TEMP.payment_account_name
  is '缴费账户名';
comment on column UNICALL.T_BILLING_INFO_TEMP.payment_accout_bankcode
  is '开户银行';
comment on column UNICALL.T_BILLING_INFO_TEMP.payment_account
  is '缴费账号';
comment on column UNICALL.T_BILLING_INFO_TEMP.id_no
  is '投保人证件号';
comment on column UNICALL.T_BILLING_INFO_TEMP.prj_id
  is '所属项目';
comment on column UNICALL.T_BILLING_INFO_TEMP.opdate
  is '保单生效时间';
comment on column UNICALL.T_BILLING_INFO_TEMP.submit_date
  is '投保时间';
comment on column UNICALL.T_BILLING_INFO_TEMP.coverage
  is '保额';
comment on column UNICALL.T_BILLING_INFO_TEMP.years
  is '缴费期次';
comment on column UNICALL.T_BILLING_INFO_TEMP.cover1
  is '缴费年限';
comment on column UNICALL.T_BILLING_INFO_TEMP.cover2
  is '缴费中止期';
comment on column UNICALL.T_BILLING_INFO_TEMP.amount
  is '单期保费';
comment on column UNICALL.T_BILLING_INFO_TEMP.nextdate
  is '下一缴费日期';
comment on column UNICALL.T_BILLING_INFO_TEMP.rectele
  is '投保人缴费电话';
comment on column UNICALL.T_BILLING_INFO_TEMP.sprerec_years
  is '应缴期数';
comment on column UNICALL.T_BILLING_INFO_TEMP.pay_sum
  is '已缴期数';
comment on column UNICALL.T_BILLING_INFO_TEMP.insurance_code
  is '险种代码';
comment on column UNICALL.T_BILLING_INFO_TEMP.company_id
  is '外包公司ID';
comment on column UNICALL.T_BILLING_INFO_TEMP.owed
  is '欠缴期数';
comment on column UNICALL.T_BILLING_INFO_TEMP.owed_amount
  is '累计欠缴保费';
comment on column UNICALL.T_BILLING_INFO_TEMP.appdate
  is '最近一次扣费时间';
comment on column UNICALL.T_BILLING_INFO_TEMP.charge_status
  is '最近一次扣费结果';
comment on column UNICALL.T_BILLING_INFO_TEMP.reason
  is '最近一次扣费失败原因';
comment on column UNICALL.T_BILLING_INFO_TEMP.owed_status
  is '缴费状态';
create index UNICALL.IDX_T_BILLING_INFO_TEMP_APP_NO on UNICALL.T_BILLING_INFO_TEMP (APP_NO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_DELIVERY_INFO
prompt ==============================
prompt
create table UNICALL.T_DELIVERY_INFO
(
  deli_id   NUMBER(20) not null,
  app_id    VARCHAR2(18),
  form_id   NUMBER(20),
  deli_adds VARCHAR2(500) not null,
  deli_tel  VARCHAR2(50) not null,
  deli_note VARCHAR2(500),
  zone_code VARCHAR2(50),
  rev1      VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.T_DELIVERY_INFO.deli_id
  is 'PK';
comment on column UNICALL.T_DELIVERY_INFO.app_id
  is '投保单ID';
comment on column UNICALL.T_DELIVERY_INFO.form_id
  is '自建投保单ID';
comment on column UNICALL.T_DELIVERY_INFO.deli_adds
  is '送单地址';
comment on column UNICALL.T_DELIVERY_INFO.deli_tel
  is '送单电话';
comment on column UNICALL.T_DELIVERY_INFO.deli_note
  is '备注';
comment on column UNICALL.T_DELIVERY_INFO.zone_code
  is '区域编码';
comment on column UNICALL.T_DELIVERY_INFO.rev1
  is '保留1';
alter table UNICALL.T_DELIVERY_INFO
  add constraint PK_T_DELIVERY_INFO_ID primary key (DELI_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_EXP_INFO
prompt =========================
prompt
create table UNICALL.T_EXP_INFO
(
  exp_id     VARCHAR2(18) not null,
  exp_nam    VARCHAR2(100),
  tel        VARCHAR2(18),
  addr       VARCHAR2(300),
  company_id NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_EXP_INFO
  is '递送公司信息表';
comment on column UNICALL.T_EXP_INFO.exp_id
  is '递送公司ID';
comment on column UNICALL.T_EXP_INFO.exp_nam
  is '递送公司名称';
comment on column UNICALL.T_EXP_INFO.tel
  is '联系电话';
comment on column UNICALL.T_EXP_INFO.addr
  is '联系地址';
comment on column UNICALL.T_EXP_INFO.company_id
  is '所属分公司ID';
alter table UNICALL.T_EXP_INFO
  add constraint PK_T_EXP_INFO primary key (EXP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_EXP_LOG
prompt ========================
prompt
create table UNICALL.T_EXP_LOG
(
  id            NUMBER(10) not null,
  ins_no        VARCHAR2(18),
  exp_id        VARCHAR2(18),
  ord_id        VARCHAR2(18),
  org           VARCHAR2(10),
  oper_time     VARCHAR2(30),
  exp_status    VARCHAR2(2),
  back_no       VARCHAR2(18),
  back_time     VARCHAR2(30),
  exchange_time VARCHAR2(30)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_EXP_LOG
  is '递送信息表';
comment on column UNICALL.T_EXP_LOG.id
  is '递送ID';
comment on column UNICALL.T_EXP_LOG.ins_no
  is '投保单号';
comment on column UNICALL.T_EXP_LOG.exp_id
  is '递送公司';
comment on column UNICALL.T_EXP_LOG.ord_id
  is '运单号';
comment on column UNICALL.T_EXP_LOG.org
  is '用户机构';
comment on column UNICALL.T_EXP_LOG.oper_time
  is '状态变化时间';
comment on column UNICALL.T_EXP_LOG.exp_status
  is '递送状态';
comment on column UNICALL.T_EXP_LOG.back_no
  is '回执号';
comment on column UNICALL.T_EXP_LOG.back_time
  is '回执时间';
comment on column UNICALL.T_EXP_LOG.exchange_time
  is '交接时间';
alter table UNICALL.T_EXP_LOG
  add constraint PK_T_EXP_LOG primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_HOLIDAY_INFO
prompt =============================
prompt
create table UNICALL.T_HOLIDAY_INFO
(
  id          NUMBER(10) not null,
  date_type   VARCHAR2(2) not null,
  start_date  VARCHAR2(20) not null,
  end_date    VARCHAR2(20) not null,
  date_desc   VARCHAR2(100),
  branch_code VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on table UNICALL.T_HOLIDAY_INFO
  is '节假日（工作日）设置表';
comment on column UNICALL.T_HOLIDAY_INFO.id
  is '序列号';
comment on column UNICALL.T_HOLIDAY_INFO.date_type
  is '类型 01：节假日；02：工作日';
comment on column UNICALL.T_HOLIDAY_INFO.start_date
  is '起始日期';
comment on column UNICALL.T_HOLIDAY_INFO.end_date
  is '截至日期';
comment on column UNICALL.T_HOLIDAY_INFO.date_desc
  is '说明';
comment on column UNICALL.T_HOLIDAY_INFO.branch_code
  is '分公司代码';
create index UNICALL.IDX_T_HOLIDAY_INFO_01 on UNICALL.T_HOLIDAY_INFO (START_DATE DESC)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );
alter table UNICALL.T_HOLIDAY_INFO
  add constraint PK_T_HOLIDAY_INFO primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table T_INS_STA_HIS
prompt ============================
prompt
create table UNICALL.T_INS_STA_HIS
(
  id       NUMBER(10) not null,
  ins_no   VARCHAR2(18),
  ins_sta  VARCHAR2(3),
  chg_time VARCHAR2(30),
  note     VARCHAR2(300),
  oper_id  VARCHAR2(10),
  pol_sta  VARCHAR2(3),
  source   VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 12M
    next 8K
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_INS_STA_HIS
  is '投保单状态历史表';
comment on column UNICALL.T_INS_STA_HIS.id
  is '序列号';
comment on column UNICALL.T_INS_STA_HIS.ins_no
  is '投保单号';
comment on column UNICALL.T_INS_STA_HIS.ins_sta
  is '投保单状态';
comment on column UNICALL.T_INS_STA_HIS.chg_time
  is '状态变化时间';
comment on column UNICALL.T_INS_STA_HIS.note
  is '说明';
comment on column UNICALL.T_INS_STA_HIS.oper_id
  is '操作人ID';
comment on column UNICALL.T_INS_STA_HIS.pol_sta
  is '保单状态';
comment on column UNICALL.T_INS_STA_HIS.source
  is '状态来源';
create index UNICALL.IDX_INS_STA_HIS_APNO on UNICALL.T_INS_STA_HIS (INS_NO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.T_INS_STA_HIS
  add constraint PK_T_INS_STA_HIS primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );
grant select on UNICALL.T_INS_STA_HIS to SXDXETL;

prompt
prompt Creating table T_PROJECT_INFO
prompt =============================
prompt
create table UNICALL.T_PROJECT_INFO
(
  prj_id     NUMBER(10) not null,
  prj_name   VARCHAR2(100) not null,
  org_id     NUMBER(10),
  prj_status VARCHAR2(2) not null,
  sale_cha   VARCHAR2(2) not null,
  ins_src    VARCHAR2(2) not null,
  oc_id      NUMBER(10),
  file_fmt   VARCHAR2(2),
  memo       VARCHAR2(300),
  sign_typ   VARCHAR2(2) not null,
  deli_typ   VARCHAR2(2) not null,
  bank_flag  CHAR(1),
  prj_typ    VARCHAR2(2),
  cus_typ    VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_PROJECT_INFO
  is '项目基本信息表';
comment on column UNICALL.T_PROJECT_INFO.prj_id
  is '项目ID';
comment on column UNICALL.T_PROJECT_INFO.prj_name
  is '项目名称';
comment on column UNICALL.T_PROJECT_INFO.org_id
  is '项目所属机构';
comment on column UNICALL.T_PROJECT_INFO.prj_status
  is '是否有效';
comment on column UNICALL.T_PROJECT_INFO.sale_cha
  is '销售渠道';
comment on column UNICALL.T_PROJECT_INFO.ins_src
  is '投保单来源';
comment on column UNICALL.T_PROJECT_INFO.oc_id
  is '相关外包公司';
comment on column UNICALL.T_PROJECT_INFO.file_fmt
  is '导入文件格式';
comment on column UNICALL.T_PROJECT_INFO.memo
  is '项目说明';
comment on column UNICALL.T_PROJECT_INFO.sign_typ
  is '出单方式';
comment on column UNICALL.T_PROJECT_INFO.deli_typ
  is '配送方式';
comment on column UNICALL.T_PROJECT_INFO.bank_flag
  is '是否银保通';
comment on column UNICALL.T_PROJECT_INFO.prj_typ
  is '项目类别';
comment on column UNICALL.T_PROJECT_INFO.cus_typ
  is '客户类别';
alter table UNICALL.T_PROJECT_INFO
  add constraint PK_T_PROJECT_INFO primary key (PRJ_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
grant select on UNICALL.T_PROJECT_INFO to SXDXETL;

prompt
prompt Creating table T_PRJ_NOTICE_INFO
prompt ================================
prompt
create table UNICALL.T_PRJ_NOTICE_INFO
(
  ncid        NUMBER(10) not null,
  prj_id      NUMBER(10),
  status_code VARCHAR2(3),
  notice_flag VARCHAR2(2),
  notice_pe   NUMBER(3),
  warn_pe     NUMBER(3),
  use_id      NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.T_PRJ_NOTICE_INFO.prj_id
  is '项目ID';
comment on column UNICALL.T_PRJ_NOTICE_INFO.status_code
  is '状态码';
comment on column UNICALL.T_PRJ_NOTICE_INFO.notice_flag
  is '是否提醒';
comment on column UNICALL.T_PRJ_NOTICE_INFO.notice_pe
  is '提醒期间';
comment on column UNICALL.T_PRJ_NOTICE_INFO.warn_pe
  is '预警期间';
comment on column UNICALL.T_PRJ_NOTICE_INFO.use_id
  is '提醒对象';
alter table UNICALL.T_PRJ_NOTICE_INFO
  add constraint PK_T_PRJ_NOTICE_INFO primary key (NCID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.T_PRJ_NOTICE_INFO
  add constraint FK_T_PRJ_NO_R_T_PROJEC foreign key (PRJ_ID)
  references UNICALL.T_PROJECT_INFO (PRJ_ID);

prompt
prompt Creating table T_NOTICE_INS
prompt ===========================
prompt
create table UNICALL.T_NOTICE_INS
(
  nins_id     NUMBER(10) not null,
  ncid        NUMBER(10),
  appno       VARCHAR2(18),
  policyno    VARCHAR2(18),
  c_date      VARCHAR2(30),
  nc_status   VARCHAR2(2),
  proc_status VARCHAR2(2),
  passed      NUMBER(4) not null,
  updatetime  DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_NOTICE_INS
  is '提醒实例表';
comment on column UNICALL.T_NOTICE_INS.nins_id
  is '提醒实例ID';
comment on column UNICALL.T_NOTICE_INS.ncid
  is '提醒ID';
comment on column UNICALL.T_NOTICE_INS.appno
  is '投保单号';
comment on column UNICALL.T_NOTICE_INS.policyno
  is '保单号';
comment on column UNICALL.T_NOTICE_INS.c_date
  is '生成日期';
comment on column UNICALL.T_NOTICE_INS.nc_status
  is '提醒状态';
comment on column UNICALL.T_NOTICE_INS.proc_status
  is '处理状态';
comment on column UNICALL.T_NOTICE_INS.passed
  is '状态已过天数';
comment on column UNICALL.T_NOTICE_INS.updatetime
  is '处理时间';
alter table UNICALL.T_NOTICE_INS
  add constraint PK_T_NOTICE_INS primary key (NINS_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.T_NOTICE_INS
  add constraint FK_T_NOTICE_R_T_PRJ_NO foreign key (NCID)
  references UNICALL.T_PRJ_NOTICE_INFO (NCID);

prompt
prompt Creating table T_NOTICE_TPL
prompt ===========================
prompt
create table UNICALL.T_NOTICE_TPL
(
  tpl_id   NUMBER(10) not null,
  tpl_name VARCHAR2(100),
  tpl_desc VARCHAR2(200)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.T_NOTICE_TPL.tpl_id
  is '模板ID';
comment on column UNICALL.T_NOTICE_TPL.tpl_name
  is '模板名';
comment on column UNICALL.T_NOTICE_TPL.tpl_desc
  is '模板描述';
alter table UNICALL.T_NOTICE_TPL
  add constraint PK_T_NOTICE_TPL primary key (TPL_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_NOTICE_TPL_DTL
prompt ===============================
prompt
create table UNICALL.T_NOTICE_TPL_DTL
(
  dtl_id      NUMBER(10) not null,
  status_code VARCHAR2(3),
  tpl_id      NUMBER(10),
  notice_flag VARCHAR2(2),
  notice_pe   NUMBER(3),
  warn_pe     NUMBER(3)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.T_NOTICE_TPL_DTL.status_code
  is '状态码';
comment on column UNICALL.T_NOTICE_TPL_DTL.tpl_id
  is '模板ID';
alter table UNICALL.T_NOTICE_TPL_DTL
  add constraint PK_T_NOTICE_TPL_DTL primary key (DTL_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.T_NOTICE_TPL_DTL
  add constraint FK_T_NOTICE_DTL_R_T_NOTICE foreign key (TPL_ID)
  references UNICALL.T_NOTICE_TPL (TPL_ID);

prompt
prompt Creating table T_PERSON
prompt =======================
prompt
create table UNICALL.T_PERSON
(
  fname   VARCHAR2(20) not null,
  fage    NUMBER(10),
  fremark VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255;
alter table UNICALL.T_PERSON
  add primary key (FNAME)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table T_PRJ_GRP
prompt ========================
prompt
create table UNICALL.T_PRJ_GRP
(
  grp_id   NUMBER(10) not null,
  grp_name VARCHAR2(100),
  grp_desc VARCHAR2(300),
  is_del   CHAR(2),
  org_id   NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_PRJ_GRP
  is '项目群信息表';
comment on column UNICALL.T_PRJ_GRP.grp_id
  is '群ID';
comment on column UNICALL.T_PRJ_GRP.grp_name
  is '项目群名称';
comment on column UNICALL.T_PRJ_GRP.grp_desc
  is '项目群描述';
comment on column UNICALL.T_PRJ_GRP.is_del
  is '删除标记：01：正常 02：已删除';
comment on column UNICALL.T_PRJ_GRP.org_id
  is '实现数据权限过滤';
alter table UNICALL.T_PRJ_GRP
  add constraint PK_T_PRJ_GRP primary key (GRP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_PRJ_INS_DET
prompt ============================
prompt
create table UNICALL.T_PRJ_INS_DET
(
  id      NUMBER(10) not null,
  prj_id  NUMBER(10),
  bat_nam VARCHAR2(100),
  ins_no  VARCHAR2(18)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_PRJ_INS_DET
  is '投保单导入明细表';
comment on column UNICALL.T_PRJ_INS_DET.prj_id
  is '项目ID';
comment on column UNICALL.T_PRJ_INS_DET.bat_nam
  is '批次名称';
comment on column UNICALL.T_PRJ_INS_DET.ins_no
  is '投保单号';
alter table UNICALL.T_PRJ_INS_DET
  add constraint PK_T_PRJ_INS_DET primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_PRJ_INS_LOG
prompt ============================
prompt
create table UNICALL.T_PRJ_INS_LOG
(
  id        NUMBER(10) not null,
  prj_id    NUMBER(10),
  bat_nam   VARCHAR2(100),
  fil       VARCHAR2(100),
  file_fmt  VARCHAR2(2),
  file_time VARCHAR2(30),
  note      VARCHAR2(1000),
  totol     NUMBER(10),
  suc_cou   NUMBER(10),
  fai_cou   NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_PRJ_INS_LOG
  is '投保单导入记录表';
comment on column UNICALL.T_PRJ_INS_LOG.prj_id
  is '项目ID';
comment on column UNICALL.T_PRJ_INS_LOG.bat_nam
  is '批次名称';
comment on column UNICALL.T_PRJ_INS_LOG.fil
  is '导入文件';
comment on column UNICALL.T_PRJ_INS_LOG.file_fmt
  is '导入文件格式';
comment on column UNICALL.T_PRJ_INS_LOG.file_time
  is '导入时间';
comment on column UNICALL.T_PRJ_INS_LOG.note
  is '备注';
comment on column UNICALL.T_PRJ_INS_LOG.totol
  is '总数';
comment on column UNICALL.T_PRJ_INS_LOG.suc_cou
  is '成功数量';
comment on column UNICALL.T_PRJ_INS_LOG.fai_cou
  is '失败数量';
alter table UNICALL.T_PRJ_INS_LOG
  add constraint PK_T_PRJ_INS_LOG primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_PRJ_REL_GRP
prompt ============================
prompt
create table UNICALL.T_PRJ_REL_GRP
(
  rel_id NUMBER(10) not null,
  grp_id NUMBER(10),
  prj_id NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_PRJ_REL_GRP
  is '项目与项目群关系表';
comment on column UNICALL.T_PRJ_REL_GRP.rel_id
  is '关系ID';
comment on column UNICALL.T_PRJ_REL_GRP.grp_id
  is '群ID';
comment on column UNICALL.T_PRJ_REL_GRP.prj_id
  is '项目ID';
alter table UNICALL.T_PRJ_REL_GRP
  add constraint PK_T_PRJ_REL_GRP primary key (REL_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.T_PRJ_REL_GRP
  add constraint FK_T_PRJ_RE_R_T_PRJ_GR foreign key (GRP_ID)
  references UNICALL.T_PRJ_GRP (GRP_ID);
alter table UNICALL.T_PRJ_REL_GRP
  add constraint FK_T_PRJ_RE_R_T_PROJEC foreign key (PRJ_ID)
  references UNICALL.T_PROJECT_INFO (PRJ_ID);

prompt
prompt Creating table T_PRJ_USER_REL
prompt =============================
prompt
create table UNICALL.T_PRJ_USER_REL
(
  prj_id NUMBER(10),
  rel_id NUMBER(10) not null,
  rol_id NUMBER(5),
  use_id NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_PRJ_USER_REL
  is '项目成员表';
comment on column UNICALL.T_PRJ_USER_REL.prj_id
  is '项目ID';
comment on column UNICALL.T_PRJ_USER_REL.rel_id
  is '成员ID';
alter table UNICALL.T_PRJ_USER_REL
  add constraint PK_T_PRJ_USER_REL primary key (REL_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.T_PRJ_USER_REL
  add constraint FK_T_PRJ_US_R_C_ROL foreign key (ROL_ID)
  references UNICALL.C_ROL (ROL_ID);
alter table UNICALL.T_PRJ_USER_REL
  add constraint FK_T_PRJ_US_R_C_USE foreign key (USE_ID)
  references UNICALL.C_USE (USE_ID);
alter table UNICALL.T_PRJ_USER_REL
  add constraint FK_T_PRJ_US_R_T_PROJEC foreign key (PRJ_ID)
  references UNICALL.T_PROJECT_INFO (PRJ_ID);

prompt
prompt Creating table T_TEMPLATE_INFO
prompt ==============================
prompt
create table UNICALL.T_TEMPLATE_INFO
(
  id           NUMBER(10) not null,
  nam          VARCHAR2(100),
  file_nam     VARCHAR2(100),
  org          VARCHAR2(30),
  oper_time    VARCHAR2(30),
  oper_id      VARCHAR2(10),
  template_str VARCHAR2(4000),
  exp_id       VARCHAR2(18)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_TEMPLATE_INFO
  is '模版信息表';
comment on column UNICALL.T_TEMPLATE_INFO.id
  is '模板ID';
comment on column UNICALL.T_TEMPLATE_INFO.nam
  is '模板名称';
comment on column UNICALL.T_TEMPLATE_INFO.file_nam
  is '文件名';
comment on column UNICALL.T_TEMPLATE_INFO.org
  is '机构';
comment on column UNICALL.T_TEMPLATE_INFO.oper_time
  is '操作时间';
comment on column UNICALL.T_TEMPLATE_INFO.oper_id
  is '操作人';
comment on column UNICALL.T_TEMPLATE_INFO.template_str
  is '模板布局字符串';
comment on column UNICALL.T_TEMPLATE_INFO.exp_id
  is '递送公司';
alter table UNICALL.T_TEMPLATE_INFO
  add constraint PK_T_TEMPLATE_INFO primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_XQ_CBJ_LIST_REPORT
prompt ===================================
prompt
create table UNICALL.T_XQ_CBJ_LIST_REPORT
(
  opdate       DATE,
  idorg        VARCHAR2(50),
  saleattr     VARCHAR2(100),
  agent_id     VARCHAR2(50),
  emp_name     VARCHAR2(50),
  policyno     VARCHAR2(18) not null,
  appno        VARCHAR2(18) not null,
  classcode    CHAR(8),
  classname    VARCHAR2(100),
  acus_name    VARCHAR2(100),
  acus_licno   VARCHAR2(18),
  icus_name    VARCHAR2(100),
  icus_licno   VARCHAR2(18),
  tb_job       VARCHAR2(200),
  rectele      VARCHAR2(50),
  tb_hometel   VARCHAR2(50),
  tb_unittel   VARCHAR2(50),
  tb_mobiletel VARCHAR2(50),
  post_address VARCHAR2(1000),
  post_zip     VARCHAR2(6),
  addr_address VARCHAR2(1000),
  addr_zip     VARCHAR2(6),
  polist       VARCHAR2(100),
  setcode      VARCHAR2(50),
  delfrm       VARCHAR2(50),
  bankcode     VARCHAR2(50),
  bankno       VARCHAR2(50),
  begdate      DATE,
  nextdate     DATE,
  years        NUMBER(11),
  sumamount    NUMBER(18,2),
  singleamount NUMBER(18,2),
  yearnum      NUMBER(11),
  linum        NUMBER(11),
  nh_total_fee NUMBER(18,2),
  total_fee    NUMBER(18,2),
  create_date  DATE not null,
  update_date  DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_XQ_CBJ_LIST_REPORT
  is '电销承保件清单报表';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.opdate
  is '承保月份';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.idorg
  is '分公司';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.saleattr
  is '销售渠道';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.agent_id
  is '业务员工号';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.emp_name
  is '业务员姓名';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.policyno
  is '保单号';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.appno
  is '投保单号';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.classcode
  is '险种代码';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.classname
  is '险种名称';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.acus_name
  is '投保人姓名';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.acus_licno
  is '投保人身份证号';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.icus_name
  is '被保人姓名';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.icus_licno
  is '被保人身份证号';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.tb_job
  is '投保人职业';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.rectele
  is '投保人收费电话';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.tb_hometel
  is '投保人家庭电话';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.tb_unittel
  is '投保人单位电话';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.tb_mobiletel
  is '投保人手机号';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.post_address
  is '客户邮寄地址';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.post_zip
  is '客户邮寄地址对应的邮编';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.addr_address
  is '客户住址';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.addr_zip
  is '客户住址对应的邮编';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.polist
  is '保单状态';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.setcode
  is '缴费方式';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.delfrm
  is '支付形式';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.bankcode
  is '扣款银行';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.bankno
  is '扣款账号';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.begdate
  is '保单责任起期';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.nextdate
  is '下次缴费日期';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.years
  is '应缴期次';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.sumamount
  is '累计缴费';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.singleamount
  is '单期缴费';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.yearnum
  is '缴费年限';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.linum
  is '理赔次数';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.nh_total_fee
  is '保单总保费（年化新保）每年交费金额
';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.total_fee
  is '保单总保额';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.create_date
  is '创建时间';
comment on column UNICALL.T_XQ_CBJ_LIST_REPORT.update_date
  is '更新时间';
create index UNICALL.T_XQ_CBJ_LIST_REPORT_OPDATE on UNICALL.T_XQ_CBJ_LIST_REPORT (OPDATE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table T_XQ_RESERVE_LIST_REPORT
prompt =======================================
prompt
create table UNICALL.T_XQ_RESERVE_LIST_REPORT
(
  cre_time       DATE,
  dx_org_id      NUMBER(10),
  prj_org_id     NUMBER(10),
  use_ali_id     VARCHAR2(20),
  sum_amount     NUMBER(18),
  yy_suc_amount  NUMBER(18),
  jjps_amount    NUMBER(18),
  wlxd_amount    NUMBER(18),
  wtj_amount     NUMBER(18),
  wtj_suc_amount NUMBER(18),
  rate_yy        NUMBER(18,2),
  rate_wtj       NUMBER(18,2),
  dx_org_name    VARCHAR2(100),
  prj_org_name   VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.T_XQ_RESERVE_LIST_REPORT
  is '预约和问题件统计报表';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.cre_time
  is '创建时间';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.dx_org_id
  is '电销中心ID';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.prj_org_id
  is '所属项目ID';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.use_ali_id
  is '预约坐席工号';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.sum_amount
  is '预约数';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.yy_suc_amount
  is '预约成功数';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.jjps_amount
  is '拒绝配送数';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.wlxd_amount
  is '未联系到数量';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.wtj_amount
  is '问题件数量';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.wtj_suc_amount
  is '问题件处理成功数';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.rate_yy
  is '预约成功率';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.rate_wtj
  is '问题件处理成功率';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.dx_org_name
  is '电销中心';
comment on column UNICALL.T_XQ_RESERVE_LIST_REPORT.prj_org_name
  is '所属项目';
create index UNICALL.IDX_XQ_RESERVE_CRE_TIME on UNICALL.T_XQ_RESERVE_LIST_REPORT (CRE_TIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_RESERVE_USE_ALI_ID on UNICALL.T_XQ_RESERVE_LIST_REPORT (USE_ALI_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table USABLE_SHCPIC_PREINS_CUS_HIS
prompt ===========================================
prompt
create table UNICALL.USABLE_SHCPIC_PREINS_CUS_HIS
(
  usable_id           NUMBER(10) not null,
  usable_zone_number  VARCHAR2(10),
  usable_tele_number  VARCHAR2(20),
  c_agentcompany_code VARCHAR2(100),
  c_company_code      VARCHAR2(100),
  c_agentcompany_id   VARCHAR2(500),
  usable_status       NUMBER(5),
  usable_date         DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 1565M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_AGENT_CODE on UNICALL.USABLE_SHCPIC_PREINS_CUS_HIS (C_AGENTCOMPANY_CODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 700M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_USABLE_HIS_01 on UNICALL.USABLE_SHCPIC_PREINS_CUS_HIS (USABLE_TELE_NUMBER)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 731M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.USABLE_SHCPIC_PREINS_CUS_HIS
  add constraint PK_USABLE_SHCPIC_PRE_CUS_HIS primary key (USABLE_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 507M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table USABLE_SHCPIC_PREINS_CUS_INF
prompt ===========================================
prompt
create table UNICALL.USABLE_SHCPIC_PREINS_CUS_INF
(
  usable_id           NUMBER(10) not null,
  usable_zone_number  VARCHAR2(10),
  usable_tele_number  VARCHAR2(20),
  c_agentcompany_code VARCHAR2(100),
  c_company_code      VARCHAR2(100),
  c_agentcompany_id   VARCHAR2(500),
  usable_status       NUMBER(5),
  usable_date         DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 1935M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_USABLE_SH_PRE_CUS_INF_01 on UNICALL.USABLE_SHCPIC_PREINS_CUS_INF (USABLE_TELE_NUMBER)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 935M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.USABLE_SHCPIC_PREINS_CUS_INF
  add constraint PK_USABLE_SHCPIC_PREINS_CUS_IN primary key (USABLE_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 654M
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_ACCOUNT
prompt =========================
prompt
create table UNICALL.XQ_ACCOUNT
(
  sno        NUMBER(18) not null,
  typeid     NUMBER(7) not null,
  account_id NUMBER(20),
  acco_no    VARCHAR2(120) not null,
  usetype    CHAR(1) not null,
  regdate    DATE,
  open_date  DATE,
  status     CHAR(1),
  s_date     DATE,
  s_reason   CHAR(2),
  currency   CHAR(3) not null,
  bankcode   VARCHAR2(20) not null,
  bankname   VARCHAR2(80),
  policyno   VARCHAR2(20) not null,
  ownerid    VARCHAR2(40) not null,
  oper_no    VARCHAR2(20),
  etl_time   DATE not null,
  begtime    NUMBER(11),
  endtime    NUMBER(11),
  src_sys    VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_ACCOUNT
  is '账户信息（银行账户）';
comment on column UNICALL.XQ_ACCOUNT.sno
  is 'IAA物理主键';
comment on column UNICALL.XQ_ACCOUNT.typeid
  is 'IAA数据类型';
comment on column UNICALL.XQ_ACCOUNT.account_id
  is 'IAA锚点，AGREEMENT';
comment on column UNICALL.XQ_ACCOUNT.acco_no
  is '银行账户号';
comment on column UNICALL.XQ_ACCOUNT.usetype
  is '账户用途（收费、付费、收付费）';
comment on column UNICALL.XQ_ACCOUNT.regdate
  is '录入日期';
comment on column UNICALL.XQ_ACCOUNT.open_date
  is '开户日期';
comment on column UNICALL.XQ_ACCOUNT.status
  is '账户状态';
comment on column UNICALL.XQ_ACCOUNT.s_date
  is '账户状态日期';
comment on column UNICALL.XQ_ACCOUNT.s_reason
  is '账户状态原因';
comment on column UNICALL.XQ_ACCOUNT.currency
  is '币种';
comment on column UNICALL.XQ_ACCOUNT.bankcode
  is '银行账户开户行代码';
comment on column UNICALL.XQ_ACCOUNT.bankname
  is '银行账户开户行名称';
comment on column UNICALL.XQ_ACCOUNT.policyno
  is '保单号';
comment on column UNICALL.XQ_ACCOUNT.ownerid
  is '账户所有人证件号';
comment on column UNICALL.XQ_ACCOUNT.oper_no
  is '操作员';
comment on column UNICALL.XQ_ACCOUNT.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_ACCOUNT.begtime
  is '开始日期';
comment on column UNICALL.XQ_ACCOUNT.endtime
  is '中止日期';
comment on column UNICALL.XQ_ACCOUNT.src_sys
  is '来源系统';
create index UNICALL.IDX_XQ_ACCOUNT_BEGINTIME on UNICALL.XQ_ACCOUNT (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ACCOUNT_OWNERID on UNICALL.XQ_ACCOUNT (OWNERID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ACCOUNT_POLICYNO on UNICALL.XQ_ACCOUNT (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ACCOUNT_USETYPE on UNICALL.XQ_ACCOUNT (USETYPE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_ACCOUNT
  add constraint PK_XQ_ACCOUNT primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_ADDRESS
prompt =========================
prompt
create table UNICALL.XQ_ADDRESS
(
  sno              NUMBER(18) not null,
  typeid           NUMBER(7) not null,
  country          VARCHAR2(20),
  city             VARCHAR2(60),
  region           VARCHAR2(60),
  subregion        VARCHAR2(80),
  street           VARCHAR2(20),
  subaddr          VARCHAR2(500),
  zip              VARCHAR2(20),
  addr             VARCHAR2(500) not null,
  usage            NUMBER(7) not null,
  person_id        NUMBER(18),
  pid              VARCHAR2(40) not null,
  idtype           NUMBER(10) not null,
  id15             VARCHAR2(40),
  branch           CHAR(14) not null,
  etl_time         DATE not null,
  idtype_ids       CHAR(2),
  source_person_id VARCHAR2(20),
  seq              VARCHAR2(10),
  begtime          NUMBER(11),
  endtime          NUMBER(11),
  src_sys          VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_ADDRESS
  is '地址信息';
comment on column UNICALL.XQ_ADDRESS.sno
  is '物理主键';
comment on column UNICALL.XQ_ADDRESS.typeid
  is 'IAA数据类型';
comment on column UNICALL.XQ_ADDRESS.country
  is '国家';
comment on column UNICALL.XQ_ADDRESS.city
  is '市';
comment on column UNICALL.XQ_ADDRESS.region
  is '省';
comment on column UNICALL.XQ_ADDRESS.subregion
  is '区（县） ';
comment on column UNICALL.XQ_ADDRESS.street
  is '街道(乡/镇）';
comment on column UNICALL.XQ_ADDRESS.subaddr
  is '地址';
comment on column UNICALL.XQ_ADDRESS.zip
  is '邮政编码';
comment on column UNICALL.XQ_ADDRESS.addr
  is '完整地址信息';
comment on column UNICALL.XQ_ADDRESS.usage
  is '类型（家庭、工作单位）
';
comment on column UNICALL.XQ_ADDRESS.person_id
  is '地址所属客户IAA业务相关主键';
comment on column UNICALL.XQ_ADDRESS.pid
  is '身份证号/团体客户号';
comment on column UNICALL.XQ_ADDRESS.idtype
  is '证件类型';
comment on column UNICALL.XQ_ADDRESS.id15
  is '15位身份证号码';
comment on column UNICALL.XQ_ADDRESS.branch
  is '分公司代码';
comment on column UNICALL.XQ_ADDRESS.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_ADDRESS.idtype_ids
  is '被保人证件类型 IDS证件类型
00:团体客户
01:身份证
02:户口簿
03:护照
04:军官证
05:士兵证
06:港澳居民来往内地通行证
07:台湾同胞来往内地通行证
08:临时身份证
09:外国人居留证
10:警察证
11:文职干部证
12:驾驶执照
13:虚拟身份证
14:出生证书
99:其他证书';
comment on column UNICALL.XQ_ADDRESS.source_person_id
  is '源系统客户号';
comment on column UNICALL.XQ_ADDRESS.seq
  is '序号';
comment on column UNICALL.XQ_ADDRESS.begtime
  is '开始日期
';
comment on column UNICALL.XQ_ADDRESS.endtime
  is '中止日期
';
comment on column UNICALL.XQ_ADDRESS.src_sys
  is '来源系统';
create index UNICALL.IDX_XQADDRESS_ID15 on UNICALL.XQ_ADDRESS (ID15)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ADDRESS_BEGINTIME on UNICALL.XQ_ADDRESS (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ADDRESS_PERSON_ID on UNICALL.XQ_ADDRESS (PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ADDRESS_PID on UNICALL.XQ_ADDRESS (PID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ADDRESS_SEQ on UNICALL.XQ_ADDRESS (SEQ)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ADDRESS_SPID on UNICALL.XQ_ADDRESS (SOURCE_PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_ADDRESS_USAGE on UNICALL.XQ_ADDRESS (USAGE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_ADDRESS
  add constraint PK_XQ_ADDRESS primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_ADDRESS
  add constraint UK_XQ_ADDRESS_USAGE_SPID_SEQ unique (USAGE, SOURCE_PERSON_ID, SEQ)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_ALL_ADDRESS
prompt =============================
prompt
create table UNICALL.XQ_ALL_ADDRESS
(
  sno              NUMBER(20),
  typeid           NUMBER(7) not null,
  country          VARCHAR2(20),
  city             VARCHAR2(60),
  region           VARCHAR2(60),
  subregion        VARCHAR2(80),
  street           VARCHAR2(20),
  subaddr          VARCHAR2(500),
  zip              VARCHAR2(20),
  addr             VARCHAR2(500) not null,
  usage            CHAR(1) not null,
  person_id        NUMBER(20),
  pid              VARCHAR2(40) not null,
  idtype           CHAR(2),
  purpose          CHAR(1),
  seq              VARCHAR2(10) not null,
  source_person_id VARCHAR2(20) not null,
  id15             VARCHAR2(40),
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         DATE not null,
  src_sys          VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX1_XQ_ALL_ADDRESS_BEGTIME on UNICALL.XQ_ALL_ADDRESS (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX1_XQ_ALL_ADDRESS_ZH on UNICALL.XQ_ALL_ADDRESS (USAGE, SOURCE_PERSON_ID, SEQ)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX1_XQ_A_AD_S_P_ID on UNICALL.XQ_ALL_ADDRESS (SOURCE_PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_ALL_ADDRESS
  add constraint XQ_ALL_ADDRESS_USS_PRIMARY primary key (USAGE, SOURCE_PERSON_ID, SEQ);

prompt
prompt Creating table XQ_ALL_PERSON
prompt ============================
prompt
create table UNICALL.XQ_ALL_PERSON
(
  sno              NUMBER(20) not null,
  typeid           NUMBER(7) not null,
  person_id        NUMBER(20),
  persontype       NUMBER(20) not null,
  bthdate          DATE,
  diedate          DATE,
  edulevel         CHAR(2),
  sex              CHAR(1),
  income           NUMBER(20,6),
  company          VARCHAR2(180),
  marriage         CHAR(3),
  smoker           CHAR(1),
  blood            NUMBER(20),
  ethnicity        CHAR(2),
  hdesp            CHAR(1),
  customerid       VARCHAR2(40),
  name             VARCHAR2(120),
  job              CHAR(7),
  drvcard          VARCHAR2(2),
  country          CHAR(2),
  residence        VARCHAR2(90),
  id               VARCHAR2(40) not null,
  id15             VARCHAR2(40),
  idtype           CHAR(2),
  cust_id05        VARCHAR2(20),
  source_person_id VARCHAR2(20) not null,
  reg_date         DATE,
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         DATE not null,
  src_sys          VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX1_XQ_ALL_PERSON_BEGTIME on UNICALL.XQ_ALL_PERSON (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX1_XQ_ALL_PERSON_ID on UNICALL.XQ_ALL_PERSON (ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX1_XQ_ALL_PERSON_ID15 on UNICALL.XQ_ALL_PERSON (ID15)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX1_XQ_ALL_P_S_P_ID on UNICALL.XQ_ALL_PERSON (SOURCE_PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_ALL_PERSON
  add constraint XQ_ALL_PERSON_SPI_PRIMARY primary key (SOURCE_PERSON_ID);

prompt
prompt Creating table XQ_ALL_PHONE
prompt ===========================
prompt
create table UNICALL.XQ_ALL_PHONE
(
  sno              NUMBER(20),
  typeid           NUMBER(7) not null,
  areacode         VARCHAR2(20),
  countrycode      VARCHAR2(20),
  tel              VARCHAR2(20),
  ext              VARCHAR2(20),
  type             CHAR(1) not null,
  telnumber        VARCHAR2(100) not null,
  usage            CHAR(1) not null,
  person_id        NUMBER(20),
  pid              VARCHAR2(40) not null,
  idtype           CHAR(2),
  purpose          CHAR(1) not null,
  seq              VARCHAR2(10) not null,
  source_person_id VARCHAR2(20) not null,
  id15             VARCHAR2(40),
  begtime          NUMBER(11) not null,
  endtime          NUMBER(11) not null,
  branch           CHAR(14) not null,
  etl_time         DATE not null,
  src_sys          VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX1_XQ_ALL_PHONE_BEGTIME on UNICALL.XQ_ALL_PHONE (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX1_XQ_ALL_PHONE_SOURCE_P_ID on UNICALL.XQ_ALL_PHONE (SOURCE_PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX1_XQ_ALL_PHONE_ZH on UNICALL.XQ_ALL_PHONE (USAGE, SOURCE_PERSON_ID, SEQ)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_ALL_PHONE
  add constraint XQ_ALL_PHONE_USS_PRIMARY primary key (USAGE, SOURCE_PERSON_ID, SEQ);

prompt
prompt Creating table XQ_APP
prompt =====================
prompt
create table UNICALL.XQ_APP
(
  xq_app_id             NUMBER(18) not null,
  policyno              VARCHAR2(20) not null,
  appno                 VARCHAR2(20),
  aperson_id            NUMBER(18),
  apid                  VARCHAR2(40),
  aidtype               NUMBER(10),
  riskcon_id            NUMBER(18),
  saleattr              NUMBER(10),
  saleprj               NUMBER(10),
  salearea              VARCHAR2(100),
  begdate               DATE,
  stopdate              DATE,
  polist                NUMBER(10),
  pieces                NUMBER(20,6),
  opdate                DATE,
  renewdate             DATE,
  tmount                NUMBER(16,2),
  person_id             NUMBER(18),
  idtype                NUMBER(10),
  pid                   VARCHAR2(40),
  appdate               DATE,
  renewid               CHAR(1),
  sale_prod_code        VARCHAR2(8),
  npaylen               NUMBER(20,6),
  stdrate               NUMBER(10,2),
  unstdrate             NUMBER(10,2),
  etl_time              DATE,
  typeid                NUMBER(7),
  gcon_id               NUMBER(20),
  gpolicyno             VARCHAR2(20),
  deskpay               CHAR(1),
  reason                VARCHAR2(200),
  currency              CHAR(3),
  oper_id               NUMBER(20),
  operno                VARCHAR2(20),
  empno_id              NUMBER(20),
  empno                 VARCHAR2(20),
  csr_id                NUMBER(20),
  csrno                 VARCHAR2(20),
  comnum                NUMBER(20),
  job                   CHAR(8),
  sharetype             CHAR(2),
  specagr               VARCHAR2(2048),
  discount              NUMBER(20,6),
  iscard                CHAR(1),
  dcdm                  CHAR(2),
  prelname              CHAR(3),
  bankflag              CHAR(2),
  payseq                VARCHAR2(2048),
  benparam              NUMBER(20),
  owner_source_id       VARCHAR2(20),
  insured_source_id     VARCHAR2(20),
  workno                VARCHAR2(20),
  comb_policy_no        VARCHAR2(20),
  app_age               NUMBER(3),
  begtime               NUMBER(11),
  endtime               NUMBER(11),
  branch                CHAR(14),
  src_sys               VARCHAR2(20),
  sub_agt_no            VARCHAR2(20),
  total_pay_amount      NUMBER(16,2),
  total_statistics_date DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 734M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_APP
  is '个人保单(按保单号)';
comment on column UNICALL.XQ_APP.xq_app_id
  is '保单标识';
comment on column UNICALL.XQ_APP.policyno
  is '保单号';
comment on column UNICALL.XQ_APP.appno
  is '投保单号';
comment on column UNICALL.XQ_APP.aperson_id
  is '投保人信息IAA业务相关主键';
comment on column UNICALL.XQ_APP.apid
  is '投保人身份证件号/团体客户号';
comment on column UNICALL.XQ_APP.aidtype
  is '投保人证件类型';
comment on column UNICALL.XQ_APP.riskcon_id
  is '业务主键';
comment on column UNICALL.XQ_APP.saleattr
  is '销售渠道';
comment on column UNICALL.XQ_APP.saleprj
  is '销售项目';
comment on column UNICALL.XQ_APP.salearea
  is '销售机构';
comment on column UNICALL.XQ_APP.begdate
  is '责任起始日期';
comment on column UNICALL.XQ_APP.stopdate
  is '责任终止日期';
comment on column UNICALL.XQ_APP.polist
  is '电销系统状态与IDS状态对应
有效（2，A，D）、
失效（3,B）、
退保（7,8,9,c）、
变更中（E）、
责任终止(4,5,6,F)。
关联续期字典表';
comment on column UNICALL.XQ_APP.pieces
  is '份数';
comment on column UNICALL.XQ_APP.opdate
  is '生效日期';
comment on column UNICALL.XQ_APP.renewdate
  is '续保日期';
comment on column UNICALL.XQ_APP.tmount
  is '总保费';
comment on column UNICALL.XQ_APP.person_id
  is '被保险人IAA业务相关主键';
comment on column UNICALL.XQ_APP.idtype
  is '被保险人证件类型';
comment on column UNICALL.XQ_APP.pid
  is '被保险人证件号';
comment on column UNICALL.XQ_APP.appdate
  is '投保日期';
comment on column UNICALL.XQ_APP.renewid
  is '续保标志';
comment on column UNICALL.XQ_APP.sale_prod_code
  is '销售产品代码';
comment on column UNICALL.XQ_APP.npaylen
  is '每份缴费标准';
comment on column UNICALL.XQ_APP.stdrate
  is '每份标准加费额/职业加费金额';
comment on column UNICALL.XQ_APP.unstdrate
  is '每份非标准加费额/综合加费金额';
comment on column UNICALL.XQ_APP.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_APP.typeid
  is 'IAA数据类型';
comment on column UNICALL.XQ_APP.gcon_id
  is '所属团体保单IAA业务相关主键';
comment on column UNICALL.XQ_APP.gpolicyno
  is '团单号';
comment on column UNICALL.XQ_APP.deskpay
  is '垫缴条款选择（保单是否可以垫缴）';
comment on column UNICALL.XQ_APP.reason
  is '投保单/保单状态原因';
comment on column UNICALL.XQ_APP.currency
  is '币种';
comment on column UNICALL.XQ_APP.oper_id
  is '操作员IAA相关业务主键';
comment on column UNICALL.XQ_APP.operno
  is '操作员工号';
comment on column UNICALL.XQ_APP.empno_id
  is '业务员信息IAA业务相关主键';
comment on column UNICALL.XQ_APP.empno
  is '业务员代码';
comment on column UNICALL.XQ_APP.csr_id
  is '收展员信息';
comment on column UNICALL.XQ_APP.csrno
  is '收展员代码';
comment on column UNICALL.XQ_APP.comnum
  is '共同被保险人人数';
comment on column UNICALL.XQ_APP.job
  is '被保险人职业类型';
comment on column UNICALL.XQ_APP.sharetype
  is '红利分配方式';
comment on column UNICALL.XQ_APP.specagr
  is '特别约定';
comment on column UNICALL.XQ_APP.discount
  is '豁免后缴费比率 0（全免）-1（全额）';
comment on column UNICALL.XQ_APP.iscard
  is '卡式业务标志';
comment on column UNICALL.XQ_APP.dcdm
  is '保单档次';
comment on column UNICALL.XQ_APP.prelname
  is '投被保人关系';
comment on column UNICALL.XQ_APP.bankflag
  is '银保通标志';
comment on column UNICALL.XQ_APP.payseq
  is '受益人';
comment on column UNICALL.XQ_APP.benparam
  is '受益人条件数';
comment on column UNICALL.XQ_APP.owner_source_id
  is 'FF中投保人内部ID，对应PERSON.SOURCE_PERSON_ID';
comment on column UNICALL.XQ_APP.insured_source_id
  is 'FF中被保人内部ID，对应PERSON.SOURCE_PERSON_ID';
comment on column UNICALL.XQ_APP.workno
  is '团体保单中个人的单位工号';
comment on column UNICALL.XQ_APP.comb_policy_no
  is '多主险组合保单号';
comment on column UNICALL.XQ_APP.app_age
  is '投保年龄';
comment on column UNICALL.XQ_APP.begtime
  is '开始日期';
comment on column UNICALL.XQ_APP.endtime
  is '中止日期';
comment on column UNICALL.XQ_APP.branch
  is '分公司代码';
comment on column UNICALL.XQ_APP.src_sys
  is '来源系统';
comment on column UNICALL.XQ_APP.sub_agt_no
  is '二级业务员代码（目前存放电销坐席工号）';
comment on column UNICALL.XQ_APP.total_pay_amount
  is '累计缴费金额';
comment on column UNICALL.XQ_APP.total_statistics_date
  is '累计缴费金额统计时间';
create index UNICALL.IDX_PERSON_ID on UNICALL.XQ_APP (APERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_APP_APID on UNICALL.XQ_APP (APID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 5M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_APP_APPNO on UNICALL.XQ_APP (APPNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 5M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_APP_POLICYNO on UNICALL.XQ_APP (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 5M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_APP_POLIST on UNICALL.XQ_APP (POLIST)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_APP
  add constraint PK_XQ_APP primary key (XQ_APP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 3M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_APP
  add constraint UK_XQ_APP_POLICYNO unique (POLICYNO);

prompt
prompt Creating table XQ_APP_POS
prompt =========================
prompt
create table UNICALL.XQ_APP_POS
(
  sno         NUMBER(20),
  typeid      NUMBER(7) not null,
  changeid    CHAR(2) not null,
  status      CHAR(1) not null,
  procdate    DATE not null,
  abstr       VARCHAR2(500),
  appdate     DATE not null,
  modino      VARCHAR2(20) not null,
  con_id      NUMBER(20),
  policyno    VARCHAR2(20) not null,
  classcode   CHAR(8) not null,
  opdate      DATE not null,
  operid      NUMBER(20),
  operno      VARCHAR2(20) not null,
  oper_role   VARCHAR2(20),
  id          VARCHAR2(40),
  name        VARCHAR2(120),
  veri_no     VARCHAR2(20),
  veri_date   DATE,
  app_channel VARCHAR2(3),
  begtime     NUMBER(11) not null,
  endtime     NUMBER(11) not null,
  branch      CHAR(14) not null,
  etl_time    DATE not null,
  src_sys     VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_APP_POS
  is '  保全服务';
comment on column UNICALL.XQ_APP_POS.sno
  is 'IAA物理主键';
comment on column UNICALL.XQ_APP_POS.typeid
  is '交易类型';
comment on column UNICALL.XQ_APP_POS.changeid
  is '变更类型编码';
comment on column UNICALL.XQ_APP_POS.status
  is '保全服务交易状态';
comment on column UNICALL.XQ_APP_POS.procdate
  is '交易生效日期';
comment on column UNICALL.XQ_APP_POS.abstr
  is '通融、撤保原因';
comment on column UNICALL.XQ_APP_POS.appdate
  is '交易申请日期';
comment on column UNICALL.XQ_APP_POS.modino
  is '业务交易批单号';
comment on column UNICALL.XQ_APP_POS.con_id
  is '保单IAA业务相关主键';
comment on column UNICALL.XQ_APP_POS.policyno
  is '保单号';
comment on column UNICALL.XQ_APP_POS.classcode
  is '险种';
comment on column UNICALL.XQ_APP_POS.opdate
  is '操作日期';
comment on column UNICALL.XQ_APP_POS.operid
  is '操作员IAA业务相关主键';
comment on column UNICALL.XQ_APP_POS.operno
  is '操作员工号';
comment on column UNICALL.XQ_APP_POS.oper_role
  is '操作员岗位类型';
comment on column UNICALL.XQ_APP_POS.id
  is '申请人身份证号';
comment on column UNICALL.XQ_APP_POS.name
  is '申请人姓名';
comment on column UNICALL.XQ_APP_POS.veri_no
  is '审核人工号
';
comment on column UNICALL.XQ_APP_POS.veri_date
  is '审核日期
';
comment on column UNICALL.XQ_APP_POS.app_channel
  is '受理渠道
';
comment on column UNICALL.XQ_APP_POS.begtime
  is '开始日期';
comment on column UNICALL.XQ_APP_POS.endtime
  is '中止日期';
comment on column UNICALL.XQ_APP_POS.branch
  is '分公司代码';
comment on column UNICALL.XQ_APP_POS.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_APP_POS.src_sys
  is '来源系统';
create index UNICALL.INDEX_XQ_APP_POS on UNICALL.XQ_APP_POS (MODINO, POLICYNO, CLASSCODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_APP_POS
  add constraint XQ_APP_POS_BK primary key (MODINO, POLICYNO, CLASSCODE)
  disable;

prompt
prompt Creating table XQ_APP_POS_ID
prompt ============================
prompt
create table UNICALL.XQ_APP_POS_ID
(
  sno         NUMBER(20),
  typeid      NUMBER(7) not null,
  changeid    CHAR(2),
  status      CHAR(1) not null,
  procdate    DATE not null,
  abstr       VARCHAR2(500),
  appdate     DATE not null,
  modino      VARCHAR2(20) not null,
  con_id      NUMBER(20),
  oid_num     VARCHAR2(100),
  id          VARCHAR2(40) not null,
  id15        VARCHAR2(20),
  opdate      DATE not null,
  operid      NUMBER(20),
  operno      VARCHAR2(20) not null,
  oper_role   VARCHAR2(20),
  veri_no     VARCHAR2(20),
  veri_date   DATE,
  app_channel VARCHAR2(3),
  begtime     NUMBER(11) not null,
  endtime     NUMBER(11) not null,
  branch      CHAR(14) not null,
  etl_time    DATE not null,
  src_sys     VARCHAR2(20) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_APP_POS_ID
  is '  变更申请表';
comment on column UNICALL.XQ_APP_POS_ID.sno
  is 'IAA物理主键';
comment on column UNICALL.XQ_APP_POS_ID.typeid
  is '交易类型';
comment on column UNICALL.XQ_APP_POS_ID.changeid
  is '变更类型编码';
comment on column UNICALL.XQ_APP_POS_ID.status
  is '保全服务交易状态';
comment on column UNICALL.XQ_APP_POS_ID.procdate
  is '交易生效日期';
comment on column UNICALL.XQ_APP_POS_ID.abstr
  is '通融、撤保原因';
comment on column UNICALL.XQ_APP_POS_ID.appdate
  is '交易申请日期';
comment on column UNICALL.XQ_APP_POS_ID.modino
  is '业务交易批单号';
comment on column UNICALL.XQ_APP_POS_ID.con_id
  is '保单IAA业务相关主键';
comment on column UNICALL.XQ_APP_POS_ID.oid_num
  is '客户代码';
comment on column UNICALL.XQ_APP_POS_ID.id
  is '申请人身份证号';
comment on column UNICALL.XQ_APP_POS_ID.id15
  is '15位身份证号';
comment on column UNICALL.XQ_APP_POS_ID.opdate
  is '操作日期';
comment on column UNICALL.XQ_APP_POS_ID.operid
  is '操作员IAA业务相关主键';
comment on column UNICALL.XQ_APP_POS_ID.operno
  is '操作员工号';
comment on column UNICALL.XQ_APP_POS_ID.oper_role
  is '操作员岗位类型';
comment on column UNICALL.XQ_APP_POS_ID.veri_no
  is '审核人工号
';
comment on column UNICALL.XQ_APP_POS_ID.veri_date
  is '审核日期
';
comment on column UNICALL.XQ_APP_POS_ID.app_channel
  is '受理渠道
';
comment on column UNICALL.XQ_APP_POS_ID.begtime
  is '开始日期';
comment on column UNICALL.XQ_APP_POS_ID.endtime
  is '中止日期';
comment on column UNICALL.XQ_APP_POS_ID.branch
  is '分公司代码';
comment on column UNICALL.XQ_APP_POS_ID.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_APP_POS_ID.src_sys
  is '来源系统';
create index UNICALL.INDEX_XQ_APP_POS_ID on UNICALL.XQ_APP_POS_ID (MODINO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_APP_POS_ID
  add constraint XQ_APP_POS_ID_BK primary key (MODINO)
  disable;

prompt
prompt Creating table XQ_CHARGE_FAILURE
prompt ================================
prompt
create table UNICALL.XQ_CHARGE_FAILURE
(
  id              NUMBER(20) not null,
  sno             NUMBER(20),
  typeid          NUMBER(7) not null,
  policyno        VARCHAR2(20) not null,
  bankcode        VARCHAR2(24) not null,
  bankno          CHAR(30) not null,
  pid             VARCHAR2(40),
  name            VARCHAR2(120),
  amount          NUMBER(15,2),
  status          CHAR(2),
  reason          VARCHAR2(200),
  cover1          DATE,
  cover2          DATE,
  appdate         DATE not null,
  transfer_reason CHAR(1),
  begtime         NUMBER(11) not null,
  endtime         NUMBER(11) not null,
  branch          CHAR(14) not null,
  etl_time        DATE not null,
  src_sys         VARCHAR2(20) not null,
  create_date     DATE not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.XQ_CHARGE_FAILURE.id
  is '自增长主键';
comment on column UNICALL.XQ_CHARGE_FAILURE.sno
  is '  IAA物理主键';
comment on column UNICALL.XQ_CHARGE_FAILURE.typeid
  is '  IAA数据类型';
comment on column UNICALL.XQ_CHARGE_FAILURE.policyno
  is '  保单号';
comment on column UNICALL.XQ_CHARGE_FAILURE.bankcode
  is '  银行代码';
comment on column UNICALL.XQ_CHARGE_FAILURE.bankno
  is '  银行账号';
comment on column UNICALL.XQ_CHARGE_FAILURE.pid
  is '  身份证号';
comment on column UNICALL.XQ_CHARGE_FAILURE.name
  is '  姓名';
comment on column UNICALL.XQ_CHARGE_FAILURE.amount
  is '  金额';
comment on column UNICALL.XQ_CHARGE_FAILURE.status
  is '  扣款状态';
comment on column UNICALL.XQ_CHARGE_FAILURE.reason
  is '  状态原因';
comment on column UNICALL.XQ_CHARGE_FAILURE.cover1
  is '  cover1';
comment on column UNICALL.XQ_CHARGE_FAILURE.cover2
  is '  cover2';
comment on column UNICALL.XQ_CHARGE_FAILURE.appdate
  is '  扣款日期';
comment on column UNICALL.XQ_CHARGE_FAILURE.transfer_reason
  is '  转帐原因';
comment on column UNICALL.XQ_CHARGE_FAILURE.begtime
  is '  开始日期';
comment on column UNICALL.XQ_CHARGE_FAILURE.endtime
  is '  中止日期';
comment on column UNICALL.XQ_CHARGE_FAILURE.branch
  is '  分公司代码';
comment on column UNICALL.XQ_CHARGE_FAILURE.etl_time
  is '  ETL处理时间';
comment on column UNICALL.XQ_CHARGE_FAILURE.src_sys
  is '  来源系统';
comment on column UNICALL.XQ_CHARGE_FAILURE.create_date
  is '创建时间';
create index UNICALL.IDX_XQ_CHARGE_FAILURE_BRANCH on UNICALL.XQ_CHARGE_FAILURE (BRANCH)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_CHARGE_FAILURE_ETL_TIME on UNICALL.XQ_CHARGE_FAILURE (ETL_TIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_CHARGE_FAILURE_POLICYNO on UNICALL.XQ_CHARGE_FAILURE (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_CHARGE_FAILURE
  add constraint PK_XQ_CHARGE_FAILURE_SNO primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_CHGCON
prompt ========================
prompt
create table UNICALL.XQ_CHGCON
(
  chgcon_id NUMBER(18) not null,
  typeid    NUMBER(7),
  changeid  CHAR(2),
  oldstr    VARCHAR2(1024),
  newstr    VARCHAR2(1024),
  oldval    NUMBER(20,6),
  newval    NUMBER(20,6),
  modyname  VARCHAR2(80),
  apppos_id NUMBER(20),
  modino    VARCHAR2(20),
  con_id    NUMBER(20),
  policyno  VARCHAR2(20),
  classcode CHAR(8),
  begtime   NUMBER(11),
  endtime   NUMBER(11),
  branch    CHAR(14),
  etl_time  DATE,
  src_sys   VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on table UNICALL.XQ_CHGCON
  is '保全变更表';
alter table UNICALL.XQ_CHGCON
  add constraint PK_XQ_CHGCON primary key (CHGCON_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255;

prompt
prompt Creating table XQ_DATA_IDS_HIST
prompt ===============================
prompt
create table UNICALL.XQ_DATA_IDS_HIST
(
  sno        NUMBER(18) not null,
  policyno   VARCHAR2(20) not null,
  ukey       VARCHAR2(35),
  remark     VARCHAR2(500),
  modifier   VARCHAR2(20),
  updatetime DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
  );
comment on table UNICALL.XQ_DATA_IDS_HIST
  is 'IDS数据变更历史';
comment on column UNICALL.XQ_DATA_IDS_HIST.sno
  is '物理主键';
comment on column UNICALL.XQ_DATA_IDS_HIST.policyno
  is '保单号';
comment on column UNICALL.XQ_DATA_IDS_HIST.ukey
  is '更新业务唯一标识';
comment on column UNICALL.XQ_DATA_IDS_HIST.remark
  is '状态变更说明';
comment on column UNICALL.XQ_DATA_IDS_HIST.modifier
  is '变更者';
comment on column UNICALL.XQ_DATA_IDS_HIST.updatetime
  is '变更时间';
alter table UNICALL.XQ_DATA_IDS_HIST
  add constraint PK_XQ_DATA_IDS_HIST primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
  );

prompt
prompt Creating table XQ_DICT
prompt ======================
prompt
create table UNICALL.XQ_DICT
(
  id        NUMBER(10) not null,
  parent_id NUMBER(10),
  item_name VARCHAR2(50) not null,
  item_code VARCHAR2(50) not null,
  is_delete CHAR(1) default 0 not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_DICT
  is '续期字典表';
comment on column UNICALL.XQ_DICT.id
  is '数据字典ID';
comment on column UNICALL.XQ_DICT.parent_id
  is '父ID';
comment on column UNICALL.XQ_DICT.item_name
  is '名称';
comment on column UNICALL.XQ_DICT.item_code
  is '编码';
comment on column UNICALL.XQ_DICT.is_delete
  is '1：删除，0：正常';
alter table UNICALL.XQ_DICT
  add constraint PK_XQ_DICT primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_DICT
  add constraint FK_XQ_DICT_REFERENCE_XQ_DICT foreign key (PARENT_ID)
  references UNICALL.XQ_DICT (ID);

prompt
prompt Creating table XQ_DX_EMERGENCY_CON
prompt ==================================
prompt
create table UNICALL.XQ_DX_EMERGENCY_CON
(
  con_id       NUMBER(18) not null,
  apid         VARCHAR2(40),
  con_name     VARCHAR2(64),
  con_relation VARCHAR2(3),
  con_tel      VARCHAR2(32),
  type         NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 807M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_DX_EMERGENCY_CON
  is 'j紧急联络人信息';
comment on column UNICALL.XQ_DX_EMERGENCY_CON.con_id
  is '主键id';
comment on column UNICALL.XQ_DX_EMERGENCY_CON.apid
  is '证件号码';
comment on column UNICALL.XQ_DX_EMERGENCY_CON.con_name
  is '紧急联络人姓名';
comment on column UNICALL.XQ_DX_EMERGENCY_CON.con_relation
  is '紧急联络人与投保人关系';
comment on column UNICALL.XQ_DX_EMERGENCY_CON.con_tel
  is '紧急联络人电话';
comment on column UNICALL.XQ_DX_EMERGENCY_CON.type
  is '0是电销1是续期';
create index UNICALL.PK_APID_ID on UNICALL.XQ_DX_EMERGENCY_CON (APID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_DX_EMERGENCY_CON
  add constraint PK_CON_ID primary key (CON_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_EMPNO
prompt =======================
prompt
create table UNICALL.XQ_EMPNO
(
  sno        NUMBER(20) not null,
  typeid     NUMBER(7),
  empno_id   NUMBER(20),
  person_id  NUMBER(20),
  empno      VARCHAR2(20) not null,
  status     NUMBER(10) not null,
  name       VARCHAR2(120),
  degreeno   CHAR(2),
  indate     DATE,
  outdate    DATE,
  regdate    DATE,
  degdate    DATE,
  pid        VARCHAR2(40),
  begdate    DATE,
  enddate    DATE,
  edu_level  CHAR(2),
  begtime    NUMBER(11),
  endtime    NUMBER(11),
  branch     CHAR(14),
  etl_time   TIMESTAMP(6),
  src_sys    VARCHAR2(20),
  c_agt_ind  CHAR(1),
  status_ids CHAR(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_EMPNO
  is '  渠道工号信息';
comment on column UNICALL.XQ_EMPNO.sno
  is '物理主键';
comment on column UNICALL.XQ_EMPNO.typeid
  is '  业务员类型';
comment on column UNICALL.XQ_EMPNO.empno_id
  is '  IAA锚点，Roleplayer';
comment on column UNICALL.XQ_EMPNO.person_id
  is '  渠道相关个人信息IAA业务相关主键';
comment on column UNICALL.XQ_EMPNO.empno
  is '  工号';
comment on column UNICALL.XQ_EMPNO.status
  is '  状态（
1持证
与
6禁止新保为有效，其余均为无效）';
comment on column UNICALL.XQ_EMPNO.name
  is '  姓名';
comment on column UNICALL.XQ_EMPNO.degreeno
  is '  职级';
comment on column UNICALL.XQ_EMPNO.indate
  is '  入司日期';
comment on column UNICALL.XQ_EMPNO.outdate
  is '  离司日期';
comment on column UNICALL.XQ_EMPNO.regdate
  is '  注册日期';
comment on column UNICALL.XQ_EMPNO.degdate
  is '  升级日期';
comment on column UNICALL.XQ_EMPNO.pid
  is '  身份证号码';
comment on column UNICALL.XQ_EMPNO.begdate
  is '  有效起始日期';
comment on column UNICALL.XQ_EMPNO.enddate
  is '  有效终止日期';
comment on column UNICALL.XQ_EMPNO.edu_level
  is '  代理人学历';
comment on column UNICALL.XQ_EMPNO.begtime
  is '  开始日期';
comment on column UNICALL.XQ_EMPNO.endtime
  is '  中止日期';
comment on column UNICALL.XQ_EMPNO.branch
  is '  分公司代码';
comment on column UNICALL.XQ_EMPNO.etl_time
  is '  ETL处理时间';
comment on column UNICALL.XQ_EMPNO.src_sys
  is '  来源系统';
comment on column UNICALL.XQ_EMPNO.c_agt_ind
  is '是否C人力';
comment on column UNICALL.XQ_EMPNO.status_ids
  is 'IDS状态：0未持证
1持证
2非营销员
3挂靠人员
5业务转内勤
6禁止新保
7异地调动
9离职(核保人员:无效)
8正在办理离职手续
10在职(核保人员:有效)
';
alter table UNICALL.XQ_EMPNO
  add constraint PK_XQ_EMPNO primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_EMPNO
  add constraint UK_XQ_EMPNO unique (EMPNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_EMPNO_TEMP
prompt ============================
prompt
create table UNICALL.XQ_EMPNO_TEMP
(
  sno       NUMBER(20),
  typeid    NUMBER(7),
  empno_id  NUMBER(20),
  person_id NUMBER(20),
  empno     VARCHAR2(20),
  status    CHAR(2),
  name      VARCHAR2(120),
  degreeno  CHAR(2),
  indate    DATE,
  outdate   DATE,
  regdate   DATE,
  degdate   DATE,
  pid       VARCHAR2(40),
  begdate   DATE,
  enddate   DATE,
  edu_level CHAR(2),
  begtime   NUMBER(11),
  endtime   NUMBER(11),
  branch    CHAR(14),
  etl_time  DATE,
  src_sys   VARCHAR2(20),
  c_agt_ind CHAR(1)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_EMPNO_TEMP
  is '  渠道工号信息';
comment on column UNICALL.XQ_EMPNO_TEMP.sno
  is '  IAA物理主键';
comment on column UNICALL.XQ_EMPNO_TEMP.typeid
  is '  业务员类型';
comment on column UNICALL.XQ_EMPNO_TEMP.empno_id
  is '  IAA锚点，Roleplayer';
comment on column UNICALL.XQ_EMPNO_TEMP.person_id
  is '  渠道相关个人信息IAA业务相关主键';
comment on column UNICALL.XQ_EMPNO_TEMP.empno
  is '  工号';
comment on column UNICALL.XQ_EMPNO_TEMP.status
  is '  状态';
comment on column UNICALL.XQ_EMPNO_TEMP.name
  is '  姓名';
comment on column UNICALL.XQ_EMPNO_TEMP.degreeno
  is '  职级';
comment on column UNICALL.XQ_EMPNO_TEMP.indate
  is '  入司日期';
comment on column UNICALL.XQ_EMPNO_TEMP.outdate
  is '  离司日期';
comment on column UNICALL.XQ_EMPNO_TEMP.regdate
  is '  注册日期';
comment on column UNICALL.XQ_EMPNO_TEMP.degdate
  is '  升级日期';
comment on column UNICALL.XQ_EMPNO_TEMP.pid
  is '  身份证号码';
comment on column UNICALL.XQ_EMPNO_TEMP.begdate
  is '  有效起始日期';
comment on column UNICALL.XQ_EMPNO_TEMP.enddate
  is '  有效终止日期';
comment on column UNICALL.XQ_EMPNO_TEMP.edu_level
  is '  代理人学历';
comment on column UNICALL.XQ_EMPNO_TEMP.begtime
  is '  开始日期';
comment on column UNICALL.XQ_EMPNO_TEMP.endtime
  is '  中止日期';
comment on column UNICALL.XQ_EMPNO_TEMP.branch
  is '  分公司代码';
comment on column UNICALL.XQ_EMPNO_TEMP.etl_time
  is '  ETL处理时间';
comment on column UNICALL.XQ_EMPNO_TEMP.src_sys
  is '  来源系统';
comment on column UNICALL.XQ_EMPNO_TEMP.c_agt_ind
  is '是否C人力';

prompt
prompt Creating table XQ_INVALID_APP
prompt =============================
prompt
create table UNICALL.XQ_INVALID_APP
(
  xq_invalid_app_id NUMBER(18) not null,
  xq_app_id         NUMBER(18),
  policyno          VARCHAR2(20),
  appno             VARCHAR2(20),
  aperson_id        NUMBER(18),
  apid              VARCHAR2(40),
  aidtype           NUMBER(10),
  riskcon_id        NUMBER(18),
  saleattr          NUMBER(10),
  saleprj           NUMBER(10),
  salearea          VARCHAR2(100),
  begdate           DATE,
  stopdate          DATE,
  polist            NUMBER(10),
  pieces            NUMBER(20,6),
  opdate            DATE,
  renewdate         DATE,
  tmount            NUMBER(16,2),
  owe_amount        CHAR(10),
  person_id         NUMBER(18),
  idtype            NUMBER(10),
  pid               VARCHAR2(40),
  appdate           DATE,
  use_ali_id        VARCHAR2(20),
  task_date         DATE,
  appoint_date      DATE,
  apname            VARCHAR2(120),
  setcode           NUMBER(10),
  next_date         DATE,
  invalid_date      DATE,
  con_times         NUMBER(10),
  reinstate         VARCHAR2(2),
  status            NUMBER(10),
  polist_ids        CHAR(2),
  paycode           NUMBER(10),
  mod_date          DATE,
  cre_date          DATE,
  rein_date         DATE,
  etl_date          DATE,
  begtime           NUMBER(11),
  endtime           NUMBER(11)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 732M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_INVALID_APP
  is '失效保单';
comment on column UNICALL.XQ_INVALID_APP.xq_invalid_app_id
  is '保单标识';
comment on column UNICALL.XQ_INVALID_APP.xq_app_id
  is '保单ID';
comment on column UNICALL.XQ_INVALID_APP.policyno
  is '保单号';
comment on column UNICALL.XQ_INVALID_APP.appno
  is '投保单号';
comment on column UNICALL.XQ_INVALID_APP.aperson_id
  is '投保人信息IAA业务相关主键';
comment on column UNICALL.XQ_INVALID_APP.apid
  is '投保人身份证件号/团体客户号';
comment on column UNICALL.XQ_INVALID_APP.aidtype
  is '投保人证件类型';
comment on column UNICALL.XQ_INVALID_APP.riskcon_id
  is '业务主键';
comment on column UNICALL.XQ_INVALID_APP.saleattr
  is '销售渠道';
comment on column UNICALL.XQ_INVALID_APP.saleprj
  is '销售项目';
comment on column UNICALL.XQ_INVALID_APP.salearea
  is '销售地区';
comment on column UNICALL.XQ_INVALID_APP.begdate
  is '责任起始日期';
comment on column UNICALL.XQ_INVALID_APP.stopdate
  is '责任终止日期';
comment on column UNICALL.XQ_INVALID_APP.polist
  is '电销系统状态与IDS状态对应
有效（2，A，D）、
失效（3,B）、
退保（7,8,9,C）、
变更中（E）、
责任终止(4,5,6,F)。
关联续期字典表';
comment on column UNICALL.XQ_INVALID_APP.pieces
  is '份数';
comment on column UNICALL.XQ_INVALID_APP.opdate
  is '生效日期';
comment on column UNICALL.XQ_INVALID_APP.renewdate
  is '续保日期';
comment on column UNICALL.XQ_INVALID_APP.tmount
  is '总保费';
comment on column UNICALL.XQ_INVALID_APP.owe_amount
  is '欠缴金额';
comment on column UNICALL.XQ_INVALID_APP.person_id
  is '被保险人IAA业务相关主键';
comment on column UNICALL.XQ_INVALID_APP.idtype
  is '被保险人证件类型';
comment on column UNICALL.XQ_INVALID_APP.pid
  is '被保险人证件号';
comment on column UNICALL.XQ_INVALID_APP.appdate
  is '投保日期';
comment on column UNICALL.XQ_INVALID_APP.use_ali_id
  is '续期代表工号';
comment on column UNICALL.XQ_INVALID_APP.task_date
  is '分单时间';
comment on column UNICALL.XQ_INVALID_APP.appoint_date
  is '预约外拨日';
comment on column UNICALL.XQ_INVALID_APP.apname
  is '客户姓名';
comment on column UNICALL.XQ_INVALID_APP.setcode
  is '缴费方式';
comment on column UNICALL.XQ_INVALID_APP.next_date
  is '下次缴费日';
comment on column UNICALL.XQ_INVALID_APP.invalid_date
  is '失效日期';
comment on column UNICALL.XQ_INVALID_APP.con_times
  is '联系次数';
comment on column UNICALL.XQ_INVALID_APP.reinstate
  is '复效情况 1：成功 0：失败';
comment on column UNICALL.XQ_INVALID_APP.status
  is '失效保单续期状态 1401:待分配 1402:有效 1403:待审批 1404:取消 1450:其它';
comment on column UNICALL.XQ_INVALID_APP.polist_ids
  is '
1～未生效
2～有效
3～失效（中止）
4～永久失效（终止）
5～移出
6～满期
7～生存退保
8～死亡退保
9～犹豫退保
A～给付期
B～借款失效
C～通融退保
D～理赔中
E～变更中
F～责任终止
';
comment on column UNICALL.XQ_INVALID_APP.paycode
  is '缴费方式';
comment on column UNICALL.XQ_INVALID_APP.mod_date
  is '更新时间';
comment on column UNICALL.XQ_INVALID_APP.cre_date
  is '创建时间';
comment on column UNICALL.XQ_INVALID_APP.rein_date
  is '复效时间';
comment on column UNICALL.XQ_INVALID_APP.etl_date
  is 'ETL处理时间';
comment on column UNICALL.XQ_INVALID_APP.begtime
  is '开始日期';
comment on column UNICALL.XQ_INVALID_APP.endtime
  is '中止日期';
create index UNICALL.IDX_XQ_INVALID_APP_INDATE on UNICALL.XQ_INVALID_APP (INVALID_DATE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_INVALID_APP_POLICYNO on UNICALL.XQ_INVALID_APP (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_INVALID_APP_POLIST_IDS on UNICALL.XQ_INVALID_APP (POLIST_IDS)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_INVALID_APP_SETCODE on UNICALL.XQ_INVALID_APP (SETCODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_INVALID_APP_STA on UNICALL.XQ_INVALID_APP (STATUS)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_INVALID_APP_USEALID on UNICALL.XQ_INVALID_APP (USE_ALI_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_INVALID_APP
  add constraint PK_XQ_INVALID_APP primary key (XQ_INVALID_APP_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_INVALID_APP
  add constraint FK_INVAPP_XQAPP foreign key (XQ_APP_ID)
  references UNICALL.XQ_APP (XQ_APP_ID);

prompt
prompt Creating table XQ_INVAPP_PERIOD
prompt ===============================
prompt
create table UNICALL.XQ_INVAPP_PERIOD
(
  xq_invalid_app_period_id NUMBER(18) not null,
  xq_invalid_app_id        NUMBER(18),
  period_value             VARCHAR2(20) not null,
  begin_date               DATE not null,
  end_date                 DATE not null,
  call_times               NUMBER,
  is_success               VARCHAR2(2) default '0'
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_INVAPP_PERIOD
  is '账龄=30，账龄=60，账龄=90，账龄=180，账龄=365，账龄=730,';
comment on column UNICALL.XQ_INVAPP_PERIOD.xq_invalid_app_period_id
  is '账期标识';
comment on column UNICALL.XQ_INVAPP_PERIOD.xq_invalid_app_id
  is '失效保单ID';
comment on column UNICALL.XQ_INVAPP_PERIOD.period_value
  is '账期值';
comment on column UNICALL.XQ_INVAPP_PERIOD.begin_date
  is '账期开始日期';
comment on column UNICALL.XQ_INVAPP_PERIOD.end_date
  is '账期结束日期';
comment on column UNICALL.XQ_INVAPP_PERIOD.call_times
  is '账期内已拨打次数';
comment on column UNICALL.XQ_INVAPP_PERIOD.is_success
  is '拨打是否成功 1:成功 0:失败';
alter table UNICALL.XQ_INVAPP_PERIOD
  add constraint PK_XQ_INVAPP_PERIOD primary key (XQ_INVALID_APP_PERIOD_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_INVAPP_PERIOD
  add constraint FK_INVPERIOD_INVAPP foreign key (XQ_INVALID_APP_ID)
  references UNICALL.XQ_INVALID_APP (XQ_INVALID_APP_ID);

prompt
prompt Creating table XQ_INVALID_APP_RETURNVISIT
prompt =========================================
prompt
create table UNICALL.XQ_INVALID_APP_RETURNVISIT
(
  invalid_returnvist_id NUMBER(18) not null,
  invalid_app_period_id NUMBER(18) not null,
  xq_invalid_app_id     NUMBER(18),
  call_use_ali          VARCHAR2(20) not null,
  appoint_date          DATE,
  call_date             DATE,
  returnvist_sta        NUMBER(10),
  caller_no             VARCHAR2(50),
  callee_no             VARCHAR2(50),
  remark                VARCHAR2(400),
  policyno              VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_INVALID_APP_RETURNVISIT
  is '外拨小结，回访记录';
comment on column UNICALL.XQ_INVALID_APP_RETURNVISIT.invalid_returnvist_id
  is '回访标识';
comment on column UNICALL.XQ_INVALID_APP_RETURNVISIT.invalid_app_period_id
  is '失效保单账期ID';
comment on column UNICALL.XQ_INVALID_APP_RETURNVISIT.xq_invalid_app_id
  is '失效保单ID';
comment on column UNICALL.XQ_INVALID_APP_RETURNVISIT.call_use_ali
  is '关联C_USE';
comment on column UNICALL.XQ_INVALID_APP_RETURNVISIT.appoint_date
  is '预约外拨日';
comment on column UNICALL.XQ_INVALID_APP_RETURNVISIT.call_date
  is '回访拨打日期';
comment on column UNICALL.XQ_INVALID_APP_RETURNVISIT.returnvist_sta
  is '关联续期字典表';
comment on column UNICALL.XQ_INVALID_APP_RETURNVISIT.caller_no
  is '主叫号码';
comment on column UNICALL.XQ_INVALID_APP_RETURNVISIT.callee_no
  is '被叫号码';
comment on column UNICALL.XQ_INVALID_APP_RETURNVISIT.remark
  is '备注';
comment on column UNICALL.XQ_INVALID_APP_RETURNVISIT.policyno
  is '保单号';
alter table UNICALL.XQ_INVALID_APP_RETURNVISIT
  add constraint PK_XQ_INVALID_APP_RETURNVISIT primary key (INVALID_RETURNVIST_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_INVALID_APP_RETURNVISIT
  add constraint FK_INVRETURNVISIT_INVAPP foreign key (XQ_INVALID_APP_ID)
  references UNICALL.XQ_INVALID_APP (XQ_INVALID_APP_ID);
alter table UNICALL.XQ_INVALID_APP_RETURNVISIT
  add constraint FK_INVRETURNVISIT_INVPERIOD foreign key (INVALID_APP_PERIOD_ID)
  references UNICALL.XQ_INVAPP_PERIOD (XQ_INVALID_APP_PERIOD_ID);

prompt
prompt Creating table XQ_INVALID_APP_TASK_APPLY
prompt ========================================
prompt
create table UNICALL.XQ_INVALID_APP_TASK_APPLY
(
  invl_app_apply_id NUMBER(18) not null,
  xq_app_id         NUMBER(18),
  old_use_ali       VARCHAR2(20) not null,
  new_use_ali       VARCHAR2(20) not null,
  amount            NUMBER(20,6),
  apply_use_ali     VARCHAR2(20) not null,
  approve_use_ali   VARCHAR2(20),
  apply_date        DATE not null,
  aprove_date       DATE,
  apply_sta         VARCHAR2(2) not null,
  remark            VARCHAR2(200)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_INVALID_APP_TASK_APPLY
  is '失效保单分单调整申请';
comment on column UNICALL.XQ_INVALID_APP_TASK_APPLY.invl_app_apply_id
  is '分单申请标识';
comment on column UNICALL.XQ_INVALID_APP_TASK_APPLY.xq_app_id
  is '保单标识';
comment on column UNICALL.XQ_INVALID_APP_TASK_APPLY.old_use_ali
  is '原座席';
comment on column UNICALL.XQ_INVALID_APP_TASK_APPLY.new_use_ali
  is '新坐席工号';
comment on column UNICALL.XQ_INVALID_APP_TASK_APPLY.amount
  is '金额';
comment on column UNICALL.XQ_INVALID_APP_TASK_APPLY.apply_use_ali
  is '申请人工号';
comment on column UNICALL.XQ_INVALID_APP_TASK_APPLY.approve_use_ali
  is '审批人工号';
comment on column UNICALL.XQ_INVALID_APP_TASK_APPLY.apply_date
  is '申请日期';
comment on column UNICALL.XQ_INVALID_APP_TASK_APPLY.aprove_date
  is '审批日期';
comment on column UNICALL.XQ_INVALID_APP_TASK_APPLY.apply_sta
  is '0:不通过  1:通过  2:待审核';
comment on column UNICALL.XQ_INVALID_APP_TASK_APPLY.remark
  is '备注';
alter table UNICALL.XQ_INVALID_APP_TASK_APPLY
  add constraint PK_XQ_INVALID_APP_TASK_APPLY primary key (INVL_APP_APPLY_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_INVALID_APP_TASK_APPLY
  add constraint FK_INVAPPLY_INVAPP foreign key (XQ_APP_ID)
  references UNICALL.XQ_INVALID_APP (XQ_INVALID_APP_ID);

prompt
prompt Creating table XQ_LOG
prompt =====================
prompt
create table UNICALL.XQ_LOG
(
  sno           NUMBER(18) not null,
  module        VARCHAR2(50),
  logtype       VARCHAR2(10),
  procedurename VARCHAR2(100),
  sucamount     NUMBER,
  erramount     NUMBER,
  updateamount  NUMBER,
  otheramount   VARCHAR2(4000),
  state         VARCHAR2(10),
  errorcontent  VARCHAR2(4000),
  createtime    DATE,
  createuser    VARCHAR2(100),
  updatetime    DATE,
  remark        VARCHAR2(500)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_LOG
  is '电销日志记录表';
comment on column UNICALL.XQ_LOG.sno
  is '物理主键';
comment on column UNICALL.XQ_LOG.module
  is '模块名称';
comment on column UNICALL.XQ_LOG.logtype
  is '2种日志类型:java/proc';
comment on column UNICALL.XQ_LOG.procedurename
  is '存储过程名称';
comment on column UNICALL.XQ_LOG.sucamount
  is '成功多少条';
comment on column UNICALL.XQ_LOG.erramount
  is '失败多少条';
comment on column UNICALL.XQ_LOG.updateamount
  is '更新多少条';
comment on column UNICALL.XQ_LOG.otheramount
  is '其他多少条说明';
comment on column UNICALL.XQ_LOG.state
  is '执行成功还是失败记录(1成功 0失败)';
comment on column UNICALL.XQ_LOG.errorcontent
  is '详细错误内容';
comment on column UNICALL.XQ_LOG.createtime
  is '创建时间';
comment on column UNICALL.XQ_LOG.createuser
  is '创建人';
comment on column UNICALL.XQ_LOG.updatetime
  is '变更时间';
comment on column UNICALL.XQ_LOG.remark
  is '备注 ';
alter table UNICALL.XQ_LOG
  add constraint PK_XQ_LOG primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_MONEYSCH
prompt ==========================
prompt
create table UNICALL.XQ_MONEYSCH
(
  sno               NUMBER(18) not null,
  typeid            NUMBER(7) not null,
  con_id            NUMBER(18),
  policyno          VARCHAR2(20) not null,
  classcode         CHAR(8) not null,
  paysch            CHAR(2) not null,
  delsch            CHAR(1),
  setcode           CHAR(1) not null,
  delfrm            CHAR(1),
  begdate           DATE not null,
  nretdate          DATE,
  pbdate            DATE not null,
  pedate            DATE not null,
  nextdate          DATE,
  benefit_inc       CHAR(1) not null,
  reczip            VARCHAR2(20),
  recaddr           VARCHAR2(500),
  rectele           VARCHAR2(30),
  appointed_bp_date DATE,
  prem_term         VARCHAR2(20),
  bp_option         VARCHAR2(20),
  etl_time          DATE,
  begtime           NUMBER(11),
  endtime           NUMBER(11),
  src_sys           VARCHAR2(20),
  initial_paysch    CHAR(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_MONEYSCH
  is '缴费/给付计划';
comment on column UNICALL.XQ_MONEYSCH.sno
  is 'IAA物理主键';
comment on column UNICALL.XQ_MONEYSCH.typeid
  is 'IAA数据类型(缴费和给付2合1)';
comment on column UNICALL.XQ_MONEYSCH.con_id
  is '保单IAA业务相关主键';
comment on column UNICALL.XQ_MONEYSCH.policyno
  is '保单号';
comment on column UNICALL.XQ_MONEYSCH.classcode
  is '险种代码';
comment on column UNICALL.XQ_MONEYSCH.paysch
  is '缴费频率';
comment on column UNICALL.XQ_MONEYSCH.delsch
  is '给付频率';
comment on column UNICALL.XQ_MONEYSCH.setcode
  is '缴费方式';
comment on column UNICALL.XQ_MONEYSCH.delfrm
  is '给付方式';
comment on column UNICALL.XQ_MONEYSCH.begdate
  is '缴费周年日期';
comment on column UNICALL.XQ_MONEYSCH.nretdate
  is '首次年金领取日期';
comment on column UNICALL.XQ_MONEYSCH.pbdate
  is '缴费起始日期';
comment on column UNICALL.XQ_MONEYSCH.pedate
  is '缴费终止日期';
comment on column UNICALL.XQ_MONEYSCH.nextdate
  is '下次缴费日期';
comment on column UNICALL.XQ_MONEYSCH.benefit_inc
  is '给付类型(平准/递增)';
comment on column UNICALL.XQ_MONEYSCH.reczip
  is '收费邮政编码';
comment on column UNICALL.XQ_MONEYSCH.recaddr
  is '收费地址信息';
comment on column UNICALL.XQ_MONEYSCH.rectele
  is '收费联系电话';
comment on column UNICALL.XQ_MONEYSCH.appointed_bp_date
  is '客户指定的领取日期（鸿鑫）';
comment on column UNICALL.XQ_MONEYSCH.prem_term
  is '缴费期限（FF系统中客户选择的缴费期限，综意险直接按照RISKCON.YEARNUM供数）';
comment on column UNICALL.XQ_MONEYSCH.bp_option
  is '保险期限/领取年龄';
comment on column UNICALL.XQ_MONEYSCH.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_MONEYSCH.begtime
  is '开始日期
';
comment on column UNICALL.XQ_MONEYSCH.endtime
  is '中止日期
';
comment on column UNICALL.XQ_MONEYSCH.src_sys
  is '来源系统
';
comment on column UNICALL.XQ_MONEYSCH.initial_paysch
  is '承保时缴费频率';
create index UNICALL.IDX_XQ_MONEYSCH_BEGINTIME on UNICALL.XQ_MONEYSCH (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_MONEYSCH_ENDTIME on UNICALL.XQ_MONEYSCH (ENDTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_MONEYSCH_PBDATE on UNICALL.XQ_MONEYSCH (PBDATE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_MONEYSCH_PEDATE on UNICALL.XQ_MONEYSCH (PEDATE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_MONEYSCH
  add constraint PK_XQ_MONEYYSCH primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_MONEYSCH
  add constraint UK_XQ_MONEYYSCH_PNO_CLACODE unique (POLICYNO, CLASSCODE)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_REMINDER
prompt ==========================
prompt
create table UNICALL.XQ_REMINDER
(
  reminder_id            NUMBER(18) not null,
  xq_app_id              NUMBER(18),
  policyno               VARCHAR2(20),
  use_ali_id             VARCHAR2(20),
  appoint_date           DATE,
  next_date              DATE,
  task_date              DATE,
  status                 NUMBER(10),
  amount                 NUMBER(20,6) not null,
  prndate                DATE not null,
  yearnum                NUMBER(20) not null,
  years                  NUMBER(20) not null,
  paycode                NUMBER(10) not null,
  setcode                NUMBER(10) not null,
  pcode                  CHAR(1) not null,
  verdate                DATE,
  cover1                 DATE not null,
  cover2                 DATE not null,
  person_id              NUMBER(18),
  apname                 VARCHAR2(120),
  apid                   VARCHAR2(40) not null,
  idtype                 NUMBER(10) not null,
  status_ids_var         CHAR(2),
  source_payin_actvty_id VARCHAR2(35),
  begtime                NUMBER(11),
  endtime                NUMBER(11),
  mod_date               DATE,
  cre_date               DATE,
  etl_date               DATE,
  is_delete              CHAR(1),
  del_date               DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 808M
    next 8K
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_REMINDER
  is '续期催缴保单';
comment on column UNICALL.XQ_REMINDER.reminder_id
  is '应缴件标识';
comment on column UNICALL.XQ_REMINDER.xq_app_id
  is '关联保单XQ_APP';
comment on column UNICALL.XQ_REMINDER.policyno
  is '保单号';
comment on column UNICALL.XQ_REMINDER.use_ali_id
  is '续收代表工号';
comment on column UNICALL.XQ_REMINDER.appoint_date
  is '预约外拨日';
comment on column UNICALL.XQ_REMINDER.next_date
  is '下次缴费日';
comment on column UNICALL.XQ_REMINDER.task_date
  is '分配时间';
comment on column UNICALL.XQ_REMINDER.status
  is '应缴件状态
1 待分配
2 有效
3 待审批
4 已缴
5 取消
关联数据字典表';
comment on column UNICALL.XQ_REMINDER.amount
  is '缴费/领款金额';
comment on column UNICALL.XQ_REMINDER.prndate
  is '生成日期';
comment on column UNICALL.XQ_REMINDER.yearnum
  is '保单约定缴费年限';
comment on column UNICALL.XQ_REMINDER.years
  is '期次';
comment on column UNICALL.XQ_REMINDER.paycode
  is '本次缴费对应缴费频率
01～趸缴
10～月缴
11～季缴
12～半年缴
13～年缴';
comment on column UNICALL.XQ_REMINDER.setcode
  is '支付/领款方式
1：现:2：支票3：转帐(银行,邮局)4：银行代收(银保通)8：POS转账9：赠险';
comment on column UNICALL.XQ_REMINDER.pcode
  is '交易财务类型';
comment on column UNICALL.XQ_REMINDER.verdate
  is '交易生效日期';
comment on column UNICALL.XQ_REMINDER.cover1
  is '财务交易责任起始日期';
comment on column UNICALL.XQ_REMINDER.cover2
  is '财务交易责任终止日期';
comment on column UNICALL.XQ_REMINDER.person_id
  is '缴费/领款人IAA业务相关主键';
comment on column UNICALL.XQ_REMINDER.apname
  is '投保人姓名';
comment on column UNICALL.XQ_REMINDER.apid
  is '投保人身份证件号';
comment on column UNICALL.XQ_REMINDER.idtype
  is '投保人身份证件类型';
comment on column UNICALL.XQ_REMINDER.status_ids_var
  is 'IDS中应缴件状态0：未处理1:划帐中(划帐成功)2:划帐不成功3:已转为正式记录';
comment on column UNICALL.XQ_REMINDER.source_payin_actvty_id
  is '应收数据唯一标识';
comment on column UNICALL.XQ_REMINDER.begtime
  is '开始日期
';
comment on column UNICALL.XQ_REMINDER.endtime
  is '中止日期
';
comment on column UNICALL.XQ_REMINDER.mod_date
  is '更新时间';
comment on column UNICALL.XQ_REMINDER.cre_date
  is '创建时间';
comment on column UNICALL.XQ_REMINDER.etl_date
  is 'ETL时间';
comment on column UNICALL.XQ_REMINDER.is_delete
  is '空:正常，1:删除 ';
comment on column UNICALL.XQ_REMINDER.del_date
  is '删除时间';
create index UNICALL.IDX_XQ_REMINDER_01 on UNICALL.XQ_REMINDER (COVER1, STATUS)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_REMINDER_03 on UNICALL.XQ_REMINDER (APID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_REMINDER_04 on UNICALL.XQ_REMINDER (USE_ALI_ID, STATUS)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_REMINDER_COVER1 on UNICALL.XQ_REMINDER (COVER1)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 640K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_REMINDER_POLICYNO on UNICALL.XQ_REMINDER (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 768K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_REMINDER_STATUS on UNICALL.XQ_REMINDER (STATUS)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 576K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_REMINDER_USE_ALI on UNICALL.XQ_REMINDER (USE_ALI_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_REMINDER
  add constraint PK_XQ_REMINDER primary key (REMINDER_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 320K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_REMINDER
  add constraint FK_XQ_REMIN_REFERENCE_XQ_APP foreign key (XQ_APP_ID)
  references UNICALL.XQ_APP (XQ_APP_ID);

prompt
prompt Creating table XQ_PERIOD
prompt ========================
prompt
create table UNICALL.XQ_PERIOD
(
  period_id    NUMBER(18) not null,
  reminder_id  NUMBER(18),
  period_value VARCHAR2(20) not null,
  begin_date   DATE not null,
  end_date     DATE not null,
  call_times   NUMBER,
  is_success   VARCHAR2(2) default 0
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 4M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_PERIOD
  is '账龄=10，账龄=20，账龄=30，账龄=40，账龄=50';
comment on column UNICALL.XQ_PERIOD.period_id
  is '账期标识';
comment on column UNICALL.XQ_PERIOD.reminder_id
  is '应缴件标识';
comment on column UNICALL.XQ_PERIOD.period_value
  is '账期值';
comment on column UNICALL.XQ_PERIOD.begin_date
  is '账期开始日期';
comment on column UNICALL.XQ_PERIOD.end_date
  is '账期结束日期';
comment on column UNICALL.XQ_PERIOD.call_times
  is '账期内已拨打次数';
comment on column UNICALL.XQ_PERIOD.is_success
  is '1:成功 0:失败';
create index UNICALL.IDX_XQ_PERIOD_BEGIN on UNICALL.XQ_PERIOD (BEGIN_DATE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 4M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PERIOD_END on UNICALL.XQ_PERIOD (END_DATE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 4M
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PERIOD_REMINDER_ID on UNICALL.XQ_PERIOD (REMINDER_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_PERIOD
  add constraint PK_XQ_PERIOD primary key (PERIOD_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_PERIOD
  add constraint FK_XQ_PERIO_REFERENCE_XQ_REMIN foreign key (REMINDER_ID)
  references UNICALL.XQ_REMINDER (REMINDER_ID);

prompt
prompt Creating table XQ_PERSON
prompt ========================
prompt
create table UNICALL.XQ_PERSON
(
  sno              NUMBER(18) not null,
  person_id        NUMBER(18),
  persontype       NUMBER(18) not null,
  bthdate          DATE,
  diedate          DATE,
  edulevel         CHAR(2),
  sex              CHAR(1),
  income           NUMBER(20,6),
  company          VARCHAR2(180),
  marriage         CHAR(3),
  smoker           CHAR(1),
  blood            NUMBER(20),
  ethnicity        CHAR(2),
  hdesp            CHAR(1),
  customerid       VARCHAR2(40),
  name             VARCHAR2(120),
  job              CHAR(7),
  drvcard          VARCHAR2(2),
  country          CHAR(2),
  residence        VARCHAR2(90),
  id               VARCHAR2(40) not null,
  id15             VARCHAR2(40),
  idtype           NUMBER(10) not null,
  etl_time         DATE not null,
  idtype_ids       CHAR(2),
  source_person_id VARCHAR2(20),
  branch           CHAR(14),
  begtime          NUMBER(11),
  endtime          NUMBER(11),
  src_sys          VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 2M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_PERSON
  is '个人客户';
comment on column UNICALL.XQ_PERSON.sno
  is '物理主键';
comment on column UNICALL.XQ_PERSON.person_id
  is '业务主键';
comment on column UNICALL.XQ_PERSON.persontype
  is '人员主要角色（客户、营销员、联系人）
1015691CUSTOMER
1015692CHANNELROLE';
comment on column UNICALL.XQ_PERSON.bthdate
  is '生日';
comment on column UNICALL.XQ_PERSON.diedate
  is '死亡日期';
comment on column UNICALL.XQ_PERSON.edulevel
  is '09研究生
02硕士
01博士
10博士后
03大学本科
04专科
06中专
11技校
05高中
07初中
08小学
12文盲或半文盲
13未知';
comment on column UNICALL.XQ_PERSON.sex
  is '1男
2女
0男女';
comment on column UNICALL.XQ_PERSON.income
  is '年收入';
comment on column UNICALL.XQ_PERSON.company
  is '服务单位名称';
comment on column UNICALL.XQ_PERSON.marriage
  is '婚姻状态：
203离婚
201已婚
202未婚
204鳏寡
206初婚
207再婚
208复婚
205分居';
comment on column UNICALL.XQ_PERSON.smoker
  is '0非吸烟者
1吸烟者';
comment on column UNICALL.XQ_PERSON.blood
  is '血型';
comment on column UNICALL.XQ_PERSON.ethnicity
  is '民族';
comment on column UNICALL.XQ_PERSON.hdesp
  is '健康状况
0健康
1死亡
2有问题';
comment on column UNICALL.XQ_PERSON.customerid
  is '客户号';
comment on column UNICALL.XQ_PERSON.name
  is '姓名';
comment on column UNICALL.XQ_PERSON.job
  is '全职职业代码';
comment on column UNICALL.XQ_PERSON.drvcard
  is '驾照类型';
comment on column UNICALL.XQ_PERSON.country
  is '国籍';
comment on column UNICALL.XQ_PERSON.residence
  is '户籍所在地（县或市）';
comment on column UNICALL.XQ_PERSON.id
  is '证件号码(18)';
comment on column UNICALL.XQ_PERSON.id15
  is '15位身份证号码';
comment on column UNICALL.XQ_PERSON.idtype
  is '证件类型';
comment on column UNICALL.XQ_PERSON.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_PERSON.idtype_ids
  is '被保人证件类型 IDS证件类型
00:团体客户
01:身份证
02:户口簿
03:护照
04:军官证
05:士兵证
06:港澳居民来往内地通行证
07:台湾同胞来往内地通行证
08:临时身份证
09:外国人居留证
10:警察证
11:文职干部证
12:驾驶执照
13:虚拟身份证
14:出生证书
99:其他证书';
comment on column UNICALL.XQ_PERSON.source_person_id
  is '	源系统客户号';
comment on column UNICALL.XQ_PERSON.branch
  is '	分公司代码';
comment on column UNICALL.XQ_PERSON.begtime
  is '开始日期';
comment on column UNICALL.XQ_PERSON.endtime
  is '中止日期';
comment on column UNICALL.XQ_PERSON.src_sys
  is '来源系统';
create index UNICALL.IDX_XQPERSON_BEGINTIME on UNICALL.XQ_PERSON (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQPERSON_ID on UNICALL.XQ_PERSON (ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQPERSON_ID15 on UNICALL.XQ_PERSON (ID15)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQPERSON_NAME on UNICALL.XQ_PERSON (NAME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PERSON_PERSON_ID on UNICALL.XQ_PERSON (PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_PERSON
  add constraint PK_XQ_PERSON primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 256K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_PERSON
  add constraint UK_XQ_PERSON unique (SOURCE_PERSON_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_PHONE
prompt =======================
prompt
create table UNICALL.XQ_PHONE
(
  sno              NUMBER(18) not null,
  areacode         VARCHAR2(20),
  countrycode      VARCHAR2(20),
  tel              VARCHAR2(20),
  ext              VARCHAR2(20),
  type             CHAR(1) not null,
  telnumber        VARCHAR2(100) not null,
  usage            CHAR(1) not null,
  person_id        NUMBER(18),
  pid              VARCHAR2(40) not null,
  idtype           NUMBER(10) not null,
  id15             VARCHAR2(40),
  etl_time         DATE not null,
  idtype_ids       CHAR(2),
  source_person_id VARCHAR2(20),
  seq              VARCHAR2(10),
  begtime          NUMBER(11),
  endtime          NUMBER(11),
  src_sys          VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_PHONE
  is '电话';
comment on column UNICALL.XQ_PHONE.sno
  is '物理主键';
comment on column UNICALL.XQ_PHONE.areacode
  is '电话区号';
comment on column UNICALL.XQ_PHONE.countrycode
  is '国家';
comment on column UNICALL.XQ_PHONE.tel
  is '电话号码（总机）';
comment on column UNICALL.XQ_PHONE.ext
  is '电话号码（分机）';
comment on column UNICALL.XQ_PHONE.type
  is '1REGULAR
2MOBILE
3FAX
4ON-BOARD';
comment on column UNICALL.XQ_PHONE.telnumber
  is '联系电话';
comment on column UNICALL.XQ_PHONE.usage
  is '1 移动电话
2 家庭电话
3 行政办公司室
4 联系人
5 其他电话
5 传真
6 车载电话
7 热线
8 办公电话
9 其他联系电话';
comment on column UNICALL.XQ_PHONE.person_id
  is '客户IAA业务相关主键';
comment on column UNICALL.XQ_PHONE.pid
  is '身份证号/团体客户号';
comment on column UNICALL.XQ_PHONE.idtype
  is '证件类型';
comment on column UNICALL.XQ_PHONE.id15
  is '15位身份证号码';
comment on column UNICALL.XQ_PHONE.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_PHONE.idtype_ids
  is '被保人证件类型 IDS证件类型
00:团体客户
01:身份证
02:户口簿
03:护照
04:军官证
05:士兵证
06:港澳居民来往内地通行证
07:台湾同胞来往内地通行证
08:临时身份证
09:外国人居留证
10:警察证
11:文职干部证
12:驾驶执照
13:虚拟身份证
14:出生证书
99:其他证书';
comment on column UNICALL.XQ_PHONE.source_person_id
  is '源系统客户号';
comment on column UNICALL.XQ_PHONE.begtime
  is '开始日期';
comment on column UNICALL.XQ_PHONE.endtime
  is '中止日期';
comment on column UNICALL.XQ_PHONE.src_sys
  is '来源系统';
create index UNICALL.IDX_XQPHONE_ID15 on UNICALL.XQ_PHONE (ID15)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PHONE_BEGINTIME on UNICALL.XQ_PHONE (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PHONE_PERSON_ID on UNICALL.XQ_PHONE (PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PHONE_PID on UNICALL.XQ_PHONE (PID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PHONE_SEQ on UNICALL.XQ_PHONE (SEQ)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PHONE_SPID on UNICALL.XQ_PHONE (SOURCE_PERSON_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PHONE_TEL on UNICALL.XQ_PHONE (TEL)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PHONE_USAGE on UNICALL.XQ_PHONE (USAGE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_PHONE
  add constraint PK_XQ_PHONE primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_PHONE
  add constraint UK_XQ_PHONE_USAGGE_SPID_SEQ unique (USAGE, SOURCE_PERSON_ID, SEQ)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_PLC_PRM_TRANS_ACCT
prompt ====================================
prompt
create table UNICALL.XQ_PLC_PRM_TRANS_ACCT
(
  plc_prm_trans_acct_id NUMBER(20) not null,
  sno                   NUMBER(20) not null,
  policy_no             VARCHAR2(20) not null,
  account_usage         VARCHAR2(1) not null,
  account_no            VARCHAR2(120) not null,
  bank_code             VARCHAR2(20) not null,
  bank_name             VARCHAR2(80),
  owner_id              VARCHAR2(40) not null,
  currency              VARCHAR2(3) not null,
  open_date             DATE,
  oper_date             DATE,
  oper_no               VARCHAR2(20),
  begtime               NUMBER(11) not null,
  endtime               NUMBER(11) not null,
  branch                CHAR(14) not null,
  etl_time              DATE not null,
  src_sys               VARCHAR2(20) not null,
  create_date           DATE,
  update_date           DATE
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_PLC_PRM_TRANS_ACCT
  is '保单缴费帐号';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.plc_prm_trans_acct_id
  is '物理主键';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.sno
  is '记录行号';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.policy_no
  is '保单号（续期账号）/投保单号（首期账号）';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.account_usage
  is '账户用途';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.account_no
  is '银行账户号';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.bank_code
  is '银行账户开户行代码';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.bank_name
  is '银行账户开户行名称';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.owner_id
  is '账户所有人证件号（个人或团体客户）';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.currency
  is '币种代码';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.open_date
  is '开户日期';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.oper_date
  is '录入日期';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.oper_no
  is '操作员';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.begtime
  is '开始日期';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.endtime
  is '中止日期';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.branch
  is '分公司代码';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_PLC_PRM_TRANS_ACCT.src_sys
  is '来源系统';
alter table UNICALL.XQ_PLC_PRM_TRANS_ACCT
  add constraint PK_PLC_PRM_TRANS_ACCT primary key (PLC_PRM_TRANS_ACCT_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_PLC_PRM_TRANS_ACCT
  add constraint UK_PLC_PRM_TRANS_ACCT unique (POLICY_NO, ACCOUNT_USAGE)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_PREREC
prompt ========================
prompt
create table UNICALL.XQ_PREREC
(
  sno                    NUMBER(18) not null,
  typeid                 NUMBER(7) not null,
  con_id                 NUMBER(20),
  policyno               VARCHAR2(20),
  classcode              CHAR(8) not null,
  amount                 NUMBER(20,4) not null,
  stdrate                NUMBER(20,6) not null,
  unstdrate              NUMBER(20,6) not null,
  yearnum                NUMBER(20) not null,
  paycode                NUMBER(10) not null,
  setcode                NUMBER(10) not null,
  pcode                  CHAR(1) not null,
  paydate                DATE not null,
  years                  NUMBER(20) not null,
  cover1                 DATE not null,
  cover2                 DATE not null,
  source_payin_actvty_id VARCHAR2(35) not null,
  etl_time               DATE,
  paycode_ids            CHAR(2),
  setcode_ids            CHAR(2),
  check_id               NUMBER(20),
  checkno                VARCHAR2(40),
  currency               CHAR(3),
  movewhy                VARCHAR2(120),
  oper_id                NUMBER(20),
  operno                 VARCHAR2(20),
  empno_id               NUMBER(20),
  empno                  VARCHAR2(20),
  csr_id                 NUMBER(20),
  csrno                  VARCHAR2(20),
  deptno                 VARCHAR2(20),
  seckey                 VARCHAR2(20),
  inner_settle_ind       CHAR(1),
  begtime                NUMBER(11),
  endtime                NUMBER(11),
  branch                 CHAR(14),
  src_sys                VARCHAR2(20),
  sale_mode              CHAR(4),
  the_thrdprt            CHAR(4),
  job                    CHAR(8),
  busi_branch            CHAR(14),
  fin_proc_type          NUMBER(7),
  insrnc_rate            NUMBER(7,4)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 293M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_PREREC
  is '财务实收信息';
comment on column UNICALL.XQ_PREREC.sno
  is '物理主键';
comment on column UNICALL.XQ_PREREC.typeid
  is 'IAA数据类型（实收实付）';
comment on column UNICALL.XQ_PREREC.con_id
  is '保单IAA业务相关主键';
comment on column UNICALL.XQ_PREREC.policyno
  is '保单号';
comment on column UNICALL.XQ_PREREC.classcode
  is '险种代码';
comment on column UNICALL.XQ_PREREC.amount
  is '  缴费/领款金额';
comment on column UNICALL.XQ_PREREC.stdrate
  is '  标准加费';
comment on column UNICALL.XQ_PREREC.unstdrate
  is '  非标准加费';
comment on column UNICALL.XQ_PREREC.yearnum
  is '  缴费年限';
comment on column UNICALL.XQ_PREREC.paycode
  is '  缴费频率';
comment on column UNICALL.XQ_PREREC.setcode
  is '  缴费/领款方式';
comment on column UNICALL.XQ_PREREC.pcode
  is '  交易财务类型';
comment on column UNICALL.XQ_PREREC.paydate
  is '  交易生效日期';
comment on column UNICALL.XQ_PREREC.years
  is '  期次';
comment on column UNICALL.XQ_PREREC.cover1
  is '  财务交易责任起始日期';
comment on column UNICALL.XQ_PREREC.cover2
  is '  财务交易责任终止日期';
comment on column UNICALL.XQ_PREREC.source_payin_actvty_id
  is '  实收应收关联ID';
comment on column UNICALL.XQ_PREREC.etl_time
  is '  ETL处理时间';
comment on column UNICALL.XQ_PREREC.paycode_ids
  is '缴费频率 01:趸缴 10:月缴 11:季缴 12:半年缴 13:年缴';
comment on column UNICALL.XQ_PREREC.setcode_ids
  is '支付形式 1:现金 2:支票 3:转帐(银行,邮局) 4:银行代收(银保通) 8:POS转账 9:赠险';
comment on column UNICALL.XQ_PREREC.check_id
  is '  支票IAA相关业务主键';
comment on column UNICALL.XQ_PREREC.checkno
  is '  支票号';
comment on column UNICALL.XQ_PREREC.currency
  is '  币种代码';
comment on column UNICALL.XQ_PREREC.movewhy
  is '  红冲原因';
comment on column UNICALL.XQ_PREREC.oper_id
  is '  操作员IAA相关业务主键';
comment on column UNICALL.XQ_PREREC.operno
  is '  操作员工号';
comment on column UNICALL.XQ_PREREC.empno_id
  is '  业务员IAA业务相关主键';
comment on column UNICALL.XQ_PREREC.empno
  is '  业务员代码';
comment on column UNICALL.XQ_PREREC.csr_id
  is '  收展员IAA业务相关主键';
comment on column UNICALL.XQ_PREREC.csrno
  is '  收展员代码';
comment on column UNICALL.XQ_PREREC.deptno
  is '  业务操作部门';
comment on column UNICALL.XQ_PREREC.seckey
  is '  业务归属部门';
comment on column UNICALL.XQ_PREREC.inner_settle_ind
  is '  内部结算标记';
comment on column UNICALL.XQ_PREREC.begtime
  is '  开始日期';
comment on column UNICALL.XQ_PREREC.endtime
  is '  中止日期';
comment on column UNICALL.XQ_PREREC.branch
  is '  分公司代码';
comment on column UNICALL.XQ_PREREC.src_sys
  is '  来源系统';
comment on column UNICALL.XQ_PREREC.sale_mode
  is '结算模式';
comment on column UNICALL.XQ_PREREC.the_thrdprt
  is '第三方结算机构';
comment on column UNICALL.XQ_PREREC.job
  is '被保人全职代码';
comment on column UNICALL.XQ_PREREC.busi_branch
  is '保单对应机构（到4级机构）';
comment on column UNICALL.XQ_PREREC.fin_proc_type
  is '财务处理类型，主要针对款别变更的流水，财务不进行处理';
comment on column UNICALL.XQ_PREREC.insrnc_rate
  is '共保比例（指太保主承担时的共保承担比例，非共保和太保非主承担时取值100）（存放百分数，70%放70）';
create index UNICALL.IDX_XQ_PREREC_BEGINTIME on UNICALL.XQ_PREREC (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PREREC_CLASSCODE on UNICALL.XQ_PREREC (CLASSCODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PREREC_COVER1 on UNICALL.XQ_PREREC (COVER1)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PREREC_POLICYNO on UNICALL.XQ_PREREC (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_PREREC_SPAID on UNICALL.XQ_PREREC (SOURCE_PAYIN_ACTVTY_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_PREREC
  add constraint PK_XQ_PREREC primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_RATE_OF_CONTINUATION
prompt ======================================
prompt
create table UNICALL.XQ_RATE_OF_CONTINUATION
(
  org_id         CHAR(14),
  org_type       INTEGER,
  time_of_sta    VARCHAR2(20),
  task_date      DATE,
  sta_type       INTEGER,
  sta_rate       INTEGER,
  d1             NUMBER(20,6),
  n1             NUMBER(20,6),
  d2             NUMBER(20,6),
  n2             NUMBER(20,6),
  d3             NUMBER(20,6),
  n3             NUMBER(20,6),
  d4             NUMBER(20,6),
  n4             NUMBER(20,6),
  sales_project  VARCHAR2(150),
  sales_organ    VARCHAR2(150),
  sales_classify VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_RATE_OF_CONTINUATION
  is '继续率报表中间表';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.org_id
  is '机构id';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.org_type
  is '机构类型：落地分公司为0，销售机构为1';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.time_of_sta
  is '统计时间';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.task_date
  is '任务提交时间';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.sta_type
  is '统计类型：10为月缴费，11为季缴，13为年缴';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.sta_rate
  is '统计频率：3三期已缴，5三期未缴，4/7/13/25';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.d1
  is '当月分子';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.n1
  is '当月分母';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.d2
  is '宽一分子';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.n2
  is '宽一分母';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.d3
  is '宽末分子';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.n3
  is '宽末分母';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.d4
  is '累计分子';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.n4
  is '累计分母';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.sales_project
  is '销售项目';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.sales_organ
  is '销售机构';
comment on column UNICALL.XQ_RATE_OF_CONTINUATION.sales_classify
  is '销售机构分类：（总公司，分公司，总销，总分销）';

prompt
prompt Creating table XQ_RATE_OF_CONTINUATION_BAK
prompt ==========================================
prompt
create table UNICALL.XQ_RATE_OF_CONTINUATION_BAK
(
  org_id         CHAR(14),
  org_type       INTEGER,
  time_of_sta    VARCHAR2(20),
  task_date      DATE,
  sta_type       INTEGER,
  sta_rate       INTEGER,
  d1             NUMBER(20,6),
  n1             NUMBER(20,6),
  d2             NUMBER(20,6),
  n2             NUMBER(20,6),
  d3             NUMBER(20,6),
  n3             NUMBER(20,6),
  d4             NUMBER(20,6),
  n4             NUMBER(20,6),
  sales_project  VARCHAR2(150),
  sales_organ    VARCHAR2(150),
  sales_classify VARCHAR2(100)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_REALPAYRC
prompt ===========================
prompt
create table UNICALL.XQ_REALPAYRC
(
  id                      NUMBER(20) not null,
  sno                     NUMBER(20),
  typeid                  NUMBER(7) not null,
  con_id                  NUMBER(20),
  policyno                VARCHAR2(20) not null,
  classcode               CHAR(8) not null,
  check_id                NUMBER(20),
  checkno                 VARCHAR2(40),
  amount                  NUMBER(20,4) not null,
  currency                CHAR(3) not null,
  gendate                 DATE not null,
  delfrm                  CHAR(1) not null,
  setcode                 CHAR(1) not null,
  movewhy                 VARCHAR2(120),
  delcode                 CHAR(3) not null,
  typeno                  CHAR(2) not null,
  regdate                 DATE not null,
  agent_id                NUMBER(20),
  agentno                 VARCHAR2(20) not null,
  oper_id                 NUMBER(20),
  operno                  VARCHAR2(20) not null,
  deptno                  VARCHAR2(20) not null,
  docpro                  CHAR(1),
  docno                   VARCHAR2(20),
  person_id               NUMBER(20),
  pid                     VARCHAR2(40) not null,
  idtype                  CHAR(2) not null,
  paytime                 NUMBER(20) not null,
  seckey                  VARCHAR2(20),
  source_payout_actvty_id VARCHAR2(35) not null,
  begtime                 NUMBER(11) not null,
  endtime                 NUMBER(11) not null,
  branch                  CHAR(14) not null,
  etl_time                DATE not null,
  src_sys                 VARCHAR2(20) not null,
  sale_mode               CHAR(4),
  the_thrdprt             CHAR(4),
  empno                   VARCHAR2(20),
  csrno                   VARCHAR2(20),
  job                     CHAR(8),
  busi_branch             CHAR(14),
  fin_proc_type           NUMBER(7),
  insrnc_rate             NUMBER(7,4),
  create_date             DATE not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_REALPAYRC
  is '财务实付信息';
comment on column UNICALL.XQ_REALPAYRC.id
  is '自增长主键';
comment on column UNICALL.XQ_REALPAYRC.sno
  is 'IAA物理主键';
comment on column UNICALL.XQ_REALPAYRC.typeid
  is 'IAA数据类型（实收实付）';
comment on column UNICALL.XQ_REALPAYRC.con_id
  is '保单IAA业务相关主键';
comment on column UNICALL.XQ_REALPAYRC.policyno
  is '保单号';
comment on column UNICALL.XQ_REALPAYRC.classcode
  is '险种代码';
comment on column UNICALL.XQ_REALPAYRC.check_id
  is '支票IAA相关业务主键';
comment on column UNICALL.XQ_REALPAYRC.checkno
  is '支票号';
comment on column UNICALL.XQ_REALPAYRC.amount
  is '缴费/领款金额';
comment on column UNICALL.XQ_REALPAYRC.currency
  is '币种代码';
comment on column UNICALL.XQ_REALPAYRC.gendate
  is '应付日期';
comment on column UNICALL.XQ_REALPAYRC.delfrm
  is '给付频率';
comment on column UNICALL.XQ_REALPAYRC.setcode
  is '领款方式';
comment on column UNICALL.XQ_REALPAYRC.movewhy
  is '红冲原因';
comment on column UNICALL.XQ_REALPAYRC.delcode
  is '交易财务类型';
comment on column UNICALL.XQ_REALPAYRC.typeno
  is '交易子类型（给付的基础定义在riskpay中；理赔的基础定义在clmprefunc中，其它责任都是00）';
comment on column UNICALL.XQ_REALPAYRC.regdate
  is '交易生效日期';
comment on column UNICALL.XQ_REALPAYRC.agent_id
  is '经办人IAA相关业务主键';
comment on column UNICALL.XQ_REALPAYRC.agentno
  is '经办人代码';
comment on column UNICALL.XQ_REALPAYRC.oper_id
  is '操作员IAA相关业务主键';
comment on column UNICALL.XQ_REALPAYRC.operno
  is '操作员工号';
comment on column UNICALL.XQ_REALPAYRC.deptno
  is '业务操作部门';
comment on column UNICALL.XQ_REALPAYRC.docpro
  is '单证类型2批改单号3赔案号4给付证号5报案号6通融给付';
comment on column UNICALL.XQ_REALPAYRC.docno
  is '单证号';
comment on column UNICALL.XQ_REALPAYRC.person_id
  is '缴费/领款人IAA业务相关主键';
comment on column UNICALL.XQ_REALPAYRC.pid
  is '领款人身份证号';
comment on column UNICALL.XQ_REALPAYRC.idtype
  is '领款人身份证件类型';
comment on column UNICALL.XQ_REALPAYRC.paytime
  is '期次';
comment on column UNICALL.XQ_REALPAYRC.seckey
  is '业务归属部门';
comment on column UNICALL.XQ_REALPAYRC.source_payout_actvty_id
  is '应付实付关联id';
comment on column UNICALL.XQ_REALPAYRC.begtime
  is '开始日期';
comment on column UNICALL.XQ_REALPAYRC.endtime
  is '中止日期';
comment on column UNICALL.XQ_REALPAYRC.branch
  is '分公司代码';
comment on column UNICALL.XQ_REALPAYRC.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_REALPAYRC.src_sys
  is '来源系统';
comment on column UNICALL.XQ_REALPAYRC.sale_mode
  is '结算模式';
comment on column UNICALL.XQ_REALPAYRC.the_thrdprt
  is '第三方结算机构';
comment on column UNICALL.XQ_REALPAYRC.empno
  is '业务员代码';
comment on column UNICALL.XQ_REALPAYRC.csrno
  is '收展员代码';
comment on column UNICALL.XQ_REALPAYRC.job
  is '被保人全职代码';
comment on column UNICALL.XQ_REALPAYRC.busi_branch
  is '保单对应机构（到4级机构）';
comment on column UNICALL.XQ_REALPAYRC.fin_proc_type
  is '财务处理类型，主要针对款别变更的流水，财务不进行处理';
comment on column UNICALL.XQ_REALPAYRC.insrnc_rate
  is '共保比例（指太保主承担时的共保承担比例，非共保和太保非主承担时取值100）（存放百分数，70%放70）';
comment on column UNICALL.XQ_REALPAYRC.create_date
  is '创建时间';
create index UNICALL.IDX_XQ_REALPAYRC_BRANCH on UNICALL.XQ_REALPAYRC (BRANCH)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_REALPAYRC_CLASSCODE on UNICALL.XQ_REALPAYRC (CLASSCODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_REALPAYRC_ETL_TIME on UNICALL.XQ_REALPAYRC (ETL_TIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_REALPAYRC_POLICYNO on UNICALL.XQ_REALPAYRC (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_REALPAYRC
  add constraint PK_XQ_REALPAYRE_SNO primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_RECEIVABLETASK_REPORT_LOG
prompt ===========================================
prompt
create table UNICALL.XQ_RECEIVABLETASK_REPORT_LOG
(
  id          NUMBER(10) not null,
  report_date VARCHAR2(20),
  counts      NUMBER(10),
  upload      VARCHAR2(300),
  file_name   VARCHAR2(50),
  type        NUMBER(10)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.XQ_RECEIVABLETASK_REPORT_LOG.report_date
  is '清单统计时间';
comment on column UNICALL.XQ_RECEIVABLETASK_REPORT_LOG.counts
  is '统计条数';
comment on column UNICALL.XQ_RECEIVABLETASK_REPORT_LOG.upload
  is '上传FTP路径';
comment on column UNICALL.XQ_RECEIVABLETASK_REPORT_LOG.file_name
  is '上传文件名';
comment on column UNICALL.XQ_RECEIVABLETASK_REPORT_LOG.type
  is '清单类型：2001 应收任务清单  2002  电销续收总清单    2003   月转年清单';
alter table UNICALL.XQ_RECEIVABLETASK_REPORT_LOG
  add primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_REMINDER_REPORT
prompt =================================
prompt
create table UNICALL.XQ_REMINDER_REPORT
(
  id                 NUMBER(18) not null,
  cur_date           DATE,
  report_type        VARCHAR2(2),
  use_ali_id         VARCHAR2(20),
  use_nam            VARCHAR2(1024),
  four_samount       NUMBER(20,6),
  four_ramount       NUMBER(20,6),
  four_rate          VARCHAR2(10),
  seven_samount      NUMBER(20,6),
  seven_ramount      NUMBER(20,6),
  seven_rate         VARCHAR2(10),
  thirteen_samount   NUMBER(20,6),
  thirteen_ramount   NUMBER(20,6),
  thirteen_rate      VARCHAR2(10),
  total_samount      NUMBER(20,6),
  total_ramount      NUMBER(20,6),
  total_rate         VARCHAR2(10),
  twentyfive_samount NUMBER(20,6),
  twentyfive_ramount NUMBER(20,6),
  twentyfive_rate    VARCHAR2(10),
  paycode            VARCHAR2(2),
  grpid              NUMBER(30),
  grpname            VARCHAR2(1024)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_REMINDER_REPORT
  is '续收代表达成报表';
comment on column UNICALL.XQ_REMINDER_REPORT.id
  is '主键 自增长';
comment on column UNICALL.XQ_REMINDER_REPORT.cur_date
  is '统计月';
comment on column UNICALL.XQ_REMINDER_REPORT.report_type
  is '报表类型(''00'' 当月， ''01'' 宽一，''02'' 宽末)';
comment on column UNICALL.XQ_REMINDER_REPORT.use_ali_id
  is '续收代表工号';
comment on column UNICALL.XQ_REMINDER_REPORT.use_nam
  is '续收代表姓名';
comment on column UNICALL.XQ_REMINDER_REPORT.four_samount
  is '4个月应收保费';
comment on column UNICALL.XQ_REMINDER_REPORT.four_ramount
  is '4个月实收保费';
comment on column UNICALL.XQ_REMINDER_REPORT.four_rate
  is '4个月达成率';
comment on column UNICALL.XQ_REMINDER_REPORT.seven_samount
  is '7个月应收保费';
comment on column UNICALL.XQ_REMINDER_REPORT.seven_ramount
  is '7个月实收保费';
comment on column UNICALL.XQ_REMINDER_REPORT.seven_rate
  is '7个月达成率';
comment on column UNICALL.XQ_REMINDER_REPORT.thirteen_samount
  is '13个月应收保费';
comment on column UNICALL.XQ_REMINDER_REPORT.thirteen_ramount
  is '13个月实收保费';
comment on column UNICALL.XQ_REMINDER_REPORT.thirteen_rate
  is '13个月达成率';
comment on column UNICALL.XQ_REMINDER_REPORT.total_samount
  is '整体应收保费';
comment on column UNICALL.XQ_REMINDER_REPORT.total_ramount
  is '整体实收保费';
comment on column UNICALL.XQ_REMINDER_REPORT.total_rate
  is '整体达成率';
comment on column UNICALL.XQ_REMINDER_REPORT.twentyfive_samount
  is '25个月应收保费';
comment on column UNICALL.XQ_REMINDER_REPORT.twentyfive_ramount
  is '25个月实收保费';
comment on column UNICALL.XQ_REMINDER_REPORT.twentyfive_rate
  is '25个月达成率';
comment on column UNICALL.XQ_REMINDER_REPORT.paycode
  is '缴费频率(''00'' 月缴， ''01'' 季缴，''02'' 年缴，''03''全部)';
comment on column UNICALL.XQ_REMINDER_REPORT.grpid
  is '所在用户组id';
comment on column UNICALL.XQ_REMINDER_REPORT.grpname
  is '所在用户组名称';
alter table UNICALL.XQ_REMINDER_REPORT
  add constraint XQ_REMINDER_REPORT_ID primary key (ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_RETURNVISIT
prompt =============================
prompt
create table UNICALL.XQ_RETURNVISIT
(
  returnvist_id  NUMBER(18) not null,
  period_id      NUMBER(18) not null,
  reminder_id    NUMBER(18) not null,
  call_use_ali   VARCHAR2(20) not null,
  appoint_date   DATE,
  call_date      DATE,
  returnvist_sta NUMBER(10),
  caller_no      VARCHAR2(50),
  callee_no      VARCHAR2(50),
  remark         VARCHAR2(400),
  policyno       VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_RETURNVISIT
  is '外拨小结，回访记录';
comment on column UNICALL.XQ_RETURNVISIT.returnvist_id
  is '回访标识';
comment on column UNICALL.XQ_RETURNVISIT.period_id
  is '关联 T_XQ_PERRIOD';
comment on column UNICALL.XQ_RETURNVISIT.reminder_id
  is '关联XQ_REMINDER';
comment on column UNICALL.XQ_RETURNVISIT.call_use_ali
  is '关联C_USE';
comment on column UNICALL.XQ_RETURNVISIT.appoint_date
  is '预约外拨日';
comment on column UNICALL.XQ_RETURNVISIT.call_date
  is '回访拨打日期';
comment on column UNICALL.XQ_RETURNVISIT.returnvist_sta
  is '关联续期字典表';
comment on column UNICALL.XQ_RETURNVISIT.caller_no
  is '主叫号码';
comment on column UNICALL.XQ_RETURNVISIT.callee_no
  is '被叫号码';
comment on column UNICALL.XQ_RETURNVISIT.remark
  is '备注';
comment on column UNICALL.XQ_RETURNVISIT.policyno
  is '保单号';
create index UNICALL.IDX_XQ_RETURNVISIT_PERIOD_ID on UNICALL.XQ_RETURNVISIT (PERIOD_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_RETURNVISIT_REMINDER_ID on UNICALL.XQ_RETURNVISIT (REMINDER_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_RETURNVISIT
  add constraint PK_XQ_RETURNVISIT primary key (RETURNVIST_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_RETURNVISIT
  add constraint FK_RETURNVISIT_REF_PERIOD foreign key (PERIOD_ID)
  references UNICALL.XQ_PERIOD (PERIOD_ID);
alter table UNICALL.XQ_RETURNVISIT
  add constraint FK_XQ_RETUR_REFERENCE_XQ_DICT foreign key (RETURNVIST_STA)
  references UNICALL.XQ_DICT (ID);
alter table UNICALL.XQ_RETURNVISIT
  add constraint FK_XQ_RETUR_REFERENCE_XQ_REMIN foreign key (REMINDER_ID)
  references UNICALL.XQ_REMINDER (REMINDER_ID);

prompt
prompt Creating table XQ_RISKCLASS
prompt ===========================
prompt
create table UNICALL.XQ_RISKCLASS
(
  o_classcode VARCHAR2(8) not null,
  classcode   CHAR(8) not null,
  permdays    NUMBER(20) not null,
  riskattr    CHAR(1) not null,
  riskcode    CHAR(8) not null,
  classname   VARCHAR2(120) not null,
  timestr     CHAR(1) not null,
  grpattr     CHAR(1) not null,
  appflag     NUMBER(20),
  apptype     NUMBER(20),
  deldays     NUMBER(20),
  prttype     NUMBER(20),
  clmcode     CHAR(3),
  riskname    VARCHAR2(120),
  end_date    DATE,
  etl_time    DATE not null,
  begtime     NUMBER(11),
  endtime     NUMBER(11),
  src_sys     VARCHAR2(20),
  sno         NUMBER(18) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_RISKCLASS
  is '险种信息';
comment on column UNICALL.XQ_RISKCLASS.o_classcode
  is '6位险种代码';
comment on column UNICALL.XQ_RISKCLASS.classcode
  is '8位险种代码';
comment on column UNICALL.XQ_RISKCLASS.permdays
  is '宽限期天数';
comment on column UNICALL.XQ_RISKCLASS.riskattr
  is '险种类型';
comment on column UNICALL.XQ_RISKCLASS.riskcode
  is '险种代码';
comment on column UNICALL.XQ_RISKCLASS.classname
  is '险种名称（老系统CBS 6位代码对应的CLASSNAME）';
comment on column UNICALL.XQ_RISKCLASS.timestr
  is '长短险标志';
comment on column UNICALL.XQ_RISKCLASS.grpattr
  is '团个险标志';
comment on column UNICALL.XQ_RISKCLASS.appflag
  is '续保标志';
comment on column UNICALL.XQ_RISKCLASS.apptype
  is '续保类型';
comment on column UNICALL.XQ_RISKCLASS.deldays
  is '宽限期延长天数';
comment on column UNICALL.XQ_RISKCLASS.prttype
  is '保单续保打印标准';
comment on column UNICALL.XQ_RISKCLASS.clmcode
  is '保额计算的责任';
comment on column UNICALL.XQ_RISKCLASS.riskname
  is '险种款式名称（老系统CBS 6位代码对应的RISKNAME）';
comment on column UNICALL.XQ_RISKCLASS.end_date
  is '停售日期（目前只有综意险有这个字段）';
comment on column UNICALL.XQ_RISKCLASS.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_RISKCLASS.begtime
  is '开始日期';
comment on column UNICALL.XQ_RISKCLASS.endtime
  is '中止日期';
comment on column UNICALL.XQ_RISKCLASS.src_sys
  is '来源系统';
comment on column UNICALL.XQ_RISKCLASS.sno
  is '物理主键';
create index UNICALL.IDX_XQ_RISKCLASS_BEGINTIME on UNICALL.XQ_RISKCLASS (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_RISKCLASS_CLASSCODE on UNICALL.XQ_RISKCLASS (CLASSCODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_RISKCLASS
  add constraint PK_XQ_RISKCLASS primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_RISKCLASS
  add constraint UK_RISKCLASS_OCLASSCODE unique (O_CLASSCODE)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_RISKCLASS_0710
prompt ================================
prompt
create table UNICALL.XQ_RISKCLASS_0710
(
  o_classcode VARCHAR2(20) not null,
  classcode   CHAR(20) not null,
  permdays    VARCHAR2(20) not null,
  riskattr    CHAR(10) not null,
  riskcode    CHAR(8) not null,
  classname   VARCHAR2(120) not null,
  timestr     CHAR(10) not null,
  grpattr     CHAR(10) not null,
  appflag     VARCHAR2(20),
  apptype     VARCHAR2(20),
  deldays     VARCHAR2(20),
  prttype     VARCHAR2(20),
  clmcode     CHAR(30),
  riskname    VARCHAR2(120),
  end_date    VARCHAR2(30),
  etl_time    VARCHAR2(30),
  begtime     VARCHAR2(11),
  endtime     VARCHAR2(11),
  src_sys     VARCHAR2(20),
  sno         VARCHAR2(18) not null
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_RISKCLASS_0710
  is '险种信息';
comment on column UNICALL.XQ_RISKCLASS_0710.o_classcode
  is '6位险种代码';
comment on column UNICALL.XQ_RISKCLASS_0710.classcode
  is '8位险种代码';
comment on column UNICALL.XQ_RISKCLASS_0710.permdays
  is '宽限期天数';
comment on column UNICALL.XQ_RISKCLASS_0710.riskattr
  is '险种类型';
comment on column UNICALL.XQ_RISKCLASS_0710.riskcode
  is '险种代码';
comment on column UNICALL.XQ_RISKCLASS_0710.classname
  is '险种名称（老系统CBS 6位代码对应的CLASSNAME）';
comment on column UNICALL.XQ_RISKCLASS_0710.timestr
  is '长短险标志';
comment on column UNICALL.XQ_RISKCLASS_0710.grpattr
  is '团个险标志';
comment on column UNICALL.XQ_RISKCLASS_0710.appflag
  is '续保标志';
comment on column UNICALL.XQ_RISKCLASS_0710.apptype
  is '续保类型';
comment on column UNICALL.XQ_RISKCLASS_0710.deldays
  is '宽限期延长天数';
comment on column UNICALL.XQ_RISKCLASS_0710.prttype
  is '保单续保打印标准';
comment on column UNICALL.XQ_RISKCLASS_0710.clmcode
  is '保额计算的责任';
comment on column UNICALL.XQ_RISKCLASS_0710.riskname
  is '险种款式名称（老系统CBS 6位代码对应的RISKNAME）';
comment on column UNICALL.XQ_RISKCLASS_0710.end_date
  is '停售日期（目前只有综意险有这个字段）';
comment on column UNICALL.XQ_RISKCLASS_0710.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_RISKCLASS_0710.begtime
  is '开始日期';
comment on column UNICALL.XQ_RISKCLASS_0710.endtime
  is '中止日期';
comment on column UNICALL.XQ_RISKCLASS_0710.src_sys
  is '来源系统';
comment on column UNICALL.XQ_RISKCLASS_0710.sno
  is '物理主键';
create index UNICALL.IDX_XQ_RISKCLASS_0710 on UNICALL.XQ_RISKCLASS_0710 (CLASSCODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_RISKCLASS_0710
  add constraint PK_XQ_RISKCLASS_0710 primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_RISKCLASS_0710
  add constraint UK_RISKCLASS1_OCLASSCODE unique (O_CLASSCODE)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_RISKCON
prompt =========================
prompt
create table UNICALL.XQ_RISKCON
(
  sno               NUMBER(18) not null,
  xq_app_id         NUMBER(18),
  policyno          VARCHAR2(20),
  appno             VARCHAR2(20),
  aperson_id        NUMBER(18),
  apid              VARCHAR2(40),
  aidtype           NUMBER(10),
  riskcon_id        NUMBER(18),
  saleattr          NUMBER(10),
  begdate           DATE,
  stopdate          DATE,
  polist            NUMBER(10),
  pieces            NUMBER(20,6),
  opdate            DATE,
  renewdate         DATE,
  tmount            NUMBER(16,2),
  person_id         NUMBER(18),
  idtype            NUMBER(10),
  pid               VARCHAR2(40),
  appdate           DATE,
  appf              CHAR(1),
  classcode         CHAR(8),
  renewid           CHAR(1),
  sale_prod_code    VARCHAR2(8),
  npaylen           NUMBER(20,6),
  stdrate           NUMBER(10,2),
  unstdrate         NUMBER(10,2),
  etl_time          DATE,
  typeid            NUMBER(7),
  gcon_id           NUMBER(20),
  gpolicyno         VARCHAR2(20),
  deskpay           CHAR(1),
  reason            VARCHAR2(200),
  currency          CHAR(3),
  oper_id           NUMBER(20),
  operno            VARCHAR2(20),
  empno_id          NUMBER(20),
  empno             VARCHAR2(20),
  csr_id            NUMBER(20),
  csrno             VARCHAR2(20),
  comnum            NUMBER(20),
  job               CHAR(8),
  sharetype         CHAR(2),
  specagr           VARCHAR2(2048),
  discount          NUMBER(20,6),
  iscard            CHAR(1),
  dcdm              CHAR(2),
  prelname          CHAR(3),
  bankflag          CHAR(2),
  payseq            VARCHAR2(2048),
  benparam          NUMBER(20),
  owner_source_id   VARCHAR2(20),
  insured_source_id VARCHAR2(20),
  workno            VARCHAR2(20),
  comb_policy_no    VARCHAR2(20),
  app_age           NUMBER(3),
  begtime           NUMBER(11),
  endtime           NUMBER(11),
  branch            CHAR(14),
  src_sys           VARCHAR2(20),
  sub_agt_no        VARCHAR2(20),
  aidtype_ids       CHAR(2),
  saleattr_ids      CHAR(2),
  polist_ids        CHAR(2),
  idtype_ids        CHAR(2),
  initial_amount    NUMBER(20,6)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_RISKCON
  is '个人保单(按险种代码，明细)';
comment on column UNICALL.XQ_RISKCON.sno
  is '物理主键';
comment on column UNICALL.XQ_RISKCON.xq_app_id
  is '关联XQ_APP';
comment on column UNICALL.XQ_RISKCON.policyno
  is '保单号';
comment on column UNICALL.XQ_RISKCON.appno
  is '投保单号';
comment on column UNICALL.XQ_RISKCON.aperson_id
  is '投保人信息IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON.apid
  is '投保人身份证件号/团体客户号';
comment on column UNICALL.XQ_RISKCON.aidtype
  is '投保人证件类型';
comment on column UNICALL.XQ_RISKCON.riskcon_id
  is '业务主键';
comment on column UNICALL.XQ_RISKCON.saleattr
  is '销售渠道';
comment on column UNICALL.XQ_RISKCON.begdate
  is '责任起始日期';
comment on column UNICALL.XQ_RISKCON.stopdate
  is '责任终止日期';
comment on column UNICALL.XQ_RISKCON.polist
  is '投保单/保单状态
1～未生效
2～有效
3～失效（中止）
4～永久失效（终止）
5～移出
6～满期
7～生存退保
8～死亡退保
9～犹豫退保
A～给付期
B～借款失效
C～通融退保
D～理赔中
E～变更中
F～责任终止
';
comment on column UNICALL.XQ_RISKCON.pieces
  is '份数';
comment on column UNICALL.XQ_RISKCON.opdate
  is '生效日期';
comment on column UNICALL.XQ_RISKCON.renewdate
  is '续保日期';
comment on column UNICALL.XQ_RISKCON.tmount
  is '总保费';
comment on column UNICALL.XQ_RISKCON.person_id
  is '被保险人IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON.idtype
  is '被保险人证件类型';
comment on column UNICALL.XQ_RISKCON.pid
  is '被保险人证件号';
comment on column UNICALL.XQ_RISKCON.appdate
  is '投保日期';
comment on column UNICALL.XQ_RISKCON.appf
  is '主附加险标志';
comment on column UNICALL.XQ_RISKCON.classcode
  is '险种';
comment on column UNICALL.XQ_RISKCON.renewid
  is '续保标志';
comment on column UNICALL.XQ_RISKCON.sale_prod_code
  is '销售产品代码（例如福宝宝产品代码）';
comment on column UNICALL.XQ_RISKCON.npaylen
  is '每份缴费标准';
comment on column UNICALL.XQ_RISKCON.stdrate
  is '每份标准加费额/职业加费金额';
comment on column UNICALL.XQ_RISKCON.unstdrate
  is '每份非标准加费额/综合加费金额';
comment on column UNICALL.XQ_RISKCON.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_RISKCON.typeid
  is 'IAA数据类型';
comment on column UNICALL.XQ_RISKCON.gcon_id
  is '所属团体保单IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON.gpolicyno
  is '团单号';
comment on column UNICALL.XQ_RISKCON.deskpay
  is '垫缴条款选择（保单是否可以垫缴）';
comment on column UNICALL.XQ_RISKCON.reason
  is '投保单/保单状态原因';
comment on column UNICALL.XQ_RISKCON.currency
  is '币种';
comment on column UNICALL.XQ_RISKCON.oper_id
  is '操作员IAA相关业务主键';
comment on column UNICALL.XQ_RISKCON.operno
  is '操作员工号';
comment on column UNICALL.XQ_RISKCON.empno_id
  is '业务员信息IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON.empno
  is '业务员代码';
comment on column UNICALL.XQ_RISKCON.csr_id
  is '收展员信息';
comment on column UNICALL.XQ_RISKCON.csrno
  is '收展员代码';
comment on column UNICALL.XQ_RISKCON.comnum
  is '共同被保险人人数';
comment on column UNICALL.XQ_RISKCON.job
  is '被保险人职业类型';
comment on column UNICALL.XQ_RISKCON.sharetype
  is '红利分配方式';
comment on column UNICALL.XQ_RISKCON.specagr
  is '特别约定';
comment on column UNICALL.XQ_RISKCON.discount
  is '豁免后缴费比率 0（全免）-1（全额）';
comment on column UNICALL.XQ_RISKCON.iscard
  is '卡式业务标志';
comment on column UNICALL.XQ_RISKCON.dcdm
  is '保单档次';
comment on column UNICALL.XQ_RISKCON.prelname
  is '投被保人关系';
comment on column UNICALL.XQ_RISKCON.bankflag
  is '银保通标志';
comment on column UNICALL.XQ_RISKCON.payseq
  is '受益人';
comment on column UNICALL.XQ_RISKCON.benparam
  is '受益人条件数';
comment on column UNICALL.XQ_RISKCON.owner_source_id
  is 'FF中投保人内部ID，对应PERSON.SOURCE_PERSON_ID';
comment on column UNICALL.XQ_RISKCON.insured_source_id
  is 'FF中被保人内部ID，对应PERSON.SOURCE_PERSON_ID';
comment on column UNICALL.XQ_RISKCON.workno
  is '团体保单中个人的单位工号';
comment on column UNICALL.XQ_RISKCON.comb_policy_no
  is '多主险组合保单号';
comment on column UNICALL.XQ_RISKCON.app_age
  is '投保年龄';
comment on column UNICALL.XQ_RISKCON.begtime
  is '开始日期';
comment on column UNICALL.XQ_RISKCON.endtime
  is '中止日期';
comment on column UNICALL.XQ_RISKCON.branch
  is '分公司代码';
comment on column UNICALL.XQ_RISKCON.src_sys
  is '来源系统';
comment on column UNICALL.XQ_RISKCON.sub_agt_no
  is '二级业务员代码（目前存放电销坐席工号）';
comment on column UNICALL.XQ_RISKCON.aidtype_ids
  is '投保人证件类型 IDS证件类型
00:团体客户
01:身份证
02:户口簿
03:护照
04:军官证
05:士兵证
06:港澳居民来往内地通行证
07:台湾同胞来往内地通行证
08:临时身份证
09:外国人居留证
10:警察证
11:文职干部证
12:驾驶执照
13:虚拟身份证
14:出生证书
99:其他证书';
comment on column UNICALL.XQ_RISKCON.saleattr_ids
  is '61:总公司座席 62:分公司座席 63:总公司外包 64';
comment on column UNICALL.XQ_RISKCON.polist_ids
  is '
1～未生效
2～有效
3～失效（中止）
4～永久失效（终止）
5～移出
6～满期
7～生存退保
8～死亡退保
9～犹豫退保
A～给付期
B～借款失效
C～通融退保
D～理赔中
E～变更中
F～责任终止
';
comment on column UNICALL.XQ_RISKCON.idtype_ids
  is '被保人证件类型 IDS证件类型
00:团体客户
01:身份证
02:户口簿
03:护照
04:军官证
05:士兵证
06:港澳居民来往内地通行证
07:台湾同胞来往内地通行证
08:临时身份证
09:外国人居留证
10:警察证
11:文职干部证
12:驾驶执照
13:虚拟身份证
14:出生证书
99:其他证书';
comment on column UNICALL.XQ_RISKCON.initial_amount
  is '承保时单期保费';
create index UNICALL.IDX_RISKCON_DETAIL_POLICYNO on UNICALL.XQ_RISKCON (POLICYNO DESC)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_RISKCON_APID on UNICALL.XQ_RISKCON (APID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_RISKCON_APP_ID on UNICALL.XQ_RISKCON (XQ_APP_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_RISKCON_EMPNO on UNICALL.XQ_RISKCON (EMPNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_RISKCON_POLICYNO on UNICALL.XQ_RISKCON (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.INDEX_RESKCON_INSUR_SOUR_ID on UNICALL.XQ_RISKCON (INSURED_SOURCE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.INDEX_RESKCON_OWNER_SOUR_ID on UNICALL.XQ_RISKCON (OWNER_SOURCE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_RISKCON
  add constraint PK_XQ_RISKCON primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_RISKCON
  add constraint UK_XQ_RISKCON_PNO_CLACODE unique (POLICYNO, CLASSCODE)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_RISKCON
  add constraint FK_XQ_RISKC_REFERENCE_XQ_APP foreign key (XQ_APP_ID)
  references UNICALL.XQ_APP (XQ_APP_ID)
  disable;

prompt
prompt Creating table XQ_RISKCON_0710
prompt ==============================
prompt
create table UNICALL.XQ_RISKCON_0710
(
  sno               NUMBER(18) not null,
  xq_app_id         NUMBER(18),
  policyno          VARCHAR2(20),
  appno             VARCHAR2(20),
  aperson_id        NUMBER(18),
  apid              VARCHAR2(40),
  aidtype           NUMBER(10),
  riskcon_id        NUMBER(18),
  saleattr          NUMBER(10),
  begdate           DATE,
  stopdate          DATE,
  polist            NUMBER(10),
  pieces            NUMBER(20,6),
  opdate            DATE,
  renewdate         DATE,
  tmount            NUMBER(16,2),
  person_id         NUMBER(18),
  idtype            NUMBER(10),
  pid               VARCHAR2(40),
  appdate           DATE,
  appf              CHAR(2),
  classcode         CHAR(8),
  renewid           VARCHAR2(20),
  sale_prod_code    VARCHAR2(8),
  npaylen           NUMBER(20,6),
  stdrate           NUMBER(10,2),
  unstdrate         NUMBER(10,2),
  etl_time          VARCHAR2(30),
  typeid            NUMBER(20),
  gcon_id           NUMBER(20),
  gpolicyno         VARCHAR2(20),
  deskpay           CHAR(2),
  reason            VARCHAR2(200),
  currency          CHAR(3),
  oper_id           NUMBER(20),
  operno            VARCHAR2(20),
  empno_id          VARCHAR2(20),
  empno             VARCHAR2(20),
  csr_id            NUMBER(20),
  csrno             VARCHAR2(20),
  comnum            NUMBER(20),
  job               CHAR(8),
  sharetype         CHAR(10),
  specagr           VARCHAR2(2048),
  discount          NUMBER(20,6),
  iscard            VARCHAR2(20),
  dcdm              VARCHAR2(20),
  prelname          VARCHAR2(1000),
  bankflag          CHAR(10),
  payseq            VARCHAR2(2048),
  benparam          NUMBER(20),
  owner_source_id   VARCHAR2(20),
  insured_source_id VARCHAR2(20),
  workno            VARCHAR2(200),
  comb_policy_no    VARCHAR2(20),
  app_age           CHAR(10),
  begtime           CHAR(11),
  endtime           CHAR(11),
  branch            CHAR(14),
  src_sys           VARCHAR2(20),
  sub_agt_no        VARCHAR2(20),
  aidtype_ids       VARCHAR2(20),
  saleattr_ids      VARCHAR2(20),
  polist_ids        VARCHAR2(20),
  idtype_ids        VARCHAR2(20),
  initial_amount    NUMBER(20,6)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 16K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_RISKCON_0710
  is '个人保单(按险种代码，明细)';
comment on column UNICALL.XQ_RISKCON_0710.sno
  is '物理主键';
comment on column UNICALL.XQ_RISKCON_0710.xq_app_id
  is '关联XQ_APP';
comment on column UNICALL.XQ_RISKCON_0710.policyno
  is '保单号';
comment on column UNICALL.XQ_RISKCON_0710.appno
  is '投保单号';
comment on column UNICALL.XQ_RISKCON_0710.aperson_id
  is '投保人信息IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON_0710.apid
  is '投保人身份证件号/团体客户号';
comment on column UNICALL.XQ_RISKCON_0710.aidtype
  is '投保人证件类型';
comment on column UNICALL.XQ_RISKCON_0710.riskcon_id
  is '业务主键';
comment on column UNICALL.XQ_RISKCON_0710.saleattr
  is '销售渠道';
comment on column UNICALL.XQ_RISKCON_0710.begdate
  is '责任起始日期';
comment on column UNICALL.XQ_RISKCON_0710.stopdate
  is '责任终止日期';
comment on column UNICALL.XQ_RISKCON_0710.polist
  is '投保单/保单状态
1～未生效
2～有效
3～失效（中止）
4～永久失效（终止）
5～移出
6～满期
7～生存退保
8～死亡退保
9～犹豫退保
A～给付期
B～借款失效
C～通融退保
D～理赔中
E～变更中
F～责任终止
';
comment on column UNICALL.XQ_RISKCON_0710.pieces
  is '份数';
comment on column UNICALL.XQ_RISKCON_0710.opdate
  is '生效日期';
comment on column UNICALL.XQ_RISKCON_0710.renewdate
  is '续保日期';
comment on column UNICALL.XQ_RISKCON_0710.tmount
  is '总保费';
comment on column UNICALL.XQ_RISKCON_0710.person_id
  is '被保险人IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON_0710.idtype
  is '被保险人证件类型';
comment on column UNICALL.XQ_RISKCON_0710.pid
  is '被保险人证件号';
comment on column UNICALL.XQ_RISKCON_0710.appdate
  is '投保日期';
comment on column UNICALL.XQ_RISKCON_0710.appf
  is '主附加险标志';
comment on column UNICALL.XQ_RISKCON_0710.classcode
  is '险种';
comment on column UNICALL.XQ_RISKCON_0710.renewid
  is '续保标志';
comment on column UNICALL.XQ_RISKCON_0710.sale_prod_code
  is '销售产品代码（例如福宝宝产品代码）';
comment on column UNICALL.XQ_RISKCON_0710.npaylen
  is '每份缴费标准';
comment on column UNICALL.XQ_RISKCON_0710.stdrate
  is '每份标准加费额/职业加费金额';
comment on column UNICALL.XQ_RISKCON_0710.unstdrate
  is '每份非标准加费额/综合加费金额';
comment on column UNICALL.XQ_RISKCON_0710.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_RISKCON_0710.typeid
  is 'IAA数据类型';
comment on column UNICALL.XQ_RISKCON_0710.gcon_id
  is '所属团体保单IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON_0710.gpolicyno
  is '团单号';
comment on column UNICALL.XQ_RISKCON_0710.deskpay
  is '垫缴条款选择（保单是否可以垫缴）';
comment on column UNICALL.XQ_RISKCON_0710.reason
  is '投保单/保单状态原因';
comment on column UNICALL.XQ_RISKCON_0710.currency
  is '币种';
comment on column UNICALL.XQ_RISKCON_0710.oper_id
  is '操作员IAA相关业务主键';
comment on column UNICALL.XQ_RISKCON_0710.operno
  is '操作员工号';
comment on column UNICALL.XQ_RISKCON_0710.empno_id
  is '业务员信息IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON_0710.empno
  is '业务员代码';
comment on column UNICALL.XQ_RISKCON_0710.csr_id
  is '收展员信息';
comment on column UNICALL.XQ_RISKCON_0710.csrno
  is '收展员代码';
comment on column UNICALL.XQ_RISKCON_0710.comnum
  is '共同被保险人人数';
comment on column UNICALL.XQ_RISKCON_0710.job
  is '被保险人职业类型';
comment on column UNICALL.XQ_RISKCON_0710.sharetype
  is '红利分配方式';
comment on column UNICALL.XQ_RISKCON_0710.specagr
  is '特别约定';
comment on column UNICALL.XQ_RISKCON_0710.discount
  is '豁免后缴费比率 0（全免）-1（全额）';
comment on column UNICALL.XQ_RISKCON_0710.iscard
  is '卡式业务标志';
comment on column UNICALL.XQ_RISKCON_0710.dcdm
  is '保单档次';
comment on column UNICALL.XQ_RISKCON_0710.prelname
  is '投被保人关系';
comment on column UNICALL.XQ_RISKCON_0710.bankflag
  is '银保通标志';
comment on column UNICALL.XQ_RISKCON_0710.payseq
  is '受益人';
comment on column UNICALL.XQ_RISKCON_0710.benparam
  is '受益人条件数';
comment on column UNICALL.XQ_RISKCON_0710.owner_source_id
  is 'FF中投保人内部ID，对应PERSON.SOURCE_PERSON_ID';
comment on column UNICALL.XQ_RISKCON_0710.insured_source_id
  is 'FF中被保人内部ID，对应PERSON.SOURCE_PERSON_ID';
comment on column UNICALL.XQ_RISKCON_0710.workno
  is '团体保单中个人的单位工号';
comment on column UNICALL.XQ_RISKCON_0710.comb_policy_no
  is '多主险组合保单号';
comment on column UNICALL.XQ_RISKCON_0710.app_age
  is '投保年龄';
comment on column UNICALL.XQ_RISKCON_0710.begtime
  is '开始日期';
comment on column UNICALL.XQ_RISKCON_0710.endtime
  is '中止日期';
comment on column UNICALL.XQ_RISKCON_0710.branch
  is '分公司代码';
comment on column UNICALL.XQ_RISKCON_0710.src_sys
  is '来源系统';
comment on column UNICALL.XQ_RISKCON_0710.sub_agt_no
  is '二级业务员代码（目前存放电销坐席工号）';
comment on column UNICALL.XQ_RISKCON_0710.aidtype_ids
  is '投保人证件类型 IDS证件类型
00:团体客户
01:身份证
02:户口簿
03:护照
04:军官证
05:士兵证
06:港澳居民来往内地通行证
07:台湾同胞来往内地通行证
08:临时身份证
09:外国人居留证
10:警察证
11:文职干部证
12:驾驶执照
13:虚拟身份证
14:出生证书
99:其他证书';
comment on column UNICALL.XQ_RISKCON_0710.saleattr_ids
  is '61:总公司座席 62:分公司座席 63:总公司外包 64';
comment on column UNICALL.XQ_RISKCON_0710.polist_ids
  is '
1～未生效
2～有效
3～失效（中止）
4～永久失效（终止）
5～移出
6～满期
7～生存退保
8～死亡退保
9～犹豫退保
A～给付期
B～借款失效
C～通融退保
D～理赔中
E～变更中
F～责任终止
';
comment on column UNICALL.XQ_RISKCON_0710.idtype_ids
  is '被保人证件类型 IDS证件类型
00:团体客户
01:身份证
02:户口簿
03:护照
04:军官证
05:士兵证
06:港澳居民来往内地通行证
07:台湾同胞来往内地通行证
08:临时身份证
09:外国人居留证
10:警察证
11:文职干部证
12:驾驶执照
13:虚拟身份证
14:出生证书
99:其他证书';
comment on column UNICALL.XQ_RISKCON_0710.initial_amount
  is '承保时单期保费';
create index UNICALL.IDX_XQ_RISKCON_0710_APID on UNICALL.XQ_RISKCON_0710 (APID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_RISKCON_0710_APP_ID on UNICALL.XQ_RISKCON_0710 (XQ_APP_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_RISKCON_0710_EMPNO on UNICALL.XQ_RISKCON_0710 (EMPNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_RISKCON_0710_POLICYNO on UNICALL.XQ_RISKCON_0710 (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.INDEX_RESKCON0710_ on UNICALL.XQ_RISKCON_0710 (INSURED_SOURCE_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_RISKCON_0710
  add constraint PK_XQ_RISKCON_0710 primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_RISKCON_0710
  add constraint UK_XQ_RISKCON_0710_PNO_CLACODE unique (POLICYNO, CLASSCODE)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_RISKCON_FULL
prompt ==============================
prompt
create table UNICALL.XQ_RISKCON_FULL
(
  sno               NUMBER(18) not null,
  xq_app_id         NUMBER(18),
  policyno          VARCHAR2(20),
  appno             VARCHAR2(20),
  aperson_id        NUMBER(18),
  apid              VARCHAR2(40),
  aidtype           NUMBER(10),
  riskcon_id        NUMBER(18),
  saleattr          NUMBER(10),
  begdate           DATE,
  stopdate          DATE,
  polist            NUMBER(10),
  pieces            NUMBER(20,6),
  opdate            DATE,
  renewdate         DATE,
  tmount            NUMBER(16,2),
  person_id         NUMBER(18),
  idtype            NUMBER(10),
  pid               VARCHAR2(40),
  appdate           DATE,
  appf              CHAR(1),
  classcode         CHAR(8),
  renewid           CHAR(1),
  sale_prod_code    VARCHAR2(8),
  npaylen           NUMBER(20,6),
  stdrate           NUMBER(10,2),
  unstdrate         NUMBER(10,2),
  etl_time          DATE,
  typeid            NUMBER(7),
  gcon_id           NUMBER(20),
  gpolicyno         VARCHAR2(20),
  deskpay           CHAR(1),
  reason            VARCHAR2(200),
  currency          CHAR(3),
  oper_id           NUMBER(20),
  operno            VARCHAR2(20),
  empno_id          NUMBER(20),
  empno             VARCHAR2(20),
  csr_id            NUMBER(20),
  csrno             VARCHAR2(20),
  comnum            NUMBER(20),
  job               CHAR(8),
  sharetype         CHAR(2),
  specagr           VARCHAR2(2048),
  discount          NUMBER(20,6),
  iscard            CHAR(1),
  dcdm              CHAR(2),
  prelname          CHAR(3),
  bankflag          CHAR(2),
  payseq            VARCHAR2(2048),
  benparam          NUMBER(20),
  owner_source_id   VARCHAR2(20),
  insured_source_id VARCHAR2(20),
  workno            VARCHAR2(20),
  comb_policy_no    VARCHAR2(20),
  app_age           NUMBER(3),
  begtime           NUMBER(11),
  endtime           NUMBER(11),
  branch            CHAR(14),
  src_sys           VARCHAR2(20),
  sub_agt_no        VARCHAR2(20),
  aidtype_ids       CHAR(2),
  saleattr_ids      CHAR(2),
  polist_ids        CHAR(2),
  idtype_ids        CHAR(2),
  initial_amount    NUMBER(20,6)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_RISKCON_FULL
  is '个人保单(按险种代码，明细)';
comment on column UNICALL.XQ_RISKCON_FULL.sno
  is '物理主键';
comment on column UNICALL.XQ_RISKCON_FULL.xq_app_id
  is '关联XQ_APP';
comment on column UNICALL.XQ_RISKCON_FULL.policyno
  is '保单号';
comment on column UNICALL.XQ_RISKCON_FULL.appno
  is '投保单号';
comment on column UNICALL.XQ_RISKCON_FULL.aperson_id
  is '投保人信息IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON_FULL.apid
  is '投保人身份证件号/团体客户号';
comment on column UNICALL.XQ_RISKCON_FULL.aidtype
  is '投保人证件类型';
comment on column UNICALL.XQ_RISKCON_FULL.riskcon_id
  is '业务主键';
comment on column UNICALL.XQ_RISKCON_FULL.saleattr
  is '销售渠道';
comment on column UNICALL.XQ_RISKCON_FULL.begdate
  is '责任起始日期';
comment on column UNICALL.XQ_RISKCON_FULL.stopdate
  is '责任终止日期';
comment on column UNICALL.XQ_RISKCON_FULL.polist
  is '投保单/保单状态
1～未生效
2～有效
3～失效（中止）
4～永久失效（终止）
5～移出
6～满期
7～生存退保
8～死亡退保
9～犹豫退保
A～给付期
B～借款失效
C～通融退保
D～理赔中
E～变更中
F～责任终止
';
comment on column UNICALL.XQ_RISKCON_FULL.pieces
  is '份数';
comment on column UNICALL.XQ_RISKCON_FULL.opdate
  is '生效日期';
comment on column UNICALL.XQ_RISKCON_FULL.renewdate
  is '续保日期';
comment on column UNICALL.XQ_RISKCON_FULL.tmount
  is '总保费';
comment on column UNICALL.XQ_RISKCON_FULL.person_id
  is '被保险人IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON_FULL.idtype
  is '被保险人证件类型';
comment on column UNICALL.XQ_RISKCON_FULL.pid
  is '被保险人证件号';
comment on column UNICALL.XQ_RISKCON_FULL.appdate
  is '投保日期';
comment on column UNICALL.XQ_RISKCON_FULL.appf
  is '主附加险标志';
comment on column UNICALL.XQ_RISKCON_FULL.classcode
  is '险种';
comment on column UNICALL.XQ_RISKCON_FULL.renewid
  is '续保标志';
comment on column UNICALL.XQ_RISKCON_FULL.sale_prod_code
  is '销售产品代码（例如福宝宝产品代码）';
comment on column UNICALL.XQ_RISKCON_FULL.npaylen
  is '每份缴费标准';
comment on column UNICALL.XQ_RISKCON_FULL.stdrate
  is '每份标准加费额/职业加费金额';
comment on column UNICALL.XQ_RISKCON_FULL.unstdrate
  is '每份非标准加费额/综合加费金额';
comment on column UNICALL.XQ_RISKCON_FULL.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_RISKCON_FULL.typeid
  is 'IAA数据类型';
comment on column UNICALL.XQ_RISKCON_FULL.gcon_id
  is '所属团体保单IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON_FULL.gpolicyno
  is '团单号';
comment on column UNICALL.XQ_RISKCON_FULL.deskpay
  is '垫缴条款选择（保单是否可以垫缴）';
comment on column UNICALL.XQ_RISKCON_FULL.reason
  is '投保单/保单状态原因';
comment on column UNICALL.XQ_RISKCON_FULL.currency
  is '币种';
comment on column UNICALL.XQ_RISKCON_FULL.oper_id
  is '操作员IAA相关业务主键';
comment on column UNICALL.XQ_RISKCON_FULL.operno
  is '操作员工号';
comment on column UNICALL.XQ_RISKCON_FULL.empno_id
  is '业务员信息IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON_FULL.empno
  is '业务员代码';
comment on column UNICALL.XQ_RISKCON_FULL.csr_id
  is '收展员信息';
comment on column UNICALL.XQ_RISKCON_FULL.csrno
  is '收展员代码';
comment on column UNICALL.XQ_RISKCON_FULL.comnum
  is '共同被保险人人数';
comment on column UNICALL.XQ_RISKCON_FULL.job
  is '被保险人职业类型';
comment on column UNICALL.XQ_RISKCON_FULL.sharetype
  is '红利分配方式';
comment on column UNICALL.XQ_RISKCON_FULL.specagr
  is '特别约定';
comment on column UNICALL.XQ_RISKCON_FULL.discount
  is '豁免后缴费比率 0（全免）-1（全额）';
comment on column UNICALL.XQ_RISKCON_FULL.iscard
  is '卡式业务标志';
comment on column UNICALL.XQ_RISKCON_FULL.dcdm
  is '保单档次';
comment on column UNICALL.XQ_RISKCON_FULL.prelname
  is '投被保人关系';
comment on column UNICALL.XQ_RISKCON_FULL.bankflag
  is '银保通标志';
comment on column UNICALL.XQ_RISKCON_FULL.payseq
  is '受益人';
comment on column UNICALL.XQ_RISKCON_FULL.benparam
  is '受益人条件数';
comment on column UNICALL.XQ_RISKCON_FULL.owner_source_id
  is 'FF中投保人内部ID，对应PERSON.SOURCE_PERSON_ID';
comment on column UNICALL.XQ_RISKCON_FULL.insured_source_id
  is 'FF中被保人内部ID，对应PERSON.SOURCE_PERSON_ID';
comment on column UNICALL.XQ_RISKCON_FULL.workno
  is '团体保单中个人的单位工号';
comment on column UNICALL.XQ_RISKCON_FULL.comb_policy_no
  is '多主险组合保单号';
comment on column UNICALL.XQ_RISKCON_FULL.app_age
  is '投保年龄';
comment on column UNICALL.XQ_RISKCON_FULL.begtime
  is '开始日期';
comment on column UNICALL.XQ_RISKCON_FULL.endtime
  is '中止日期';
comment on column UNICALL.XQ_RISKCON_FULL.branch
  is '分公司代码';
comment on column UNICALL.XQ_RISKCON_FULL.src_sys
  is '来源系统';
comment on column UNICALL.XQ_RISKCON_FULL.sub_agt_no
  is '二级业务员代码（目前存放电销坐席工号）';
comment on column UNICALL.XQ_RISKCON_FULL.aidtype_ids
  is '投保人证件类型 IDS证件类型
00:团体客户
01:身份证
02:户口簿
03:护照
04:军官证
05:士兵证
06:港澳居民来往内地通行证
07:台湾同胞来往内地通行证
08:临时身份证
09:外国人居留证
10:警察证
11:文职干部证
12:驾驶执照
13:虚拟身份证
14:出生证书
99:其他证书';
comment on column UNICALL.XQ_RISKCON_FULL.saleattr_ids
  is '61:总公司座席 62:分公司座席 63:总公司外包 64';
comment on column UNICALL.XQ_RISKCON_FULL.polist_ids
  is '
1～未生效
2～有效
3～失效（中止）
4～永久失效（终止）
5～移出
6～满期
7～生存退保
8～死亡退保
9～犹豫退保
A～给付期
B～借款失效
C～通融退保
D～理赔中
E～变更中
F～责任终止
';
comment on column UNICALL.XQ_RISKCON_FULL.idtype_ids
  is '被保人证件类型 IDS证件类型
00:团体客户
01:身份证
02:户口簿
03:护照
04:军官证
05:士兵证
06:港澳居民来往内地通行证
07:台湾同胞来往内地通行证
08:临时身份证
09:外国人居留证
10:警察证
11:文职干部证
12:驾驶执照
13:虚拟身份证
14:出生证书
99:其他证书';
comment on column UNICALL.XQ_RISKCON_FULL.initial_amount
  is '承保时单期保费';
create index UNICALL.IDX_XQ_RISKCON_FULL_POLICYNO on UNICALL.XQ_RISKCON_FULL (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_RISKCON_FULL
  add constraint PK_XQ_RISKCON_FULL primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_RISKCON_TEMP
prompt ==============================
prompt
create table UNICALL.XQ_RISKCON_TEMP
(
  sno                NUMBER(20),
  typeid             NUMBER(7),
  aperson_id         NUMBER(20),
  apid               VARCHAR2(40),
  aidtype            CHAR(2),
  xq_riskcon_temp_id NUMBER(20),
  gcon_id            NUMBER(20),
  gpolicyno          VARCHAR2(20),
  deskpay            CHAR(1),
  saleattr           CHAR(2),
  renewid            CHAR(1),
  renewdate          DATE,
  begdate            DATE,
  stopdate           DATE,
  polist             CHAR(1),
  reason             VARCHAR2(200),
  policyno           VARCHAR2(20),
  appno              VARCHAR2(20),
  currency           CHAR(3),
  pieces             NUMBER(20,6),
  appf               CHAR(1),
  opdate             DATE,
  tmount             NUMBER(16,2),
  oper_id            NUMBER(20),
  operno             VARCHAR2(20),
  empno_id           NUMBER(20),
  empno              VARCHAR2(20),
  csr_id             NUMBER(20),
  csrno              VARCHAR2(20),
  classcode          CHAR(8),
  appdate            DATE,
  comnum             NUMBER(20),
  person_id          NUMBER(20),
  idtype             CHAR(2),
  pid                VARCHAR2(40),
  job                CHAR(8),
  sharetype          CHAR(2),
  specagr            VARCHAR2(2048),
  discount           NUMBER(20,6),
  iscard             CHAR(1),
  npaylen            NUMBER(20,6),
  stdrate            NUMBER(10,2),
  unstdrate          NUMBER(10,2),
  dcdm               CHAR(2),
  prelname           CHAR(3),
  bankflag           CHAR(2),
  payseq             VARCHAR2(2048),
  benparam           NUMBER(20),
  sale_prod_code     VARCHAR2(8),
  owner_source_id    VARCHAR2(20),
  insured_source_id  VARCHAR2(20),
  workno             VARCHAR2(20),
  comb_policy_no     VARCHAR2(20),
  app_age            NUMBER(3),
  begtime            NUMBER(11),
  endtime            NUMBER(11),
  branch             CHAR(14),
  etl_time           DATE,
  src_sys            VARCHAR2(20),
  sub_agt_no         VARCHAR2(20),
  o_classcode        VARCHAR2(8),
  cross_sale_ind     VARCHAR2(1),
  prem_rate_level    VARCHAR2(2),
  ill_score          NUMBER(10,2),
  group_no           VARCHAR2(2)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.XQ_RISKCON_TEMP.sno
  is 'IAA物理主键';
comment on column UNICALL.XQ_RISKCON_TEMP.typeid
  is 'IAA数据类型';
comment on column UNICALL.XQ_RISKCON_TEMP.aperson_id
  is '投保人信息IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON_TEMP.apid
  is '投保人身份证件号/团体客户号';
comment on column UNICALL.XQ_RISKCON_TEMP.aidtype
  is '投保人证件类型';
comment on column UNICALL.XQ_RISKCON_TEMP.xq_riskcon_temp_id
  is 'IAA锚点，Agreement';
comment on column UNICALL.XQ_RISKCON_TEMP.gcon_id
  is '所属团体保单IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON_TEMP.gpolicyno
  is '团单号';
comment on column UNICALL.XQ_RISKCON_TEMP.deskpay
  is '垫缴条款选择（保单是否可以垫缴）';
comment on column UNICALL.XQ_RISKCON_TEMP.saleattr
  is '销售渠道';
comment on column UNICALL.XQ_RISKCON_TEMP.renewid
  is '续保标志';
comment on column UNICALL.XQ_RISKCON_TEMP.renewdate
  is '续保日期';
comment on column UNICALL.XQ_RISKCON_TEMP.begdate
  is '责任起始日期';
comment on column UNICALL.XQ_RISKCON_TEMP.stopdate
  is '责任终止日期';
comment on column UNICALL.XQ_RISKCON_TEMP.polist
  is '投保单/保单状态';
comment on column UNICALL.XQ_RISKCON_TEMP.reason
  is '投保单/保单状态原因';
comment on column UNICALL.XQ_RISKCON_TEMP.policyno
  is '保单号';
comment on column UNICALL.XQ_RISKCON_TEMP.appno
  is '投保单号';
comment on column UNICALL.XQ_RISKCON_TEMP.currency
  is '币种';
comment on column UNICALL.XQ_RISKCON_TEMP.pieces
  is '份数';
comment on column UNICALL.XQ_RISKCON_TEMP.appf
  is '主附加险标志';
comment on column UNICALL.XQ_RISKCON_TEMP.opdate
  is '生效日期';
comment on column UNICALL.XQ_RISKCON_TEMP.tmount
  is '总保费';
comment on column UNICALL.XQ_RISKCON_TEMP.oper_id
  is '操作员IAA相关业务主键';
comment on column UNICALL.XQ_RISKCON_TEMP.operno
  is '操作员工号';
comment on column UNICALL.XQ_RISKCON_TEMP.empno_id
  is '业务员信息IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON_TEMP.empno
  is '业务员代码';
comment on column UNICALL.XQ_RISKCON_TEMP.csr_id
  is '收展员信息IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON_TEMP.csrno
  is '收展员代码';
comment on column UNICALL.XQ_RISKCON_TEMP.classcode
  is '险种';
comment on column UNICALL.XQ_RISKCON_TEMP.appdate
  is '投保日期';
comment on column UNICALL.XQ_RISKCON_TEMP.comnum
  is '共同被保险人人数';
comment on column UNICALL.XQ_RISKCON_TEMP.person_id
  is '被保险人IAA业务相关主键';
comment on column UNICALL.XQ_RISKCON_TEMP.idtype
  is '被保险人证件类型';
comment on column UNICALL.XQ_RISKCON_TEMP.pid
  is '被保险人证件号';
comment on column UNICALL.XQ_RISKCON_TEMP.job
  is '被保险人职业类型';
comment on column UNICALL.XQ_RISKCON_TEMP.sharetype
  is '红利分配方式';
comment on column UNICALL.XQ_RISKCON_TEMP.specagr
  is '特别约定';
comment on column UNICALL.XQ_RISKCON_TEMP.discount
  is '豁免后缴费比率 0（全免）-1（全额）';
comment on column UNICALL.XQ_RISKCON_TEMP.iscard
  is '卡式业务标志';
comment on column UNICALL.XQ_RISKCON_TEMP.npaylen
  is '每份缴费标准';
comment on column UNICALL.XQ_RISKCON_TEMP.stdrate
  is '每份标准加费额/职业加费金额';
comment on column UNICALL.XQ_RISKCON_TEMP.unstdrate
  is '每份非标准加费额/综合加费金额';
comment on column UNICALL.XQ_RISKCON_TEMP.dcdm
  is '保单档次';
comment on column UNICALL.XQ_RISKCON_TEMP.prelname
  is '投被保人关系';
comment on column UNICALL.XQ_RISKCON_TEMP.bankflag
  is '银保通标志';
comment on column UNICALL.XQ_RISKCON_TEMP.payseq
  is '受益人';
comment on column UNICALL.XQ_RISKCON_TEMP.benparam
  is '受益人条件数';
comment on column UNICALL.XQ_RISKCON_TEMP.sale_prod_code
  is '销售产品代码（例如福宝宝产品代码）';
comment on column UNICALL.XQ_RISKCON_TEMP.owner_source_id
  is 'FF中投保人内部ID，对应PERSON.SOURCE_PERSON_ID';
comment on column UNICALL.XQ_RISKCON_TEMP.insured_source_id
  is 'FF中被保人内部ID，对应PERSON.SOURCE_PERSON_ID';
comment on column UNICALL.XQ_RISKCON_TEMP.workno
  is '团体保单中个人的单位工号';
comment on column UNICALL.XQ_RISKCON_TEMP.comb_policy_no
  is '多主险组合保单号';
comment on column UNICALL.XQ_RISKCON_TEMP.app_age
  is '投保年龄';
comment on column UNICALL.XQ_RISKCON_TEMP.begtime
  is '开始日期';
comment on column UNICALL.XQ_RISKCON_TEMP.endtime
  is '中止日期';
comment on column UNICALL.XQ_RISKCON_TEMP.branch
  is '分公司代码';
comment on column UNICALL.XQ_RISKCON_TEMP.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_RISKCON_TEMP.src_sys
  is '来源系统';
comment on column UNICALL.XQ_RISKCON_TEMP.sub_agt_no
  is '二级业务员代码（目前存放电销坐席工号）';
comment on column UNICALL.XQ_RISKCON_TEMP.o_classcode
  is 'IDS转换前的综意险系统6位险种代码';
comment on column UNICALL.XQ_RISKCON_TEMP.cross_sale_ind
  is '是否交叉销售标示';
comment on column UNICALL.XQ_RISKCON_TEMP.prem_rate_level
  is '吉祥人生费率等级';
comment on column UNICALL.XQ_RISKCON_TEMP.ill_score
  is '团体重疾评点（综意险提供）';
comment on column UNICALL.XQ_RISKCON_TEMP.group_no
  is '组别号';
create index UNICALL.IDX_XQ_RISKCON_TEMP_POLICYNO on UNICALL.XQ_RISKCON_TEMP (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_SALES_INFO
prompt ============================
prompt
create table UNICALL.XQ_SALES_INFO
(
  xq_sales_info_id NUMBER(18) not null,
  sales_classify   VARCHAR2(50),
  sales_project    VARCHAR2(150),
  sales_organ      VARCHAR2(150),
  empno            VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_SALES_INFO
  is '业务员销售信息表';
comment on column UNICALL.XQ_SALES_INFO.sales_classify
  is '销售分类';
comment on column UNICALL.XQ_SALES_INFO.sales_project
  is '销售项目';
comment on column UNICALL.XQ_SALES_INFO.sales_organ
  is '销售机构';
comment on column UNICALL.XQ_SALES_INFO.empno
  is '业务员代码';
alter table UNICALL.XQ_SALES_INFO
  add constraint PK_XQ_SALES_INFO primary key (XQ_SALES_INFO_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_SALES_INFO_BAK
prompt ================================
prompt
create table UNICALL.XQ_SALES_INFO_BAK
(
  xq_sales_info_id NUMBER(18) not null,
  sales_classify   VARCHAR2(50),
  sales_project    VARCHAR2(150),
  sales_organ      VARCHAR2(150),
  empno            VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating table XQ_SPREREC
prompt =========================
prompt
create table UNICALL.XQ_SPREREC
(
  sno                    NUMBER(18) not null,
  reminder_id            NUMBER(18),
  policyno               VARCHAR2(20),
  status                 NUMBER(10),
  classcode              CHAR(8),
  amount                 NUMBER(20,4) not null,
  stdrate                NUMBER(20,6) not null,
  unstdrate              NUMBER(20,6) not null,
  prndate                DATE not null,
  yearnum                NUMBER(20) not null,
  paycode                NUMBER(10) not null,
  setcode                NUMBER(10) not null,
  pcode                  CHAR(1) not null,
  verdate                DATE,
  cover1                 DATE not null,
  cover2                 DATE not null,
  person_id              NUMBER(20),
  apid                   VARCHAR2(40) not null,
  idtype                 NUMBER(10) not null,
  years                  NUMBER(20) not null,
  source_payin_actvty_id VARCHAR2(35) not null,
  etl_time               DATE,
  status_ids             NUMBER(10),
  status_ids_var         CHAR(2),
  paycode_ids            CHAR(2),
  setcode_ids            CHAR(2),
  idtype_ids             CHAR(2),
  begtime                NUMBER(11),
  endtime                NUMBER(11),
  src_sys                VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 810M
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_SPREREC
  is '财务应收信息（按险种代码，明细）';
comment on column UNICALL.XQ_SPREREC.sno
  is '物理主键';
comment on column UNICALL.XQ_SPREREC.reminder_id
  is '关联应缴件ID';
comment on column UNICALL.XQ_SPREREC.policyno
  is '保单号';
comment on column UNICALL.XQ_SPREREC.status
  is '续收系统应缴件状态 1 待分配 2 待收费 3 待审批 4 已缴 5 取消';
comment on column UNICALL.XQ_SPREREC.classcode
  is '8位险种代码';
comment on column UNICALL.XQ_SPREREC.amount
  is '缴费/领款金额';
comment on column UNICALL.XQ_SPREREC.stdrate
  is '标准加费';
comment on column UNICALL.XQ_SPREREC.unstdrate
  is '非标准加费';
comment on column UNICALL.XQ_SPREREC.prndate
  is '生成日期';
comment on column UNICALL.XQ_SPREREC.yearnum
  is '保单约定缴费年限';
comment on column UNICALL.XQ_SPREREC.paycode
  is '本次缴费对应缴费频率';
comment on column UNICALL.XQ_SPREREC.setcode
  is '缴费/领款方式';
comment on column UNICALL.XQ_SPREREC.pcode
  is '交易财务类型';
comment on column UNICALL.XQ_SPREREC.verdate
  is '交易生效日期';
comment on column UNICALL.XQ_SPREREC.cover1
  is '财务交易责任起始日期';
comment on column UNICALL.XQ_SPREREC.cover2
  is '财务交易责任终止日期';
comment on column UNICALL.XQ_SPREREC.person_id
  is '缴费/领款人IAA业务相关主键';
comment on column UNICALL.XQ_SPREREC.apid
  is '投保人身份证件号';
comment on column UNICALL.XQ_SPREREC.idtype
  is '投保人身份证件类型';
comment on column UNICALL.XQ_SPREREC.years
  is '期次';
comment on column UNICALL.XQ_SPREREC.source_payin_actvty_id
  is '应收数据唯一标识';
comment on column UNICALL.XQ_SPREREC.etl_time
  is 'ETL处理时间';
comment on column UNICALL.XQ_SPREREC.status_ids
  is 'IDS中应缴件状态对应续期字典表 300：未处理301:划帐中(划帐成功)302:划帐不成功303:已转为正式记录';
comment on column UNICALL.XQ_SPREREC.status_ids_var
  is 'IDS中应缴件状态0：未处理1:划帐中(划帐成功)2:划帐不成功3:已转为正式记录';
comment on column UNICALL.XQ_SPREREC.paycode_ids
  is 'IDS缴费频率 01:趸缴 10:月缴  11:季缴 12:半年缴 13:年缴';
comment on column UNICALL.XQ_SPREREC.setcode_ids
  is 'IDS支付形式 1:现金 2:支票 3:转帐(银行,邮局) 4:银行代收(银保通) 8:POS转账 9:赠险 7:其它支付';
comment on column UNICALL.XQ_SPREREC.idtype_ids
  is 'IDS证件类型 00:团体客户 01:身份证 02:户口簿 03:护照 04:军官证 05:士兵证 06:港澳居民来往内地通行证 07:台湾同胞来往内地通行证 08:临时身份证 09:外国人居留证 10:警察证 11:文职干部证 12:驾驶执照 13:虚拟身份证 14:出生证书 99:其他证书';
comment on column UNICALL.XQ_SPREREC.begtime
  is '开始日期
';
comment on column UNICALL.XQ_SPREREC.endtime
  is '中止日期
';
comment on column UNICALL.XQ_SPREREC.src_sys
  is '来源系统
';
create index UNICALL.IDX_XQ_SPREREC_BEGINTIME on UNICALL.XQ_SPREREC (BEGTIME)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_SPREREC_CLASSCODE on UNICALL.XQ_SPREREC (CLASSCODE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_SPREREC_COVER1 on UNICALL.XQ_SPREREC (COVER1)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_SPREREC_POLICYNO on UNICALL.XQ_SPREREC (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_SPREREC_REMINDER_ID on UNICALL.XQ_SPREREC (REMINDER_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_SPREREC_SPAID on UNICALL.XQ_SPREREC (SOURCE_PAYIN_ACTVTY_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 128K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_SPREREC
  add constraint PK_XQ_SPREREC primary key (SNO)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_SPREREC
  add constraint UK_XQ_SPRERC_SPID unique (SOURCE_PAYIN_ACTVTY_ID);
alter table UNICALL.XQ_SPREREC
  add constraint FK_XQ_SPRER_XQ_REMINDER foreign key (REMINDER_ID)
  references UNICALL.XQ_REMINDER (REMINDER_ID);

prompt
prompt Creating table XQ_TASK_APPLY
prompt ============================
prompt
create table UNICALL.XQ_TASK_APPLY
(
  task_apply_id   NUMBER(18) not null,
  reminder_id     NUMBER(18) not null,
  new_use_ali     VARCHAR2(20) not null,
  apply_use_ali   VARCHAR2(20) not null,
  approve_use_ali VARCHAR2(20),
  apply_date      DATE not null,
  aprove_date     DATE,
  apply_sta       VARCHAR2(2) not null,
  remark          VARCHAR2(200),
  amount          NUMBER(20,6),
  old_use_ali     VARCHAR2(20)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on table UNICALL.XQ_TASK_APPLY
  is '分单调整申请';
comment on column UNICALL.XQ_TASK_APPLY.task_apply_id
  is '分单申请标识';
comment on column UNICALL.XQ_TASK_APPLY.reminder_id
  is '关联XQ_REMINDER';
comment on column UNICALL.XQ_TASK_APPLY.new_use_ali
  is '新坐席工号';
comment on column UNICALL.XQ_TASK_APPLY.apply_use_ali
  is '申请人工号';
comment on column UNICALL.XQ_TASK_APPLY.approve_use_ali
  is '审批人工号';
comment on column UNICALL.XQ_TASK_APPLY.apply_date
  is '申请日期';
comment on column UNICALL.XQ_TASK_APPLY.aprove_date
  is '审批日期';
comment on column UNICALL.XQ_TASK_APPLY.apply_sta
  is '0:不通过  1:通过  2:待审核  ';
comment on column UNICALL.XQ_TASK_APPLY.remark
  is '备注';
comment on column UNICALL.XQ_TASK_APPLY.amount
  is '金额';
comment on column UNICALL.XQ_TASK_APPLY.old_use_ali
  is '原坐席工号';
create index UNICALL.IDX_XQ_TASK_APPLY_DATE on UNICALL.XQ_TASK_APPLY (APPLY_DATE)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_TASK_APPLY_REMINDER on UNICALL.XQ_TASK_APPLY (REMINDER_ID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_TASK_APPLY_STA on UNICALL.XQ_TASK_APPLY (APPLY_STA)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_TASK_APPLY
  add constraint PK_XQ_TASK_APPLY primary key (TASK_APPLY_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_TASK_APPLY
  add constraint FK_XQ_TASK_REFERENCE_XQ_REMIN foreign key (REMINDER_ID)
  references UNICALL.XQ_REMINDER (REMINDER_ID);

prompt
prompt Creating table XQ_TRANSFER
prompt ==========================
prompt
create table UNICALL.XQ_TRANSFER
(
  transfer_id          VARCHAR2(11) not null,
  use_ali_id           VARCHAR2(20) not null,
  use_name             VARCHAR2(50) not null,
  branch_company_code  VARCHAR2(100) not null,
  saleprj              VARCHAR2(100),
  company_code         VARCHAR2(100) not null,
  appno                VARCHAR2(20) not null,
  policyno             VARCHAR2(20) not null,
  apname               VARCHAR2(120) not null,
  idtype               NUMBER(10),
  apid                 VARCHAR2(40) not null,
  con_tel              VARCHAR2(100) not null,
  app_item             NUMBER(10) not null,
  app_con              NUMBER(10) not null,
  record_time          DATE,
  write_back_time      DATE,
  accept_date          DATE,
  accept_alid          VARCHAR2(50),
  accept_name          VARCHAR2(50),
  accept_result        VARCHAR2(500),
  tran_end_date        DATE,
  tran_date            DATE,
  tran_sta             NUMBER(10),
  tran_src             VARCHAR2(2) not null,
  imp_use_alid         VARCHAR2(20),
  remark               VARCHAR2(500),
  classname            VARCHAR2(100),
  accept_result_remark VARCHAR2(500)
)
tablespace UNICALL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
comment on column UNICALL.XQ_TRANSFER.transfer_id
  is '转办件标识';
comment on column UNICALL.XQ_TRANSFER.use_ali_id
  is '续收代表工号';
comment on column UNICALL.XQ_TRANSFER.use_name
  is '续收代表姓名';
comment on column UNICALL.XQ_TRANSFER.branch_company_code
  is '保单所属电销中心/分公司';
comment on column UNICALL.XQ_TRANSFER.saleprj
  is '保单销售项目';
comment on column UNICALL.XQ_TRANSFER.company_code
  is '保单出单分公司';
comment on column UNICALL.XQ_TRANSFER.appno
  is '投保单号';
comment on column UNICALL.XQ_TRANSFER.policyno
  is '保单号';
comment on column UNICALL.XQ_TRANSFER.apname
  is '投保单人姓名';
comment on column UNICALL.XQ_TRANSFER.idtype
  is '投保人证件类型';
comment on column UNICALL.XQ_TRANSFER.apid
  is '投保人证件号';
comment on column UNICALL.XQ_TRANSFER.con_tel
  is '投保人联系电话';
comment on column UNICALL.XQ_TRANSFER.app_item
  is '保全项目';
comment on column UNICALL.XQ_TRANSFER.app_con
  is '保全内容';
comment on column UNICALL.XQ_TRANSFER.record_time
  is '录入时间';
comment on column UNICALL.XQ_TRANSFER.write_back_time
  is '回写时间';
comment on column UNICALL.XQ_TRANSFER.accept_date
  is '转办受理日期';
comment on column UNICALL.XQ_TRANSFER.accept_alid
  is '转办件受理人工号';
comment on column UNICALL.XQ_TRANSFER.accept_name
  is '转办件受理人姓名';
comment on column UNICALL.XQ_TRANSFER.accept_result
  is '受理结果';
comment on column UNICALL.XQ_TRANSFER.tran_end_date
  is '转办办结日期';
comment on column UNICALL.XQ_TRANSFER.tran_date
  is '转办日期';
comment on column UNICALL.XQ_TRANSFER.tran_sta
  is '转办件状态';
comment on column UNICALL.XQ_TRANSFER.tran_src
  is '转办件来源(录入/导入)  0:录入 1:导入';
comment on column UNICALL.XQ_TRANSFER.imp_use_alid
  is '导入主管工号';
comment on column UNICALL.XQ_TRANSFER.remark
  is '备注';
comment on column UNICALL.XQ_TRANSFER.classname
  is '险种名称';
comment on column UNICALL.XQ_TRANSFER.accept_result_remark
  is '受理结果说明';
create index UNICALL.IDX_XQ_TRANSFER_APID on UNICALL.XQ_TRANSFER (APID)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_TRANSFER_APP_CON on UNICALL.XQ_TRANSFER (APP_CON)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
create index UNICALL.IDX_XQ_TRANSFER_POLICYNO on UNICALL.XQ_TRANSFER (POLICYNO)
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );
alter table UNICALL.XQ_TRANSFER
  add constraint PK_XQ_TRANSFER primary key (TRANSFER_ID)
  using index 
  tablespace UNICALL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    next 1M
    minextents 1
    maxextents unlimited
  );

prompt
prompt Creating sequence C_CUS_BAS_SEQ
prompt ===============================
prompt
create sequence UNICALL.C_CUS_BAS_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 238271
increment by 1
cache 20;

prompt
prompt Creating sequence SATIFSYID_SEQ
prompt ===============================
prompt
create sequence UNICALL.SATIFSYID_SEQ
minvalue 10
maxvalue 999999999999999999999999999
start with 13
increment by 1
nocache;

prompt
prompt Creating sequence SEQ_BANKCOMM_APP_NB
prompt =====================================
prompt
create sequence UNICALL.SEQ_BANKCOMM_APP_NB
minvalue 1
maxvalue 9999999999999999999999999999
start with 161
increment by 1
cache 20
cycle;

prompt
prompt Creating sequence SEQ_BANKCOMM_POLICY_SEND
prompt ==========================================
prompt
create sequence UNICALL.SEQ_BANKCOMM_POLICY_SEND
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating sequence SEQ_BANKCOMM_PRINT_ACTVTY
prompt ===========================================
prompt
create sequence UNICALL.SEQ_BANKCOMM_PRINT_ACTVTY
minvalue 1
maxvalue 9999999999999999999999999999
start with 1
increment by 1
cache 20
cycle;

prompt
prompt Creating sequence SEQ_CONTINUATION_REPORT
prompt =========================================
prompt
create sequence UNICALL.SEQ_CONTINUATION_REPORT
minvalue 1
maxvalue 99999999999
start with 1391
increment by 1
cache 20
order;

prompt
prompt Creating sequence SEQ_C_AGENTCOMPANY
prompt ====================================
prompt
create sequence UNICALL.SEQ_C_AGENTCOMPANY
minvalue 1
maxvalue 999999999999999999999999999
start with 77
increment by 1
nocache;

prompt
prompt Creating sequence SEQ_C_AGENTCOMPANY_FACTOR
prompt ===========================================
prompt
create sequence UNICALL.SEQ_C_AGENTCOMPANY_FACTOR
minvalue 1
maxvalue 999999999999999999999999999
start with 19
increment by 1
nocache;

prompt
prompt Creating sequence SEQ_POLICYNO_SERIAL_NUMBER
prompt ============================================
prompt
create sequence UNICALL.SEQ_POLICYNO_SERIAL_NUMBER
minvalue 100000000
maxvalue 999999999
start with 100071872
increment by 1
cache 20
cycle;

prompt
prompt Creating sequence SEQ_TB_APP
prompt ============================
prompt
create sequence UNICALL.SEQ_TB_APP
minvalue 10000
maxvalue 99999
start with 92006
increment by 1
cache 20
cycle;

prompt
prompt Creating sequence SEQ_TB_INTORG
prompt ===============================
prompt
create sequence UNICALL.SEQ_TB_INTORG
minvalue 1
maxvalue 9999999999999999999999999999
start with 41
increment by 1
cache 20
cycle;

prompt
prompt Creating sequence SEQ_TB_RESERVE_TASK
prompt =====================================
prompt
create sequence UNICALL.SEQ_TB_RESERVE_TASK
minvalue 1
maxvalue 9999999999999999999999999999
start with 661
increment by 1
cache 20
cycle;

prompt
prompt Creating sequence SEQ_T_AGENTCOMPANY_TYPE
prompt =========================================
prompt
create sequence UNICALL.SEQ_T_AGENTCOMPANY_TYPE
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
nocache;

prompt
prompt Creating sequence SEQ_USABLE_CUS_INF
prompt ====================================
prompt
create sequence UNICALL.SEQ_USABLE_CUS_INF
minvalue 1
maxvalue 999999999999999999999999999
start with 68931212
increment by 1
nocache;

prompt
prompt Creating sequence SEQ_XQ_CHARGE_FAILURE
prompt =======================================
prompt
create sequence UNICALL.SEQ_XQ_CHARGE_FAILURE
minvalue 1
maxvalue 9999999999999999999999999999
start with 109741
increment by 1
cache 20
cycle;

prompt
prompt Creating sequence SEQ_XQ_PLC_PRM_TRANS_ACCT
prompt ===========================================
prompt
create sequence UNICALL.SEQ_XQ_PLC_PRM_TRANS_ACCT
minvalue 1
maxvalue 9999999999999999999999999999
start with 3265
increment by 1
cache 20
cycle;

prompt
prompt Creating sequence SEQ_XQ_REALPAYRC
prompt ==================================
prompt
create sequence UNICALL.SEQ_XQ_REALPAYRC
minvalue 1
maxvalue 9999999999999999999999999999
start with 741
increment by 1
cache 20
cycle;

prompt
prompt Creating sequence SEQ_XQ_REMINDER_REPORT
prompt ========================================
prompt
create sequence UNICALL.SEQ_XQ_REMINDER_REPORT
minvalue 1
maxvalue 9999999999999999999999999999
start with 69473
increment by 1
cache 20
cycle;

prompt
prompt Creating sequence SEQ_XQ_TRANSFER
prompt =================================
prompt
create sequence UNICALL.SEQ_XQ_TRANSFER
minvalue 1
maxvalue 9999
start with 1206
increment by 1
cache 10
cycle;

prompt
prompt Creating sequence SHCPIC_CREDIT_SEQ
prompt ===================================
prompt
create sequence UNICALL.SHCPIC_CREDIT_SEQ
minvalue 1
maxvalue 999999999999999999999999999
start with 1
increment by 1
cache 20;

prompt
prompt Creating synonym UB
prompt ===================
prompt
create or replace synonym UNICALL.UB
  for UNICALL.SB;

prompt
prompt Creating view MUL_XQ_RISKCON
prompt ============================
prompt
CREATE OR REPLACE VIEW UNICALL.MUL_XQ_RISKCON AS
SELECT r.policyno,r.apid,xr.classname,f.orgname FROM xq_riskcon r,xq_riskclass xr,ff_company f
  where r.classcode =xr.classcode and r.branch =f.orgcode
  AND r.TMOUNT >=1000
  AND xr.TIMESTR =1
  AND f.orgname LIKE '广东%';

prompt
prompt Creating view VI_XQ_RISKCON
prompt ===========================
prompt
CREATE OR REPLACE VIEW UNICALL.VI_XQ_RISKCON AS
SELECT r.policyno,r.apid,r.classname
  FROM MUL_XQ_RISKCON r;

prompt
prompt Creating view V_PERFORMANCE
prompt ===========================
prompt
create or replace view unicall.v_performance as
select cus.ob_com_id comID, com.ob_com_nam comName, di.use_id userID, u.use_ali_id agentID, di.con_sta_id statID,di.dia_tim,cus.dia_cou dialedcount
from c_ob_com_cus_di di, c_ob_com_cus cus, c_use u, c_ob_com com
where di.c_ob_com_cus_id=cus.c_ob_com_cus_id and di.use_id = u.use_id and cus.ob_com_id=com.ob_com_id;

prompt
prompt Creating view V_PERFORMANCE_RPT
prompt ===============================
prompt
create or replace view unicall.v_performance_rpt as
select comID,comName,userID,AgentID,to_char(Dia_TIM,'YYYY-MM-DD') DialedTime,
   sum( decode(statID,110,1,111,1,112,1,113,1,114,1,115,1,116,1,117,1,118,1,0) ) NotSales,
   sum(decode(statID,110,1,0)) NotSale_110,
   sum(decode(statID,111,1,0)) NotSale_111,
   sum(decode(statID,112,1,0)) NotSale_112,
   sum(decode(statID,113,1,0)) NotSale_113,
   sum(decode(statID,114,1,0)) NotSale_114,
   sum(decode(statID,115,1,0)) NotSale_115,
   sum(decode(statID,116,1,0)) NotSale_116,
   sum(decode(statID,117,1,0)) NotSale_117,
   sum(decode(statID,117,1,0)) NotSale_118,
   sum(decode(statID,200,1,201,1,202,1,203,1,204,1,205,1,206,1,207,1,208,1,209,1,210,1,211,1,212,1,213,1,0)) Sales,
   sum(decode(statID,200,1,0)) Sale_200,
   sum(decode(statID,201,1,0)) Sale_201,
   sum(decode(statID,202,1,0)) Sale_202,
   sum(decode(statID,203,1,0)) Sale_203,
   sum(decode(statID,204,1,0)) Sale_204,
   sum(decode(statID,205,1,0)) Sale_205,
   sum(decode(statID,206,1,0)) Sale_206,
   sum(decode(statID,207,1,0)) Sale_207,
   sum(decode(statID,208,1,0)) Sale_208,
   sum(decode(statID,209,1,0)) Sale_209,
   sum(decode(statID,210,1,0)) Sale_210,
   sum(decode(statID,211,1,0)) Sale_211,
   sum(decode(statID,212,1,0)) Sale_212,
   sum(decode(statID,213,1,0)) Sale_213,
   sum(dialedcount) DialedCount
from v_performance
group by comID,comName,userID,AgentID,to_char(Dia_TIM,'YYYY-MM-DD');

prompt
prompt Creating package CURSOR_POLICY_INFO_EXPORT
prompt ==========================================
prompt
CREATE OR REPLACE PACKAGE UNICALL.CURSOR_POLICY_INFO_EXPORT
    AS
     TYPE POLICY_INFO IS REF CURSOR;
   END;
/

prompt
prompt Creating package TYPES
prompt ======================
prompt
create or replace package unicall.types
    as
     type cursorType is ref cursor;
   end;
/

prompt
prompt Creating package XQ_CONTINUATION_REPORT
prompt =======================================
prompt
create or replace package unicall.XQ_CONTINUATION_REPORT is
  type CUR_REPORT is REF CURSOR;
  PROCEDURE REPORT_CONTINUATION(p_orgtype integer,p_searchTime varchar2,p_rate integer,report out CUR_REPORT);
end XQ_CONTINUATION_REPORT;
/

prompt
prompt Creating function CANCELQDBF
prompt ============================
prompt
create or replace function unicall.cancelQDBF(pszt varchar2,qdbf number) return number is
  Result number;
begin
  if pszt = '注销' then
     return qdbf;
  else
     return 0;
  end if;
end cancelQDBF;
/

prompt
prompt Creating function FUN_PARSE_DATE
prompt ================================
prompt
create or replace function unicall.fun_parse_date(
  date_string varchar2
  ,format_string varchar2
)return date as
begin
  return to_date(date_string,format_string);
  exception
    when others then
    return null;
    --to_date('1800-1-1','yyyy-mm-dd');
end fun_parse_date;
/

prompt
prompt Creating function ISCONTACTED
prompt =============================
prompt
create or replace function unicall.isContacted(callstatus varchar2) return number is
  Result number;
begin
  if callstatus=114 then
     return 0;
  else
     return 1;
  end if;
end isContacted;
/

prompt
prompt Creating function ISDIALED
prompt ==========================
prompt
create or replace function unicall.isDialed(callstatus varchar2) return number is
  Result number;
begin
    if callstatus = '3001' then
       return 0;
    else
       return 1;
    end if;
end isDialed;
/

prompt
prompt Creating function ISFLLOWED
prompt ===========================
prompt
create or replace function unicall.isFllowed(callstatus varchar2) return number is
  Result number;
begin
  if substr(callstatus,1,2)='跟踪' then
     return 1;
  else
      return 0;
  end if;
end isFllowed;
/

prompt
prompt Creating function ISINCALL
prompt ==========================
prompt
create or replace function unicall.isIncall(callmethod varchar2) return number is
  Result number;
begin
  if callmethod='0' then
     return 1;
  else
     return 0;
  end if;
end isIncall;
/

prompt
prompt Creating function ISOUTCALL
prompt ===========================
prompt
create or replace function unicall.isoutcall(callmethod varchar2) return number is
  Result number;
begin
  if callmethod='1' then
     return 1;
  else
     return 0;
  end if;
end isoutcall;
/

prompt
prompt Creating function ISPNOCANCEL
prompt =============================
prompt
create or replace function unicall.isPNOCancel(pszt varchar2) return number is
  Result number;
begin
  if pszt = '注销' then
     return 1;
  else
     return 0;
  end if;
end isPNOCancel;
/

prompt
prompt Creating function ISSUBMITTED
prompt =============================
prompt
create or replace function unicall.isSubmitted(callstatus varchar2) return number is
  Result number;
begin
  if callstatus in (200,201,202,203) then
     return 1;
  else
     return 0;
  end if;
end isSubmitted;
/

prompt
prompt Creating procedure AGENTID_ADD_SIX
prompt ==================================
prompt
create or replace procedure unicall.agentId_add_six is
  newVal varchar2(10);
  cursor cur is
    select * from c_use_par c where c.cat_id = 802001 and c.use_id in (select t.use_id from c_use t where t.rig_sta_id = 3 and regexp_like(t.use_ali_id, '^[0-9]+$'));
begin
  for c in cur loop
    begin
      --dbms_output.put_line('oldDes : '||c.val);
      newVal := '6' || c.val;
      --dbms_output.put_line('newDes : '||newVal);
      --dbms_output.put_line('------------------------');
      update C_USE_PAR t set t.val = newVal where t.cat_id = 802001 and t.use_id = c.use_id;
    end;
  end loop;
end agentId_add_six;
/

prompt
prompt Creating procedure AGENTID_SUB_SIX
prompt ==================================
prompt
create or replace procedure unicall.agentId_sub_six is
  newVal varchar2(10);
  cursor cur is
    select * from c_use_par c where c.cat_id = 802001 and c.use_id in (select t.use_id from c_use t where t.rig_sta_id = 3 and regexp_like(t.use_ali_id, '^[0-9]+$'));
begin
  for c in cur loop
    begin
     -- dbms_output.put_line('oldDes : '||c.val);
      newVal  := substr(c.val, 2, 4);
     -- dbms_output.put_line('newDes : '||newVal);
     -- dbms_output.put_line('------------------------');
      update C_USE_PAR t set t.val = newVal where t.cat_id = 802001 and t.use_id = c.use_id;
    end;
  end loop;
end agentId_sub_six;
/

prompt
prompt Creating procedure AUTOASSIGNACTIVECODE
prompt =======================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.AutoAssignActiveCode IS
  v_active_code_id number(10) := 0;
  --定义保障起期
  v_current_datetime VARCHAR2(10) := to_char(SYSDATE + 2, 'yyyy-mm-dd');

  --查询待分配激活码赠险数据 自建赠险
  CURSOR cur_info IS
    SELECT id, company_id, product_code_id
      FROM cpic_presentins_info b
     WHERE b.app_stat = '01'
       AND b.actcode_id IS NULL
     ORDER BY b.create_time;
  v_info cur_info%ROWTYPE;

  --查询待分配激活码赠险数据 批量导入中介赠险数据
  CURSOR cur_info_volumn IS
    SELECT id, company_id, product_code_id
      FROM cpic_presentins_info_volumn b
     WHERE b.app_stat = '01'
       AND b.actcode_id IS NULL
     ORDER BY b.create_time;
  v_info_volumn cur_info_volumn%ROWTYPE;

BEGIN
  OPEN cur_info;
  LOOP
    FETCH cur_info
      INTO v_info;
    EXIT WHEN cur_info%NOTFOUND;
    select (select c.id
              from SHCPIC_PREINS_ACTIVE_CODE c
             where c.company_id = v_info.company_id
               and c.product_code_id = v_info.product_code_id
               and c.distribute_id is null
               and rownum = 1)
      into v_active_code_id
      from DUAL;
    IF v_active_code_id > 0 THEN
      UPDATE SHCPIC_PREINS_ACTIVE_CODE c
         SET c.distribute_id = 3
       WHERE c.id = v_active_code_id;

      UPDATE SHCPIC_PREINS_DISTRIBUTE e
         SET e.amount = e.amount + 1
       WHERE e.id = 3;

      UPDATE cpic_presentins_info n
         SET n.actcode_id  = v_active_code_id,
             n.app_startdt = v_current_datetime
       WHERE n.id = v_info.id;
    END IF;
    COMMIT;
  END LOOP;
  CLOSE cur_info;

  OPEN cur_info_volumn;
  LOOP
    FETCH cur_info_volumn
      INTO v_info_volumn;
    EXIT WHEN cur_info_volumn%NOTFOUND;
    select ( select c.id
              from SHCPIC_PREINS_ACTIVE_CODE c
             where c.company_id = v_info_volumn.company_id
               and c.product_code_id = v_info_volumn.product_code_id
               and c.distribute_id is null
               and rownum = 1)
      into v_active_code_id
      from DUAL;
    IF v_active_code_id > 0 THEN
      UPDATE SHCPIC_PREINS_ACTIVE_CODE c
         SET c.distribute_id = 3
       WHERE c.id = v_active_code_id;

      UPDATE SHCPIC_PREINS_DISTRIBUTE e
         SET e.amount = e.amount + 1
       WHERE e.id = 3;

      UPDATE cpic_presentins_info_volumn n
         SET n.actcode_id  = v_active_code_id,
             n.app_startdt = v_current_datetime
       WHERE n.id = v_info_volumn.id;
    END IF;
    COMMIT;
  END LOOP;
  CLOSE cur_info_volumn;
END AutoAssignActiveCode;
/

prompt
prompt Creating procedure BACKUP_VERIFY_FAIL_INSUR
prompt ===========================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.BACKUP_VERIFY_FAIL_INSUR IS

BEGIN
 --备份核保失败的保单
 insert into proposal_form_result_his
    (id, insure_name, relation, insure_sex, insure_birthday, insure_pass_type, insure_pass_code, insure_post_code, insure_address, insure_employment, insure_mobile, insure_family_pho, insure_com_pho, d_insure_name, d_insure_sex, d_insure_birthday, d_insure_pass_type, d_insure_pass_code, d_insure_post_code, d_insure_address, d_insure_employment, d_insure_mobile, d_insure_family_pho, d_insure_com_pho, price, counts, ben_type, bank_name, bank_code, bank_account, audit_status, c_ob_com_cus_id, user_id, createtime, sale_code, appno, policyno, id_checkpoint_type, companyname, insure_email, d_insure_email, pay_type, app_latest_status, app_latest_time, app_accept_status, app_accept_time, app_quit_status, app_quit_time, total_pay_des, cus_gro_id, check_user_id, insure_con_addr_type, d_insure_con_addr_type, companycode, insurance_sum, audittime, d_insure_weight, d_insure_height, r_pay_type, auto_charge_date, auto_charge_flag, charge_amount, charge_ret, confirm_ret, uwr_ret, chatge_state_code, tradeseq, org_id, backup_time)
 select
    id, insure_name, relation, insure_sex, insure_birthday, insure_pass_type, insure_pass_code, insure_post_code, insure_address, insure_employment, insure_mobile, insure_family_pho, insure_com_pho, d_insure_name, d_insure_sex, d_insure_birthday, d_insure_pass_type, d_insure_pass_code, d_insure_post_code, d_insure_address, d_insure_employment, d_insure_mobile, d_insure_family_pho, d_insure_com_pho, price, counts, ben_type, bank_name, bank_code, bank_account, audit_status, c_ob_com_cus_id, user_id, createtime, sale_code, appno, policyno, id_checkpoint_type, companyname, insure_email, d_insure_email, pay_type, app_latest_status, app_latest_time, app_accept_status, app_accept_time, app_quit_status, app_quit_time, total_pay_des, cus_gro_id, check_user_id, insure_con_addr_type, d_insure_con_addr_type, companycode, insurance_sum, audittime, d_insure_weight, d_insure_height, r_pay_type, auto_charge_date, auto_charge_flag, charge_amount, charge_ret, confirm_ret, uwr_ret, chatge_state_code, tradeseq, org_id, sysdate
 from shcpic_proposal_form_result t where t.uwr_ret='0';

 --删除核保失败的保单
 delete from shcpic_proposal_form_result t where t.uwr_ret='0';

 --提交
 COMMIT;

EXCEPTION
  WHEN OTHERS THEN
    --发生异常
    dbms_output.put_line('error');
    --回滚
    ROLLBACK;
END BACKUP_VERIFY_FAIL_INSUR;
/

prompt
prompt Creating procedure COMM_DATE_SREACH
prompt ===================================
prompt
create or replace procedure unicall.COMM_DATE_SREACH
is
begin
---从tb_app表添加BANKCOMM_INFO表中没有的记录至BANKCOMM_INFO表
insert into BANKCOMM_INFO(
select tb.id,ID_TYPE,ID_NO,'E1',Appno,Idorg,Firstcreate,App_Status,Regdate,Opdate
 from(
   select * from(
     select r.sno id,tb.appno,tb.app_status,tb.idorg,tb.firstcreate,
     SUBSTR(tb.contents,INSTR(tb.contents,'|%|', 1, 4) + 3,INSTR(tb.contents,'|%|', 1, 5) -INSTR(tb.contents,'|%|', 1, 4) - 3) as id_type,
     SUBSTR(tb.contents,INSTR(tb.contents,'|%|', 1, 5) + 3,INSTR(tb.contents,'|%|', 1, 6) -INSTR(tb.contents,'|%|', 1, 5) - 3) as id_no,r.opdate,r.policyno
     from tb_app tb,riskcon r where tb.appno=r.appno and tb.iddmtype='2002' and r.opdate is not null
   )
   where appno not in (select rtrim(c.appno) from BANKCOMM_INFO c) group by appno,id,app_status,idorg,firstcreate,id_type,id_no,opdate,policyno
 ) tb left join realpayrc re on tb.policyno=re.policyno
);
commit;
---如果tb_app表投保单状态更改，那么从tb_app表更新BANKCOMM_INFO表
----数据更新
update BANKCOMM_INFO t set (app_status,regdate)=(
select tb.app_status,tb.regdate from(
   select tb.*,r.regdate from(
    select tb.appno,tb.app_status,r.policyno from(
        select tb.appno,tb.app_status
        from tb_app tb,BANKCOMM_INFO b where tb.appno=rtrim(b.appno) and tb.app_status<>b.app_status
      )tb,riskcon r where tb.appno=r.appno group by tb.appno,tb.app_status,r.policyno
    )tb left join realpayrc r on tb.policyno=r.policyno
  ) tb where rtrim(t.appno)=tb.appno)
where exists(
      select 1 from tb_app tb where tb.appno=rtrim(t.appno) and tb.app_status<>t.app_status
);
commit;
----数据更新完成


end COMM_DATE_SREACH;
/

prompt
prompt Creating procedure DN_ADD_EIGHT
prompt ===============================
prompt
create or replace procedure unicall.dn_add_eight is
  ip        varchar2(50);
  dn        varchar2(10);
  position  varchar2(10);
  newCatDes varchar2(100);
  oneflag   number(5);
  twoflag   number(5);
  cursor cur is
    select t.cat_id as catId, t.cat_des as catDes
      from c_cat t
     where regexp_like(t.cat_des, '^([0-9]+.?)+(:[0-9]{4}:[0-9]{4})$');
begin
  for c in cur loop
    begin
      -- dbms_output.put_line('oldDes : '||c.catDes);
      oneflag  := instr(c.catDes, ':', 1, 1);
      twoflag  := instr(c.catDes, ':', 1, 2);
      ip       := substr(c.catDes, 1, oneflag - 1);
      dn       := substr(c.catDes, oneflag + 1, 4);
      position := substr(c.catDes, twoflag + 1, 4);

      dn        := '8' || dn;
      position  := '8' || position;
      newCatDes := ip || ':' || dn || ':' || position;
      -- dbms_output.put_line('newDes : '||newCatDes);
      --  dbms_output.put_line('------------------------');
      update c_cat t set t.cat_des = newCatDes where t.cat_id = c.catId;
    end;
  end loop;
end dn_add_eight;
/

prompt
prompt Creating procedure DN_SUB_EIGHT
prompt ===============================
prompt
create or replace procedure unicall.dn_sub_eight is
  ip        varchar2(50);
  dn        varchar2(10);
  position  varchar2(10);
  newCatDes varchar2(100);
  oneflag   number(5);
  twoflag   number(5);
  cursor cur is
    select t.cat_id as catId, t.cat_des as catDes
      from c_cat t
     where regexp_like(t.cat_des, '^([0-9]+.?)+(:[0-9]{5}:[0-9]{5})$');
begin
  for c in cur loop
    begin
      -- dbms_output.put_line('oldDes : '||c.catDes);

      oneflag  := instr(c.catDes, ':', 1, 1);
      twoflag  := instr(c.catDes, ':', 1, 2);
      ip       := substr(c.catDes, 1, oneflag - 1);
      dn       := substr(c.catDes, oneflag + 1, 5);
      position := substr(c.catDes, twoflag + 1, 5);

      dn        := substr(dn, 2, 4);
      position  := substr(position, 2, 4);
      newCatDes := ip || ':' || dn || ':' || position;

      -- dbms_output.put_line('newDes : '||newCatDes);
      -- dbms_output.put_line('------------------------');
      update c_cat t set t.cat_des = newCatDes where t.cat_id = c.catId;
    end;
  end loop;
end dn_sub_eight;
/

prompt
prompt Creating procedure GETAPPNO
prompt ===========================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.GetAppNo( idorgIn in varchar2 ,resultNum OUT INTEGER) AS
       --vc_nowdate varchar2(10);
       --vc_tb_appno_count number(10) :=0;
       --vc_tb_appno_id number(18) :=0;
       idbranchorgTemp varchar2(18);
BEGIN
       --select to_char(sysdate,'YYYY-MM-DD') into vc_nowdate from dual;--取当前日期
       select a.idbranchorg  into idbranchorgTemp from TB_ORGINFO a where a.id = idorgIn;
       select t.appcounter into resultNum from TB_APPNO t where t.idorg = idbranchorgTemp and to_char(t.appdate,'YYYY-MM-DD') = '1920-01-01' for update;
       if resultNum >= 9999 then
          update TB_APPNO t set t.appcounter = 1000, t.lastupdate = sysdate where t.idorg = idbranchorgTemp and to_char(t.appdate,'YYYY-MM-DD') = '1920-01-01';
          resultNum := 1000;
          commit;
       else
          update TB_APPNO t set t.appcounter = t.appcounter + 1, t.lastupdate = sysdate where t.idorg = idbranchorgTemp and to_char(t.appdate,'YYYY-MM-DD') = '1920-01-01';
          resultNum := resultNum + 1;
          commit;
       end if;
       commit;
END GetAppNo;
/

prompt
prompt Creating procedure GETPOLICYNO
prompt ==============================
prompt
create or replace procedure unicall.GETPOLICYNO is
  v_policyno      varchar2(18); --保单号
  v_year          varchar2(2); --2位年
  v_serial_number number(9); --流水号

  cursor cur_product_code is
    select *
      from shcpic_preins_product_code t
     where t.insured_period is not null
       and t.insured_period_unit is not null
       and t.insurance_ident is not null
       and t.composite_ins_code is not null
       and t.pay_stad is not null;
  v_product_code cur_product_code%rowtype;

  v_exp      varchar2(4000);
  v_exp_code varchar2(100);
begin

  open cur_product_code;
  loop

    fetch cur_product_code
      into v_product_code;
    exit when cur_product_code%notfound;

    begin
      for preins in (select t.id
                       from cpic_new_presentins_info t
                      where t.product_code_id = v_product_code.id
                        and t.policyno is null
                        and t.apper_name is not null
                        and t.app_startdt is not null
                        and t.apper_cell_no is not null
                        and t.app_stat_new = '01'
                      order by t.id asc) loop

        begin
          select to_char(sysdate, 'yy') into v_year from dual;
          select seq_policyno_serial_number.nextval
            into v_serial_number
            from dual;

          v_policyno := 'DX' || v_year || '1' ||
                        v_product_code.insurance_ident || v_serial_number;

          update cpic_new_presentins_info t
             set t.policyno = v_policyno, t.app_stat_new = '02'
           where t.id = preins.id;
          commit;

        exception
          when others then
            begin
              rollback;

              v_exp      := SUBSTR(SQLERRM, 1, 1000);
              v_exp_code := sqlcode;
              insert into p_deal_biz_day_log
                (statetime, endtime, remark, ex, CODE)
              values
                (sysdate, sysdate, '赠险ID:' || preins.id, v_exp, v_exp_code);
              commit;
            end;
        end;
      end loop;

    exception
      when others then
        begin
          rollback;
          dbms_output.put_line(sqlerrm || ':' || sqlcode);
        end;
    end;
  end loop;
  close cur_product_code;

exception
  when others then
    begin
      rollback;
      close cur_product_code;
      dbms_output.put_line(sqlerrm || ':' || sqlcode);
    end;
end GETPOLICYNO;
/

prompt
prompt Creating procedure NEW_POLICY_INFO_EXPORT
prompt =========================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.NEW_POLICY_INFO_EXPORT(START_DATE VARCHAR2 ,          --成交开始时间
                                                   END_DATE VARCHAR2 ,            --成交结束时间
                                                   CREATE_START_DATE VARCHAR2 ,   --创建开始时间
                                                   CREATE_END_DATE VARCHAR2 ,     --创建结束时间
                                                   COMPANY_ID VARCHAR2,          --数据权限
                                                   TB_APPLICATION_ID VARCHAR2,   --投保单ID
                                                   TB_APPLICATION_PRJID VARCHAR2,--所属项目
                                                   TB_APPLICATION_APPNO VARCHAR2,--投保单号
                                                   TB_APPLICATION_NO    VARCHAR2,--保单号
                                                   TB_APPLICATION_STA   VARCHAR2,--投保单状态
                                                   TB_APPLICATION_IDROG VARCHAR2,--所属机构
                                                   TB_APPLICATION_TSRID VARCHAR2,--业务员工号
                                                   RES_STA VARCHAR2,--预约状态
                                                   CURSOR_POLICY_INFO OUT CURSOR_POLICY_INFO_EXPORT.POLICY_INFO) IS

  SQLWHERESTRING         VARCHAR2(4000):='';
  SQLVAR                 VARCHAR2(30000);

BEGIN
  IF COMPANY_ID IS NOT NULL THEN
   SQLWHERESTRING:=SQLWHERESTRING||' AND TA.ORG_ID IN ('||COMPANY_ID||')';
  END IF;
  IF TB_APPLICATION_ID IS NOT NULL THEN
    SQLWHERESTRING:=SQLWHERESTRING||' AND TA.APPLICATION_ID='''||TB_APPLICATION_ID||'''';
  --    SQLWHERESTRING:=SQLWHERESTRING||' AND INSTR(TA.APPLICATION_ID,'''||TB_APPLICATION_ID||''')>0';
  END IF;
  IF TB_APPLICATION_PRJID IS NOT NULL THEN
    SQLWHERESTRING:=SQLWHERESTRING||' AND TA.PRJ_ID='''||TB_APPLICATION_PRJID||'''';
  END IF;
  IF TB_APPLICATION_APPNO IS NOT NULL THEN
    SQLWHERESTRING:=SQLWHERESTRING||' AND TA.APPNO='''||TB_APPLICATION_APPNO||'''';
  --    SQLWHERESTRING:=SQLWHERESTRING||' AND INSTR(TA.APPNO,'''||TB_APPLICATION_APPNO||''')>0';
  END IF;
  IF TB_APPLICATION_NO IS NOT NULL THEN
    SQLWHERESTRING:=SQLWHERESTRING||' AND TA.POLICYNO='''||TB_APPLICATION_NO||'''';
  --    SQLWHERESTRING:=SQLWHERESTRING||' AND INSTR(TA.POLICYNO,'''||TB_APPLICATION_NO||''')>0';
  END IF;
  IF TB_APPLICATION_STA IS NOT NULL THEN
    SQLWHERESTRING:=SQLWHERESTRING||' AND TA.APP_STATUS='''||TB_APPLICATION_STA||'''';
  END IF;
  IF TB_APPLICATION_IDROG IS NOT NULL THEN
    SQLWHERESTRING:=SQLWHERESTRING||' AND TA.IDORG IN ('||TB_APPLICATION_IDROG||')';
  END IF;
  IF TB_APPLICATION_TSRID IS NOT NULL THEN
    SQLWHERESTRING:=SQLWHERESTRING||' AND TA.AGENT_ID  ='''||TB_APPLICATION_TSRID||'''';
  END IF;
  IF RES_STA IS NOT NULL THEN
    SQLWHERESTRING:=SQLWHERESTRING||' AND TA.RESERV_STATUS  ='''||RES_STA||'''';
  END IF;
  IF CREATE_START_DATE IS NOT NULL AND CREATE_END_DATE IS NOT NULL THEN
    SQLWHERESTRING:=SQLWHERESTRING||' AND TA.FIRSTCREATE BETWEEN TO_DATE('''||CREATE_START_DATE||''',''YYYY-MM-DD HH24:MI:SS'') AND TO_DATE('''||CREATE_END_DATE||''',''YYYY-MM-DD HH24:MI:SS'')';
  END IF;

   dbms_output.put_line(SQLWHERESTRING);
          SQLVAR:='SELECT  t.application_id id,t.appno,policyno,idorg, tsrid,app_date, t.insurance_code,t.app_name, t.payment_account,t.id_no,
               t.app_mobile,t.contact_tel,t.family_addr,t.payment_type,t.sumpre,t.gro_id, t.chg_time, t.policy_chg_time,
               t.return_input_time,t.deduct_money_time,t.ins_sta, t.deli_note, t.oper_time,t.exp_status,t.company_name,t.cover1,t.res_sta FROM (

            SELECT  t.*, row_number() over (PARTITION BY t.appno ORDER BY t.gro_id desc) as rownun  FROM (
                SELECT t.*,
                       tel.OPER_TIME,                                                       --递送返回日期
                       tel.EXP_STATUS FROM(                                                 --快递结果 递送状态
                   SELECT t.*,
                          tdi.DELI_NOTE FROM(                                               --递送备注
                    SELECT t.* ,tsh.INS_STA FROM(                                            --划账情况
                    SELECT t.* ,tsh.CHG_TIME AS DEDUCT_MONEY_TIME
                    FROM(                                                                   --扣款成功日期
                    SELECT t.* ,
                           tsh.CHG_TIME AS RETURN_INPUT_TIME
                    FROM(                                                                    --回执录入日期
                    SELECT t.* ,
                           tsh.CHG_TIME AS POLICY_CHG_TIME
                    FROM(                                                                   --保单递送日期

                        SELECT t.*,
                               tsh.CHG_TIME
                        FROM(                                                                --出单日期
                            SELECT t.*,
                                   cg.gro_id
                            FROM(
                                 SELECT t.*,
                                        shc.company_name
                                 FROM (
                                       SELECT ta.*,
                                              tac.name APP_NAME,                             --投保人姓名
                                              taca.adds_detail family_addr,                 --家庭地址
                                              tacc.con_value contact_tel                     --投保人固定电话
                                       FROM (

                                            SELECT ta.application_id,
                                                   ta.APPNO,                                 --投保单号
                                                   ta.POLICYNO,                             --保单号码
                                                   ta.IDORG,                                 --地区
                                                   ta.TSRID,                                 --座席工号
                                                   tad.APP_DATE,                             --成交日期
                                                   tapi.ins_code AS INSURANCE_CODE,         --险种代码

                                                   tad.fee_acc_no AS PAYMENT_ACCOUNT, --缴费账号
                                                   ta.acus_licno AS ID_NO,           --投保人证件号
                                                   ta.acus_mob AS APP_MOBILE,       --投保人手机
                                                   tapi.pay_typ AS PAYMENT_TYPE,     --缴费方式
                                                   tapi.pay_period AS COVER1,           --缴费年限
                                                   ta.total_fee AS SUMPRE,           --总保费
                                                   ta.reserv_status AS RES_STA,   --预约结果
                                                   tcar.app_customer_id

                                            FROM tb_application      ta,
                                                 tb_app_prd_info     tapi,
                                                 tb_app_dtl          tad,
                                                 tb_customer_app_rel tcar
                                            WHERE ta.application_id = tapi.application_id(+)
                                              AND ta.application_id = tad.application_id(+)
                                              AND ta.application_id = tcar.application_id(+)
                                               '  ||  SQLWHERESTRING || ') ta,
                                                  tb_application_customer tac,
                                                  tb_app_customer_adds taca,
                                                  tb_app_customer_contact tacc
                                        WHERE ta.app_customer_id = tac.app_customer_id(+)
                                          AND ta.app_customer_id = taca.app_customer_id(+)
                                          AND ta.app_customer_id = tacc.app_customer_id(+)
                                          AND tac.customer_typ = ''01''
                                          AND (ta.app_date BETWEEN '''|| START_DATE || ''' AND  '''|| END_DATE || ''' OR ta.app_date BETWEEN TO_CHAR(TO_DATE('''|| START_DATE || ''',''YYYY/MM/DD''),''YYYY/MM/DD'') AND  TO_CHAR(TO_DATE('''|| END_DATE || ''',''YYYY/MM/DD''),''YYYY/MM/DD'')
                                           OR (SUBSTR(TA.APP_DATE,-4)||''/''||SUBSTR(TA.APP_DATE,-7,2)||''/''||SUBSTR(TA.APP_DATE,1,2) BETWEEN TO_CHAR(TO_DATE('''|| START_DATE || ''',''YYYY/MM/DD''),''YYYY/MM/DD'') AND  TO_CHAR(TO_DATE('''|| END_DATE || ''',''YYYY/MM/DD''),''YYYY/MM/DD'')
                                               )
                                         )
                                          ) t,SHCPIC_COMPANY shc
                                 WHERE t.idorg=shc.company_code
                                 ) t,(SELECT cg.GRO_ID,c.use_ali_id
                                      FROM C_USE c,C_USE_GRO cg
                                      WHERE c.USE_ID = cg.USE_ID
                                      ) cg
                            WHERE t.tsrid=cg.use_ali_id(+)
                            ) t,(SELECT * FROM T_INS_STA_HIS WHERE ins_sta=''08'') tsh WHERE t.appno = tsh.ins_no(+)
                            ) t,(SELECT * FROM T_INS_STA_HIS WHERE ins_sta=''10'') tsh  WHERE t.appno = tsh.ins_no(+)
                            ) t,(SELECT * FROM T_INS_STA_HIS WHERE ins_sta=''15'') tsh  WHERE t.appno = tsh.ins_no(+)
                            ) t,(SELECT * FROM T_INS_STA_HIS WHERE ins_sta=''07'') tsh  WHERE t.appno = tsh.ins_no(+)
                            ) t,(SELECT * FROM T_INS_STA_HIS WHERE ins_sta=''06'') tsh  WHERE t.appno = tsh.ins_no(+)
                            ) t,  T_DELIVERY_INFO tdi
                        WHERE t.application_id = tdi.app_id(+)
                        ) t , (
                               SELECT *
                               FROM T_EXP_LOG) tel
                    WHERE t.appno = tel.ins_no(+))t
                    ) t
               WHERE t.rownun = 1';
               OPEN CURSOR_POLICY_INFO FOR SQLVAR;
END NEW_POLICY_INFO_EXPORT;
/

prompt
prompt Creating procedure NEW_XU_QI_POLICY_DATA
prompt ========================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.NEW_XU_QI_POLICY_DATA IS
  v_app_coverage             NUMBER(10) := 0; --保额
  v_insurance_name           VARCHAR2(100) := ''; --产品名称
  v_company_id               NUMBER(10) := 0; --公司ID
  v_rig_sta_des              VARCHAR2(64) := ''; --座席
  v_years                    NUMBER(20) := ''; --缴费期次
  v_cover1                   DATE := NULL; --缴费年限
  v_cover2                   DATE := NULL; --缴费中止期
  v_amount                   NUMBER(20, 4) := 0; --单期保费
  v_nextdate                 DATE := NULL; --下一缴费日期
  v_rectele                  VARCHAR2(30) := ''; --投保人缴费电话
  v_sprerec_years            NUMBER(20) := 0; --应缴期数
  v_pay_sum                  NUMBER(20) := 0; --已缴期数
  v_appdate                  DATE := NULL; --最近一次扣费时间
  v_status                   CHAR(2) := ''; --最近一次扣费结果/缴费状态
  v_reason                   VARCHAR2(200) := ''; --最近一次扣费失败原因
  v_payment_account_name     VARCHAR2(50) := ''; --缴费账户名
  v_payment_account_bankcode VARCHAR2(20) := ''; --开户银行
  v_payment_account          VARCHAR2(50) := ''; --缴费账号
  v_submit_date              DATE := NULL; --投保时间
  v_submit_str               VARCHAR2(50) := ''; --投保时间
  v_app_customer_id          NUMBER(20) := 0; --投保客户ID
  v_app_nm                   VARCHAR2(50) := ''; --投保人姓名
  v_contact_tel              VARCHAR2(50) := ''; --固定电话
  v_ins_id                   VARCHAR2(50) := ''; --险种代码
  v_pay_typ                  VARCHAR2(2) := ''; --激费方法;
  v_owed                     NUMBER(20) := 0; --欠缴期数
  v_owed_amount              NUMBER(20) := 0; --累计欠缴保费
  v_count                    NUMBER(20) := 0; --计数

  CURSOR c_app_table is
    SELECT ta.application_id,
           ta.idorg,
           ta.tsrid,
           ta.appno,
           ta.acus_mob,
           ta.acus_licno,
           ta.prj_id,
           ta.polist,
           ta.policyno,
           ta.opdate
      FROM (SELECT ta.application_id,
                   ta.idorg,
                   ta.tsrid,
                   ta.appno,
                   ta.acus_mob,
                   ta.acus_licno,
                   ta.prj_id,
                   r.polist,
                   r.policyno,
                   r.opdate,
                   row_number() OVER(PARTITION BY ta.appno ORDER BY r.opdate DESC) rownun
              FROM tb_application ta, xq_riskcon r
             WHERE ta.appno = r.appno
               AND ta.iaccept = '1') ta
     WHERE rownun = 1;

BEGIN
  --删除生效数据
  DELETE t_billing_info tb
   WHERE tb.app_no in
         (SELECT t.appno
            FROM (SELECT t.appno
                    FROM (SELECT t.appno, s.insurance_id
                            FROM (SELECT t.appno,
                                         t.idorg,
                                         r.policyno,
                                         tapi.ins_code AS ins_id
                                    FROM tb_application  t,
                                         xq_riskcon         r,
                                         tb_app_prd_info tapi
                                   WHERE t.appno = r.appno
                                     AND t.application_id = tapi.application_id
                                     AND t.iaccept = '1') t,
                                 SHCPIC_INSURANCE_TERM_CODE s
                           WHERE t.ins_id = s.insurance_code) t,
                         SHCPIC_INSURANCE s
                   WHERE t.insurance_id = s.id) t
           GROUP BY t.appno);
  COMMIT;
  FOR v_app_table in c_app_table LOOP
    BEGIN
       v_app_coverage := 0;
      FOR v_app_prd_info in (SELECT *
                               FROM tb_app_prd_info tapi
                              WHERE tapi.application_id =
                                    v_app_table.application_id) LOOP
        BEGIN
          --获取计算保额
          v_app_coverage := v_app_coverage + NVL(v_app_prd_info.amount, 0) *
                            NVL(v_app_prd_info.pieces, 0);
          v_ins_id       := v_app_prd_info.ins_code;
          v_pay_typ      := v_app_prd_info.pay_typ;
          --v_app_coverage:=v_app_coverage+v_app_prd_info.amount*v_app_prd_info.pieces;
        END;
      END LOOP;

      --获取产品名称
      SELECT (SELECT sins.name
                FROM SHCPIC_INSURANCE sins
               WHERE sins.id = (SELECT MAX(sitc.insurance_id)
                                  FROM SHCPIC_INSURANCE_TERM_CODE sitc
                                 WHERE v_ins_id = sitc.insurance_code
                                 GROUP BY sitc.insurance_code))
        INTO v_insurance_name
        FROM dual;
      --获取公司ID
      SELECT (SELECT sc.id
                FROM SHCPIC_COMPANY sc
               WHERE sc.company_code = v_app_table.idorg)
        INTO v_company_id
        FROM dual;
      --获取座席
      SELECT (SELECT c.rig_sta_des
                FROM (SELECT c.use_id, cr.rig_sta_des
                        FROM c_use c, C_RIG_STA cr
                       WHERE c.rig_sta_id = cr.rig_sta_id) c
               WHERE v_app_table.tsrid = to_char(c.use_id(+)))
        INTO v_rig_sta_des
        FROM dual;
      --获取 缴费期次 缴费年限 缴费中止期 单期保费
      SELECT COUNT(p.policyno)
        INTO v_count
        FROM prerec p
       WHERE p.policyno = v_app_table.policyno;
      IF v_count > 0 THEN
        SELECT nvl(p.years, 0), p.cover1, p.cover2, p.amount
          INTO v_years, v_cover1, v_cover2, v_amount
          FROM (SELECT nvl(p.years, 0) years,
                       p.cover1,
                       p.cover2,
                       p.amount,
                       row_number() OVER(PARTITION BY p.policyno ORDER BY p.years DESC) rownun --years，使用row_number() over进行分组
                  FROM prerec p
                 WHERE p.policyno = v_app_table.policyno) p
         WHERE rownun = 1;
      END IF;
      --获取 下一缴费日期 投保人缴费电话
      SELECT COUNT(m.policyno)
        INTO v_count
        FROM moneysch m
       WHERE m.policyno = v_app_table.policyno;
      IF v_count > 0 THEN
        SELECT m.nextdate, m.rectele
          INTO v_nextdate, v_rectele
          FROM (SELECT m.nextdate,
                       m.rectele,
                       row_number() OVER(PARTITION BY m.policyno ORDER BY m.nextdate DESC) rownun --nextdate，使用row_number() over进行分组
                  FROM moneysch m
                 WHERE m.policyno = v_app_table.policyno) m
         WHERE rownun = 1;
      END IF;
      --获取 应缴期数 已缴期数
      SELECT count(s.policyno)
        INTO v_count
        FROM sprerec s
       WHERE s.policyno = v_app_table.policyno;
      IF v_count > 0 then
        SELECT s.years, s.status, s.years - s.status
          INTO v_sprerec_years, v_pay_sum, v_owed
          FROM (SELECT s.years,
                       s.status,
                       row_number() OVER(PARTITION BY s.policyno ORDER BY s.status DESC) rownun --status，使用row_number() over进行分组
                  FROM sprerec s
                 WHERE s.policyno = v_app_table.policyno) s
         WHERE rownun = 1;
      END IF;
      --获取 最近一次扣费时间 最近一次扣费结果/缴费状态
      SELECT count(c.policyno)
        INTO v_count
        FROM charge_failure c
       WHERE c.policyno = v_app_table.policyno;
      IF v_count > 0 then
        SELECT c.appdate, c.status, c.reason
          INTO v_appdate, v_status, v_reason
          FROM (SELECT c.appdate,
                       c.status,
                       c.reason,
                       row_number() OVER(PARTITION BY c.policyno ORDER BY c.appdate DESC) rownun --status，使用row_number() over进行分组
                  FROM charge_failure c
                 WHERE c.policyno = v_app_table.policyno) c
         WHERE rownun = 1;
      END IF;
      --获取 缴费账户名 开户银行 缴费账号 投保时间
      SELECT COUNT(tad.application_id)
        INTO v_count
        FROM tb_app_dtl tad
       WHERE tad.application_id = v_app_table.application_id;
      IF v_count > 0 THEN
        BEGIN
          SELECT tad.fee_acc_nam,
                 tad.fee_acc_bank,
                 tad.fee_acc_no,
                 tad.app_date
            INTO v_payment_account_name,
                 v_payment_account_bankcode,
                 v_payment_account,
                 v_submit_str
            FROM tb_app_dtl tad
           WHERE tad.application_id = v_app_table.application_id;
          IF v_submit_str IS NOT NULL THEN
            BEGIN
              v_submit_date := to_date(v_submit_str, 'yyyy-mm-dd');
            EXCEPTION
              WHEN OTHERS THEN
                BEGIN
                  v_submit_date := to_date(v_submit_str, 'dd-mm-yyyy');
                END;
            END;
          END IF;
        END;
      END IF;
      --获取 客户表ID
      -- select tcar.app_customer_id
      --  into v_app_customer_id
      --  from tb_customer_app_rel tcar
      -- where tcar.application_id = v_app_table.application_id;

      --获取 投保人姓名,客户表ID
      SELECT count(tac.app_customer_id)
        INTO v_count
        FROM tb_customer_app_rel tar, tb_application_customer tac
       WHERE tar.application_id = v_app_table.application_id
         AND tar.app_customer_id = tac.app_customer_id
         AND tac.customer_typ = '01';
      IF v_count > 0 THEN
        SELECT tac.name, tac.app_customer_id
          INTO v_app_nm, v_app_customer_id
          FROM tb_customer_app_rel tar, tb_application_customer tac
         WHERE tar.application_id = v_app_table.application_id
           AND tar.app_customer_id = tac.app_customer_id
           AND tac.customer_typ = '01';
      END IF;
      -- select tac.name
      --        into v_app_nm
      --        from tb_application_customer tac
      --       where tac.app_customer_id = v_app_customer_id
      --         and tac.customer_typ = '01';

      --获取 投保人固定电话
      SELECT (SELECT tacc.con_value
                FROM tb_app_customer_contact tacc
               WHERE tacc.app_customer_id = v_app_customer_id
                 AND tacc.cus_con_typ_id = 1)
        INTO v_contact_tel
        FROM dual;
      --计算累计欠缴保费
      v_owed_amount := v_owed * v_amount;
      --插入表
      --dbms_output.put_line(v_app_table.appno);
      INSERT INTO t_billing_info
        (APP_NO,
         POLICYNO,
         POLIST,
         PAYMENT_TYPE,
         APP_NM,
         CONTACT_TEL,
         APP_MOBILE,
         INSURANCE_NAME,
         RIG_STA_DES,
         TSRID,
         PAYMENT_ACCOUNT_NAME,
         PAYMENT_ACCOUT_BANKCODE,
         PAYMENT_ACCOUNT,
         ID_NO,
         PRJ_ID,
         OPDATE,
         SUBMIT_DATE,
         COVERAGE,
         YEARS,
         COVER1,
         COVER2,
         AMOUNT,
         NEXTDATE,
         RECTELE,
         SPREREC_YEARS,
         PAY_SUM,
         INSURANCE_CODE,
         COMPANY_ID,
         OWED,
         OWED_AMOUNT,
         APPDATE,
         CHARGE_STATUS,
         REASON,
         OWED_STATUS)
      VALUES
        (v_app_table.appno,
         v_app_table.policyno,
         '1',
         v_pay_typ,
         v_app_nm,
         v_contact_tel,
         v_app_table.acus_mob,
         v_insurance_name,
         v_rig_sta_des,
         v_app_table.tsrid,
         v_payment_account_name,
         v_payment_account_bankcode,
         v_payment_account,
         v_app_table.acus_licno,
         v_app_table.prj_id,
         v_app_table.opdate,
         v_submit_date,
         v_app_coverage,
         v_years,
         v_cover1, --v_cover1
         v_cover2, --v_cover2
         v_amount, --v_amount
         v_nextdate, --v_nextdate
         v_rectele, --v_rectele
         v_sprerec_years, --v_sprerec_years
         v_pay_sum, --v_pay_sum
         v_ins_id, --v_ins_id
         v_company_id, --v_company_id
         v_owed, --v_owed
         v_owed_amount, --v_owed_amount
         v_appdate, --v_appdate
         v_status, --v_status
         v_reason, --v_reason
         v_status); --v_status
      --close c_app_prd_info;
      COMMIT;
    EXCEPTION
      WHEN OTHERS THEN
        -- 遇到异常做一些处理
        BEGIN
          dbms_output.put_line('data error :' || v_app_table.policyno);
        END;
    END;
  END LOOP;
  -- close c_app_table;
  -- 插入续期保单及生效保单一部
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    --没有发现数据
    --close c_app_table;
    dbms_output.put_line('NO_DATA_FOUND error');
    ROLLBACK;
  WHEN too_many_rows THEN
    --返回行数太多
    --close c_app_table;
    dbms_output.put_line('Return too many rows');
    ROLLBACK;
END NEW_XU_QI_POLICY_DATA;
/

prompt
prompt Creating procedure POLICY_INFO_EXPORT
prompt =====================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.POLICY_INFO_EXPORT(START_DATE VARCHAR2, END_DATE VARCHAR2, COMPANY_ID VARCHAR2, CURSOR_POLICY_INFO OUT CURSOR_POLICY_INFO_EXPORT.POLICY_INFO) IS

  START_CURRENT_DATE     DATE;
  END_CURRENT_DATE       DATE;

BEGIN
  IF START_DATE IS NULL THEN
    START_CURRENT_DATE := SYSDATE;
  ELSE
    START_CURRENT_DATE := TO_DATE(START_DATE,'YYYY-MM-DD');
  END IF;

  IF END_DATE IS NULL THEN
    END_CURRENT_DATE := SYSDATE;
  ELSE
    END_CURRENT_DATE := TO_DATE(END_DATE,'YYYY-MM-DD');
  END IF;

    START_CURRENT_DATE := START_CURRENT_DATE;  --开始时间
    END_CURRENT_DATE := END_CURRENT_DATE;      --结果时间

  OPEN CURSOR_POLICY_INFO FOR

          SELECT  t.id,t.appno,policyno,idorg, tsrid,firstcreate, t.insurance_code,t.app_name, t.payment_account,t.id_no,
               t.app_mobile,t.contact_tel,t.family_addr,t.payment_type,t.sumpre,t.gro_id, t.chg_time, t.policy_chg_time,
               t.return_input_time,t.deduct_money_time,t.ins_sta, t.deli_note, t.oper_time,t.exp_status,t.company_name,t.cover1 FROM (

            SELECT  t.*, row_number() over (partition by t.appno order by t.DEDUCT_MONEY_TIME desc) as rownun  FROM (
                SELECT t.*,
                       tel.OPER_TIME,             --递送返回日期
                       tel.EXP_STATUS FROM(       --快递结果 递送状态
                   SELECT t.*,
                          tdi.DELI_NOTE FROM(     --递送备注
                    SELECT t.* ,tsh.INS_STA FROM(          --划账情况  通过最后一次回盘接口传回的扣款情况判断
                    SELECT t.* ,tsh.CHG_TIME AS DEDUCT_MONEY_TIME FROM(         --扣款成功日期   精确到秒
                    SELECT t.* , tsh.CHG_TIME AS RETURN_INPUT_TIME FROM(      --回执录入日期   精确到秒
                    SELECT t.* ,tsh.CHG_TIME AS POLICY_CHG_TIME FROM(     --保单递送日期

                     SELECT t.*,
                            tsh.CHG_TIME FROM(                              ----出单日期   精确到秒
                       SELECT t.*, cg.gro_id FROM(
                       SELECT t.*,shc.company_name from (
                          SELECT t.id,
                                 t.APPNO, --投保单号
                                 t.POLICYNO, --保单号码
                                 t.IDORG, --地区
                                 t.TSRID, --座席工号
                                 t.FIRSTCREATE, --成交日期
                                SUBSTR(SUBSTR(t.contents,
                                        INSTR(t.contents, '|%|', 1, 47) + 3,
                                        INSTR(t.contents, '|%|', 1, 48) -
                                        INSTR(t.contents, '|%|', 1, 47) - 3),
                                 INSTR(SUBSTR(t.contents,
                                        INSTR(t.contents, '|%|', 1, 47) + 3,
                                        INSTR(t.contents, '|%|', 1, 48) -
                                        INSTR(t.contents, '|%|', 1, 47) - 3), '@', 1, 1) + 1,
                                 INSTR(SUBSTR(t.contents,
                                        INSTR(t.contents, '|%|', 1, 47) + 3,
                                        INSTR(t.contents, '|%|', 1, 48) -
                                        INSTR(t.contents, '|%|', 1, 47) - 3), '@',1,2) -
                                 INSTR(SUBSTR(t.contents,
                                        INSTR(t.contents, '|%|', 1, 47) + 3,
                                        INSTR(t.contents, '|%|', 1, 48) -
                                        INSTR(t.contents, '|%|', 1, 47) - 3), '@',1,1) - 1) as INSURANCE_CODE, ----险种代码 |%|47~47 @1~2
                                 SUBSTR(t.contents,
                                        INSTR(t.contents, '|%|', 1, 2) + 3,
                                        INSTR(t.contents, '|%|', 1, 3) -
                                        INSTR(t.contents, '|%|', 1, 2) - 3) as APP_NAME, --投保人姓名 |%|2~3
                                 SUBSTR(t.contents,
                                        INSTR(t.contents, '|%|', 1, 57) + 3,
                                        INSTR(t.contents, '|%|', 1, 58) -
                                        INSTR(t.contents, '|%|', 1, 57) - 3) as PAYMENT_ACCOUNT, --缴费账号 |%|57~58
                                 SUBSTR(t.contents,
                                        INSTR(t.contents, '|%|', 1, 5) + 3,
                                        INSTR(t.contents, '|%|', 1, 6) -
                                        INSTR(t.contents, '|%|', 1, 5) - 3) as ID_NO, --投保人证件号 |%|5~6
                                 SUBSTR(t.contents,
                                        INSTR(t.contents, '|%|', 1, 20) + 3,
                                        INSTR(t.contents, '|%|', 1, 21) -
                                        INSTR(t.contents, '|%|', 1, 20) - 3) as APP_MOBILE, --投保人手机 |%|20~21
                                 SUBSTR(t.contents,
                                        INSTR(t.contents, '|%|', 1, 18) + 3,
                                        INSTR(t.contents, '|%|', 1, 19) -
                                        INSTR(t.contents, '|%|', 1, 18) - 3) as CONTACT_TEL, --投保人固定电话 |%|18~19
                                 SUBSTR(t.contents,
                                        INSTR(t.contents, '|%|', 1, 16) + 3,
                                        INSTR(t.contents, '|%|', 1, 17) -
                                        INSTR(t.contents, '|%|', 1, 16) - 3) as FAMILY_ADDR, --家庭地址
                                 SUBSTR(SUBSTR(t.contents,
                                         INSTR(t.contents, '|%|', 1, 47) + 3,
                                         INSTR(t.contents, '|%|', 1, 48) -
                                         INSTR(t.contents, '|%|', 1, 47) - 3),
                                  INSTR(SUBSTR(t.contents,
                                         INSTR(t.contents, '|%|', 1, 47) + 3,
                                         INSTR(t.contents, '|%|', 1, 48) -
                                         INSTR(t.contents, '|%|', 1, 47) - 3), '@',1,6) + 1,
                                  INSTR(SUBSTR(t.contents,
                                         INSTR(t.contents, '|%|', 1, 47) + 3,
                                         INSTR(t.contents, '|%|', 1, 48) -
                                         INSTR(t.contents, '|%|', 1, 47) - 3),'@',1,7) -
                                  INSTR(SUBSTR(t.contents,
                                         INSTR(t.contents, '|%|', 1, 47) + 3,
                                         INSTR(t.contents, '|%|', 1, 48) -
                                         INSTR(t.contents, '|%|', 1, 47) - 3),'@', 1,6) - 1) AS PAYMENT_TYPE,  --缴费方式
                                 SUBSTR(SUBSTR(t.contents,
                                         INSTR(t.contents, '|%|', 1, 47) + 3,
                                         INSTR(t.contents, '|%|', 1, 48) -
                                         INSTR(t.contents, '|%|', 1, 47) - 3),
                                  INSTR(SUBSTR(t.contents,
                                         INSTR(t.contents, '|%|', 1, 47) + 3,
                                         INSTR(t.contents, '|%|', 1, 48) -
                                         INSTR(t.contents, '|%|', 1, 47) - 3),'@', 1, 7) + 1,
                                  INSTR(SUBSTR(t.contents,
                                         INSTR(t.contents, '|%|', 1, 47) + 3,
                                         INSTR(t.contents, '|%|', 1, 48) -
                                         INSTR(t.contents, '|%|', 1, 47) - 3), '@',1, 8) -
                                  INSTR(SUBSTR(t.contents,
                                         INSTR(t.contents, '|%|', 1, 47) + 3,
                                         INSTR(t.contents, '|%|', 1, 48) -
                                         INSTR(t.contents, '|%|', 1, 47) - 3), '@', 1, 7) - 1) AS COVER1,     --缴费年限
                                 SUBSTR(t.contents,
                                        INSTR(t.contents, '|%|', 1, 49) + 3,
                                        INSTR(t.contents, '|%|', 1, 50) -
                                        INSTR(t.contents, '|%|', 1, 49) - 3) as SUMPRE --总保费
                            FROM TB_APP t WHERE t.IACCEPT = '1'
                             AND TO_DATE(to_char(t.firstcreate, 'YYYY-MM-DD'),'YYYY-MM-DD') BETWEEN START_CURRENT_DATE AND END_CURRENT_DATE) t,SHCPIC_COMPANY shc where t.idorg=shc.company_code
                        ) t,(SELECT cg.GRO_ID,c.use_ali_id FROM (SELECt * FROM C_USE WHERE COMPANY_ID IN (COMPANY_ID)) c,C_USE_GRO cg WHERE c.USE_ID = cg.USE_ID AND c.RIG_STA_ID='3') cg  WHERE t.tsrid=cg.use_ali_id(+)
                      ) t,(SELECT * FROM T_INS_STA_HIS WHERE ins_sta='08') tsh WHERE t.appno = tsh.ins_no(+)
                      ) t,(SELECT * FROM T_INS_STA_HIS WHERE ins_sta='10') tsh  WHERE t.appno = tsh.ins_no(+)
                      ) t,(SELECT * FROM T_INS_STA_HIS WHERE ins_sta='15') tsh  WHERE t.appno = tsh.ins_no(+)
                      ) t,(SELECT * FROM T_INS_STA_HIS WHERE ins_sta='07') tsh  WHERE t.appno = tsh.ins_no(+)
                      ) t,(SELECT * FROM T_INS_STA_HIS WHERE ins_sta='06') tsh  WHERE t.appno = tsh.ins_no(+)
                   ) t,  T_DELIVERY_INFO tdi WHERE t.id = tdi.app_id(+)
                 ) t , (SELECT * FROM T_EXP_LOG WHERE exp_status  IN ('01','02','03','04','05','99')) tel WHERE t.appno = tel.ins_no(+))t
               ) t WHERE t.rownun = 1;

END POLICY_INFO_EXPORT;
/

prompt
prompt Creating procedure PROCEDURE_AUTOASSIGNACTIVECODE
prompt =================================================
prompt
create or replace procedure unicall.procedure_AutoAssignActiveCode( VI_personId in number, VI_companyId in number, VI_productId in number, VI_sourceType in varchar2 ) as
       v_active_code_id number(10):= 0 ;
       v_active_code_count number(10):=0;
       v_current_datetime varchar2(10) := to_char(sysdate+2,'yyyy-mm-dd');
begin
       --查看是否有可用激活码
       select count(1) into v_active_code_count from SHCPIC_PREINS_ACTIVE_CODE c where c.PRODUCT_CODE_ID  = VI_productId  and c.COMPANY_ID = VI_companyId and c.DISTRIBUTE_ID is null;
       if v_active_code_count > 0 then
          select c.id into v_active_code_id from SHCPIC_PREINS_ACTIVE_CODE c where c.PRODUCT_CODE_ID  = VI_productId and c.COMPANY_ID = VI_companyId and c.DISTRIBUTE_ID is null and rownum = 1 for update;
          if  v_active_code_id > 0 then
              if VI_sourceType = '01' then
                update SHCPIC_PREINS_ACTIVE_CODE c set c.distribute_id = 3 where c.id = v_active_code_id;
                update SHCPIC_PREINS_DISTRIBUTE e  set e.amount = e.amount + 1 where e.id = 3;
                update cpic_presentins_info_volumn n set n.actcode_id = v_active_code_id , n.app_startdt = v_current_datetime where n.id = VI_personId;
              elsif  VI_sourceType = '02' then
                update SHCPIC_PREINS_ACTIVE_CODE c set c.distribute_id = 3 where c.id = v_active_code_id;
                update SHCPIC_PREINS_DISTRIBUTE e  set e.amount = e.amount + 1 where e.id = 3;
                update cpic_presentins_info n set n.actcode_id = v_active_code_id , n.app_startdt = v_current_datetime where n.id = VI_personId;
              end if;
              commit;
         end if;
      end if;
end procedure_AutoAssignActiveCode;
/

prompt
prompt Creating procedure PROC_EXP_DATA
prompt ================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.PROC_EXP_data
(
  i_task_id in number
  ,i_exp_type in number default 0
  ,i_clumn_list in varchar2
  ,o_dt out SYS_REFCURSOR
  ,o_updated_rows out number
) as
v_sql varchar2(8000);
v_condition varchar2(2000);
v_start_time date:=sysdate;
v_source_type_code number(3);
v_lastCondition varchar2(100);
v_preCondition varchar2(2000);
v_errcode   number;
v_errmsg    varchar2(100);
begin
o_updated_rows:=0;
  select nvl(regexp_replace(lower(trim(task_condition)),'^(and( )+)*',''),' 1=1')
  ,fun_find_source(upper(task_condition)) into v_condition,v_source_type_code
  from tasks where id=i_task_id;
  insert into log_information(command_name, command_type, start_time,end_time,  update_number, condition_id)
VALUES('准备导出保全或电销', '导出保全或电销', v_start_time,systimestamp, 0, i_task_id);
  --增加默认过滤条件
  If I_Exp_Type=0 Then --只有清洗成功的才可以导出电销
  select substr(v_condition,instr(v_condition,'and rownum',1,1)) into v_lastCondition from dual;
  --dbms_output.put_line('v_lastCondition:'||v_lastCondition);
  select substr(v_condition,0,instr(v_condition,'and rownum',1,1)-1) into v_preCondition from dual;
  -- dbms_output.put_line('v_preCondition:'||v_preCondition);
    v_sql:=' from (with w_customer as(
  select cus.customer_id temp_customer_id from customer cus
  inner join d_branch_info d on cus.branch_code=d.branch_code
  inner join d_birthdate_month b on cus.BIRTHDATE_MONTH_DAY_CODE=b.BIRTHDATE_MONTH_DAY_CODE
  where (from_last_sale_time_code>2 or sale_status_code=0 and clear_status_code=3) and '||v_preCondition||'
  minus
  select customer_id from filter_red_black where dx_filter=1 and status=1
)
--获取客户信息
select cus.customer_id,replace(customer_name,'' '','''') customer_name,0 id_type,to_char(birthday,''yyyy-mm-dd'') birthday,gender_code
,marital_status,death_critical_illness,fax,family_zip_code,company_zip_code
,family_address,company_address,contact_address,company,job_name,email,cus.tel_code
,zone_code,cus.govern_id,city,p.policy_no,province,p.remark||cus.note note,to_char(any_date,''yyyy-mm-dd'') any_date,other_info_1
,other_info_2,other_info_3,other_info_5,other_info_4,cus.d_donation_code is_accept_donation
,t.family_phone,t.office_phone,t.mobile_phone,t.charge_phone,t.other_phone,b.bank_code,b.bank_name,b.bank_account,p.class_name
from w_customer w inner join customer cus on w.temp_customer_id=cus.customer_id
left join
(
  --获取保单信息
   select customer_id,policy_no,class_name,trim(class_code) class_code,charge_way,begin_date,rmk2 remark
  from(
    select t.*,f_catstring(t.rmk) over(partition by customer_id) rmk2
    from (
      select p.policy_holder_id customer_id,p.policy_no,p.class_name,p.class_code,p.charge_way,p.begin_date
      ,(''[''||trim(p.policy_no)||'';''||p.class_name||'';''||p.bank_name||'';''||trim(p.account_no)||'';''||p.charge_total_amount
      ||''元;{''||p.recognizee_holder_id||''}]'') rmk
      ,row_number()over (partition by p.policy_holder_id order by p.begin_date desc) rn
      from w_customer l inner join policy p on l.temp_customer_id=p.policy_holder_id

    ) t where rn<3
  )  where rn=1
) p on w.temp_customer_id=p.customer_id
left join
(
  --获取电话信息
  select customer_id,
  max(decode(rn,1,phone,null)) family_phone,
  max(decode(rn,2,phone,null)) office_phone,
  max(decode(rn,3,phone,null)) mobile_phone,
  max(decode(rn,4,phone,null)) charge_phone,
  max(decode(rn,5,phone,null)) other_phone
  from
  (
    select r.customer_id,r.phone,row_number()over (partition by customer_id order by phone desc) rn
    from w_customer l inner join customer_phone r on l.temp_customer_id=r.customer_id
    where not exists (select 1 from filter_red_black where dx_filter=1 and status=1 and telephone=r.phone)
  )
  group by customer_id
) t on w.temp_customer_id=t.customer_id
left join
(
  --获取银行信息
  select customer_id,bank_code,bank_name,bank_account from (
    select customer_id,bank_code,bank_name,account_no bank_account
    ,row_number() over (partition by customer_id order by account_no) rn
    from w_customer l inner join bank_accounts r
    on l.temp_customer_id=r.customer_id
  ) where rn=1
) b on w.temp_customer_id=b.customer_id
left join filter_class_code fcc on trim(p.class_code)=fcc.class_code and fcc.dx_filter=1 and fcc.status=1
 where fun_check_paycode(:source_type_code,p.charge_way,p.begin_date,:v_start_time)=1
 and fcc.class_code is null ) where 1=1 '||v_lastCondition||'';
--v_sql:='insert into temp_exp_rs('||regexp_replace(lower(trim(i_clumn_list)),'^( )+select( )+','')||')'||i_clumn_list||' from
v_sql:=i_clumn_list||v_sql;
dbms_output.put_line(v_sql);
open o_dt for v_sql using v_source_type_code,v_start_time;
  elsif I_Exp_Type=1 Then --只有无电话或清洗失败的,且不在保全中的客户才可以导出保全
    v_sql:=' from (with w_customer as(
  select cus.customer_id temp_customer_id from customer cus
  inner join d_branch_info d on cus.branch_code=d.branch_code
  inner join d_birthdate_month b on cus.BIRTHDATE_MONTH_DAY_CODE=b.BIRTHDATE_MONTH_DAY_CODE
  where clear_status_code in(0,4) and operation_status_code<>1 and '||v_condition||'
  minus
  select customer_id from filter_red_black where bq_filter=1 and status=1
)
--获取客户信息
select cus.customer_id,replace(customer_name,'' '','''') customer_name,0 id_type,to_char(birthday,''yyyy-mm-dd'') birthday,gender_code
,marital_status,death_critical_illness,fax,family_zip_code,company_zip_code
,family_address,company_address,contact_address,company,job_name,email,cus.tel_code
,zone_code,cus.govern_id,city,p.policy_no,province,p.remark||cus.note note,to_char(any_date,''yyyy-mm-dd'') any_date,other_info_1
,other_info_2,other_info_3,other_info_5,other_info_4,cus.d_donation_code is_accept_donation
,null family_phone,null office_phone,null mobile_phone,null charge_phone,null other_phone,null bank_name,null bank_account,p.class_name
from w_customer w inner join customer cus on w.temp_customer_id=cus.customer_id
left join
(
  --获取保单信息
   select customer_id,policy_no,class_name,class_code,charge_way,begin_date,rmk2 remark
  from(
    select t.*,f_catstring(t.rmk) over(partition by customer_id) rmk2
    from (
      select p.policy_holder_id customer_id,p.policy_no,p.class_name,p.class_code,p.charge_way,p.begin_date
      ,(''[''||trim(p.policy_no)||'';''||p.class_name||'';''||p.bank_name||'';''||trim(p.account_no)||'';''||p.charge_total_amount
      ||''元;{''||p.recognizee_holder_id||''}]'') rmk
      ,row_number()over (partition by p.policy_holder_id order by p.begin_date desc) rn
      from w_customer l inner join policy p on l.temp_customer_id=p.policy_holder_id

    ) t where rn<3
  )  where rn=1
) p on w.temp_customer_id=p.customer_id
where fun_check_paycode(:source_type_code,p.charge_way,p.begin_date,:v_start_time)=1)';
--v_sql:='insert into temp_exp_rs('||regexp_replace(lower(trim(i_clumn_list)),'^( )+select( )+','')||')'||i_clumn_list||' from
v_sql:=i_clumn_list||v_sql;
dbms_output.put_line(v_sql);
open o_dt for v_sql using v_source_type_code,v_start_time;
end if;
exception
  when others then
   v_errcode   :=   sqlcode;
   v_errmsg   :=   substr(sqlerrm,1,100);
   dbms_output.put_line( 'error   code   is '   ||   v_errcode   ||   '   error   message   is '   ||   v_errmsg);
  o_updated_rows:= -1;
  insert into log_information(command_name, command_type, start_time,end_time,  update_number, condition_id)
  VALUES('导出保全或电销; error   code   is '   ||   v_errcode, '错误,error   message   is '   ||   v_errmsg, v_start_time,systimestamp, o_updated_rows, i_task_id);
commit;
end;
/

prompt
prompt Creating procedure PRO_REQLES_205_01
prompt ====================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.PRO_REQLES_205_01 IS
  --7月电销承保
  CURSOR CUR_RISKCON IS
    SELECT *
      FROM IDSALL_RISKCON
     WHERE BEGDATE >= TO_DATE('2012-07-01', 'yyyy-mm-dd')
       AND BEGDATE <= TO_DATE('2012-07-31', 'yyyy-mm-dd')
       AND SALEATTR IN ('61', '62', '63', '64');

  REC_RISKCON  IDSALL_RISKCON%ROWTYPE;
  REC_TBL      TBL_REQLES_205_01%ROWTYPE;
  VAR_PAYCODE  IDSALL_PREREC.PAYCODE%TYPE;
  VAR_SETCODE  IDSALL_PREREC.SETCODE%TYPE;
  VAR_BANKCODE IDSALL_CHARGE_FAILURE.BANKCODE%TYPE;

BEGIN
  OPEN CUR_RISKCON;
  LOOP
    FETCH CUR_RISKCON
      INTO REC_RISKCON;
    EXIT WHEN CUR_RISKCON%NOTFOUND;
/

prompt
prompt Creating procedure PRO_TASK_AUTO_ALLOCATION
prompt ===========================================
prompt
create or replace procedure unicall.pro_task_auto_allocation(userAliId   in varchar2,
                                                     userOrgId   in number,
                                                     result_flag out varchar2) as

  type my_array is table of c_use%Rowtype index by binary_integer;
  v_my_array   my_array;
  v_user_count number := 0;
  v_count      number := 1;
  v_allocation_count number :=0; -- 上次分配到的坐席位置
  v_sql varchar2(2000) := '';

  cursor cur_reserve_task is
    select *
      from tb_reserve_task t
     where t.status in (1001,1003,1004)
       and t.dx_org_id = userOrgId
       and t.is_close = '0'
       and t.use_ali_id is null;
begin

  result_flag := '1';

  -- 查询出主管所属电销中心下的预约坐席
  select * bulk collect into v_my_array from c_use t where 1 = 1 and not exists
  (select 1 from c_use_par p where p.cat_id in (802007, 802008, 802009) and p.val = '1' and p.use_id = t.use_id)
   and t.use_flag = '2'
   and t.org_id = userOrgId
   order by t.use_id;

 v_user_count := v_my_array.count;
 v_sql  := 'select count(*) from c_use t where  t.is_allocation = 1 and not exists (select 1 from c_use_par p where p.cat_id in (802007, 802008, 802009) and p.val = '||''''||'1'||''''||' and p.use_id = t.use_id) and t.use_flag = '||''''||'2'||''''||' and t.org_id = '||userOrgId;

 execute immediate v_sql into v_allocation_count;
 v_count := v_allocation_count + 1;

  for c_reserve_task in cur_reserve_task loop
    if cur_reserve_task%notfound then
      exit;
    end if;

    begin
    update tb_reserve_task t set t.use_ali_id   = v_my_array(v_count).use_ali_id, t.task_use_ali = userAliId,t.task_date = sysdate where t.id = c_reserve_task.id;
    Exception
      when others then
         result_flag := '0';
        exit;
      end;

   if v_count = v_user_count then
      v_count := 1;
    else
      v_count := v_count + 1;
    end if;
  end loop;

  -- 更新坐席信息 标记分配到此坐席
  -- 如果预约坐席只有一个 is_allocation = 0
  if v_user_count = 1 then
    begin
    update c_use t set t.is_allocation = 0 where t.use_ali_id = v_my_array(v_user_count).use_ali_id ;
     Exception
      when others then
        result_flag := '0';
      end;
  else
    begin
    for i in v_count..v_my_array.count loop
      update c_use t set t.is_allocation = 0 where t.use_id = v_my_array(i).use_id ;
     end loop ;

     for i in 1..(v_count-1) loop
      update c_use t set t.is_allocation = 1 where t.use_id = v_my_array(i).use_id ;
     end loop;
      Exception
      when others then
         result_flag := '0';
      end;
  end if;

  if result_flag = '1' then
     commit;
  else
    rollback;
    end if;

end;
/

prompt
prompt Creating procedure P_ACCEPT_INS
prompt ===============================
prompt
create or replace procedure unicall.p_accept_ins(para_date date) is
  v_current_datetime date;
begin
  if para_date is null then
    v_current_datetime := sysdate;
  else
    v_current_datetime := para_date;
  end if;

  delete rpt_accept_ins_day
   where substr(T_ARCHIVE, 0, 10) =
         to_char(v_current_datetime, 'yyyy-mm-dd');

  insert into rpt_accept_ins_day
    (useid,
     usename,
     payway,
     year_fare,
     policyno,
     appno,
     d_insure_name,
     create_time,
     accept_time,
     product_id,
     product_name,
     campaign_id,
     campaign_name,
     T_ARCHIVE)
    select (select u.use_ali_id from c_use u where u.use_id = t.user_id) as useid, --座席ID
           (select u.use_nam from c_use u where u.use_id = t.user_id) usename, --座席姓名
           -- 1 as event,--事件
           (select pro.element_value_name
              from shcpic_product_result pro
             where pro.proposal_form_id = t.id
               and pro.element_id = 91) as payway, --缴费方式
           --1 as first_fare,--首期保费
           --1 as year_fare,--年保费
           price as year_fare, --年总保费
           t.policyno as policyno, --保单号
           t.appno, --投保单号
           t.d_insure_name as d_insure_name, --被保人姓名
           t.createtime as create_time, --受理日期
           t.app_accept_time as accept_time, --承保日期
           
           (select product.id
              from shcpic_product product
             where product.id in
                   (select pro2.pro_product_id
                      from shcpic_product_result pro2
                     where pro2.proposal_form_id = t.id)) as product_id, --产品ID
           
           (select product.name
              from shcpic_product product
             where product.id in
                   (select pro2.pro_product_id
                      from shcpic_product_result pro2
                     where pro2.proposal_form_id = t.id)) as product_name, --产品名称
           (select obcom.ob_com_id
              from c_ob_com obcom
             where obcom.ob_com_id =
                   (select OB_Com_Id
                      from c_ob_com_cus ob
                     where ob.c_ob_com_cus_id = t.c_ob_com_cus_id)) as campaign_id, --活动ID
           (select obcom.ob_com_nam
              from c_ob_com obcom
             where obcom.ob_com_id =
                   (select OB_Com_Id
                      from c_ob_com_cus ob
                     where ob.c_ob_com_cus_id = t.c_ob_com_cus_id)) as campaign_name, --活动名称
           to_char(v_current_datetime, 'YYYY-MM-DD HH24:MI:SS')
      from shcpic_proposal_form_result t
     where to_char(to_date(t.app_latest_time, 'YYYY-MM-DD HH24:MI:SS'),
                   'yyyy-mm-dd') =
           to_char(v_current_datetime, 'yyyy-mm-dd')-- 当天更新过状态的(为了记录存档日期,分成多次插入数据表)
       and not (t.app_accept_time is null)          -- 承保过的
       and not exists                               -- 未计入报表的
     (select 1 from rpt_accept_ins_day r where r.appno = t.appno);
  commit;    
end;
/

prompt
prompt Creating procedure P_APP_STATUS_UPDATE
prompt ======================================
prompt
create or replace procedure unicall.p_app_status_update(para_date date) is
  v_current_datetime date;

  v_idapp              number(20) := 0; --电销系统ID
  v_id_checkpoint_type varchar(4) := ''; --环节类型
  v_checktime          varchar(20) := ''; -- 状态时间（承保、退保等）
  v_lastupdate         varchar(20) := ''; --更新时间
  cur                  types.cursorType; --select  appno,policyno into v_appno,v_policyno from shcpic_tb_app  where idDMsystem=v_idapp;

begin
  if para_date is null then
    v_current_datetime := sysdate;
  else
    v_current_datetime := para_date;
  end if;

  open cur for
    select tb.iddmsystem,
           t.id_checkpoint_type,
           to_char(t.lastupdate, 'YYYY-MM-DD HH24:MI:SS'),
           to_char(t.checkpointtime, 'YYYY-MM-DD HH24:MI:SS')
      from tb_app_checkpoint t, tb_app tb
     where tb.id = t.idapp
       and to_char(t.lastupdate, 'YYYY-MM-DD') =
           to_char(v_current_datetime, 'YYYY-MM-DD')
       and t.recordstatus = 1
     order by t.idapp asc, t.id_checkpoint_type asc;

  loop
    fetch cur
      into v_idapp, v_id_checkpoint_type, v_lastupdate, v_checktime;
    exit when cur%notfound;
    if v_id_checkpoint_type in ('1003') then
      update shcpic_proposal_form_result
         set id_checkpoint_type = v_id_checkpoint_type,
             app_latest_status  = v_id_checkpoint_type,
             app_latest_time    = v_lastupdate,
             app_accept_status  = v_id_checkpoint_type,
             app_accept_time    = v_checktime
       where id = v_idapp;
    
    elsif v_id_checkpoint_type in ('3001', '3002') then
      update shcpic_proposal_form_result
         set id_checkpoint_type = v_id_checkpoint_type,
             app_latest_status  = v_id_checkpoint_type,
             app_latest_time    = v_lastupdate,
             app_quit_status    = v_id_checkpoint_type,
             app_quit_time      = v_checktime
       where id = v_idapp;
    else
      update shcpic_proposal_form_result
         set id_checkpoint_type = v_id_checkpoint_type,
             app_latest_status  = v_id_checkpoint_type,
             app_latest_time    = v_lastupdate
       where id = v_idapp;
    end if;
  end loop;
  close cur;
  commit;
EXCEPTION
  when NO_DATA_FOUND then
    close cur;
    dbms_output.put_line('NO_DATA_FOUND error');
    rollback;
  when too_many_rows then
    close cur;
    dbms_output.put_line('返回值多行');
    rollback;
  when others then
    close cur;
    dbms_output.put_line('others error');
    rollback;
  
end;
/

prompt
prompt Creating procedure P_XQ_LOG_ERR
prompt ===============================
prompt
create or replace procedure unicall.P_XQ_LOG_ERR(ModuleName    varchar2, --模块名称
                                        ProcedureName varchar2, --存储过程名称
                                        SucAmount     number, --成功记录数
                                        ErrAmount     number, --失败记录数
                                        UpdateAmount  number, --更新记录数
                                        OtherAmount   VARCHAR2, --其他操作记录信息
                                        ErrorContent  VARCHAR2 --错误详细内容
                                        ) is
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_LOG_IN
  *  建立日期   ：2012-06-19
  *  作者       ：yangguoqi
  *  模块       ：日志管理模块
  *  描述       ：存储过程中日志
  *  调用方式例如：
  *  p_xq_log_err('IDS','P_XQ_PERSON_IN_EVERY_DAY',12,0,8,'数据丢失4条',sqlerrm);
  *  p_xq_log_err('IDS','P_XQ_PERSON_IN_EVERY_DAY',12,0,8,'数据丢失4条','全局异常 ERROR 主键唯一性约束');
  *----------------------------------------------------
  *  修改历史   日期    修改人    修改原因
  *  1
  *  2
  ******************************************************
  */
  v_excutesql    VARCHAR2(4000); --执行sql语句
  v_sno          VARCHAR2(20); --主键
  v_otherAmount  VARCHAR2(500); --其他操作记录信息
  v_errorContent VARCHAR2(4000); --错误信息

begin
  select t.nextvalue+1 into v_sno from c_id_bro t where t.name = 'xq_log';
  if length(OtherAmount) > 500 then
      v_otherAmount := substr(OtherAmount, 0, 500);
    else
      v_otherAmount:=OtherAmount;
  end if;

  if length(ErrorContent) > 4000 then
      v_errorContent := substr(ErrorContent, 0, 500);
    else
      v_errorContent:=ErrorContent;
  end if;
  --使用占位符来提高Oracle PGA的使用率
  v_excutesql := 'insert into xq_log(sno,module,
          logtype,
          procedurename,
          sucamount,
          erramount,
          updateamount,
          otheramount,
          state,
          errorcontent,
          createtime,
          createuser,
          updatetime) values(:sno,:module,
          :logtype,
          :procedurename,
          :sucamount,
          :erramount,
          :updateamount,
          :otheramount,
          :state,
          :errorcontent,
          :createtime,
          :createuser,
          :updatetime)';
  execute immediate v_excutesql
    using v_sno, ModuleName, 'proc', ProcedureName, SucAmount, ErrAmount, UpdateAmount, v_otherAmount, '0', v_errorContent, sysdate, 'sys_unicall', sysdate;

  commit;--提交数据行

  update c_id_bro t set t.nextvalue = v_sno where t.name = 'xq_log';
  commit;

EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;
      dbms_output.put_line('p_xq_log_in 全局异常 ERROR' || sqlerrm);
    end;
end P_XQ_LOG_ERR;
/

prompt
prompt Creating procedure P_XQ_LOG_IN_ERR
prompt ==================================
prompt
create or replace procedure unicall.P_XQ_LOG_IN_ERR(ModuleName    varchar2, --模块名称
                                        ProcedureName varchar2, --存储过程名称
                                        OtherAmount   VARCHAR2, --其他操作记录信息 记录错误记录主键
                                        ErrorContent  VARCHAR2 --错误详细内容
                                        ) is
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_LOG_IN_ERR
  *  建立日期   ：2012-06-19
  *  作者       ：yangguoqi
  *  模块       ：日志管理模块
  *  描述       ：存储过程中错误日志
  *  调用方式例如：
  *  p_xq_log_in_err('IDS','P_XQ_PERSON_IN_EVERY_DAY','Ac00011',sqlerrm);
  *  p_xq_log_in_err('IDS','P_XQ_PERSON_IN_EVERY_DAY','Ac00011','全局异常 ERROR 主键唯一性约束');
  *----------------------------------------------------
  *  修改历史   日期    修改人    修改原因
  *  1
  *  2
  ******************************************************
  */
  v_excutesql    VARCHAR2(4000); --执行sql语句
  v_sno          VARCHAR2(20); --主键
  v_otherAmount  VARCHAR2(4000); --其他操作记录信息
  v_errorContent VARCHAR2(4000); --错误信息

begin
  select t.nextvalue+1 into v_sno from c_id_bro t where t.name = 'xq_log';
  if length(OtherAmount) > 4000 then
      v_otherAmount := substr(OtherAmount, 0, 4000);
    else
      v_otherAmount:=OtherAmount;
  end if;

  if length(ErrorContent) > 4000 then
      v_errorContent := substr(ErrorContent, 0, 4000);
    else
      v_errorContent:=ErrorContent;
  end if;
  --使用占位符来提高Oracle PGA的使用率
  v_excutesql := 'insert into xq_log(sno,module,
          logtype,
          procedurename,
          sucamount,
          erramount,
          updateamount,
          otheramount,
          state,
          errorcontent,
          createtime,
          createuser,
          updatetime) values(:sno,:module,
          :logtype,
          :procedurename,
          :sucamount,
          :erramount,
          :updateamount,
          :otheramount,
          :state,
          :errorcontent,
          :createtime,
          :createuser,
          :updatetime)';
  execute immediate v_excutesql
    using v_sno, ModuleName, 'proc', ProcedureName, 0, 1, 0, v_otherAmount, '3', v_errorContent, sysdate, 'sys_unicall', sysdate;

  commit;--提交数据行

  update c_id_bro t set t.nextvalue = v_sno where t.name = 'xq_log';
  commit;

EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;
      dbms_output.put_line('P_XQ_LOG_IN_ERR 全局异常 ERROR' || sqlerrm);
    end;
end P_XQ_LOG_IN_ERR;
/

prompt
prompt Creating procedure P_XQ_LOG_SUC
prompt ===============================
prompt
create or replace procedure unicall.P_XQ_LOG_SUC(ModuleName    varchar2, --模块名称
                                        ProcedureName varchar2, --存储过程名称
                                        SucAmount     number, --成功插入记录数
                                        ErrAmount     number, --失败记录数
                                        UpdateAmount  number, --更新记录数
                                        OtherAmount   VARCHAR2, --其他操作记录信息
                                        ErrorContent  VARCHAR2 --错误详细内容
                                        ) is
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_LOG_IN
  *  建立日期   ：2012-06-19
  *  作者       ：yangguoqi
  *  模块       ：日志管理模块
  *  描述       ：存储过程中日志
  *  调用方式例如：
  *  p_xq_log_suc('IDS','P_XQ_PERSON_IN_EVERY_DAY',12,0,8,'数据丢失4条',sqlerrm);
  *  p_xq_log_suc('IDS','P_XQ_PERSON_IN_EVERY_DAY',12,0,8,'数据丢失4条','全局异常 ERROR 主键唯一性约束');
  *----------------------------------------------------
  *  修改历史   日期    修改人    修改原因
  *  1
  *  2
  ******************************************************
  */
  v_excutesql    VARCHAR2(4000); --执行sql语句
  v_sno          VARCHAR2(20); --主键
  v_otherAmount  VARCHAR2(500); --其他操作记录信息
  v_errorContent VARCHAR2(4000); --错误信息

begin
  select t.nextvalue+1 into v_sno from c_id_bro t where t.name = 'xq_log';
  if length(OtherAmount) > 500 then
      v_otherAmount := substr(OtherAmount, 0, 500);
    else
      v_otherAmount:=OtherAmount;
  end if;

  if length(ErrorContent) > 4000 then
      v_errorContent := substr(ErrorContent, 0, 500);
    else
      v_errorContent:=ErrorContent;
  end if;
  --使用占位符来提高Oracle PGA的使用率
  v_excutesql := 'insert into xq_log(sno,module,
          logtype,
          procedurename,
          sucamount,
          erramount,
          updateamount,
          otheramount,
          state,
          errorcontent,
          createtime,
          createuser,
          updatetime) values(:sno,:module,
          :logtype,
          :procedurename,
          :sucamount,
          :erramount,
          :updateamount,
          :otheramount,
          :state,
          :errorcontent,
          :createtime,
          :createuser,
          :updatetime)';
  execute immediate v_excutesql
    using v_sno, ModuleName, 'proc', ProcedureName, SucAmount, ErrAmount, UpdateAmount, v_otherAmount, '1', v_errorContent, sysdate, 'sys_unicall', sysdate;

  commit;--提交数据行

  update c_id_bro t set t.nextvalue = v_sno where t.name = 'xq_log';
  commit;

EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;
      dbms_output.put_line('p_xq_log_in 全局异常 ERROR' || sqlerrm);
    end;
end P_XQ_LOG_SUC;
/

prompt
prompt Creating procedure P_BANKCOMM_APP_NB_IN
prompt =======================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_BANKCOMM_APP_NB_IN IS
  /*
  ******************************************************
  *  存储过程名 ：P_BANKCOMM_APP_NB_IN
  *  建立日期   ：2012-09-12
  *  作者       ：QINYUNLONG
  *  模块       ：IDS
  *  描述       ：批量处理APP_NB
  */
  V_UPDATE_ROWS NUMBER(18) := 0;
  V_INSERT_ROWS NUMBER(18) := 0;
  V_ERROR_ROWS  NUMBER(18) := 0;

  V_SNO     NUMBER(18) := 0;
  V_BEGTIME NUMBER(11) := 0;
  COUN_ID   NUMBER(18) := 0;

  TIME_BEFORE BINARY_INTEGER := DBMS_UTILITY.GET_TIME; --过程开始时间(毫秒)
  TIME_AFTER  BINARY_INTEGER; --过程结束时间(毫秒)

  V_MINTSTAMP DATE; --最小日期TIMESTAMP
  V_MAXTSTAMP DATE; --最大日期TIMESTAMP
  V_MINDATE   DATE; --最小日期
  V_MAXDATE   DATE; --最大日期

  CURSOR CUR_INFO(STARTDATE DATE, ENDDATE DATE) IS
    SELECT *
      FROM APP_NB C
     WHERE C.ETL_TIME >= STARTDATE
       AND C.ETL_TIME < ENDDATE
       AND C.SALEATTR = '61'
       AND C.AGT_NO IN (SELECT B.EMPNO FROM TB_BANKCOMM_EMPNO B);

  V_INFO CUR_INFO%ROWTYPE;

BEGIN
  --查询临时表最大和最小日期
  SELECT MIN(TEM.ETL_TIME), MAX(TEM.ETL_TIME)
    INTO V_MINTSTAMP, V_MAXTSTAMP
    FROM APP_NB TEM;
  V_MINDATE := TO_DATE(TO_CHAR(V_MINTSTAMP, 'YYYY-MM-DD'), 'YYYY-MM-DD');
  V_MAXDATE := TO_DATE(TO_CHAR(V_MAXTSTAMP, 'YYYY-MM-DD'), 'YYYY-MM-DD');

  SELECT B.NEXTVALUE
    INTO COUN_ID
    FROM C_ID_BRO B
   WHERE B.NAME = 'bankcomm_app_nb';

  LOOP
    EXIT WHEN V_MINDATE > V_MAXDATE OR V_MINDATE IS NULL;

    OPEN CUR_INFO(V_MINDATE, V_MINDATE + 1);
    LOOP
      FETCH CUR_INFO
        INTO V_INFO;
      EXIT WHEN CUR_INFO%NOTFOUND;

      SELECT (SELECT B.SNO
                FROM BANKCOMM_APP_NB B
               WHERE B.APPNO = V_INFO.APPNO
                 AND B.CLASSCODE = V_INFO.CLASSCODE
                 AND ROWNUM = 1)
        INTO V_SNO
        FROM DUAL;

      IF V_SNO > 0 THEN
        SELECT (SELECT B.BEGTIME
                  FROM BANKCOMM_APP_NB B
                 WHERE B.APPNO = V_INFO.APPNO
                   AND B.CLASSCODE = V_INFO.CLASSCODE
                   AND ROWNUM = 1)
          INTO V_BEGTIME
          FROM DUAL;

        IF V_INFO.BEGTIME > V_BEGTIME THEN
          --UPDATE
          BEGIN

            UPDATE BANKCOMM_APP_NB A
               SET A.TYPEID                = V_INFO.TYPEID,
                   A.STATUS                = V_INFO.STATUS,
                   A.PROCDATE              = V_INFO.PROCDATE,
                   A.ABSTR                 = V_INFO.ABSTR,
                   A.APPDATE               = V_INFO.APPDATE,
                   A.CON_ID                = V_INFO.CON_ID,
                   A.POLICYNO              = V_INFO.POLICYNO,
                   A.OPDATE                = V_INFO.OPDATE,
                   A.OPERID                = V_INFO.OPERID,
                   A.OPERNO                = V_INFO.OPERNO,
                   A.OPER_ROLE             = V_INFO.OPER_ROLE,
                   A.PIECES                = V_INFO.PIECES,
                   A.YEARNUM               = V_INFO.YEARNUM,
                   A.SALEATTR              = V_INFO.SALEATTR,
                   A.AGT_RP_ID             = V_INFO.AGT_RP_ID,
                   A.AGT_RP_TYPE           = V_INFO.AGT_RP_TYPE,
                   A.AGT_NO                = V_INFO.AGT_NO,
                   A.OWNER_RP_ID           = V_INFO.OWNER_RP_ID,
                   A.OWNER_RP_TYPE         = V_INFO.OWNER_RP_TYPE,
                   A.OWNER_ID              = V_INFO.OWNER_ID,
                   A.INSURED_RP_ID         = V_INFO.INSURED_RP_ID,
                   A.INSURED_RP_TYPE       = V_INFO.INSURED_RP_TYPE,
                   A.INSURED_ID            = V_INFO.INSURED_ID,
                   A.OWNER_INSURED_RLSHIP  = V_INFO.OWNER_INSURED_RLSHIP,
                   A.RIDER_IND             = V_INFO.RIDER_IND,
                   A.PREM_START_DATE       = V_INFO.PREM_START_DATE,
                   A.PREM_END_DATE         = V_INFO.PREM_END_DATE,
                   A.REC_POSTAL_CODE       = V_INFO.REC_POSTAL_CODE,
                   A.REC_ADDR              = V_INFO.REC_ADDR,
                   A.REC_TEL               = V_INFO.REC_TEL,
                   A.PREM_FRQ              = V_INFO.PREM_FRQ,
                   A.PREM_MTHD             = V_INFO.PREM_MTHD,
                   A.STD_PIECE_PREM        = V_INFO.STD_PIECE_PREM,
                   A.STD_ADD_PIECE_PREM    = V_INFO.STD_ADD_PIECE_PREM,
                   A.NONSTD_ADD_PIECE_PREM = V_INFO.NONSTD_ADD_PIECE_PREM,
                   A.AGT_PHONE             = V_INFO.AGT_PHONE,
                   A.SALE_TYPE             = V_INFO.SALE_TYPE,
                   A.SALE_PROD_CODE        = V_INFO.SALE_PROD_CODE,
                   A.APP_AGE               = V_INFO.APP_AGE,
                   A.BEGTIME               = V_INFO.BEGTIME,
                   A.ENDTIME               = V_INFO.ENDTIME,
                   A.BRANCH                = V_INFO.BRANCH,
                   A.ETL_TIME              = V_INFO.ETL_TIME,
                   A.SRC_SYS               = V_INFO.SRC_SYS,
                   A.APP_CONFIRM_NO        = V_INFO.APP_CONFIRM_NO,
                   A.APP_TERMINAL_ID       = V_INFO.APP_TERMINAL_ID,
                   A.CROSS_SALE_IND        = V_INFO.CROSS_SALE_IND,
                   A.SUB_SALE_TYPE         = V_INFO.SUB_SALE_TYPE,
                   A.CSTMZD_RCMD_NO        = V_INFO.CSTMZD_RCMD_NO,
                   A.UPDATE_TIME           = SYSDATE,
                   A.MARK_STATE            = '2'

             WHERE A.SNO = V_SNO;

            V_UPDATE_ROWS := V_UPDATE_ROWS + 1;

          EXCEPTION
            WHEN OTHERS THEN
              V_ERROR_ROWS := V_ERROR_ROWS + 1;
              -- 遇到异常做一些处理
              BEGIN
                P_XQ_LOG_IN_ERR('IDS',
                                'P_BANKCOMM_APP_NB_IN',
                                'APPNO=' || V_INFO.APPNO || '   CLASSCODE=' ||
                                V_INFO.CLASSCODE,
                                '更新表BANKCOMM_APP_NB数据' || SQLERRM);
              END;
          END;
        END IF;
      ELSE

        COUN_ID := COUN_ID + 1;

        BEGIN

          INSERT INTO BANKCOMM_APP_NB
            (SNO,
             TYPEID,
             STATUS,
             PROCDATE,
             ABSTR,
             APPDATE,
             APPNO,
             CON_ID,
             POLICYNO,
             CLASSCODE,
             OPDATE,
             OPERID,
             OPERNO,
             OPER_ROLE,
             PIECES,
             YEARNUM,
             SALEATTR,
             AGT_RP_ID,
             AGT_RP_TYPE,
             AGT_NO,
             OWNER_RP_ID,
             OWNER_RP_TYPE,
             OWNER_ID,
             INSURED_RP_ID,
             INSURED_RP_TYPE,
             INSURED_ID,
             OWNER_INSURED_RLSHIP,
             RIDER_IND,
             PREM_START_DATE,
             PREM_END_DATE,
             REC_POSTAL_CODE,
             REC_ADDR,
             REC_TEL,
             PREM_FRQ,
             PREM_MTHD,
             STD_PIECE_PREM,
             STD_ADD_PIECE_PREM,
             NONSTD_ADD_PIECE_PREM,
             AGT_PHONE,
             SALE_TYPE,
             SALE_PROD_CODE,
             APP_AGE,
             BEGTIME,
             ENDTIME,
             BRANCH,
             ETL_TIME,
             SRC_SYS,
             APP_CONFIRM_NO,
             APP_TERMINAL_ID,
             CROSS_SALE_IND,
             SUB_SALE_TYPE,
             CSTMZD_RCMD_NO,
             CREATE_TIME,
             MARK_STATE)
          VALUES
            (COUN_ID,
             V_INFO.TYPEID,
             V_INFO.STATUS,
             V_INFO.PROCDATE,
             V_INFO.ABSTR,
             V_INFO.APPDATE,
             V_INFO.APPNO,
             V_INFO.CON_ID,
             V_INFO.POLICYNO,
             V_INFO.CLASSCODE,
             V_INFO.OPDATE,
             V_INFO.OPERID,
             V_INFO.OPERNO,
             V_INFO.OPER_ROLE,
             V_INFO.PIECES,
             V_INFO.YEARNUM,
             V_INFO.SALEATTR,
             V_INFO.AGT_RP_ID,
             V_INFO.AGT_RP_TYPE,
             V_INFO.AGT_NO,
             V_INFO.OWNER_RP_ID,
             V_INFO.OWNER_RP_TYPE,
             V_INFO.OWNER_ID,
             V_INFO.INSURED_RP_ID,
             V_INFO.INSURED_RP_TYPE,
             V_INFO.INSURED_ID,
             V_INFO.OWNER_INSURED_RLSHIP,
             V_INFO.RIDER_IND,
             V_INFO.PREM_START_DATE,
             V_INFO.PREM_END_DATE,
             V_INFO.REC_POSTAL_CODE,
             V_INFO.REC_ADDR,
             V_INFO.REC_TEL,
             V_INFO.PREM_FRQ,
             V_INFO.PREM_MTHD,
             V_INFO.STD_PIECE_PREM,
             V_INFO.STD_ADD_PIECE_PREM,
             V_INFO.NONSTD_ADD_PIECE_PREM,
             V_INFO.AGT_PHONE,
             V_INFO.SALE_TYPE,
             V_INFO.SALE_PROD_CODE,
             V_INFO.APP_AGE,
             V_INFO.BEGTIME,
             V_INFO.ENDTIME,
             V_INFO.BRANCH,
             V_INFO.ETL_TIME,
             V_INFO.SRC_SYS,
             V_INFO.APP_CONFIRM_NO,
             V_INFO.APP_TERMINAL_ID,
             V_INFO.CROSS_SALE_IND,
             V_INFO.SUB_SALE_TYPE,
             V_INFO.CSTMZD_RCMD_NO,
             SYSDATE,
             '1');

          V_INSERT_ROWS := V_INSERT_ROWS + 1;
        EXCEPTION
          WHEN OTHERS THEN
            BEGIN
              P_XQ_LOG_IN_ERR('IDS',
                              'P_BANKCOMM_APP_NB_IN',
                              'APPNO=' || V_INFO.APPNO || '   CLASSCODE=' ||
                              V_INFO.CLASSCODE,
                              '插入表BANKCOMM_APP_NB数据' || SQLERRM); --写日志
              V_ERROR_ROWS := V_ERROR_ROWS + 1;
            END;
        END;
      END IF;
    END LOOP;

    COMMIT;

    CLOSE CUR_INFO;

    V_MINDATE := V_MINDATE + 1;

  END LOOP;

  COMMIT;

  UPDATE C_ID_BRO B
     SET B.NEXTVALUE = COUN_ID
   WHERE B.NAME = 'bankcomm_app_nb';
  COMMIT;

  --添加数据库成功日志
  TIME_AFTER := DBMS_UTILITY.GET_TIME;
  P_XQ_LOG_SUC('IDS',
               'P_BANKCOMM_APP_NB_IN',
               V_INSERT_ROWS,
               V_ERROR_ROWS,
               V_UPDATE_ROWS,
               '执行过程持续时间:' || (TIME_AFTER - TIME_BEFORE) / 100 || '秒',
               SQLERRM);

EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      IF CUR_INFO%ISOPEN THEN
        CLOSE CUR_INFO;
      END IF;

      UPDATE C_ID_BRO T
         SET T.NEXTVALUE = COUN_ID
       WHERE T.NAME = 'bankcomm_app_nb';
      COMMIT;

      --添加数据库失败日志
      TIME_AFTER := DBMS_UTILITY.GET_TIME;
      P_XQ_LOG_ERR('IDS',
                   'P_BANKCOMM_APP_NB_IN',
                   V_INSERT_ROWS,
                   V_ERROR_ROWS,
                   V_UPDATE_ROWS,
                   '执行过程持续时间:' || (TIME_AFTER - TIME_BEFORE) / 100 || '秒',
                   SQLERRM);
    END;
END P_BANKCOMM_APP_NB_IN;
/

prompt
prompt Creating procedure P_BANKCOMM_POLICY_SEND_IN
prompt ============================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_BANKCOMM_POLICY_SEND_IN IS
  /*
  ******************************************************
  *  存储过程名 ：P_BANKCOMM_POLICY_SEND_IN
  *  建立日期   ：2012-09-12
  *  作者       ：QINYUNLONG
  *  模块       ：IDS
  *  描述       ：批量处理POLICY_SEND
  */
  V_UPDATE_ROWS NUMBER(18) := 0;
  V_INSERT_ROWS NUMBER(18) := 0;
  V_ERROR_ROWS  NUMBER(18) := 0;

  V_SNO     NUMBER(18) := 0;
  V_BEGTIME NUMBER(11) := 0;
  coun_id   number(18) := 0;

  TIME_BEFORE BINARY_INTEGER := DBMS_UTILITY.GET_TIME; --过程开始时间(毫秒)
  TIME_AFTER  BINARY_INTEGER; --过程结束时间(毫秒)

  V_MINTSTAMP TIMESTAMP; --最小日期TIMESTAMP
  V_MAXTSTAMP TIMESTAMP; --最大日期TIMESTAMP
  V_MINDATE   DATE; --最小日期
  V_MAXDATE   DATE; --最大日期

  CURSOR CUR_INFO(STARTDATE DATE, ENDDATE DATE) IS
    SELECT *
      FROM POLICY_SEND C
     WHERE C.ETL_TIME >= STARTDATE
       AND C.ETL_TIME < ENDDATE
       AND EXISTS
     (SELECT * FROM BANKCOMM_APP_NB B WHERE C.POLICYNO = B.POLICYNO);

  V_INFO CUR_INFO%ROWTYPE;

BEGIN
  --查询临时表最大和最小日期
  SELECT MIN(TEM.ETL_TIME), MAX(TEM.ETL_TIME)
    INTO V_MINTSTAMP, V_MAXTSTAMP
    FROM POLICY_SEND TEM;
  V_MINDATE := TO_DATE(TO_CHAR(V_MINTSTAMP, 'YYYY-MM-DD'), 'YYYY-MM-DD');
  V_MAXDATE := TO_DATE(TO_CHAR(V_MAXTSTAMP, 'YYYY-MM-DD'), 'YYYY-MM-DD');

  select b.nextvalue
    into coun_id
    from c_id_bro b
   where b.name = 'bankcomm_policy_send';

  LOOP
    EXIT WHEN V_MINDATE > V_MAXDATE OR V_MINDATE IS NULL;

    OPEN CUR_INFO(V_MINDATE, V_MINDATE + 1);
    LOOP
      FETCH CUR_INFO
        INTO V_INFO;
      EXIT WHEN CUR_INFO%NOTFOUND;

      SELECT (SELECT B.SNO
                FROM BANKCOMM_POLICY_SEND B
               WHERE B.POLICYNO = V_INFO.POLICYNO
                 AND ROWNUM = 1)
        INTO V_SNO
        FROM DUAL;

      IF V_SNO > 0 THEN
        SELECT (SELECT B.BEGTIME
                  FROM BANKCOMM_POLICY_SEND B
                 WHERE B.POLICYNO = V_INFO.POLICYNO
                   AND ROWNUM = 1)
          INTO V_BEGTIME
          FROM DUAL;

        IF V_INFO.BEGTIME > V_BEGTIME THEN
          --UPDATE
          BEGIN

            UPDATE BANKCOMM_POLICY_SEND A
               SET TYPEID        = V_INFO.TYPEID,
                   EMPNO         = V_INFO.EMPNO,
                   SENDDATE      = V_INFO.SENDDATE,
                   CANCELDATE    = V_INFO.CANCELDATE,
                   PROCESS_DATE  = V_INFO.PROCESS_DATE,
                   SENDOPERNO    = V_INFO.SENDOPERNO,
                   CANCELOPERNO  = V_INFO.CANCELOPERNO,
                   BEGTIME       = V_INFO.BEGTIME,
                   ENDTIME       = V_INFO.ENDTIME,
                   BRANCH        = V_INFO.BRANCH,
                   ETL_TIME      = to_date(to_char(V_INFO.ETL_TIME,
                                                   'YYYY-MM-DD'),
                                           'YYYY-MM-DD'),
                   SRC_SYS       = V_INFO.SRC_SYS,
                   A.UPDATE_TIME = SYSDATE

             WHERE A.SNO = V_SNO;

            V_UPDATE_ROWS := V_UPDATE_ROWS + 1;

          EXCEPTION
            WHEN OTHERS THEN
              V_ERROR_ROWS := V_ERROR_ROWS + 1;
              -- 遇到异常做一些处理
              BEGIN
                P_XQ_LOG_IN_ERR('IDS',
                                'P_BANKCOMM_POLICY_SEND_IN',
                                'POLICYNO=' || V_INFO.POLICYNO,
                                '更新表BANKCOMM_POLICY_SEND数据' || SQLERRM);
              END;
          END;
        END IF;
      ELSE

        coun_id := coun_id + 1;

        BEGIN

          INSERT INTO BANKCOMM_POLICY_SEND
            (SNO,
             TYPEID,
             POLICYNO,
             EMPNO,
             SENDDATE,
             CANCELDATE,
             PROCESS_DATE,
             SENDOPERNO,
             CANCELOPERNO,
             BEGTIME,
             ENDTIME,
             BRANCH,
             ETL_TIME,
             SRC_SYS,
             CREATE_TIME)
          VALUES
            (coun_id,
             V_INFO.TYPEID,
             V_INFO.POLICYNO,
             V_INFO.EMPNO,
             V_INFO.SENDDATE,
             V_INFO.CANCELDATE,
             V_INFO.PROCESS_DATE,
             V_INFO.SENDOPERNO,
             V_INFO.CANCELOPERNO,
             V_INFO.BEGTIME,
             V_INFO.ENDTIME,
             V_INFO.BRANCH,
             to_date(to_char(V_INFO.ETL_TIME, 'YYYY-MM-DD'), 'YYYY-MM-DD'),
             V_INFO.SRC_SYS,
             SYSDATE);

          V_INSERT_ROWS := V_INSERT_ROWS + 1;
        EXCEPTION
          WHEN OTHERS THEN
            BEGIN
              P_XQ_LOG_IN_ERR('IDS',
                              'P_BANKCOMM_POLICY_SEND_IN',
                              'POLICYNO=' || V_INFO.POLICYNO,
                              '插入表BANKCOMM_POLICY_SEND数据' || SQLERRM); --写日志
              V_ERROR_ROWS := V_ERROR_ROWS + 1;
            END;
        END;
      END IF;
    END LOOP;

    COMMIT;

    CLOSE CUR_INFO;

    V_MINDATE := V_MINDATE + 1;

  END LOOP;

  COMMIT;

  update c_id_bro b
     set b.nextvalue = coun_id
   where b.name = 'bankcomm_policy_send';
  commit;

  --添加数据库成功日志
  TIME_AFTER := DBMS_UTILITY.GET_TIME;
  P_XQ_LOG_SUC('IDS',
               'P_BANKCOMM_POLICY_SEND_IN',
               V_INSERT_ROWS,
               V_ERROR_ROWS,
               V_UPDATE_ROWS,
               '执行过程持续时间:' || (TIME_AFTER - TIME_BEFORE) / 100 || '秒',
               SQLERRM);

EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      IF CUR_INFO%ISOPEN THEN
        CLOSE CUR_INFO;
      END IF;

      update c_id_bro b
         set b.nextvalue = coun_id
       where b.name = 'bankcomm_policy_send';
      commit;

      --添加数据库失败日志
      TIME_AFTER := DBMS_UTILITY.GET_TIME;
      P_XQ_LOG_ERR('IDS',
                   'P_BANKCOMM_POLICY_SEND_IN',
                   V_INSERT_ROWS,
                   V_ERROR_ROWS,
                   V_UPDATE_ROWS,
                   '执行过程持续时间:' || (TIME_AFTER - TIME_BEFORE) / 100 || '秒',
                   SQLERRM);
    END;
END P_BANKCOMM_POLICY_SEND_IN;
/

prompt
prompt Creating procedure P_BANKCOMM_PRINT_ACTVTY_IN
prompt =============================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_BANKCOMM_PRINT_ACTVTY_IN IS
  /*
  ******************************************************
  *  存储过程名 ：P_BANKCOMM_PRINT_ACTVTY_IN
  *  建立日期   ：2012-09-12
  *  作者       ：QINYUNLONG
  *  模块       ：IDS
  *  描述       ：批量处理PRINT_ACTVTY保单打印
  */
  V_UPDATE_ROWS NUMBER(18) := 0;
  V_INSERT_ROWS NUMBER(18) := 0;
  V_ERROR_ROWS  NUMBER(18) := 0;

  V_PRINT_ACTVTY_ID NUMBER(18) := 0;
  V_BEGTIME         NUMBER(11) := 0;
  COUN_ID           NUMBER(18) := 0;

  TIME_BEFORE BINARY_INTEGER := DBMS_UTILITY.GET_TIME; --过程开始时间(毫秒)
  TIME_AFTER  BINARY_INTEGER; --过程结束时间(毫秒)

  V_MINTSTAMP TIMESTAMP; --最小日期TIMESTAMP
  V_MAXTSTAMP TIMESTAMP; --最大日期TIMESTAMP
  V_MINDATE   DATE; --最小日期
  V_MAXDATE   DATE; --最大日期

  CURSOR CUR_INFO(STARTDATE DATE, ENDDATE DATE) IS
    SELECT *
      FROM PRINT_ACTVTY C
     WHERE C.ETL_TIME >= STARTDATE
       AND C.ETL_TIME < ENDDATE
       AND EXISTS (SELECT *
              FROM BANKCOMM_APP_NB B
             WHERE C.PRINT_BUSI_NO = B.POLICYNO);

  V_INFO CUR_INFO%ROWTYPE;

BEGIN
  --查询临时表最大和最小日期
  SELECT MIN(TEM.ETL_TIME), MAX(TEM.ETL_TIME)
    INTO V_MINTSTAMP, V_MAXTSTAMP
    FROM PRINT_ACTVTY TEM;
  V_MINDATE := TO_DATE(TO_CHAR(V_MINTSTAMP, 'YYYY-MM-DD'), 'YYYY-MM-DD');
  V_MAXDATE := TO_DATE(TO_CHAR(V_MAXTSTAMP, 'YYYY-MM-DD'), 'YYYY-MM-DD');

  SELECT B.NEXTVALUE
    INTO COUN_ID
    FROM C_ID_BRO B
   WHERE B.NAME = 'bankcomm_print_actvty';

  LOOP
    EXIT WHEN V_MINDATE > V_MAXDATE OR V_MINDATE IS NULL;

    OPEN CUR_INFO(V_MINDATE, V_MINDATE + 1);
    LOOP
      FETCH CUR_INFO
        INTO V_INFO;
      EXIT WHEN CUR_INFO%NOTFOUND;

      SELECT (SELECT B.PRINT_ACTVTY_ID
                FROM BANKCOMM_PRINT_ACTVTY B
               WHERE B.PRINT_JOB_NAME = V_INFO.PRINT_JOB_NAME
                 AND B.PRINT_TYPE = V_INFO.PRINT_TYPE
                 AND B.PRINT_BUSI_NO = V_INFO.PRINT_BUSI_NO
                 AND ROWNUM = 1)
        INTO V_PRINT_ACTVTY_ID
        FROM DUAL;

      IF V_PRINT_ACTVTY_ID > 0 THEN
        SELECT (SELECT B.BEGTIME
                  FROM BANKCOMM_PRINT_ACTVTY B
                 WHERE B.PRINT_JOB_NAME = V_INFO.PRINT_JOB_NAME
                   AND B.PRINT_TYPE = V_INFO.PRINT_TYPE
                   AND B.PRINT_BUSI_NO = V_INFO.PRINT_BUSI_NO
                   AND ROWNUM = 1)
          INTO V_BEGTIME
          FROM DUAL;

        IF V_INFO.BEGTIME > V_BEGTIME THEN
          --UPDATE
          BEGIN

            UPDATE BANKCOMM_PRINT_ACTVTY A
               SET SNO                 = V_INFO.SNO,
                   OPER_TYPE           = V_INFO.OPER_TYPE,
                   STATUS              = V_INFO.STATUS,
                   CREATE_DATE         = V_INFO.CREATE_DATE,
                   PRINT_DATE          = V_INFO.PRINT_DATE,
                   DISPATCH_DATE       = V_INFO.DISPATCH_DATE,
                   RECEIVE_DATE        = V_INFO.RECEIVE_DATE,
                   BEGTIME             = V_INFO.BEGTIME,
                   ENDTIME             = V_INFO.ENDTIME,
                   BRANCH              = V_INFO.BRANCH,
                   ETL_TIME            = V_INFO.ETL_TIME,
                   SRC_SYS             = V_INFO.SRC_SYS,
                   OPER_NO             = V_INFO.OPER_NO,
                   PRINT_PIECES        = V_INFO.PRINT_PIECES,
                   PRINT_DESC          = V_INFO.PRINT_DESC,
                   COMMIT_DATE         = V_INFO.COMMIT_DATE,
                   PRINT_CENTER        = V_INFO.PRINT_CENTER,
                   BUSI_BRANCH         = V_INFO.BUSI_BRANCH,
                   DISPATCH_BRANCH_LV4 = V_INFO.DISPATCH_BRANCH_LV4,
                   A.UPDATE_TIME       = SYSDATE

             WHERE A.PRINT_ACTVTY_ID = V_PRINT_ACTVTY_ID;

            V_UPDATE_ROWS := V_UPDATE_ROWS + 1;

          EXCEPTION
            WHEN OTHERS THEN
              V_ERROR_ROWS := V_ERROR_ROWS + 1;
              -- 遇到异常做一些处理
              BEGIN
                P_XQ_LOG_IN_ERR('IDS',
                                'P_BANKCOMM_PRINT_ACTVTY_IN',
                                'PRINT_JOB_NAME=' || V_INFO.PRINT_JOB_NAME ||
                                '  PRINT_TYPE=' || V_INFO.PRINT_TYPE ||
                                '  PRINT_BUSI_NO=' || V_INFO.PRINT_BUSI_NO,
                                '更新表BANKCOMM_PRINT_ACTVTY数据' || SQLERRM);
              END;
          END;
        END IF;
      ELSE

        COUN_ID := COUN_ID + 1;

        BEGIN

          INSERT INTO BANKCOMM_PRINT_ACTVTY
            (PRINT_ACTVTY_ID,
             SNO,
             PRINT_JOB_NAME,
             PRINT_TYPE,
             OPER_TYPE,
             PRINT_BUSI_NO,
             STATUS,
             CREATE_DATE,
             PRINT_DATE,
             DISPATCH_DATE,
             RECEIVE_DATE,
             BEGTIME,
             ENDTIME,
             BRANCH,
             ETL_TIME,
             SRC_SYS,
             OPER_NO,
             PRINT_PIECES,
             PRINT_DESC,
             COMMIT_DATE,
             PRINT_CENTER,
             BUSI_BRANCH,
             DISPATCH_BRANCH_LV4,
             CREATE_TIME)
          VALUES
            (COUN_ID,
             V_INFO.SNO,
             V_INFO.PRINT_JOB_NAME,
             V_INFO.PRINT_TYPE,
             V_INFO.OPER_TYPE,
             V_INFO.PRINT_BUSI_NO,
             V_INFO.STATUS,
             V_INFO.CREATE_DATE,
             V_INFO.PRINT_DATE,
             V_INFO.DISPATCH_DATE,
             V_INFO.RECEIVE_DATE,
             V_INFO.BEGTIME,
             V_INFO.ENDTIME,
             V_INFO.BRANCH,
             V_INFO.ETL_TIME,
             V_INFO.SRC_SYS,
             V_INFO.OPER_NO,
             V_INFO.PRINT_PIECES,
             V_INFO.PRINT_DESC,
             V_INFO.COMMIT_DATE,
             V_INFO.PRINT_CENTER,
             V_INFO.BUSI_BRANCH,
             V_INFO.DISPATCH_BRANCH_LV4,
             SYSDATE);

          V_INSERT_ROWS := V_INSERT_ROWS + 1;
        EXCEPTION
          WHEN OTHERS THEN
            BEGIN
              P_XQ_LOG_IN_ERR('IDS',
                              'P_BANKCOMM_PRINT_ACTVTY_IN',
                              'PRINT_JOB_NAME=' || V_INFO.PRINT_JOB_NAME ||
                              '  PRINT_TYPE=' || V_INFO.PRINT_TYPE ||
                              '  PRINT_BUSI_NO=' || V_INFO.PRINT_BUSI_NO,
                              '插入表BANKCOMM_PRINT_ACTVTY数据' || SQLERRM);
              V_ERROR_ROWS := V_ERROR_ROWS + 1;
            END;
        END;
      END IF;
    END LOOP;

    COMMIT;

    CLOSE CUR_INFO;

    V_MINDATE := V_MINDATE + 1;

  END LOOP;

  COMMIT;

  UPDATE C_ID_BRO B
     SET B.NEXTVALUE = COUN_ID
   WHERE B.NAME = 'bankcomm_print_actvty';
  COMMIT;

  --添加数据库成功日志
  TIME_AFTER := DBMS_UTILITY.GET_TIME;
  P_XQ_LOG_SUC('IDS',
               'P_BANKCOMM_PRINT_ACTVTY_IN',
               V_INSERT_ROWS,
               V_ERROR_ROWS,
               V_UPDATE_ROWS,
               '执行过程持续时间:' || (TIME_AFTER - TIME_BEFORE) / 100 || '秒',
               SQLERRM);

EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      IF CUR_INFO%ISOPEN THEN
        CLOSE CUR_INFO;
      END IF;

      UPDATE C_ID_BRO B
         SET B.NEXTVALUE = COUN_ID
       WHERE B.NAME = 'bankcomm_print_actvty';
      COMMIT;

      --添加数据库失败日志
      TIME_AFTER := DBMS_UTILITY.GET_TIME;
      P_XQ_LOG_ERR('IDS',
                   'P_BANKCOMM_PRINT_ACTVTY_IN',
                   V_INSERT_ROWS,
                   V_ERROR_ROWS,
                   V_UPDATE_ROWS,
                   '执行过程持续时间:' || (TIME_AFTER - TIME_BEFORE) / 100 || '秒',
                   SQLERRM);
    END;
END P_BANKCOMM_PRINT_ACTVTY_IN;
/

prompt
prompt Creating procedure P_DEAL_BIZ_DAY
prompt =================================
prompt
create or replace procedure unicall.p_deal_biz_day(para_date date) is
  v_ob_com_id    number(10) := 0;
  v_use_id       number(10) := 0;
  v_campaign_nam varchar(50) := '';
  v_cus_gro_name varchar(50) := '';
  v_n_list       number(10) := 0;
  v_n_dial       number(10) := 0;

  v_n_contact       number(10) := 0;
  v_pc_contact_list varchar2(20) := '';

  v_n_deal       number(10) := 0;
  v_n_deal_m     number(10) := 0;
  v_n_deal_y     number(10) := 0;
  v_pc_deal_list varchar2(20) := '';

  v_sum_deal   number(10, 2) := 0;
  v_sum_deal_m number(10, 2) := 0;
  v_sum_deal_y number(10, 2) := 0;

  v_accept_time varchar2(20) := '';
  v_pay_way     varchar2(20) := '';
  v_price       number(10, 2) := 0;
  v_if_exists   number(10) := 0;

  cur                types.cursorType;
  v_cus_gro_id       number(10) := 0;
  v_current_datetime date;

  v_current_date date;
  v_state_date   date;
  v_remark       varchar(100);

  v_exp      varchar2(4000);
  v_exp_code varchar2(100);
  ---成交业务量统计
begin
  begin
    v_state_date := sysdate;
    if para_date is null then
      v_current_datetime := sysdate;
    else
      v_current_datetime := para_date;
    end if;

    v_current_date := to_date(to_char(v_current_datetime, 'YYYY-MM-DD'),
                              'YYYY-MM-DD');
    --- 按用户，活动查询当天的成交情况
    begin
      open cur for
        select distinct use_id, ob_com_id
          from c_ob_com_cus a
         where cal_typ = '2';
      loop
        <<a>>
        fetch cur
          into v_use_id, v_ob_com_id;
        exit when cur%notfound;
        begin
          select distinct cus_gro_id
            into v_cus_gro_id
            from c_ob_com_cus
           where use_id = v_use_id
             and ob_com_id = v_ob_com_id; --目标列表ID

          select t.cus_gro_nam
            into v_cus_gro_name
            from C_CUS_GRO t
           where t.cus_gro_id = v_cus_gro_id; --目标列表名称

          select ob_com_nam
            into v_campaign_nam
            from c_ob_com
           where ob_com_id = v_ob_com_id; --活动名称
        exception
          when others then
            -- 遇到异常做一些处理
            begin
              dbms_output.put_line('data error :' || v_use_id || '--' || v_ob_com_id);
             goto a;
            end;

        end;

        select count(1)
          into v_n_list --名单总数
          from (select a.c_ob_com_cus_id
                  from c_ob_com_cus a
                 where a.use_id = v_use_id
                   and a.ob_com_id = v_ob_com_id
                   and to_char(a.asg_dat, 'yyyy-mm-dd') =
                       to_char(v_current_date, 'yyyy-mm-dd'));

        select n_dial
          into v_n_dial --拨打总数
          from (select count(1) n_dial
                  from c_ob_com_cus a, c_ob_com_cus_dia_out b
                 where a.c_ob_com_cus_id = b.c_ob_com_cus_id
                   and a.use_id = v_use_id
                   and b.use_id = v_use_id -- 去除非座席拨打记录
                   and a.ob_com_id = v_ob_com_id
                   and to_char(b.dia_out_tim, 'yyyy-mm-dd') =
                       to_char(v_current_date, 'yyyy-mm-dd'));

        select count(1)
          into v_n_contact --接触数
          from (select b.contact
                  from c_ob_com_cus a, c_ob_com_cus_dia_out b
                 where a.c_ob_com_cus_id = b.c_ob_com_cus_id
                   and a.use_id = v_use_id
                   and b.use_id = v_use_id -- 去除非座席拨打记录
                   and a.ob_com_id = v_ob_com_id
                   and (a.con_sta_id like '2002%' or a.con_sta_id like '35%')
                   and to_char(dia_out_tim, 'yyyy-mm-dd') =
                       to_char(v_current_date, 'yyyy-mm-dd')
                 group by b.contact);

        select count(1)
          into v_n_deal
          from shcpic_proposal_form_result a, c_ob_com_cus b
         where a.c_ob_com_cus_id = b.c_ob_com_cus_id
           and use_id = v_use_id
           and b.ob_com_id = v_ob_com_id
           and substr(a.audittime, 0, 10) =
               to_char(v_current_date, 'yyyy-mm-dd')
           and a.audit_status = '1'; --成交数

        select count(1)
          into v_n_deal_m
          from shcpic_proposal_form_result a,
               c_ob_com_cus                b,
               shcpic_product_result       c
         where a.c_ob_com_cus_id = b.c_ob_com_cus_id
           and a.id = c.proposal_form_id
           and c.element_id = '91'
           and c.element_value_value = '10'
           and use_id = v_use_id
           and ob_com_id = v_ob_com_id
           and substr(audittime, 0, 10) =
               to_char(v_current_date, 'yyyy-mm-dd')
           and a.audit_status = '1'; --成交数（月缴）

        select count(1)
          into v_n_deal_y
          from shcpic_proposal_form_result a,
               c_ob_com_cus                b,
               shcpic_product_result       c
         where a.c_ob_com_cus_id = b.c_ob_com_cus_id
           and a.id = c.proposal_form_id
           and c.element_id = '91'
           and c.element_value_value = '13'
           and use_id = v_use_id
           and ob_com_id = v_ob_com_id
           and substr(audittime, 0, 10) =
               to_char(v_current_date, 'yyyy-mm-dd')
           and a.audit_status = '1'; --成交数（年缴）

        select sum(price)
          into v_sum_deal
          from shcpic_proposal_form_result a, c_ob_com_cus b
         where a.c_ob_com_cus_id = b.c_ob_com_cus_id
           and use_id = v_use_id
           and ob_com_id = v_ob_com_id
           and substr(audittime, 0, 10) =
               to_char(v_current_date, 'yyyy-mm-dd')
           and a.audit_status = '1'; --成交总额

        select sum(price)
          into v_sum_deal_m
          from shcpic_proposal_form_result a,
               c_ob_com_cus                b,
               shcpic_product_result       c
         where a.c_ob_com_cus_id = b.c_ob_com_cus_id
           and a.id = c.proposal_form_id
           and c.element_id = '91'
           and c.element_value_value = '10'
           and use_id = v_use_id
           and ob_com_id = v_ob_com_id
           and substr(audittime, 0, 10) =
               to_char(v_current_date, 'yyyy-mm-dd')
           and a.audit_status = '1'; --成交总额（月缴）

        select sum(price)
          into v_sum_deal_y
          from shcpic_proposal_form_result a,
               c_ob_com_cus                b,
               shcpic_product_result       c
         where a.c_ob_com_cus_id = b.c_ob_com_cus_id
           and a.id = c.proposal_form_id
           and c.element_id = '91'
           and c.element_value_value = '13'
           and use_id = v_use_id
           and ob_com_id = v_ob_com_id
           and substr(audittime, 0, 10) =
               to_char(v_current_date, 'yyyy-mm-dd')
           and a.audit_status = '1'; --成交总额（年缴）

        if v_n_contact <> 0 then
          if v_n_deal = 0 then
            v_pc_deal_list := '0%';
          else
            v_pc_deal_list := round((v_n_deal / v_n_contact), 2) * 100 || '%'; --成交率
          end if;
          if v_n_list = 0 then
            v_pc_contact_list := '0%';
          else
            v_pc_contact_list := round((v_n_contact / v_n_list), 2) * 100 || '%'; --接触率
          end if;
        else
          v_pc_deal_list    := '0%'; --比例
          v_pc_contact_list := '0%'; --比例
        end if;

        -- 删除当天存档数据
        delete rpt_deal_biz_day
         where substr(t_archive, 0, 10) =
               to_char(v_current_datetime, 'YYYY-MM-DD')
           and campaign_id = v_ob_com_id
           and use_id = v_use_id;

        if (v_n_list <> 0 or v_n_dial <> 0 or v_n_contact <> 0 or
           v_n_deal <> 0) then
          insert into rpt_deal_biz_day
            (use_id,
             campaign_id,
             campaign_nam,
             cus_list_nam,
             n_list,
             n_dial,

             n_contact,
             pc_contact_list,

             n_deal,
             n_deal_m,
             n_deal_y,
             pc_deal_list,

             sum_deal,
             sum_deal_m,
             sum_deal_y,

             n_accept,
             n_accept_m,
             n_accept_y,
             pc_accept_list,

             sum_accept,
             sum_accept_m,
             sum_accept_y,

             t_archive)
          values
            (v_use_id,
             v_ob_com_id,
             v_campaign_nam,
             v_cus_gro_name,
             v_n_list,
             v_n_dial,

             v_n_contact,
             v_pc_contact_list,

             v_n_deal,
             v_n_deal_m,
             v_n_deal_y,
             v_pc_deal_list,

             v_sum_deal,
             v_sum_deal_m,
             v_sum_deal_y,

             0,
             0,
             0,
             '0%',

             0,
             0,
             0,
             to_char(v_current_datetime, 'YYYY-MM-DD HH24:MI:SS'));
        end if;

      end loop;
      close cur;
      commit;

    end;
    begin
      --- 更新当天发生变更的承保记录，只要发生过承保的都计入当天的承保数
      -- 从存档日期为当天的承保列表中获取数据
      open cur for
        select (select a.use_id from c_use a where a.use_ali_id = r.useid) use_id,
               (select b.element_value_value
                  from shcpic_product_result b
                 where b.proposal_form_id = p.id
                   and b.element_id = '91') pay_way,
               r.campaign_id,
               r.campaign_name,
               r.accept_time,
               (select distinct d.cus_gro_nam
                  from c_ob_com_cus c, c_cus_gro d
                 where c.c_ob_com_cus_id = p.c_ob_com_cus_id
                   and c.cus_gro_id = d.cus_gro_id) cus_gro_name,
               p.price
          from rpt_accept_ins_day r, shcpic_proposal_form_result p
         where r.appno = p.appno
           and substr(r.t_archive, 0, 10) =
               to_char(v_current_datetime, 'YYYY-MM-DD');
      loop
        fetch cur
          into v_use_id, v_pay_way, v_ob_com_id, v_campaign_nam, v_accept_time, v_cus_gro_name, v_price;
        exit when cur%notfound;
        select count(1)
          into v_if_exists
          from rpt_deal_biz_day a
         where a.use_id = v_use_id
           and a.campaign_id = v_ob_com_id
           and substr(a.t_archive, 0, 10) = substr(v_accept_time, 0, 10);

        if v_if_exists > 0 then

          update rpt_deal_biz_day
             set n_accept       = n_accept + 1,
                 sum_accept     = sum_accept + v_price,
                 pc_accept_list = decode(n_deal,
                                         0,
                                         '0%',
                                         round((n_accept + 1 / n_deal), 2) * 100 || '%'),
                 n_accept_m     = decode(v_pay_way,
                                         '10',
                                         n_accept_m + 1,
                                         n_accept_m),
                 sum_accept_m   = decode(v_pay_way,
                                         '10',
                                         sum_accept_m + v_price,
                                         sum_accept_m),
                 n_accept_y     = decode(v_pay_way,
                                         '13',
                                         n_accept_y + 1,
                                         n_accept_y),
                 sum_accept_y   = decode(v_pay_way,
                                         '13',
                                         sum_accept_y + v_price,
                                         sum_accept_y)

           where use_id = v_use_id
             and campaign_id = v_ob_com_id
             and substr(t_archive, 0, 10) = substr(v_accept_time, 0, 10);

        else

          insert into rpt_deal_biz_day
            (use_id,
             campaign_id,
             campaign_nam,
             cus_list_nam,
             n_list,
             n_dial,

             n_contact,
             pc_contact_list,

             n_deal,
             n_deal_m,
             n_deal_y,
             pc_deal_list,

             sum_deal,
             sum_deal_m,
             sum_deal_y,

             n_accept,
             n_accept_m,
             n_accept_y,
             pc_accept_list,

             sum_accept,
             sum_accept_m,
             sum_accept_y,

             t_archive)
          values
            (v_use_id,
             v_ob_com_id,
             v_campaign_nam,
             v_cus_gro_name,
             0,
             0,

             0,
             '0%',

             0,
             0,
             0,
             '0%',

             0,
             0,
             0,

             1,
             decode(v_pay_way, '10', 1, 0),
             decode(v_pay_way, '13', 1, 0),
             '0%',

             v_price,
             decode(v_pay_way, '10', v_price, 0),
             decode(v_pay_way, '13', v_price, 0),

             v_accept_time);
        end if;
      end loop;
      close cur;
      commit;
    end;
  EXCEPTION

    when NO_DATA_FOUND then
      begin
        v_exp      := SUBSTR(SQLERRM, 1, 3000);
        v_exp_code := sqlcode;
        close cur;
        v_remark := 'NO_DATA_FOUND error';
        dbms_output.put_line('NO_DATA_FOUND error');
        rollback;
        commit;
      end;
    when too_many_rows then
      begin
        v_exp      := SUBSTR(SQLERRM, 1, 3000);
        v_exp_code := sqlcode;
        close cur;
        v_remark := '返回值多行';
        dbms_output.put_line('返回值多行');
        rollback;
      end;
    when others then
      begin
        v_exp      := SUBSTR(SQLERRM, 1, 3000);
        v_exp_code := sqlcode;
        close cur;
        v_remark := 'others error';
        dbms_output.put_line('others error');
        rollback;
      end;
  end;
  begin
    insert into p_deal_biz_day_log
      (statetime, endtime, remark, ex, CODE)
    values
      (v_state_date, sysdate, v_remark, v_exp, v_exp_code);

    commit;
  end;
end;
/

prompt
prompt Creating procedure P_INSERTTEMPINFOTOCUSTOMER
prompt =============================================
prompt
create or replace procedure unicall.P_INSERTTEMPINFOTOCUSTOMER(v_countNum  out number) is

begin
  select count(*) into v_countNum from c_cus_bas_temp ;
  --写入C_CUS_BAS
   insert into C_CUS_BAS
        (CUS_ID,
         CUS_TYP_ID,
         CUS_TRA_ID,
         CUS_STA_ID,
         CUS_TIT_ID,
         CUS_NAM,
         OPE_DAT,
         CUS_ALI_ID,
         CUS_GRA_ID,
         CHA_TYP_3,
         CHA_TYP_4,
         CHA_TYP_5,
         CHA_TYP_6,
         CHA_TYP_8,
         EXT_1,
         EXT_2,
         EXT_3,
         EXT_4,
         EXT_5,
         EXT_6,
         USE_ID,
         PHO,
         CAT_ID_03,
         CAT_ID_02,
         CAT_ID_01,
         CAR,
         REM,
         GEN,
         BIR,
         HOM_TEL,
         OFF_TEL,
         POS_COD,
         CREDIT_CARD,
         CREDIT_EXPIRE_DATE,
         IDE_NUM,
         INSDESC_IN_BIZ,
         IDE_TYP,
         IS_TAKE_IN,
         IS_BUY,
         END_TIME,
         CREATE_TIME,
         INSURANCE_PER_VOLUM_ID,
         ORG_ID,
         CUS_MARITAL,
         CUS_EDUCATION,
         CUS_SALARY,
         CUS_HEALTH,
         CUS_KEEP_INS)
select t.cus_id,3,3,null,null,t.cus_nam,null,null,null,
t.cha_typ_3,t.cha_typ_4,t.cha_typ_5,t.cha_typ_6,t.cha_typ_8,null,null,t.ext_3,t.ext_4,null, null,
t.use_id,null,null,null,null,null,t.rem,t.gen,t.bir,t.hom_tel,t.off_tel,t.pos_cod,
null,null,t.ide_num,null,t.ide_typ,null,null,null,to_char(sysdate,'YYYY-MM-DD'),t.insurance_per_volum_id,
t.org_id,null,null,null,null,null from  c_cus_bas_temp t;
commit;
--写入 C_OB_COM_CUS
   insert into C_OB_COM_CUS
        (C_OB_COM_CUS_ID,
         CUS_ID,
         OB_COM_ID,
         CON_STA_ID,
         DIA_COU,
         COU,
         DEL,
         CRE_DAT,
         LAS_MOD_DAT,
         ASG_DAT,
         BUS_ITE_ID,
         BUS_ITE_TYP,
         BRA_ID,
         BRA_NAM,
         POO_TYP,
         CAL_TYP,
         USE_ID,
         CUS_GRO_ID,
         OB_DIS_RUL_ID,
         COM_CUS_DI_ID,
         ORG_ID)
  select t.ob_com_cus_id,t.cus_id,t.ob_com_id,40, 0, 1,0,sysdate,sysdate,sysdate,null,null,null,null,0,'1',
  null,t.cus_gro_id, null,null,t.org_id from  c_cus_bas_temp t;
  commit;
  --C_CUS_GRO_CUS
   insert into C_CUS_GRO_CUS(
     CUS_GRO_ID,
     CUS_ID)
     select t.cus_gro_id,t.cus_id from  c_cus_bas_temp t;
    commit;
 exception
  when others then
    begin
      v_countNum :=-1;
      dbms_output.put_line('P_INSERTTEMPINFOTOCUSTOMER 出现异常');
    end;

end P_INSERTTEMPINFOTOCUSTOMER;
/

prompt
prompt Creating procedure P_INTERFACE
prompt ==============================
prompt
create or replace procedure unicall.P_INTERFACE
is
begin

--导入状态更改信息
---delete from itf_insurstate ;由业务对数据进行清除

insert into itf_insurstate(
select a.appno,b.bankflag,a.status,a.procdate,''
  from app_nb a ,riskcon b where a.appno = b.appno) ;


end P_INTERFACE;
/

prompt
prompt Creating procedure P_INVALID_LIST_DAY
prompt =====================================
prompt
create or replace procedure unicall.p_invalid_list_day(para_date date) is
  v_ob_com_id       number(10) := 0;
  v_ob_com_nam      varchar(50) := 0;
  v_n_list          number(10) := 0;
  v_n_dial          number(10) := 0;
  v_n_invalid       number(10) := 0;

  v_n_hangup        number(10) := 0;
  v_pc_hangup       VARCHAR2(20) := 0;

  v_n_unconnect     number(10) := 0;
  v_pc_unconnect    VARCHAR2(20) := 0;

  v_n_untouch       number(10) := 0;
  v_pc_untouch_dial VARCHAR2(20) := 0;
  v_n_tel_error     number(10) := 0;
  v_pc_error_dial   VARCHAR2(20) := 0;
  v_cus_gro_id      number(10) := 0;
  v_use_id          number(10) := 0; -- add by lib
  cur               types.cursorType;

  v_current_datetime date;
  v_current_date     date;
  ---无效名单统计
begin
  if para_date is null then
    v_current_datetime := sysdate;
  else
    v_current_datetime := para_date;
  end if;

  v_current_date := to_date(to_char(v_current_datetime, 'YYYY-MM-DD'),
                            'YYYY-MM-DD');
  open cur for
    select distinct use_id, ob_com_id
      from c_ob_com_cus a
     where cal_typ = '2';
  loop
    fetch cur
      into v_use_id, v_ob_com_id;
    exit when cur%notfound;
    
    select ob_com_nam
      into v_ob_com_nam
      from c_ob_com
     where ob_com_id = v_ob_com_id; --活动名称

    select distinct cus_gro_id
      into v_cus_gro_id
      from c_ob_com_cus a
     where ob_com_id = v_ob_com_id; -- 目标列表ID

    select count(1)
      into v_n_list --名单总数
      from (select a.c_ob_com_cus_id
              from c_ob_com_cus a, c_ob_com_cus_dia_out b
             where a.c_ob_com_cus_id = b.c_ob_com_cus_id
               and a.use_id = v_use_id
               and b.use_id = v_use_id -- 去除非座席拨打记录
               and ob_com_id = v_ob_com_id

             group by a.c_ob_com_cus_id
            having to_char(min(dia_out_tim), 'yyyy-mm-dd') = to_char(v_current_date, 'yyyy-mm-dd'));

    select n_dial
      into v_n_dial --拨打总数
      from (select count(1) n_dial
              from c_ob_com_cus a, c_ob_com_cus_dia_out b
             where a.c_ob_com_cus_id = b.c_ob_com_cus_id
               and a.use_id = v_use_id
               and b.use_id = v_use_id -- 去除非座席拨打记录
               and ob_com_id = v_ob_com_id
               and to_char(dia_out_tim, 'yyyy-mm-dd') =
                   to_char(v_current_date, 'yyyy-mm-dd'));

    select count(1)
      into v_n_untouch
      from c_ob_com_cus t
     where con_sta_id = 300302
       and use_id = v_use_id
       and ob_com_id = v_ob_com_id
       and to_char(las_mod_dat, 'yyyy-mm-dd') =
           to_char(v_current_date, 'yyyy-mm-dd'); --未找到人

    select count(1)
      into v_n_tel_error
      from c_ob_com_cus t
     where con_sta_id = 300301
       and use_id = v_use_id
       and ob_com_id = v_ob_com_id
       and to_char(las_mod_dat, 'yyyy-mm-dd') =
           to_char(v_current_date, 'yyyy-mm-dd'); --电话错误

    select count(1)
      into v_n_hangup
      from c_ob_com_cus t
     where con_sta_id = 300303
       and use_id = v_use_id
       and ob_com_id = v_ob_com_id
       and to_char(las_mod_dat, 'yyyy-mm-dd') =
           to_char(v_current_date, 'yyyy-mm-dd'); --直接挂机

    select count(1)
      into v_n_unconnect
      from c_ob_com_cus t
     where con_sta_id = 300304
       and use_id = v_use_id
       and ob_com_id = v_ob_com_id
       and to_char(las_mod_dat, 'yyyy-mm-dd') =
           to_char(v_current_date, 'yyyy-mm-dd'); --3次以上联系不到本人

    v_n_invalid := v_n_untouch + v_n_tel_error + v_n_hangup + v_n_unconnect;--无效名单总数
    
    if v_n_invalid <> 0 then
      v_pc_untouch_dial := round((v_n_untouch / v_n_invalid), 2) * 100 || '%'; --比例
      v_pc_error_dial   := round((v_n_tel_error / v_n_invalid), 2) * 100 || '%'; --比例
      v_pc_hangup       := round((v_n_hangup / v_n_invalid), 2) * 100 || '%'; --比例
      v_pc_unconnect    := round((v_n_unconnect / v_n_invalid), 2) * 100 || '%'; --比例
    else
      v_pc_untouch_dial := '0%'; --比例
      v_pc_error_dial   := '0%'; --比例
      v_pc_hangup   := '0%'; --比例
      v_pc_unconnect   := '0%'; --比例
    end if;

    delete rpt_invalid_list
     where substr(t_archive, 0, 10) =
           to_char(v_current_datetime, 'YYYY-MM-DD')
       and campaign_id = v_ob_com_id
       and use_id = v_use_id;

    if (v_n_list <> 0 or v_n_dial <> 0 or v_n_invalid <> 0) then

      insert into rpt_invalid_list
        (use_id,
         campaign_id,
         n_list,
         n_dial,
         n_invalid,
         n_untouch,
         n_tel_error,
         n_hang_up,
         n_unconnect,
         campaign_nam,
         pc_untouch_dial,
         pc_error_dial,
         pc_hang_up,
         pc_unconnect,
         t_archive)
      values
        (v_use_id,
         v_ob_com_id,
         v_n_list,
         v_n_dial,
         v_n_invalid,
         v_n_untouch,
         v_n_tel_error,
         v_n_hangup,
         v_n_unconnect,
         v_ob_com_nam,
         v_pc_untouch_dial,
         v_pc_error_dial,
         v_pc_hangup,
         v_pc_unconnect,
         to_char(v_current_datetime, 'YYYY-MM-DD HH24:MI:SS'));
    end if;
  end loop;
  close cur;
  commit;
EXCEPTION
  when NO_DATA_FOUND then
    close cur;
    dbms_output.put_line('NO_DATA_FOUND error');
    rollback;
  when too_many_rows then
    close cur;
    dbms_output.put_line('返回值多行');
    rollback;
  when others then
    close cur;
    dbms_output.put_line('others error');
    rollback;
    --commit;
end;
/

prompt
prompt Creating procedure P_PROPOSAL_FORM_UPDATE
prompt =========================================
prompt
create or replace procedure unicall.p_proposal_form_update(para_date date) is
  v_current_datetime date;

  v_idDMsystem number(20) := 0; --电销系统ID
  v_appno      varchar(20) := ''; --投保单号
  v_policyno   varchar(20) := ''; --保单号
  v_lastupdate varchar(20) := ''; --更新时间
  cur          types.cursorType;

begin
  if para_date is null then
    v_current_datetime := sysdate;
  else
    v_current_datetime := para_date;
  end if;

  open cur for
    select idDMsystem, appno, policyno, lastupdate
      from tb_app t
     where to_char(t.lastupdate, 'YYYY-MM-DD') =
           to_char(v_current_datetime, 'YYYY-MM-DD')
       and recordstatus = 1;
  loop
    fetch cur
      into v_idDMsystem, v_appno, v_policyno, v_lastupdate;
    exit when cur%notfound;
    update shcpic_proposal_form_result
       set appno = v_appno, policyno = v_policyno
     where id = v_idDMsystem;
  end loop;
  close cur;
  commit;
EXCEPTION
  when NO_DATA_FOUND then
    close cur;
    dbms_output.put_line('NO_DATA_FOUND error');
    rollback;
  when too_many_rows then
    close cur;
    dbms_output.put_line('返回值多行');
    rollback;
  when others then
    close cur;
    dbms_output.put_line('others error');
    rollback;
  
end;
/

prompt
prompt Creating procedure P_QUIT_INS
prompt =============================
prompt
create or replace procedure unicall.p_quit_ins(para_date date) is
  v_current_datetime date;
begin
  if para_date is null then
    v_current_datetime := sysdate;
  else
    v_current_datetime := para_date;
  end if;

  delete rpt_quit_ins_day
   where substr(T_ARCHIVE, 0, 10) =
         to_char(v_current_datetime, 'yyyy-mm-dd');

  insert into rpt_quit_ins_day
    (useid,
     usename,
     payway,
     year_fare,
     policyno,
     appno,
     d_insure_name,
     quit_time,
     effect_time,
     product_id,
     product_name,
     campaign_id,
     campaign_name,
     T_ARCHIVE)
  
    select (select u.use_ali_id from c_use u where u.use_id = t.user_id) as useid, --座席ID
           (select u.use_nam from c_use u where u.use_id = t.user_id) usename, --座席姓名
           --1 as event,--事件
           (select pro.element_value_name
              from shcpic_product_result pro
             where pro.proposal_form_id = t.id
               and pro.element_id = 91) as payway, --缴费方式
           -- 1 as first_fare,--已交期数
           price, --年总保费,
           t.policyno as policyno, --保单号
           t.appno, --投保单号
           t.d_insure_name as d_insure_name, --被保人姓名
           t.app_quit_time as quit_time, --退保日期
           t.app_accept_time as effect_time, --合同生效日
           
           (select product.id
              from shcpic_product product
             where product.id in
                   (select pro2.pro_product_id
                      from shcpic_product_result pro2
                     where pro2.proposal_form_id = t.id)) as product_id, --产品ID
           
           (select product.name
              from shcpic_product product
             where product.id in
                   (select pro2.pro_product_id
                      from shcpic_product_result pro2
                     where pro2.proposal_form_id = t.id)) as product_name, --产品名称
           (select obcom.ob_com_id
              from c_ob_com obcom
             where obcom.ob_com_id =
                   (select OB_Com_Id
                      from c_ob_com_cus ob
                     where ob.c_ob_com_cus_id = t.c_ob_com_cus_id)) as campaign_id, --活动ID
           (select obcom.ob_com_nam
              from c_ob_com obcom
             where obcom.ob_com_id =
                   (select OB_Com_Id
                      from c_ob_com_cus ob
                     where ob.c_ob_com_cus_id = t.c_ob_com_cus_id)) as campaign_name, --活动名称
           to_char(v_current_datetime, 'YYYY-MM-DD HH24:MI:SS')
      from shcpic_proposal_form_result t
     where to_char(to_date(t.app_latest_time, 'YYYY-MM-DD HH24:MI:SS'),
                   'yyyy-mm-dd') =
           to_char(v_current_datetime, 'yyyy-mm-dd') -- 当天更新过状态的
       and not (t.app_quit_time is null) -- 退保过的
       and not exists -- 未计入报表的
     (select 1 from rpt_quit_ins_day r where r.appno = t.appno);
  commit;
end;
/

prompt
prompt Creating procedure P_REFUSE_LIST_DAY
prompt ====================================
prompt
create or replace procedure unicall.p_refuse_list_day(para_date date) is
  v_ob_com_id           number(10) := 0;
  v_ob_com_nam          varchar(50) := 0;
  v_n_list              number(10) := 0;
  v_n_dial              number(10) := 0;
  v_n_refuse            number(10) := 0;
  v_n_unqual            number(10) := 0;
  v_pc_unqual           VARCHAR2(20) := '';
  v_n_market_reason     number(10) := 0;
  v_pc_market_dial      VARCHAR2(20) := '';
  v_n_individual_reason number(10) := 0;
  v_pc_individual_dial  VARCHAR2(20) := '';
  v_n_other             number(10) := 0;
  v_pc_other_dial       VARCHAR2(20) := '';
  v_cus_gro_id          number(10) := 0;
  v_cus_gro_name        varchar(50) := '';

  v_use_id number(10) := 0; -- add by lib
  cur      types.cursorType;

  v_current_datetime date;
  v_current_date     date;
  ---拒绝名单统计
begin
  if para_date is null then
    v_current_datetime := sysdate;
  else
    v_current_datetime := para_date;
  end if;

  v_current_date := to_date(to_char(v_current_datetime, 'YYYY-MM-DD'),
                            'YYYY-MM-DD');
  open cur for
    select distinct use_id, ob_com_id
      from c_ob_com_cus a
     where cal_typ = '2';

  loop
    fetch cur
      into v_use_id, v_ob_com_id;
    exit when cur%notfound;

    select ob_com_nam
      into v_ob_com_nam
      from c_ob_com
     where ob_com_id = v_ob_com_id; --活动名称

    select distinct cus_gro_id
      into v_cus_gro_id
      from c_ob_com_cus a
     where ob_com_id = v_ob_com_id; -- 目标列表ID

    select t.cus_gro_nam
      into v_cus_gro_name
      from c_cus_gro t
     where t.cus_gro_id = v_cus_gro_id; --目标列表名称

    select count(1)
      into v_n_list --名单总数
      from (select a.c_ob_com_cus_id
              from c_ob_com_cus a, c_ob_com_cus_dia_out b
             where a.c_ob_com_cus_id = b.c_ob_com_cus_id
               and a.use_id = v_use_id
               and b.use_id = v_use_id -- 去除非座席拨打记录
               and ob_com_id = v_ob_com_id

             group by a.c_ob_com_cus_id
            having to_char(min(dia_out_tim), 'yyyy-mm-dd') = to_char(v_current_date, 'yyyy-mm-dd'));

    select n_dial
      into v_n_dial --拨打总数
      from (select count(1) n_dial
              from c_ob_com_cus a, c_ob_com_cus_dia_out b
             where a.c_ob_com_cus_id = b.c_ob_com_cus_id
               and a.use_id = v_use_id
               and b.use_id = v_use_id -- 去除非座席拨打记录
               and ob_com_id = v_ob_com_id
               and to_char(dia_out_tim, 'yyyy-mm-dd') =
                   to_char(v_current_date, 'yyyy-mm-dd'));

    select count(1)
      into v_n_unqual
      from c_ob_com_cus t
     where con_sta_id = 20020901
       and use_id = v_use_id
       and ob_com_id = v_ob_com_id
       and to_char(las_mod_dat, 'yyyy-mm-dd') =
           to_char(v_current_date, 'yyyy-mm-dd'); --不符合条件

    select count(1)
      into v_n_market_reason
      from c_ob_com_cus t
     where con_sta_id = 20020902
       and use_id = v_use_id
       and ob_com_id = v_ob_com_id
       and to_char(las_mod_dat, 'yyyy-mm-dd') =
           to_char(v_current_date, 'yyyy-mm-dd'); --市场/产品原因

    select count(1)
      into v_n_individual_reason
      from c_ob_com_cus t
     where con_sta_id = 20020903
       and use_id = v_use_id
       and ob_com_id = v_ob_com_id
       and to_char(las_mod_dat, 'yyyy-mm-dd') =
           to_char(v_current_date, 'yyyy-mm-dd'); 

    select count(1)
      into v_n_other
      from c_ob_com_cus t
     where con_sta_id = 20020904
       and use_id = v_use_id
       and ob_com_id = v_ob_com_id
       and to_char(las_mod_dat, 'yyyy-mm-dd') =
           to_char(v_current_date, 'yyyy-mm-dd'); --其他原因

    v_n_refuse := v_n_unqual + v_n_market_reason + v_n_individual_reason + v_n_other;

    if v_n_refuse <> 0 then
      v_pc_unqual          := ROUND(v_n_unqual / v_n_refuse, 2) * 100 || '%'; --比例
      v_pc_market_dial     := ROUND(v_n_market_reason / v_n_refuse, 2) * 100 || '%'; --比例
      v_pc_individual_dial := ROUND(v_n_individual_reason / v_n_refuse, 2) * 100 || '%'; --比例
      v_pc_other_dial      := ROUND(v_n_other / v_n_refuse, 2) * 100 || '%'; --比例
    else
      v_pc_unqual          := '0%'; --比例
      v_pc_market_dial     := '0%'; --比例
      v_pc_individual_dial := '0%'; --比例
      v_pc_other_dial      := '0%'; --比例
    end if;

    delete rpt_refuse_list
     where use_id = v_use_id
       and campaign_id = v_ob_com_id
       and substr(t_archive, 0, 10) = to_char(v_current_date, 'yyyy-mm-dd');
    if (v_n_list <> 0 or v_n_dial <> 0 or v_n_refuse <> 0) then

      insert into rpt_refuse_list
        (use_id,
         campaign_id,
         campaign_nam,
         cus_list_nam,
         n_list,
         n_dial,
         n_refuse,
         n_unqual,
         pc_unqual,
         n_market_reason,
         pc_market_dial,
         n_individual_reason,
         pc_individual_dial,
         N_OTHER,
         PC_OTHER_DIAL,
         T_ARCHIVE)
      values
        (v_use_id,
         v_ob_com_id,
         v_ob_com_nam,
         v_cus_gro_name,
         v_n_list,
         v_n_dial,
         v_n_refuse,
         v_n_unqual,
         v_pc_unqual,
         v_n_market_reason,
         v_pc_market_dial,
         v_n_individual_reason,
         v_pc_individual_dial,
         v_n_other,
         v_pc_other_dial,
         to_char(v_current_datetime, 'YYYY-MM-DD HH24:MI:SS'));
    end if;

  end loop;
  close cur;
  commit;
EXCEPTION
  when NO_DATA_FOUND then
    close cur;
    dbms_output.put_line('NO_DATA_FOUND error');
    rollback;
    --when ZERO_DIVIDE then
  --    close   cur;
  --    dbms_output.put_line('ZERO_DIVIDE error');
  --    rollback;
  when too_many_rows then
    close cur;
    dbms_output.put_line('返回值多行');
    rollback;
  when others then
    close cur;
    dbms_output.put_line('others error');
    rollback;
    -- commit;
end;
/

prompt
prompt Creating procedure P_SATISFY_TOTAL
prompt ==================================
prompt
create or replace procedure unicall.p_satisfy_total(para_date date) is
  v_current_datetime date;
  v_current_date     varchar(8);
  ---无效名单统计
begin
  if para_date is null then
    v_current_datetime := sysdate;
  else
    v_current_datetime := para_date;
  end if;

  v_current_date := to_char(v_current_datetime, 'YYYYMMDD');
  --dbms_output.put_line(v_current_date);

     insert into RPT_SATISFY_TOTAL(AGENT_NAME,Agent_No,timekey,Noutbound,Satisfycount_1,Satisfycount_2,Satisfycount_3,Satisfycount,USE_ID,Use_Ali_Id) --拨打总数
        select
        substr(t.agent_name, 2, length(t.agent_name)) as agent_name--解决坐席姓名前带,号的问题
       ,t.agent_no
       ,t.timekey
       ,sum(t.nOutbound) as nOutbound
       ,sum(decode(satisfytag,1,satisfycount,0)) as Satisfycount_1--非常满意
       ,sum(decode(satisfytag,2,satisfycount,0)) as Satisfycount_2 --满意
       ,sum(decode(satisfytag,3,satisfycount,0)) as Satisfycount_3 --不满意
       ,sum(decode(satisfycount,null,0,satisfycount)) as satisfycount
       ,u.use_id,u.use_ali_id
        from
      	(select
                o.PRESENTATION_NAME as agent_name
                ,o.OBJECT_NAME as agent_no
                ,v.N_OUTBOUND+v.N_INBOUND as nOutBound
                ,v.TIME_KEY as timekey
      				 from gene_dm.v_agentcust_day v,gene_dm.o_agentcust_day o
                  where o.object_id=v.OBJECT_ID and v.T_LOGIN>0 and o.PRESENTATION_NAME!=',') t
              left join (select count(is_satisfy) as satisfycount,is_satisfy as satisfytag,substr(datetime,1,10) as datetime,agent_no from shcpic_satisfy group by substr(datetime,1,10),agent_no,is_satisfy) s
               on t.agent_no = s.agent_no  and t.timeKey = replace(substr(s.datetime,1,10),'-','')
                ,c_use u, c_use_par p-- pselect u.use_id,u.use_ali_id,p.val from c_use u,c_use_par p where p.cat_id='802001' and u.use_id = p.use_id)

                  where
                       t.timekey = v_current_date
                       and p.cat_id='802001'
                       and u.use_id = p.use_id
                       and p.val=t.agent_no
                       --and rownum<4
                       group by t.agent_name,t.agent_no,t.timekey,u.use_id,u.use_ali_id
                  ;

  commit;
end;
/

prompt
prompt Creating procedure P_TBAPP_UPDATE_POLICYNO
prompt ==========================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_TBAPP_UPDATE_POLICYNO IS

  V_SNO   VARCHAR2(18);
  V_SNO_2 VARCHAR2(18);
  V_SNO_3 VARCHAR2(18);

  CURSOR CUR_INFO IS
    SELECT I.APP_NO, I.POLICYNO
      FROM ITF_INSURSTATE I
     WHERE EXISTS (SELECT *
              FROM TB_APPLICATION A
             WHERE A.APPNO = I.APP_NO
               AND A.POLICYNO IS NULL
               AND I.POLICYNO IS NOT NULL);
  V_INFO CUR_INFO%ROWTYPE;

  CURSOR CUR_INFO_2 IS
    SELECT I.APP_NO, I.POLICYNO
      FROM ITF_INSURSTATE I
     WHERE EXISTS (SELECT *
              FROM TB_APPLICATION A
             WHERE A.APPNO = I.APP_NO
               AND A.POLICYNO <> I.POLICYNO
               AND I.POLICYNO IS NOT NULL);
  V_INFO_2 CUR_INFO_2%ROWTYPE;

  CURSOR CUR_INFO_3 IS
    SELECT R.APPNO, R.POLICYNO
      FROM RISKCON R
     WHERE EXISTS (SELECT *
              FROM TB_APPLICATION A
             WHERE A.APPNO = R.APPNO
               AND A.POLICYNO IS NULL);
  V_INFO_3 CUR_INFO_3%ROWTYPE;

BEGIN
  BEGIN
    OPEN CUR_INFO;
    LOOP
      FETCH CUR_INFO
        INTO V_INFO;
      EXIT WHEN CUR_INFO%NOTFOUND;

      SELECT (SELECT A.APPLICATION_ID
                FROM TB_APPLICATION A
               WHERE A.APPNO = V_INFO.APP_NO
                 AND ROWNUM = 1)
        INTO V_SNO
        FROM DUAL;

      IF V_SNO IS NOT NULL THEN
        BEGIN
          UPDATE TB_APPLICATION A
             SET A.POLICYNO = V_INFO.POLICYNO
           WHERE A.APPNO = V_INFO.APP_NO;
          COMMIT;
        EXCEPTION
          WHEN OTHERS THEN
            BEGIN
              DBMS_OUTPUT.PUT_LINE('=====ERROR ' || SQLERRM);
            END;
        END;
      END IF;
    END LOOP;

    COMMIT;

    CLOSE CUR_INFO;
  END;

  BEGIN
    OPEN CUR_INFO_2;
    LOOP
      FETCH CUR_INFO_2
        INTO V_INFO_2;
      EXIT WHEN CUR_INFO_2%NOTFOUND;

      SELECT (SELECT A.APPLICATION_ID
                FROM TB_APPLICATION A
               WHERE A.APPNO = V_INFO_2.APP_NO
                 AND ROWNUM = 1)
        INTO V_SNO_2
        FROM DUAL;

      IF V_SNO_2 IS NOT NULL THEN
        BEGIN
          UPDATE TB_APPLICATION A
             SET A.POLICYNO = V_INFO_2.POLICYNO
           WHERE A.APPNO = V_INFO_2.APP_NO;
          COMMIT;
        EXCEPTION
          WHEN OTHERS THEN
            BEGIN
              DBMS_OUTPUT.PUT_LINE('=====ERROR ' || SQLERRM);
            END;
        END;
      END IF;
    END LOOP;

    COMMIT;

    CLOSE CUR_INFO_2;
  END;

  BEGIN
    OPEN CUR_INFO_3;
    LOOP
      FETCH CUR_INFO_3
        INTO V_INFO_3;
      EXIT WHEN CUR_INFO_3%NOTFOUND;

      SELECT (SELECT A.APPLICATION_ID
                FROM TB_APPLICATION A
               WHERE A.APPNO = V_INFO_3.APPNO
                 AND ROWNUM = 1)
        INTO V_SNO_3
        FROM DUAL;

      IF V_SNO_3 IS NOT NULL THEN
        BEGIN
          UPDATE TB_APPLICATION A
             SET A.POLICYNO = V_INFO_3.POLICYNO
           WHERE A.APPNO = V_INFO_3.APPNO;
          COMMIT;
        EXCEPTION
          WHEN OTHERS THEN
            BEGIN
              DBMS_OUTPUT.PUT_LINE('=====ERROR ' || SQLERRM);
            END;
        END;
      END IF;
    END LOOP;

    COMMIT;

    CLOSE CUR_INFO_3;
  END;

EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      IF CUR_INFO%ISOPEN THEN
        CLOSE CUR_INFO;
      END IF;
      IF CUR_INFO_2%ISOPEN THEN
        CLOSE CUR_INFO_2;
      END IF;
      IF CUR_INFO_3%ISOPEN THEN
        CLOSE CUR_INFO_3;
      END IF;
    END;
END P_TBAPP_UPDATE_POLICYNO;
/

prompt
prompt Creating procedure P_TB_INTORG_IN
prompt =================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_TB_INTORG_IN IS
  /*
  ******************************************************
  *  存储过程名 ：P_TB_INTORG_IN
  *  建立日期   ：2012-09-21
  *  作者       ：QINYUNLONG
  *  模块       ：IDS
  *  描述       ：批量处理 TB_INTORG
  */
  V_UPDATE_ROWS NUMBER(18) := 0;
  V_INSERT_ROWS NUMBER(18) := 0;
  V_ERROR_ROWS  NUMBER(18) := 0;

  V_SNO        NUMBER(18) := 0;
  v_begtime    NUMBER(11);
  COUN_ID      NUMBER(18) := 0;
  v_company_id NUMBER(10);
  v_intorgname varchar2(200);

  TIME_BEFORE BINARY_INTEGER := DBMS_UTILITY.GET_TIME; --过程开始时间(毫秒)
  TIME_AFTER  BINARY_INTEGER; --过程结束时间(毫秒)

  CURSOR CUR_INFO_1 IS
    select * from INTORG i where i.typeid = '1000116';
  V_INFO_1 CUR_INFO_1%ROWTYPE;

  CURSOR CUR_INFO_2 IS
    select t.intorgcode, t.intorgname, t.branch
      from tb_intorg t
     where not exists
     (select * from shcpic_bank s where s.bank_code = t.intorgcode);
  V_INFO_2 CUR_INFO_2%ROWTYPE;

  CURSOR CUR_INFO_3 IS
    select t.intorgcode, t.intorgname
      from tb_intorg t
     where exists (select *
              from shcpic_bank s
             where s.bank_code = t.intorgcode
               and s.bank_name <> t.intorgname);
  V_INFO_3 CUR_INFO_3%ROWTYPE;

BEGIN
  BEGIN
    OPEN CUR_INFO_1;
    LOOP
      FETCH CUR_INFO_1
        INTO V_INFO_1;
      EXIT WHEN CUR_INFO_1%NOTFOUND;

      SELECT (SELECT A.SNO
                FROM TB_INTORG A
               WHERE A.INTORGCODE = V_INFO_1.INTORGCODE
                 AND ROWNUM = 1)
        INTO V_SNO
        FROM DUAL;

      IF V_SNO IS NULL OR V_SNO = 0 THEN

        BEGIN
          INSERT INTO TB_INTORG
            (sno,
             typeid,
             intorg_id,
             intorgcode,
             intorgname,
             governid,
             direct_mng_ind,
             areatype,
             orgtype,
             statuscode,
             firstinsert,
             lastmodify,
             fullname,
             city,
             town,
             title,
             permit_date,
             license_date,
             busi_scope,
             license_status,
             regionalism_code,
             begtime,
             endtime,
             branch,
             etl_time,
             src_sys,
             create_date)
          VALUES
            (SEQ_TB_INTORG.NEXTVAL,
             V_INFO_1.typeid,
             V_INFO_1.intorg_id,
             V_INFO_1.intorgcode,
             V_INFO_1.intorgname,
             V_INFO_1.governid,
             V_INFO_1.direct_mng_ind,
             V_INFO_1.areatype,
             V_INFO_1.orgtype,
             V_INFO_1.statuscode,
             V_INFO_1.firstinsert,
             V_INFO_1.lastmodify,
             V_INFO_1.fullname,
             V_INFO_1.city,
             V_INFO_1.town,
             V_INFO_1.title,
             V_INFO_1.permit_date,
             V_INFO_1.license_date,
             V_INFO_1.busi_scope,
             V_INFO_1.license_status,
             V_INFO_1.regionalism_code,
             V_INFO_1.begtime,
             V_INFO_1.endtime,
             V_INFO_1.branch,
             V_INFO_1.etl_time,
             V_INFO_1.src_sys,
             sysdate);

          V_INSERT_ROWS := V_INSERT_ROWS + 1;
        EXCEPTION
          WHEN OTHERS THEN
            BEGIN
              P_XQ_LOG_IN_ERR('IDS',
                              'P_TB_INTORG_IN',
                              'INTORGCODE=' || V_INFO_1.INTORGCODE,
                              '插入表TB_INTORG数据' || SQLERRM); --写日志
              V_ERROR_ROWS := V_ERROR_ROWS + 1;
            END;
        END;

      ELSE
        SELECT (SELECT A.begtime
                  FROM TB_INTORG A
                 WHERE A.INTORGCODE = V_INFO_1.INTORGCODE
                   AND ROWNUM = 1)
          INTO v_begtime
          FROM DUAL;

        if V_INFO_1.begtime > v_begtime then
          BEGIN
            Update TB_INTORG s
               set s.typeid           = V_INFO_1.typeid,
                   s.intorg_id        = V_INFO_1.intorg_id,
                   s.intorgcode       = V_INFO_1.intorgcode,
                   s.intorgname       = V_INFO_1.intorgname,
                   s.governid         = V_INFO_1.governid,
                   s.direct_mng_ind   = V_INFO_1.direct_mng_ind,
                   s.areatype         = V_INFO_1.areatype,
                   s.orgtype          = V_INFO_1.orgtype,
                   s.statuscode       = V_INFO_1.statuscode,
                   s.firstinsert      = V_INFO_1.firstinsert,
                   s.lastmodify       = V_INFO_1.lastmodify,
                   s.fullname         = V_INFO_1.fullname,
                   s.city             = V_INFO_1.city,
                   s.town             = V_INFO_1.town,
                   s.title            = V_INFO_1.title,
                   s.permit_date      = V_INFO_1.permit_date,
                   s.license_date     = V_INFO_1.license_date,
                   s.busi_scope       = V_INFO_1.busi_scope,
                   s.license_status   = V_INFO_1.license_status,
                   s.regionalism_code = V_INFO_1.regionalism_code,
                   s.begtime          = V_INFO_1.begtime,
                   s.endtime          = V_INFO_1.endtime,
                   s.branch           = V_INFO_1.branch,
                   s.etl_time         = V_INFO_1.etl_time,
                   s.src_sys          = V_INFO_1.src_sys,
                   update_date        = sysdate
             where s.sno = v_sno;

            v_update_rows := v_update_rows + 1;

          EXCEPTION
            WHEN OTHERS THEN
              BEGIN
                P_XQ_LOG_IN_ERR('IDS',
                                'P_TB_INTORG_IN',
                                'INTORGCODE=' || V_INFO_1.INTORGCODE,
                                '更新TB_INTORG数据' || SQLERRM); --写日志
                V_ERROR_ROWS := V_ERROR_ROWS + 1;
              END;
          END;
        end if;
      END IF;
    END LOOP;

    COMMIT;

    CLOSE CUR_INFO_1;
  END;

  BEGIN

    SELECT B.NEXTVALUE
      INTO COUN_ID
      FROM C_ID_BRO B
     WHERE B.NAME = 'shcpic_bank';

    OPEN CUR_INFO_2;
    LOOP
      FETCH CUR_INFO_2
        INTO V_INFO_2;
      EXIT WHEN CUR_INFO_2%NOTFOUND;

      BEGIN
        select (select sc.id
                  from shcpic_company sc
                 where sc.id in
                       (select s.parent_company_id
                          from shcpic_company s
                         where s.company_code in
                               (select f.dx_orgcode
                                  from ff_company f
                                 where exists
                                 (select *
                                          from tb_intorg t
                                         where t.branch = f.branchid
                                           and t.branch = V_INFO_2.Branch
                                           and ROWNUM = 1))))
          INTO v_company_id
          from dual;
      EXCEPTION
        WHEN OTHERS THEN
          v_company_id := '';
      END;

      BEGIN

        COUN_ID := COUN_ID + 1;

        insert into shcpic_bank
          (ID, BANK_CODE, BANK_NAME, COMPANY_ID)
        VALUES
          (COUN_ID, V_INFO_2.intorgcode, V_INFO_2.intorgname, v_company_id);

        COMMIT;

      EXCEPTION
        WHEN OTHERS THEN
          BEGIN
            dbms_output.put_line('=====ERROR ' || SQLERRM);
          END;
      END;

    END LOOP;

    COMMIT;

    CLOSE CUR_INFO_2;

    UPDATE C_ID_BRO B
       SET B.NEXTVALUE = COUN_ID
     WHERE B.NAME = 'shcpic_bank';
    COMMIT;

  END;

  BEGIN
    OPEN CUR_INFO_3;
    LOOP
      FETCH CUR_INFO_3
        INTO V_INFO_3;
      EXIT WHEN CUR_INFO_3%NOTFOUND;

      BEGIN

        update shcpic_bank sb
           set sb.bank_name = V_INFO_3.INTORGNAME
         where sb.bank_code = V_INFO_3.intorgcode
           and rownum = 1;

        commit;

      EXCEPTION
        WHEN OTHERS THEN
          BEGIN
            dbms_output.put_line('=====ERROR ' || SQLERRM);
          END;
      END;
    END LOOP;

    CLOSE CUR_INFO_3;
  END;

  TIME_AFTER := DBMS_UTILITY.GET_TIME;
  P_XQ_LOG_SUC('IDS',
               'P_TB_INTORG_IN',
               V_INSERT_ROWS,
               V_ERROR_ROWS,
               V_UPDATE_ROWS,
               '执行过程持续时间:' || (TIME_AFTER - TIME_BEFORE) / 100 || '秒',
               SQLERRM);

EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      IF CUR_INFO_1%ISOPEN THEN
        CLOSE CUR_INFO_1;
      END IF;

      IF CUR_INFO_2%ISOPEN THEN
        CLOSE CUR_INFO_2;
      END IF;

      IF CUR_INFO_3%ISOPEN THEN
        CLOSE CUR_INFO_3;
      END IF;

      UPDATE C_ID_BRO B
         SET B.NEXTVALUE = COUN_ID
       WHERE B.NAME = 'shcpic_bank';
      COMMIT;

      --添加数据库失败日志
      TIME_AFTER := DBMS_UTILITY.GET_TIME;
      P_XQ_LOG_ERR('IDS',
                   'P_TB_INTORG_IN',
                   V_INSERT_ROWS,
                   V_ERROR_ROWS,
                   V_UPDATE_ROWS,
                   '执行过程持续时间:' || (TIME_AFTER - TIME_BEFORE) / 100 || '秒',
                   SQLERRM);
    END;
END P_TB_INTORG_IN;
/

prompt
prompt Creating procedure P_TB_RESERVE_TASK
prompt ====================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_TB_RESERVE_TASK IS
  /*
  ******************************************************
  *  存储过程名 ：P_TB_RESERVE_TASK
  *  建立日期   ：2012-09-21
  *  作者       ：QINYUNLONG
  *  模块       ：IDS
  *  描述       ：批量处理 TB_RESERVE_TASK
  */
  V_UPDATE_ROWS NUMBER(18) := 0;
  V_INSERT_ROWS NUMBER(18) := 0;
  V_ERROR_ROWS  NUMBER(18) := 0;

  V_ID   NUMBER(18) := 0;
  V_ID_2 NUMBER(18) := 0;

  TIME_BEFORE BINARY_INTEGER := DBMS_UTILITY.GET_TIME; --过程开始时间(毫秒)
  TIME_AFTER  BINARY_INTEGER; --过程结束时间(毫秒)

  CURSOR CUR_INFO_1 IS
    SELECT T.APPLICATION_ID,
           T.APPNO,
           T.POLICYNO,
           DM.SRC,
           DM.ID,
           D.SALE_CHA,
           T.ORG_ID,
           T2.Org_Id        AS ORG_PROJECT,
           T3.Org_Id        as Id_Org
      FROM TB_APPLICATION T,
           TB_APP_DTL D,
           TB_DMTYPE DM,
           (SELECT * FROM TB_ORGANIZATION T1 WHERE T1.ORG_TYPE = '07') T1,
           (SELECT * FROM TB_ORGANIZATION T1 WHERE T1.ORG_TYPE = '06') T2,
           (SELECT * FROM TB_ORGANIZATION T1 WHERE T1.ORG_TYPE = '05') T3
     WHERE T.APPLICATION_ID = D.APPLICATION_ID
       AND D.SALE_CHA IN ('61', '63')
       AND T.IDDMTYPE = DM.ID
       AND DM.SRC IN ('04')
       AND T.ORG_ID = T1.ORG_ID(+)
       AND T1.PARENT_ORG_ID = T2.ORG_ID(+)
       AND T2.PARENT_ORG_ID = T3.ORG_ID(+)
       AND EXISTS (SELECT *
              FROM ITF_INSURSTATE I
             WHERE T.APPNO = I.APP_NO
               AND I.Status IN ('07'));
  V_INFO_1 CUR_INFO_1%ROWTYPE;

  CURSOR CUR_INFO_2 IS
    SELECT T.APPLICATION_ID,
           T.APPNO,
           T.POLICYNO,
           DM.SRC,
           DM.ID,
           D.SALE_CHA,
           T.ORG_ID,
           T2.Org_Id        AS ORG_PROJECT,
           T3.Org_Id        as Id_Org
      FROM TB_APPLICATION T,
           TB_APP_DTL D,
           TB_DMTYPE DM,
           (SELECT * FROM TB_ORGANIZATION T1 WHERE T1.ORG_TYPE = '07') T1,
           (SELECT * FROM TB_ORGANIZATION T1 WHERE T1.ORG_TYPE = '06') T2,
           (SELECT * FROM TB_ORGANIZATION T1 WHERE T1.ORG_TYPE = '05') T3
     WHERE T.APPLICATION_ID = D.APPLICATION_ID
       AND D.SALE_CHA IN ('61', '63')
       AND T.IDDMTYPE = DM.ID
       AND DM.SRC IN ('05')
       AND T.ORG_ID = T1.ORG_ID(+)
       AND T1.PARENT_ORG_ID = T2.ORG_ID(+)
       AND T2.PARENT_ORG_ID = T3.ORG_ID(+)
       AND EXISTS (SELECT *
              FROM ITF_INSURSTATE I
             WHERE T.APPNO = I.APP_NO
               AND I.Status IN ('I21', 'I22', '04'));
  V_INFO_2 CUR_INFO_2%ROWTYPE;

BEGIN
  BEGIN
    OPEN CUR_INFO_1;
    LOOP
      FETCH CUR_INFO_1
        INTO V_INFO_1;
      EXIT WHEN CUR_INFO_1%NOTFOUND;

      SELECT (SELECT A.ID
                FROM TB_RESERVE_TASK A
               WHERE A.APPNO = V_INFO_1.APPNO
                 AND ROWNUM = 1)
        INTO V_ID
        FROM DUAL;

      IF V_ID IS NULL OR V_ID = 0 THEN

        BEGIN
          INSERT INTO TB_RESERVE_TASK
            (ID,
             APPNO,
             POLICYNO,
             CRE_TIME,
             SALE_SRC,
             SALE_CHA,
             STATUS,
             DX_ORG_ID,
             APPLICATION_ID,
             PRJ_ORG_ID)
          VALUES
            (SEQ_TB_RESERVE_TASK.NEXTVAL,
             V_INFO_1.APPNO,
             V_INFO_1.POLICYNO,
             SYSDATE,
             V_INFO_1.SRC,
             V_INFO_1.SALE_CHA,
             '1001',
             decode(V_INFO_1.Id,
                    '2001',
                    '392',
                    '2002',
                    '392',
                    '7001',
                    '5051',
                    '7002',
                    '5051',
                    V_INFO_1.Id_Org),
             V_INFO_1.APPLICATION_ID,
             V_INFO_1.ORG_PROJECT);

          V_INSERT_ROWS := V_INSERT_ROWS + 1;
        EXCEPTION
          WHEN OTHERS THEN
            BEGIN
              P_XQ_LOG_IN_ERR('IDS',
                              'P_TB_RESERVE_TASK',
                              'APPNO=' || V_INFO_1.APPNO,
                              '插入表TB_RESERVE_TASK数据' || SQLERRM); --写日志
              V_ERROR_ROWS := V_ERROR_ROWS + 1;
            END;
        END;
      END IF;
    END LOOP;

    COMMIT;

    CLOSE CUR_INFO_1;
  END;

  ---------------------------------------------------------------------------------------

  BEGIN
    OPEN CUR_INFO_2;
    LOOP
      FETCH CUR_INFO_2
        INTO V_INFO_2;
      EXIT WHEN CUR_INFO_2%NOTFOUND;

      SELECT (SELECT A.ID
                FROM TB_RESERVE_TASK A
               WHERE A.APPNO = V_INFO_2.APPNO
                 AND ROWNUM = 1)
        INTO V_ID_2
        FROM DUAL;

      IF V_ID_2 IS NULL OR V_ID_2 = 0 THEN

        BEGIN
          INSERT INTO TB_RESERVE_TASK
            (ID,
             APPNO,
             POLICYNO,
             CRE_TIME,
             SALE_SRC,
             SALE_CHA,
             STATUS,
             DX_ORG_ID,
             APPLICATION_ID,
             PRJ_ORG_ID)
          VALUES
            (SEQ_TB_RESERVE_TASK.NEXTVAL,
             V_INFO_2.APPNO,
             V_INFO_2.POLICYNO,
             SYSDATE,
             V_INFO_2.SRC,
             V_INFO_2.SALE_CHA,
             '1001',
             decode(V_INFO_2.Id,
                    '2001',
                    '392',
                    '2002',
                    '392',
                    '7001',
                    '5051',
                    '7002',
                    '5051',
                    V_INFO_2.Id_Org),
             V_INFO_2.APPLICATION_ID,
             V_INFO_2.ORG_PROJECT);

          V_INSERT_ROWS := V_INSERT_ROWS + 1;
        EXCEPTION
          WHEN OTHERS THEN
            BEGIN
              P_XQ_LOG_IN_ERR('IDS',
                              'P_TB_RESERVE_TASK',
                              'APPNO=' || V_INFO_2.APPNO,
                              '插入表TB_RESERVE_TASK数据' || SQLERRM); --写日志
              V_ERROR_ROWS := V_ERROR_ROWS + 1;
            END;
        END;
      END IF;
    END LOOP;

    COMMIT;

    CLOSE CUR_INFO_2;
  END;

EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      IF CUR_INFO_1%ISOPEN THEN
        CLOSE CUR_INFO_1;
      END IF;
      IF CUR_INFO_2%ISOPEN THEN
        CLOSE CUR_INFO_2;
      END IF;
      --添加数据库失败日志
      TIME_AFTER := DBMS_UTILITY.GET_TIME;
      P_XQ_LOG_ERR('IDS',
                   'P_TB_RESERVE_TASK',
                   V_INSERT_ROWS,
                   V_ERROR_ROWS,
                   V_UPDATE_ROWS,
                   '执行过程持续时间:' || (TIME_AFTER - TIME_BEFORE) / 100 || '秒',
                   SQLERRM);
    END;
END P_TB_RESERVE_TASK;
/

prompt
prompt Creating procedure P_TEMPCUSINFOVALIDATE
prompt ========================================
prompt
create or replace procedure unicall.P_TempCusInfoValidate is
  /**
  校验客户信息和客户是否重复
  author xtp  20120523
  **/
  v_count     number(10);
  v_result    VARCHAR2(200);
  v_CUSGROID  number(10);
  v_OBCOMID   number(10);
  v_homeTel   VARCHAR2(100); --家庭电话
  v_officeTel VARCHAR2(100); --办公电话
  v_mobile    VARCHAR2(60); --移动电话
  v_certNo    VARCHAR2(50); --证件号码
  v_otheTel   VARCHAR2(60); --其他电话
  v_cardType  VARCHAR2(2); --证件类型
  CURSOR cur_info IS
    select t.cus_gro_id, t.ob_com_id
      from c_cus_bas_temp t
     group by t.cus_gro_id, t.ob_com_id;
  v_info cur_info%ROWTYPE;
  CURSOR cur_info1 IS
    select t1.cus_gro_id, t1.ob_com_id, t1.hom_tel
      from c_cus_bas_temp t1
     where t1.hom_tel is not null
     group by t1.cus_gro_id, t1.ob_com_id, t1.hom_tel
    having count(*) > 1;
  v_info1 cur_info1%ROWTYPE;
  CURSOR cur_info2 IS
    select t1.cus_gro_id, t1.ob_com_id, t1.cha_typ_5
      from c_cus_bas_temp t1
     where t1.cha_typ_5 is not null
     group by t1.cus_gro_id, t1.ob_com_id, t1.cha_typ_5
    having count(*) > 1;
  v_info2 cur_info2%ROWTYPE;
  CURSOR cur_info3 IS
    select t1.cus_gro_id, t1.ob_com_id, t1.off_tel
      from c_cus_bas_temp t1
     where t1.off_tel is not null
     group by t1.cus_gro_id, t1.ob_com_id, t1.off_tel
    having count(*) > 1;
  v_info3 cur_info3%ROWTYPE;
  CURSOR cur_info4 IS
    select t1.cus_gro_id, t1.ob_com_id, t1.ide_num
      from c_cus_bas_temp t1
     where t1.ide_num is not null
     group by t1.cus_gro_id, t1.ob_com_id, t1.ide_num
    having count(*) > 1;
  v_info4 cur_info4%ROWTYPE;
begin
  --A :校验黑名单信息
  -- 证件号 家庭电话，办公电话 移动电话，其他电话，
  select count(*)
    into v_count
    from cpic_cus_blacklist b
   where b.stat = '1'
     and exists
   (select *
            from c_cus_bas_temp t
           where ((t.ide_num is not null and t.ide_num = b.ide_num) or
                 (t.hom_tel is not null and b.hom_tel = t.hom_tel) or
                 (t.off_tel is not null and t.off_tel = b.off_tel) or
                 (t.off_tel is not null and b.mobile = t.cha_typ_5) or
                 (t.cha_typ_3 is not null and b.other_tel = t.cha_typ_3)));
  if v_count > 0 then
    v_result := '该记录在黑名单中存在！';
    insert into C_CUS_BAS_FAIL_TEMP
      (ID,
       CUS_NAM,
       GEN,
       IDE_TYP,
       IDE_NUM,
       BIR,
       HOM_TEL,
       OFF_TEL,
       CHA_TYP_5,
       CHA_TYP_3,
       CHA_TYP_4,
       POS_COD,
       CHA_TYP_8,
       EXT_3,
       EXT_4,
       CHA_TYP_6,
       BANK_NAME,
       BANK_ACCOUNT,
       INSURANCE_NAME,
       REM,
       INSURANCE_PER_VOLUM_ID,
       FAIL_REASON,
       CUS_GRO_ID,
       OB_COM_ID,
       USE_ID)
      select t.cus_id,
             t.cus_nam,
             t.gen,
             t.cus_typ_id,
             t.ide_num,
             t.bir,
             t.hom_tel,
             t.off_tel,
             t.cha_typ_5,
             t.cha_typ_3,
             t.cha_typ_4,
             t.pos_cod,
             t.cha_typ_8,
             t.ext_3,
             t.ext_4,
             t.cha_typ_6,
             t.bank_name,
             t.bank_account,
             t.insurance_name,
             t.ori_rem,
             t.insurance_per_volum_id,
             v_result,
             t.cus_gro_id,
             t.ob_com_id,
             t.use_id
        from c_cus_bas_temp t
       where exists
       (select *
                from cpic_cus_blacklist b
               where ((t.ide_num is not null and t.ide_num = b.ide_num) or
                     (t.hom_tel is not null and b.hom_tel = t.hom_tel) or
                     (t.off_tel is not null and t.off_tel = b.off_tel) or
                     (t.off_tel is not null and b.mobile = t.cha_typ_5) or
                     (t.cha_typ_3 is not null and b.other_tel = t.cha_typ_3)));
    delete from c_cus_bas_temp t
     where exists
     (select * from C_CUS_BAS_FAIL_TEMP f where t.cus_id = f.id);

    commit;

    v_count := 0;
  end if;

  ---同一客户名单中的重复信息校验
  --家庭电话重复

  OPEN cur_info1;
  LOOP
    FETCH cur_info1
      INTO v_info1;
    EXIT WHEN cur_info1%NOTFOUND;
    v_result   := '家庭电话重复！';
    v_CUSGROID := v_info1.cus_gro_id;
    v_OBCOMID  := v_info1.ob_com_id;
    v_homeTel  := v_info1.hom_tel;
    insert into C_CUS_BAS_FAIL_TEMP
      (ID,
       CUS_NAM,
       GEN,
       IDE_TYP,
       IDE_NUM,
       BIR,
       HOM_TEL,
       OFF_TEL,
       CHA_TYP_5,
       CHA_TYP_3,
       CHA_TYP_4,
       POS_COD,
       CHA_TYP_8,
       EXT_3,
       EXT_4,
       CHA_TYP_6,
       BANK_NAME,
       BANK_ACCOUNT,
       INSURANCE_NAME,
       REM,
       INSURANCE_PER_VOLUM_ID,
       FAIL_REASON,
       CUS_GRO_ID,
       OB_COM_ID,
       USE_ID)
      select t.cus_id,
             t.cus_nam,
             t.gen,
             t.cus_typ_id,
             t.ide_num,
             t.bir,
             t.hom_tel,
             t.off_tel,
             t.cha_typ_5,
             t.cha_typ_3,
             t.cha_typ_4,
             t.pos_cod,
             t.cha_typ_8,
             t.ext_3,
             t.ext_4,
             t.cha_typ_6,
             t.bank_name,
             t.bank_account,
             t.insurance_name,
             t.ori_rem,
             t.insurance_per_volum_id,
             v_result,
             t.cus_gro_id,
             t.ob_com_id,
             t.use_id
        from c_cus_bas_temp t
       where t.hom_tel = v_homeTel
         and t.hom_tel is not null
         and t.cus_gro_id = v_CUSGROID
         and t.ob_com_id = v_OBCOMID

         and t.cus_id not in
             (select max(t1.cus_id)
                from c_cus_bas_temp t1
               where t1.cus_gro_id = v_CUSGROID
                 and t1.ob_com_id = v_OBCOMID
                 and t1.hom_tel = v_homeTel);
    delete from c_cus_bas_temp t
     where t.hom_tel = v_homeTel
       and t.hom_tel is not null
       and t.cus_gro_id = v_CUSGROID
       and t.ob_com_id = v_OBCOMID
       and t.cus_id not in (select max(t1.cus_id)
                              from c_cus_bas_temp t1
                             where t1.cus_gro_id = v_CUSGROID
                               and t1.ob_com_id = v_OBCOMID
                               and t1.hom_tel = v_homeTel);
    commit;

  end LOOP;
  close cur_info1;

  v_count := 0;
  --移动电话重复

  OPEN cur_info2;
  LOOP
    FETCH cur_info2
      INTO v_info2;
    EXIT WHEN cur_info2%NOTFOUND;
    v_result   := '移动电话重复！';
    v_CUSGROID := v_info2.cus_gro_id;
    v_OBCOMID  := v_info2.ob_com_id;
    v_mobile   := v_info2.cha_typ_5;
    insert into C_CUS_BAS_FAIL_TEMP
      (ID,
       CUS_NAM,
       GEN,
       IDE_TYP,
       IDE_NUM,
       BIR,
       HOM_TEL,
       OFF_TEL,
       CHA_TYP_5,
       CHA_TYP_3,
       CHA_TYP_4,
       POS_COD,
       CHA_TYP_8,
       EXT_3,
       EXT_4,
       CHA_TYP_6,
       BANK_NAME,
       BANK_ACCOUNT,
       INSURANCE_NAME,
       REM,
       INSURANCE_PER_VOLUM_ID,
       FAIL_REASON,
       CUS_GRO_ID,
       OB_COM_ID,
       USE_ID)
      select t.cus_id,
             t.cus_nam,
             t.gen,
             t.cus_typ_id,
             t.ide_num,
             t.bir,
             t.hom_tel,
             t.off_tel,
             t.cha_typ_5,
             t.cha_typ_3,
             t.cha_typ_4,
             t.pos_cod,
             t.cha_typ_8,
             t.ext_3,
             t.ext_4,
             t.cha_typ_6,
             t.bank_name,
             t.bank_account,
             t.insurance_name,
             t.ori_rem,
             t.insurance_per_volum_id,
             v_result,
             t.cus_gro_id,
             t.ob_com_id,
             t.use_id
        from c_cus_bas_temp t
       where t.cha_typ_5 = v_mobile
         and t.cha_typ_5 is not null
         and t.cus_gro_id = v_CUSGROID
         and t.ob_com_id = v_OBCOMID
         and t.cus_id not in
             (select max(t1.cus_id)
                from c_cus_bas_temp t1
               where t1.cus_gro_id = v_CUSGROID
                 and t1.ob_com_id = v_OBCOMID
                 and t1.cha_typ_5 = v_mobile);
    delete from c_cus_bas_temp t
     where t.cha_typ_5 = v_mobile
       and t.cha_typ_5 is not null
       and t.cus_gro_id = v_CUSGROID
       and t.ob_com_id = v_OBCOMID
       and t.cus_id not in (select max(t1.cus_id)
                              from c_cus_bas_temp t1
                             where t1.cus_gro_id = v_CUSGROID
                               and t1.ob_com_id = v_OBCOMID
                               and t1.cha_typ_5 = v_mobile);
    commit;

  end LOOP;
  close cur_info2;

  v_count := 0;
  --办公电话重复

  OPEN cur_info3;
  LOOP
    FETCH cur_info3
      INTO v_info3;
    EXIT WHEN cur_info3%NOTFOUND;
    v_result    := '办公电话重复！';
    v_CUSGROID  := v_info3.cus_gro_id;
    v_OBCOMID   := v_info3.ob_com_id;
    v_officeTel := v_info3.off_tel;
    insert into C_CUS_BAS_FAIL_TEMP
      (ID,
       CUS_NAM,
       GEN,
       IDE_TYP,
       IDE_NUM,
       BIR,
       HOM_TEL,
       OFF_TEL,
       CHA_TYP_5,
       CHA_TYP_3,
       CHA_TYP_4,
       POS_COD,
       CHA_TYP_8,
       EXT_3,
       EXT_4,
       CHA_TYP_6,
       BANK_NAME,
       BANK_ACCOUNT,
       INSURANCE_NAME,
       REM,
       INSURANCE_PER_VOLUM_ID,
       FAIL_REASON,
       CUS_GRO_ID,
       OB_COM_ID,
       USE_ID)
      select t.cus_id,
             t.cus_nam,
             t.gen,
             t.cus_typ_id,
             t.ide_num,
             t.bir,
             t.hom_tel,
             t.off_tel,
             t.cha_typ_5,
             t.cha_typ_3,
             t.cha_typ_4,
             t.pos_cod,
             t.cha_typ_8,
             t.ext_3,
             t.ext_4,
             t.cha_typ_6,
             t.bank_name,
             t.bank_account,
             t.insurance_name,
             t.ori_rem,
             t.insurance_per_volum_id,
             v_result,
             t.cus_gro_id,
             t.ob_com_id,
             t.use_id
        from c_cus_bas_temp t
       where t.off_tel = v_officeTel
         and t.off_tel is not null
         and t.cus_gro_id = v_CUSGROID
         and t.ob_com_id = v_OBCOMID
         and t.cus_id not in
             (select max(t1.cus_id)
                from c_cus_bas_temp t1
               where t1.cus_gro_id = v_CUSGROID
                 and t1.ob_com_id = v_OBCOMID
                 and t1.off_tel = v_officeTel);
    delete from c_cus_bas_temp t
     where t.off_tel = v_officeTel
       and t.off_tel is not null
       and t.cus_gro_id = v_CUSGROID
       and t.ob_com_id = v_OBCOMID
       and t.cus_id not in
           (select max(t1.cus_id)
              from c_cus_bas_temp t1
             where t1.cus_gro_id = v_CUSGROID
               and t1.ob_com_id = v_OBCOMID
               and t1.off_tel = v_officeTel);
    commit;

  end LOOP;
  close cur_info3;

  v_count := 0;
  --证件号码

  OPEN cur_info4;
  LOOP
    FETCH cur_info4
      INTO v_info4;
    EXIT WHEN cur_info4%NOTFOUND;
    v_result   := '证件号码重复！';
    v_CUSGROID := v_info4.cus_gro_id;
    v_OBCOMID  := v_info4.ob_com_id;
    v_certNo   := v_info4.ide_num;
    insert into C_CUS_BAS_FAIL_TEMP
      (ID,
       CUS_NAM,
       GEN,
       IDE_TYP,
       IDE_NUM,
       BIR,
       HOM_TEL,
       OFF_TEL,
       CHA_TYP_5,
       CHA_TYP_3,
       CHA_TYP_4,
       POS_COD,
       CHA_TYP_8,
       EXT_3,
       EXT_4,
       CHA_TYP_6,
       BANK_NAME,
       BANK_ACCOUNT,
       INSURANCE_NAME,
       REM,
       INSURANCE_PER_VOLUM_ID,
       FAIL_REASON,
       CUS_GRO_ID,
       OB_COM_ID,
       USE_ID)
      select t.cus_id,
             t.cus_nam,
             t.gen,
             t.cus_typ_id,
             t.ide_num,
             t.bir,
             t.hom_tel,
             t.off_tel,
             t.cha_typ_5,
             t.cha_typ_3,
             t.cha_typ_4,
             t.pos_cod,
             t.cha_typ_8,
             t.ext_3,
             t.ext_4,
             t.cha_typ_6,
             t.bank_name,
             t.bank_account,
             t.insurance_name,
             t.ori_rem,
             t.insurance_per_volum_id,
             v_result,
             t.cus_gro_id,
             t.ob_com_id,
             t.use_id
        from c_cus_bas_temp t
       where t.ide_num = v_certNo
         and t.cus_gro_id = v_CUSGROID
         and t.ide_num is not null
         and t.ob_com_id = v_OBCOMID
         and t.cus_id not in (select max(t1.cus_id)
                                from c_cus_bas_temp t1
                               where t1.cus_gro_id = v_CUSGROID
                                 and t1.ob_com_id = v_OBCOMID
                                 and t1.ide_num = v_certNo);
    delete from c_cus_bas_temp t
     where t.ide_num = v_certNo
       and t.cus_gro_id = v_CUSGROID
       and t.ide_num is not null
       and t.ob_com_id = v_OBCOMID
       and t.cus_id not in (select max(t1.cus_id)
                              from c_cus_bas_temp t1
                             where t1.cus_gro_id = v_CUSGROID
                               and t1.ob_com_id = v_OBCOMID
                               and t1.ide_num = v_certNo);
    commit;

  end LOOP;
  close cur_info4;
  --C:校验在数据库中是否存在对应记录
  v_count := 0;
  OPEN cur_info;
  LOOP
    FETCH cur_info
      INTO v_info;
    EXIT WHEN cur_info%NOTFOUND;
    v_CUSGROID := v_info.cus_gro_id;
    v_OBCOMID  := v_info.ob_com_id;

    v_result := '数据库中信息重复！';
    insert into C_CUS_BAS_FAIL_TEMP
      (ID,
       CUS_NAM,
       GEN,
       IDE_TYP,
       IDE_NUM,
       BIR,
       HOM_TEL,
       OFF_TEL,
       CHA_TYP_5,
       CHA_TYP_3,
       CHA_TYP_4,
       POS_COD,
       CHA_TYP_8,
       EXT_3,
       EXT_4,
       CHA_TYP_6,
       BANK_NAME,
       BANK_ACCOUNT,
       INSURANCE_NAME,
       REM,
       INSURANCE_PER_VOLUM_ID,
       FAIL_REASON,
       CUS_GRO_ID,
       OB_COM_ID,
       USE_ID)
      select t.cus_id,
             t.cus_nam,
             t.gen,
             t.cus_typ_id,
             t.ide_num,
             t.bir,
             t.hom_tel,
             t.off_tel,
             t.cha_typ_5,
             t.cha_typ_3,
             t.cha_typ_4,
             t.pos_cod,
             t.cha_typ_8,
             t.ext_3,
             t.ext_4,
             t.cha_typ_6,
             t.bank_name,
             t.bank_account,
             t.insurance_name,
             t.ori_rem,
             t.insurance_per_volum_id,
             v_result,
             t.cus_gro_id,
             t.ob_com_id,
             t.use_id
        from c_cus_bas_temp t
       where exists
       (select *
                from C_CUS_GRO_CUS c, c_cus_bas b
               where
              --  and t.cus_gro_id = c.cus_gro_id
               c.cus_gro_id = v_CUSGROID
            and c.cus_id = b.cus_id
            and

               ((b.hom_tel = t.hom_tel and t.hom_tel is not null) or
               (b.cha_typ_5 = t.cha_typ_5 and t.cha_typ_5 is not null) or
               (b.off_tel = t.off_tel and t.off_tel is not null) or
               (b.ide_num = t.ide_num and t.ide_num is not null)));
    commit;
    delete from c_cus_bas_temp t
     where exists
     (select * from C_CUS_BAS_FAIL_TEMP f where t.cus_id = f.id);

    commit;

    v_count := 0;

  end loop;
  close cur_info;
exception
  when others then
    begin

      dbms_output.put_line('P_INSERTTEMPINFOTOCUSTOMER 出现异常');
    end;

end P_TempCusInfoValidate;
/

prompt
prompt Creating procedure P_TIMECARD_INS
prompt =================================
prompt
create or replace procedure unicall.p_timecard_ins(para_date date) is
  v_current_datetime date;
begin
  if para_date is null then
    v_current_datetime := sysdate;
  else
    v_current_datetime := para_date;
  end if;

  delete rpt_time_card_record
   where substr(RECORDDATE, 0, 10) =
         to_char(v_current_datetime, 'yyyy-mm-dd');
         
    insert into rpt_time_card_record
    (USERID,
     MINONLINETIME,
     RECORDDATE)
     select c_user_id,to_char(min(To_date(c_sta_time,'yyyy-mm-dd HH24:MI:SS')),'yyyy-mm-dd HH24:MI:SS'),to_char(sysdate,'yyyy-mm-dd HH24:MI:SS')
     from c_time_card
     where c_user_sta='01' and to_char(sysdate,'yyyy-mm-dd') = substr(c_sta_time,0,10)
     group by c_user_id;     
     update rpt_time_card_record t1 set MAXOFFLINETIME=(select to_char(max(To_date(c_sta_time,'yyyy-mm-dd HH24:MI:SS')),'yyyy-mm-dd HH24:MI:SS')
     from c_time_card t2
     where c_user_sta='03' and to_char(sysdate,'yyyy-mm-dd') = substr(c_sta_time,0,10) and t1.userid = t2.c_user_id
     group by c_user_id) where to_char(sysdate, 'yyyy-mm-dd') = substr(t1.recorddate, 0, 10);   
		 update rpt_time_card_record t1 set relaxtime=(select sum(to_number(c_ext2))
     from c_time_card t2
     where to_char(sysdate,'yyyy-mm-dd') = substr(c_sta_time,0,10) and t1.userid = t2.c_user_id
     group by c_user_id) where to_char(sysdate, 'yyyy-mm-dd') = substr(t1.recorddate, 0, 10);
     update rpt_time_card_record t1 set username=(select use_nam from c_use t2 where t1.userid=t2.use_id) where to_char(sysdate, 'yyyy-mm-dd') = substr(t1.recorddate, 0, 10);
     update rpt_time_card_record a set a.ext1=(to_date(a.maxofflinetime,'yyyy-mm-dd HH24:MI:SS')-to_date(a.minonlinetime,'yyyy-mm-dd HH24:MI:SS'))*24 where to_char(sysdate, 'yyyy-mm-dd') = substr(a.recorddate, 0, 10); 
  commit;    
end;
/

prompt
prompt Creating procedure P_TRUNCATE_TABLE
prompt ===================================
prompt
create or replace procedure unicall.p_truncate_table (table_name in varchar2)
  authid definer
as
  cursor_id integer;
begin
  cursor_id := dbms_sql.open_cursor;
  dbms_sql.parse(cursor_id, 'truncate table ' || table_name, dbms_sql.v7);
  dbms_sql.close_cursor(cursor_id);
exception
  when others then
    dbms_sql.close_cursor(cursor_id);
    raise;
end p_truncate_table;
/

prompt
prompt Creating procedure P_T_BILLING_INFO
prompt ===================================
prompt
create or replace procedure unicall.P_T_BILLING_INFO is
  v_amount        NUMBER(20, 4); --单期保费..
  v_owed          NUMBER; --欠缴期次
  v_owed_amount   NUMBER(20, 4); --累计欠缴保费
  v_sprerec_years NUMBER(20); --应缴期数
  v_pay_sum       NUMBER(20); --已缴期次
  v_years         NUMBER(20); --缴费次数
  v_nextdate      date; --下次缴费日..
  v_begdate       date; --责任起始日期
  v_paysch        char(2); --缴费方式

  v_py int;

  cursor cur_policyno is
    select t.policyno from t_billing_info t;
  v_policyno cur_policyno%rowtype;
begin
  open cur_policyno;
  loop

    <<a>>

    fetch cur_policyno
      into v_policyno;
    exit when cur_policyno%notfound;

    begin
      --下次缴费日
      select (select m.nextdate
                from xq_moneysch m
               where m.policyno = v_policyno.policyno
                 and rownum = 1)
        into v_nextdate
        from dual;

      if v_nextdate is null then
        --dbms_output.put_line('下次缴费日为空或不存在');
        goto a;
      end if;

      --缴费方式（年缴、季缴、月缴）
      select (select m.paysch
                from xq_moneysch m
               where m.policyno = v_policyno.policyno
                 and rownum = 1)
        into v_paysch
        from dual;

      --单期保费、责任起始日期
      select (select sum(r.npaylen) * max(r.pieces)
                from xq_riskcon r
               where r.policyno = v_policyno.policyno)
        into v_amount
        from dual;

      if v_amount is null then
        --dbms_output.put_line('单期保费、责任起始日期为空或不存在');
        goto a;
      end if;

      if v_paysch = '01' then
        update t_billing_info f
           set f.amount        = v_amount, --单期保费
               f.owed          = 0, --欠缴期数
               f.owed_amount   = 0, --累计欠缴保费
               f.sprerec_years = 1, --应缴期数
               f.pay_sum       = 1, --已缴期数
               f.years         = 1, --缴费期次
               f.nextdate      = v_nextdate --下次缴费日
         where f.policyno = v_policyno.policyno;
        commit;
        goto a;
      end if;

      --单期保费、责任起始日期
      select (select max(r.begdate)
                from xq_riskcon r
               where r.policyno = v_policyno.policyno)
        into v_begdate
        from dual;

      if v_begdate is null then
        --dbms_output.put_line('单期保费、责任起始日期为空或不存在');
        goto a;
      end if;

      --应缴期数,缴费期次
      /*select (select max(r.years)
                from xq_reminder r
               where r.policyno = v_policyno.policyno
                 and to_char(r.cover1, 'yyyy-mm') <=
                     to_char(sysdate, 'yyyy-mm'))
        into v_years
        from dual;

      if v_years is null then
        --dbms_output.put_line('应缴期数,缴费期次为空或不存在');
        goto a;
      end if;

      v_sprerec_years := v_years;*/

      select decode(v_paysch, '11', 3, '12', 6, '13', 12, 1)
        into v_py
        from dual;

       --应缴期数,缴费期次 =  (系统当前时间（月份） - 责任起始日期（月份）)/缴费频率
       v_years := floor(months_between(to_date(to_char(sysdate,
                                                        'yyyy-mm'),
                                                'yyyy-mm'),
                                        to_date(to_char(v_begdate, 'yyyy-mm'),
                                                'yyyy-mm')) / v_py);

       if v_years < 0 then
         v_years := 0;
       end if;

       v_sprerec_years := v_years;

      --已缴期数=（下次缴费日年月-责任起始日期年月）/缴费方式
      v_pay_sum := floor(months_between(to_date(to_char(v_nextdate,
                                                        'yyyy-mm'),
                                                'yyyy-mm'),
                                        to_date(to_char(v_begdate, 'yyyy-mm'),
                                                'yyyy-mm')) / v_py);
      --缴费期次和应缴期数、欠缴期数=应缴期数-已缴期数
      v_owed := v_sprerec_years - v_pay_sum;
      if v_owed < 0 then
        v_owed := 0;
      end if;
      --累计欠缴保费=单期保费*欠缴期数
      v_owed_amount := v_amount * v_owed;

      update t_billing_info f
         set f.amount        = v_amount, --单期保费
             f.owed          = v_owed, --欠缴期数
             f.owed_amount   = v_owed_amount, --累计欠缴保费
             f.sprerec_years = v_sprerec_years, --应缴期数
             f.pay_sum       = v_pay_sum, --已缴期数
             f.years         = v_years, --缴费期次
             f.nextdate      = v_nextdate --下次缴费日
       where f.policyno = v_policyno.policyno;
      commit;
      --dbms_output.put_line('正常：' || v_nextdate || ','
      --   || v_paysch || ',' || v_amount || ',' || v_begdate || ',' || v_years);

    exception
      when no_data_found then
        begin
          rollback;
          dbms_output.put_line(sqlerrm || ':' || sqlcode);
          dbms_output.put_line(v_nextdate || ',' || v_paysch || ',' ||
                               v_amount || ',' || v_begdate || ',' ||
                               v_years);
        end;
    end;
  end loop;
  close cur_policyno;

exception
  when others then
    begin
      rollback;
      close cur_policyno;
      dbms_output.put_line(sqlerrm || ':' || sqlcode);
    end;
end P_T_BILLING_INFO;
/

prompt
prompt Creating procedure P_USE_UNCON_CNT_DAY
prompt ======================================
prompt
create or replace procedure unicall.p_use_uncon_cnt_day is
begin
  delete rpt_use_list_day
   where to_char(t_archive, 'yyyy-mm-dd') = to_char(sysdate, 'yyyy-mm-dd');

  insert into rpt_use_list_day
    select use_id, count(*) cnt, sysdate
      from c_ob_com_cus a
     where a.con_sta_id = 40
       and not (a.use_id is null)
     group by use_id;

  commit;
end;
/

prompt
prompt Creating procedure P_XQ_ACCOUNT_IN
prompt ==================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_ACCOUNT_IN IS
  --更新或插入续收系统 账户信息（银行账户）表
  v_begtime number(18) := 0;
  v_sno     number(18) := 0;
  coun_id   number(18) := 0;

  v_insert_rows number(18) := 0;
  v_update_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  CURSOR cur_info IS
    SELECT *
      FROM PLC_PRM_TRANS_ACCT P
     WHERE EXISTS (SELECT * FROM XQ_APP A WHERE A.POLICYNO = P.POLICY_NO);
  v_info cur_info%ROWTYPE;

BEGIN
  select b.nextvalue
    into coun_id
    from c_id_bro b
   where b.name = 'xq_account';
  OPEN cur_info;
  LOOP
    FETCH cur_info
      INTO v_info;
    EXIT WHEN cur_info%NOTFOUND;

    select (select c.sno
              from xq_account c
             where c.usetype = v_info.account_usage
               and c.policyno = v_info.policy_no
               and rownum = 1)
      into v_sno
      from dual;
    IF v_sno > 0 THEN
      select (select c.begtime
                from xq_account c
               where c.sno = v_sno
                 and rownum = 1)
        into v_begtime
        from dual;

      IF v_info.begtime > v_begtime THEN
        --update xq_account
        begin
          update xq_account a
             set a.acco_no    = v_info.account_no,
                 a.usetype    = v_info.account_usage,
                 a.regdate    = v_info.oper_date,
                 a.open_date  = v_info.open_date,
                 a.bankcode   = v_info.bank_code,
                 a.bankname   = v_info.bank_name,
                 a.policyno   = v_info.policy_no,
                 a.ownerid    = v_info.owner_id,
                 a.oper_no    = v_info.oper_no,
                 a.etl_time   = v_info.etl_time,
                 a.begtime    = v_info.begtime,
                 a.endtime    = v_info.endtime,
                 a.src_sys    = v_info.src_sys
           where a.SNO = v_sno;

          v_update_rows := v_update_rows + 1;
        exception
          when others then
            -- 遇到异常做一些处理
            begin
              v_error_rows := v_error_rows + 1;
              p_xq_log_in_err('IDS',
                              'P_XQ_ACCOUNT_IN',
                              v_sno,
                              '更新表xq_account数据' || sqlerrm); --写日志
            end;
        end;
      END IF;
    else
      --insert xq_account
      coun_id := coun_id + 1;
      begin
        insert into xq_account
          (SNO,
           typeid,
           acco_no,
           usetype,
           regdate,
           open_date,
           currency,
           bankcode,
           bankname,
           policyno,
           ownerid,
           oper_no,
           etl_time,
           begtime,
           endtime,
           src_sys)
        values
          (coun_id,
           '2000642',
           v_info.account_no,
           v_info.account_usage,
           v_info.oper_date,
           v_info.open_date,
           'CNY',
           v_info.bank_code,
           v_info.bank_name,
           v_info.policy_no,
           v_info.owner_id,
           v_info.oper_no,
           v_info.etl_time,
           v_info.begtime,
           v_info.endtime,
           v_info.src_sys);

        v_insert_rows := v_insert_rows + 1;

      exception
        when others then
          -- 遇到异常做一些处理
          begin
            v_error_rows := v_error_rows + 1;
            p_xq_log_in_err('IDS',
                            'P_XQ_ACCOUNT_IN',
                            'usetype:' || v_info.account_usage || ' policyno:' ||
                            v_info.policy_no || ' ownerid:' ||
                            v_info.owner_id,
                            '插入表xq_account数据' || sqlerrm); --写日志
          end;
      end;
    END IF;
    COMMIT;
  END LOOP;
  CLOSE cur_info;
  update c_id_bro b set b.nextvalue = coun_id where b.name = 'xq_account';
  commit;
  --添加数据库成功日志
  p_xq_log_suc('IDS',
               'P_XQ_ACCOUNT_IN',
               v_insert_rows,
               v_error_rows,
               v_update_rows,
               '数据丢失0条',
               sqlerrm);

EXCEPTION
  WHEN OTHERS THEN
    begin

      if cur_info%isopen then
        CLOSE cur_info;
      end if;

      update c_id_bro t
         set t.nextvalue = coun_id
       where t.name = 'xq_account';
      commit;

      --添加数据库失败日志
      p_xq_log_err('IDS',
                   'P_XQ_ACCOUNT_IN',
                   v_insert_rows,
                   v_error_rows,
                   v_update_rows,
                   '数据丢失0条',
                   sqlerrm);
    end;
END P_XQ_ACCOUNT_IN;
/

prompt
prompt Creating procedure P_XQ_ADDRESS_IN
prompt ==================================
prompt
create or replace procedure unicall.P_XQ_ADDRESS_IN is
  v_count   number(18);
  v_id      number(18);
  v_sno     number(18);
  v_begtime NUMBER(11);
  v_idtype  number(10);

  v_insert_rows number(18) := 0;
  v_update_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  cursor cur_address is
    select * from address;
  v_address cur_address%rowtype;

begin
  --获取主键值
  select t.nextvalue into v_id from c_id_bro t where t.name = 'xq_address';

  open cur_address;
  loop
    fetch cur_address
      into v_address;
    exit when cur_address%notfound;

    select (select p.sno
            from xq_person p
           where p.SOURCE_PERSON_ID = v_address.SOURCE_PERSON_ID
             and rownum = 1)
    into v_count
    from dual;

    if v_count > 0 then
      select (select t.sno
                from xq_address t
               where t.usage = v_address.usage
                 and t.source_person_id = v_address.source_person_id
                 and t.seq = v_address.seq
                 and rownum = 1)
        into v_sno
        from dual;

      if trim(v_address.idtype) = '1' then
        v_idtype := 1101;
      else
        --证件类型对应字典表ID
        select (select t.id
                  from xq_dict t
                 where t.parent_id = 11
                   and t.item_code = v_address.idtype)
          into v_idtype
          from dual;

        if v_idtype is null then
          v_idtype := 1150;
        end if;
      end if;

      if v_sno is null then
        --未查到，插入
        begin
          insert into xq_address
            (sno,
             typeid,
             country,
             city,
             region,
             subregion,
             street,
             subaddr,
             zip,
             addr,
             usage,
             person_id,
             pid,
             idtype,
             id15,
             branch,
             etl_time,
             idtype_ids,
             source_person_id,
             begtime,
             endtime,
             src_sys,
             seq)
          values
            (v_id,
             v_address.typeid,
             v_address.country,
             v_address.city,
             v_address.region,
             v_address.subregion,
             v_address.street,
             v_address.subaddr,
             v_address.zip,
             v_address.addr,
             v_address.usage,
             v_address.person_id,
             v_address.pid,
             v_idtype,
             v_address.id15,
             v_address.branch,
             v_address.etl_time,
             v_address.idtype,
             v_address.source_person_id,
             v_address.begtime,
             v_address.endtime,
             v_address.src_sys,
             v_address.seq);

        exception
          when others then
            -- 遇到异常做一些处理
            begin
              p_xq_log_in_err('IDS','P_XQ_ADDRESS_IN',
                  'usage:'||v_address.usage||' source_person_id:'||v_address.source_person_id||' seq:'||v_address.seq,
                  '插入表xq_address数据'||sqlerrm);--写日志
              v_error_rows :=v_error_rows+1;
            end;
        end;
        v_insert_rows :=v_insert_rows+1;
        v_id := v_id + 1;
      else
        select (select t.begtime
                  from xq_address t
                 where t.usage = v_address.usage
                   and t.source_person_id = v_address.source_person_id
                   and t.seq = v_address.seq
                   and rownum = 1)
          into v_begtime
          from dual;

        if v_address.begtime > v_begtime then
          --更新
          begin
            update xq_address t
               set t.typeid           = v_address.typeid,
                   t.country          = v_address.country,
                   t.city             = v_address.city,
                   t.region           = v_address.region,
                   t.subregion        = v_address.subregion,
                   t.street           = v_address.street,
                   t.subaddr          = v_address.subaddr,
                   t.zip              = v_address.zip,
                   t.addr             = v_address.addr,
                   t.usage            = v_address.usage,
                   t.person_id        = v_address.person_id,
                   t.pid              = v_address.pid,
                   t.idtype           = v_idtype,
                   t.id15             = v_address.id15,
                   t.branch           = v_address.branch,
                   t.etl_time         = v_address.etl_time,
                   t.idtype_ids       = v_address.idtype,
                   t.source_person_id = v_address.source_person_id,
                   t.begtime          = v_address.begtime,
                   t.endtime          = v_address.endtime,
                   t.src_sys          = v_address.src_sys,
                   t.seq              = v_address.seq
             where t.sno = v_sno;

          exception
            when others then
              -- 遇到异常做一些处理
              begin
                p_xq_log_in_err('IDS','P_XQ_ADDRESS_IN',
                  v_sno,
                  '更新表xq_address数据'||sqlerrm);--写日志
                v_error_rows :=v_error_rows+1;
              end;
          end;
          v_update_rows :=v_update_rows+1;
        end if;
      end if;

      commit;

    end if;
  end loop;
  close cur_address;

  update c_id_bro t set t.nextvalue = v_id where t.name = 'xq_address';
  commit;

  --添加数据库成功日志
  p_xq_log_suc('IDS',
              'P_XQ_ADDRESS_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);

EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;

      if cur_address%isopen then
        CLOSE cur_address;
      end if;

      update c_id_bro t set t.nextvalue = v_id where t.name = 'xq_address';
      commit;
       --添加数据库失败日志
       p_xq_log_err('IDS',
              'P_XQ_ADDRESS_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);
    end;

end P_XQ_ADDRESS_IN;
/

prompt
prompt Creating procedure P_XQ_ADDRESS_IN_EVERY_DAY
prompt ============================================
prompt
create or replace procedure unicall.P_XQ_ADDRESS_IN_EVERY_DAY is
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_ADDRESS_IN_EVERY_DAY
  *  建立日期   ：2012-06-04
  *  作者       ：yangguoqi
  *  模块       ：IDS
  *  描述       ：每天同步address_temp表数据到xq_address
  *----------------------------------------------------
  *  序号   日期    修改人    修改原因
  *  1
  *  2
  ******************************************************
  */
  v_update_rows number(18) := 0;
  v_insert_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  v_all_insert_rows number(18) := 0;
  v_all_update_rows number(18) := 0;
  v_id      number(18);

  cursor cur_all_address is
    select *
      from address_temp r
     where exists (select 1
              from xq_all_address s
             where s.usage=r.usage and s.source_person_id = r.source_person_id and s.seq=r.seq
                   and r.begtime>s.begtime);

  v_all_address cur_all_address%rowtype;

begin

  delete address_temp t   --删除重复记录
         where t.rowid not in
         (select max(rowid)
            from address_temp r
           group by r.usage,r.source_person_id,r.seq);
  commit;

  --同步数据到个人全量信息表中
  open cur_all_address;
  loop
    fetch cur_all_address
      into v_all_address;
    exit when cur_all_address%notfound;

    --更新全量表中存在的信息
    begin
      --为了提高效率这里不再判断begtime是否大于
      update xq_all_address r
         set r.sno       = v_all_address.sno,
             r.typeid    = v_all_address.typeid,
             r.country   = v_all_address.country,
             r.city      = v_all_address.city,
             r.region    = v_all_address.region,
             r.subregion = v_all_address.subregion,
             r.street    = v_all_address.street,
             r.subaddr   = v_all_address.subaddr,
             r.zip       = v_all_address.zip,
             r.addr      = v_all_address.addr,
             r.person_id = v_all_address.person_id,
             r.pid       = v_all_address.pid,
             r.idtype    = v_all_address.idtype,
             r.purpose   = v_all_address.purpose,
             r.id15      = v_all_address.id15,
             r.begtime   = v_all_address.begtime,
             r.endtime   = v_all_address.endtime,
             r.branch    = v_all_address.branch,
             r.etl_time  = v_all_address.etl_time,
             r.src_sys   = v_all_address.src_sys
       where r.usage=v_all_address.usage and r.source_person_id = v_all_address.source_person_id and r.seq=v_all_address.seq;

    exception
      when others then
        v_error_rows := v_error_rows + 1;
        -- 遇到异常做一些处理
        begin
          p_xq_log_in_err('IDS','P_XQ_ADDRESS_IN_EVERY_DAY',
                'usage:'||v_all_address.usage ||' source_person_id:'||v_all_address.source_person_id ||' seq:'||v_all_address.seq
                ,'更新表xq_all_address数据'||sqlerrm);--把主键放进日志中
          v_error_rows := v_error_rows + 1;
        end;
    end;

    v_all_update_rows := v_all_update_rows + 1;

  end loop;
  close cur_all_address;
  commit;--批量提交

  --插入全量表不存在记录
    for c_r in (select sno,typeid,country,city,region,subregion,street,subaddr,zip,addr,usage,person_id,pid,
              idtype,purpose,seq,source_person_id,id15,begtime,endtime,branch,etl_time,src_sys
          from address_temp r
         where not exists (select 1
                  from xq_all_address s
                where s.usage=r.usage and s.source_person_id = r.source_person_id and s.seq=r.seq)) loop

      begin

      insert into xq_all_address(sno,typeid,country,city,region,subregion,street,subaddr,zip,addr,usage,person_id,pid,
              idtype,purpose,seq,source_person_id,id15,begtime,endtime,branch,etl_time,src_sys)
      values(c_r.sno,c_r.typeid,c_r.country,c_r.city,c_r.region,c_r.subregion,c_r.street,c_r.subaddr,c_r.zip,c_r.addr,
              c_r.usage,c_r.person_id,c_r.pid,c_r.idtype,c_r.purpose,c_r.seq,c_r.source_person_id,c_r.id15,c_r.begtime,
              c_r.endtime,c_r.branch,c_r.etl_time,c_r.src_sys);

      v_all_insert_rows := v_all_insert_rows + 1;
      EXCEPTION
            WHEN OTHERS THEN
              begin
                p_xq_log_in_err('IDS','P_XQ_ADDRESS_IN_EVERY_DAY',
                'usage:'||c_r.usage ||' source_person_id:'||c_r.source_person_id ||' seq:'||c_r.seq
                ,'插入表xq_all_address数据'||sqlerrm);--把主键放进日志中
                v_error_rows := v_error_rows + 1;
              end;
      end;
      if mod(v_all_insert_rows,5000)=0 then
         commit;--批量提交记录
      end if;
      end loop;

    commit;

  --更新xp_phone记录begtime小的
  for c_r in (select sno,typeid,country,city,region,subregion,street,subaddr,zip,addr,usage,person_id,pid,
                     nvl(decode(r.idtype,
                                '1',
                                '1101',
                                (select t.id
                                   from xq_dict t
                                  where t.parent_id = 11
                                    and item_code = r.idtype
                                    and rownum = 1)),
                         1150) idtype_c,idtype,
                      purpose,seq,source_person_id,id15,begtime,endtime,branch,etl_time,src_sys
                      from xq_all_address r
                     where exists (select 1
                              from xq_address s
                             where s.usage = r.usage
                               and s.source_person_id = r.source_person_id
                               and s.seq = r.seq
                               and r.begtime > s.begtime)) loop
      begin

         update xq_address r
               set r.typeid           = c_r.typeid,
                   r.country          = c_r.country,
                   r.city             = c_r.city,
                   r.region           = c_r.region,
                   r.subregion        = c_r.subregion,
                   r.street           = c_r.street,
                   r.subaddr          = c_r.subaddr,
                   r.zip              = c_r.zip,
                   r.addr             = c_r.addr,
                   r.person_id        = c_r.person_id,
                   r.pid              = c_r.pid,
                   r.idtype           = c_r.idtype_c,
                   r.id15             = c_r.id15,
                   r.branch           = c_r.branch,
                   r.etl_time         = c_r.etl_time,
                   r.idtype_ids       = c_r.idtype,
                   r.begtime          = c_r.begtime,
                   r.endtime          = c_r.endtime,
                   r.src_sys          = c_r.src_sys
             where r.usage = c_r.usage
                   and r.source_person_id = c_r.source_person_id
                   and r.seq = c_r.seq;

      v_update_rows := v_update_rows + 1;

      EXCEPTION
            WHEN OTHERS THEN
              begin
                p_xq_log_in_err('IDS','P_XQ_ADDRESS_IN_EVERY_DAY',
                'usage:'||c_r.usage ||' source_person_id:'||c_r.source_person_id ||' seq:'||c_r.seq
                ,'更新表xq_address数据'||sqlerrm);--把主键放进日志中
                v_error_rows := v_error_rows + 1;
              end;
      end;
      end loop;
  commit;
  --获取主键值
  select t.nextvalue+1 into v_id from c_id_bro t where t.name = 'xq_address';

  --数据插入

  for c_r in (select sno,typeid,country,city,region,subregion,street,subaddr,zip,addr,usage,person_id,pid,
                     nvl(decode(r.idtype,
                                '1',
                                '1101',
                                (select t.id
                                   from xq_dict t
                                  where t.parent_id = 11
                                    and item_code = r.idtype
                                    and rownum = 1)),
                         1150) idtype_c,idtype,
                      purpose,seq,source_person_id,id15,begtime,endtime,branch,etl_time,src_sys
                from xq_all_address r
               where exists (select 1
                        from xq_person s
                       where r.source_person_id = s.source_person_id)
                 and not exists (select 1
                        from xq_address p
                       where r.usage = p.usage
                         and r.source_person_id = p.source_person_id
                         and r.seq = p.seq)) loop

      begin

      insert into xq_address(sno,typeid,country,city,region,subregion,street,subaddr,zip,addr,usage,person_id,pid,
                  idtype,id15,branch,etl_time,idtype_ids,source_person_id,begtime,endtime,src_sys,seq)
      values(v_id,c_r.typeid,c_r.country,c_r.city,c_r.region,c_r.subregion,c_r.street,c_r.subaddr,c_r.zip,c_r.addr,
            c_r.usage,c_r.person_id,c_r.pid,c_r.idtype_c,c_r.id15,c_r.branch,c_r.etl_time,c_r.idtype,
            c_r.source_person_id,c_r.begtime,c_r.endtime,c_r.src_sys,c_r.seq);

      v_insert_rows := v_insert_rows + 1;
      v_id := v_id + 1;
      EXCEPTION
            WHEN OTHERS THEN
              begin
                p_xq_log_in_err('IDS','P_XQ_ADDRESS_IN_EVERY_DAY',
                'usage:'||c_r.usage ||' source_person_id:'||c_r.source_person_id ||' seq:'||c_r.seq
                ,'插入表xq_address数据'||sqlerrm);--把主键放进日志中
                v_error_rows := v_error_rows + 1;
              end;
      end;
      commit;
      end loop;
  commit;

  update c_id_bro t set t.nextvalue = v_id where t.name = 'xq_address';
  commit;
  dbms_output.put_line('P_XQ_ADDRESS_IN_EVERY_DAY中数据更新 ' || v_update_rows ||
                       '行，数据插入 ' || v_insert_rows || '行,失败' ||
                       v_error_rows || '行,大数据量表插入' || v_all_insert_rows || '行,大数据量表更新' || v_all_update_rows || '行');

  --添加数据库成功日志
  p_xq_log_suc('IDS',
              'P_XQ_ADDRESS_IN_EVERY_DAY',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              'P_XQ_ADDRESS_IN_EVERY_DAY中数据更新 ' || v_update_rows ||
                       '行，数据插入 ' || v_insert_rows || '行,失败' ||
                       v_error_rows || '行,大数据量表插入' || v_all_insert_rows || '行,大数据量表更新' || v_all_update_rows || '行',
              sqlerrm);
  EXCEPTION
    WHEN OTHERS THEN
    begin
      rollback;

      if cur_all_address%isopen then
        close cur_all_address;
      end if;

      rollback;

      dbms_output.put_line('P_XQ_ADDRESS_IN_EVERY_DAY全局异常ERROR' || sqlerrm);

      --添加数据库失败日志
      p_xq_log_err('IDS',
              'P_XQ_ADDRESS_IN_EVERY_DAY',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              'P_XQ_ADDRESS_IN_EVERY_DAY中数据更新 ' || v_update_rows ||
                       '行，数据插入 ' || v_insert_rows || '行,失败' ||
                       v_error_rows || '行,大数据量表插入' || v_all_insert_rows || '行,大数据量表更新' || v_all_update_rows || '行',
              sqlerrm);
      update c_id_bro t set t.nextvalue = v_id where t.name = 'xq_address';
      commit;
    end;
end P_XQ_ADDRESS_IN_EVERY_DAY;
/

prompt
prompt Creating procedure P_XQ_ADDRESS_IN_NOT_BK
prompt =========================================
prompt
create or replace procedure unicall.P_XQ_ADDRESS_IN_NOT_BK is

  v_sno     number(18);
  v_begtime NUMBER(11);
  v_idtype  number(10);

  cursor cur_address is
    select * from address;
  v_address cur_address%rowtype;

begin

  open cur_address;
  loop
    fetch cur_address
      into v_address;
    exit when cur_address%notfound;

    select (select t.sno
              from xq_address t
             where t.source_person_id = v_address.SOURCE_PERSON_ID || '001'
               and t.pid = v_address.pid
               and t.usage = v_address.usage
               and rownum = 1)
      into v_sno
      from dual;

    if v_sno is not null then
      if trim(v_address.idtype) = '1' then
        v_idtype := 1101;
      else
        --证件类型对应字典表ID
        select (select t.id
                  from xq_dict t
                 where t.parent_id = 11
                   and t.item_code = v_address.idtype)
          into v_idtype
          from dual;

        if v_idtype is null then
          v_idtype := 1150;
        end if;
      end if;
      --获取begtime值
      select (select t.begtime from xq_address t where t.sno = v_sno)
        into v_begtime
        from dual;

      if v_address.begtime > v_begtime then
        --更新
        begin
          update xq_address t
             set t.typeid           = v_address.typeid,
                 t.country          = v_address.country,
                 t.city             = v_address.city,
                 t.region           = v_address.region,
                 t.subregion        = v_address.subregion,
                 t.street           = v_address.street,
                 t.subaddr          = v_address.subaddr,
                 t.zip              = v_address.zip,
                 t.addr             = v_address.addr,
                 t.person_id        = v_address.person_id,
                 t.idtype           = v_idtype,
                 t.id15             = v_address.id15,
                 t.branch           = v_address.branch,
                 t.etl_time         = v_address.etl_time,
                 t.idtype_ids       = v_address.idtype,
                 t.begtime          = v_address.begtime,
                 t.endtime          = v_address.endtime,
                 t.src_sys          = v_address.src_sys,
                 t.seq              = v_address.seq
           where t.source_person_id = v_address.SOURCE_PERSON_ID || '001'
             and t.pid = v_address.pid
             and t.usage = v_address.usage;

        exception
          when others then
            -- 遇到异常做一些处理
            begin
              dbms_output.put_line('data error :' ||
                                   v_address.source_person_id || '--' ||
                                   v_address.sno);
            end;
        end;
      end if;
      commit;
    end if;
  end loop;
  close cur_address;

EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;
      dbms_output.put_line('ERROR');
    end;

end P_XQ_ADDRESS_IN_NOT_BK;
/

prompt
prompt Creating procedure P_XQ_APP_IN
prompt ==============================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_APP_IN IS

  i         integer := 1;
  v_id      number(18) := 0;
  v_begtime number(18) := 0;

  v_AIDTYPE     number(10);
  v_SALEATTR    number(10);
  v_POLIST      number(10) := 0;
  v_IDTYPE      number(10);
  v_AMOUNT      number(16, 2) := 0;

  v_policyno varchar2(20) := '0';
  v_amount_1 number(16, 2) := 0;
  v_amount_2 number(16, 2) := 0;

  v_insert_rows number(18) := 0;
  v_update_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  CURSOR cur_info IS
   select *
     from riskcon r
    where r.saleattr in ('61', '62', '63', '64','10','13','15','31','32','33','35','51','52')
      and r.classcode in
          (select p.classcode from xq_riskclass p where p.timestr = '1');
  v_info cur_info%rowtype;

BEGIN

  select o.nextvalue
    into v_id
    from c_id_bro o
   where o.name = 'xq_app';

  open cur_info;
  loop
    fetch cur_info
      into v_info;
    exit when cur_info%notfound;

    v_policyno := v_info.policyno;

    select (select a.begtime
              from xq_app a
             where a.policyno = v_info.policyno
               and rownum = 1)
      into v_begtime
      from dual;

    --证件类型对应字典表ID
    if trim( v_info.aidtype) = '1' then
       v_AIDTYPE := 1101;
    else
     begin
        select (select t.id
                  from xq_dict t
                 where t.parent_id = 11
                   and t.item_code = v_info.aidtype)
          into v_AIDTYPE
          from dual;

        if v_AIDTYPE is null then
           v_AIDTYPE := 1150;
        end if;
      end;
    end if;
    --销售渠道对应字典表ID
    select (select t.id
              from xq_dict t
             where t.parent_id = 6
               and t.item_code = v_info.saleattr)
      into v_SALEATTR
      from dual;

      if v_SALEATTR is null then
         v_SALEATTR := 650;
      end if;

    --保单状态对应字典表ID
      if (v_info.polist = '2' or v_info.polist = 'A' or v_info.polist = 'D' or v_info.polist = 'G') then
         v_POLIST := 201;
      elsif (v_info.polist = '3' or v_info.polist = 'B') then
         v_POLIST := 202;
      elsif (v_info.polist = '7' or v_info.polist = '8' or v_info.polist = '9' or v_info.polist = 'C') then
         v_POLIST := 203;
      elsif (v_info.polist = 'E') then
         v_POLIST := 204;
      elsif (v_info.polist = '4' or v_info.polist = '5' or v_info.polist = '6' or v_info.polist = 'F' or v_info.polist = 'H' or v_info.polist = 'O' or v_info.polist = 'P' or v_info.polist = 'Q' or v_info.polist = 'R' or v_info.polist = 'S') then
         v_POLIST := 205;
      else
         v_POLIST := 250;
      end if;


    --证件类型对应字典表ID
    if trim(v_info.idtype) = '1' then
       v_IDTYPE := 1101;
    else
       begin
        select (select t.id
                  from xq_dict t
                 where t.parent_id = 11
                   and t.item_code = v_info.idtype)
          into v_IDTYPE
          from dual;

          if v_IDTYPE is null then
             v_IDTYPE := 1150;
          end if;
       end;
     end if;

    if v_begtime > 0 then

      if v_info.begtime > v_begtime then
       --update
       begin
          update xq_app a
             set a.APPNO      = v_info.APPNO,
                 a.APERSON_ID = v_info.APERSON_ID,
                 a.APID       = v_info.APID,
                 a.AIDTYPE    = v_AIDTYPE,
                 a.RISKCON_ID = v_info.RISKCON_ID,
                 a.SALEATTR   = v_SALEATTR,
                 a.BEGDATE   = v_info.BEGDATE,
                 a.STOPDATE  = v_info.STOPDATE,
                 a.POLIST    = v_POLIST,
                 a.PIECES    = v_info.PIECES,
                 a.OPDATE    = v_info.OPDATE,
                 a.RENEWDATE = v_info.RENEWDATE,
                 a.PERSON_ID         = v_info.PERSON_ID,
                 a.IDTYPE            = v_IDTYPE,
                 a.PID               = v_info.PID,
                 a.APPDATE           = v_info.APPDATE,
                 a.RENEWID           = v_info.RENEWID,
                 a.SALE_PROD_CODE    = v_info.SALE_PROD_CODE,
                 a.NPAYLEN           = v_info.NPAYLEN,
                 a.STDRATE           = v_info.STDRATE,
                 a.UNSTDRATE         = v_info.UNSTDRATE,
                 a.ETL_TIME          = v_info.ETL_TIME,
                 a.TYPEID            = v_info.TYPEID,
                 a.GCON_ID           = v_info.GCON_ID,
                 a.GPOLICYNO         = v_info.GPOLICYNO,
                 a.DESKPAY           = v_info.DESKPAY,
                 a.REASON            = v_info.REASON,
                 a.CURRENCY          = v_info.CURRENCY,
                 a.OPER_ID           = v_info.OPER_ID,
                 a.OPERNO            = v_info.OPERNO,
                 a.EMPNO_ID          = v_info.EMPNO_ID,
                 a.EMPNO             = v_info.EMPNO,
                 a.CSR_ID            = v_info.CSR_ID,
                 a.CSRNO             = v_info.CSRNO,
                 a.COMNUM            = v_info.COMNUM,
                 a.JOB               = v_info.JOB,
                 a.SHARETYPE         = v_info.SHARETYPE,
                 a.SPECAGR           = v_info.SPECAGR,
                 a.DISCOUNT          = v_info.DISCOUNT,
                 a.ISCARD            = v_info.ISCARD,
                 a.DCDM              = v_info.DCDM,
                 a.PRELNAME          = v_info.PRELNAME,
                 a.BANKFLAG          = v_info.BANKFLAG,
                 a.PAYSEQ            = v_info.PAYSEQ,
                 a.BENPARAM          = v_info.BENPARAM,
                 a.OWNER_SOURCE_ID   = v_info.OWNER_SOURCE_ID,
                 a.INSURED_SOURCE_ID = v_info.INSURED_SOURCE_ID,
                 a.WORKNO            = v_info.WORKNO,
                 a.COMB_POLICY_NO    = v_info.COMB_POLICY_NO,
                 a.APP_AGE           = v_info.APP_AGE,
                 a.BEGTIME           = v_info.BEGTIME,
                 a.ENDTIME           = v_info.ENDTIME,
                 a.BRANCH            = v_info.BRANCH,
                 a.SRC_SYS           = v_info.SRC_SYS,
                 a.SUB_AGT_NO        = v_info.SUB_AGT_NO
           where a.policyno = v_info.policyno;

           v_update_rows :=v_update_rows+1;
           exception
           when others then
            -- 遇到异常做一些处理
              begin
                p_xq_log_in_err('IDS','P_XQ_APP_IN',
                  v_info.POLICYNO,
                  '更新表xq_app数据'||sqlerrm);--写日志
               v_error_rows :=v_error_rows+1;
              end;
         end;
      end if;

    else
     --insert
        select (select r.tmount
                  from riskcon r
                 where r.policyno = v_info.policyno
                   and r.appf = '1'
                   and r.saleattr in ('61', '62', '63', '64','10','13','15','31','32','33','35','51','52')
                   and rownum = 1)
          into v_amount_1
          from dual;

        if v_amount_1 is null then
          v_amount_1 := 0;
        end if;

         select sum(r.tmount)
           into v_amount_2
           from riskcon r
          where r.policyno = v_info.policyno
            and r.appf = '2'
            and r.saleattr in ('61', '62', '63', '64','10','13','15','31','32','33','35','51','52');


       if v_amount_2 is null then
         v_amount_2 := 0;
       end if;

        v_AMOUNT := v_amount_1 + v_amount_2;

      begin
        insert into xq_app
          (XQ_APP_ID,
           POLICYNO,
           APPNO,
           APERSON_ID,
           APID,
           AIDTYPE,
           RISKCON_ID,
           SALEATTR,
           BEGDATE,
           STOPDATE,
           POLIST,
           PIECES,
           OPDATE,
           RENEWDATE,
           TMOUNT,
           PERSON_ID,
           IDTYPE,
           PID,
           APPDATE,
           RENEWID,
           SALE_PROD_CODE,
           NPAYLEN,
           STDRATE,
           UNSTDRATE,
           ETL_TIME,
           TYPEID,
           GCON_ID,
           GPOLICYNO,
           DESKPAY,
           REASON,
           CURRENCY,
           OPER_ID,
           OPERNO,
           EMPNO_ID,
           EMPNO,
           CSR_ID,
           CSRNO,
           COMNUM,
           JOB,
           SHARETYPE,
           SPECAGR,
           DISCOUNT,
           ISCARD,
           DCDM,
           PRELNAME,
           BANKFLAG,
           PAYSEQ,
           BENPARAM,
           OWNER_SOURCE_ID,
           INSURED_SOURCE_ID,
           WORKNO,
           COMB_POLICY_NO,
           APP_AGE,
           BEGTIME,
           ENDTIME,
           BRANCH,
           SRC_SYS,
           SUB_AGT_NO,
           TOTAL_PAY_AMOUNT,
           TOTAL_STATISTICS_DATE)
        values
          (v_id,
           v_info.POLICYNO,
           v_info.APPNO,
           v_info.APERSON_ID,
           v_info.APID,
           v_AIDTYPE,
           v_info.RISKCON_ID,
           v_SALEATTR,
           v_info.BEGDATE,
           v_info.STOPDATE,
           v_POLIST,
           v_info.PIECES,
           v_info.OPDATE,
           v_info.RENEWDATE,
           v_AMOUNT,
           v_info.PERSON_ID,
           v_IDTYPE,
           v_info.PID,
           v_info.APPDATE,
           v_info.RENEWID,
           v_info.SALE_PROD_CODE,
           v_info.NPAYLEN,
           v_info.STDRATE,
           v_info.UNSTDRATE,
           v_info.ETL_TIME,
           v_info.TYPEID,
           v_info.GCON_ID,
           v_info.GPOLICYNO,
           v_info.DESKPAY,
           v_info.REASON,
           v_info.CURRENCY,
           v_info.OPER_ID,
           v_info.OPERNO,
           v_info.EMPNO_ID,
           v_info.EMPNO,
           v_info.CSR_ID,
           v_info.CSRNO,
           v_info.COMNUM,
           v_info.JOB,
           v_info.SHARETYPE,
           v_info.SPECAGR,
           v_info.DISCOUNT,
           v_info.ISCARD,
           v_info.DCDM,
           v_info.PRELNAME,
           v_info.BANKFLAG,
           v_info.PAYSEQ,
           v_info.BENPARAM,
           v_info.OWNER_SOURCE_ID,
           v_info.INSURED_SOURCE_ID,
           v_info.WORKNO,
           v_info.COMB_POLICY_NO,
           v_info.APP_AGE,
           v_info.BEGTIME,
           v_info.ENDTIME,
           v_info.BRANCH,
           v_info.SRC_SYS,
           v_info.SUB_AGT_NO,
           v_AMOUNT,
           sysdate);

           v_insert_rows :=v_insert_rows+1;
           exception
           when others then
            -- 遇到异常做一些处理
              begin
               p_xq_log_in_err('IDS','P_XQ_APP_IN',
                  v_info.POLICYNO,
                  '插入表xq_app数据'||sqlerrm);--写日志
               v_error_rows :=v_error_rows+1;
              end;
      end;
      v_id := v_id + 1;

    end if;
    if mod(i, 1000) = 0 then
      commit;
    end if;
    i := i + 1;
  end loop;
  update c_id_bro o set o.nextvalue = v_id where o.name = 'xq_app';
  commit;
  close cur_info;

  --添加数据库成功日志
  p_xq_log_suc('IDS',
              'P_XQ_APP_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);
EXCEPTION
  when others then
    begin
      rollback;

      if cur_info%isopen then
        CLOSE cur_info;
      end if;
      dbms_output.put_line('cur error: policyno = '||v_policyno||sqlerrm);
      --添加数据库成功日志
      p_xq_log_err('IDS',
              'P_XQ_APP_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);
    end;

END P_XQ_APP_IN;
/

prompt
prompt Creating procedure P_XQ_APP_UPDATE_TOTAL
prompt ========================================
prompt
create or replace procedure unicall.p_xq_app_update_total is
  --更新xq_app表字段TMOUNT、TOTAL_PAY_AMOUNT、TOTAL_STATISTICS_DATE
  i integer := 1;

  cursor cur_info is
    select x.policyno as policyno, sum(x.tmount) as stmt
      from xq_riskcon x
     where x.classcode in
           (select p.classcode from xq_riskclass p where p.timestr = '1')
     group by x.policyno;

  v_info cur_info%rowtype;

begin

  open cur_info;
  loop
    fetch cur_info
      into v_info;
    exit when cur_info%notfound;

    update xq_app p
       set p.tmount                = v_info.stmt,
           p.total_pay_amount      = v_info.stmt,
           p.total_statistics_date = sysdate
     where p.policyno = v_info.policyno;

    if mod(i, 1000) = 0 then
      commit;
    end if;
    i := i + 1;

  end loop;
  commit;

  close cur_info;
exception
  when others then
    begin
      dbms_output.put_line('cur error');
    end;
end p_xq_app_update_total;
/

prompt
prompt Creating procedure P_XQ_CBD_REPORT_IN
prompt =====================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_CBD_REPORT_IN(
 sta_date date,--统计开始日期
 end_date date --统计结束日期
) IS
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_CBD_REPORT_IN
  *  建立日期   ：2012-08-22
  *  作者       ：yangguoqi
  *  模块       ：IDS
  *  描述       ：电销承保单清单报表业务
  *----------------------------------------------------
  *  序号   日期    修改人    修改原因
  *  1
  *  2
  ******************************************************
  测试记录 去掉usage索引后 12920 0 ：22s (22秒)  2011-8-1 2011-10-1
  */

  v_insert_rows number(18) := 0;
  v_update_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  time_before binary_integer :=Dbms_Utility.get_time;--过程开始时间(毫秒)
  time_after binary_integer;--过程结束时间(毫秒)

  v_post_address varchar(1000); --客户邮寄地址
  v_post_zip varchar(6); --客户邮寄地址邮编
  v_addr_address varchar(1000);--客户地址
  v_addr_zip varchar(6);--客户地址邮编

  v_paycode varchar(50);--缴费方式
  v_setcode varchar(50);--支付形式
  v_yearnum  number(20) := 0;--缴费年限
  v_polist  varchar(50); --保单状态

  v_bankcode varchar(30);--取扣款银行
  v_bankno varchar(30);--扣款账号

  v_years  NUMBER(11);--应缴期次
  v_sumamount NUMBER(18,2);--累计缴费
  v_singleAmount NUMBER(18,2);--单期缴费
  v_linum  NUMBER(11);--理赔次数
  v_total_fee  NUMBER(18,2);--保单总保额
  v_nh_total_fee  NUMBER(18,2);--保单总保费（年化新保）

  v_tb_hometel varchar(50); --投保人家庭电话
  v_tb_unittel  VARCHAR2(50);--投保人单位电话
  v_tb_mobiletel VARCHAR2(50);--投保人手机号码

  v_tb_job varchar(200); --投保人职业
  v_job_name varchar(200); --投保人职业

  v_company_name varchar(50); --分公司

  v_item_paycode varchar(50); --paycode

  CURSOR cur_info(startdate date, enddate date) IS
    select x.*,
         xqdict.item_name saleattr_name,
         xm.nextdate,
         xm.rectele,
         (select r.classname
            from xq_riskclass r
           where r.o_classcode = x.classcode
             and rownum = 1) classname,
         xe.name,
         tas.status_desc,
         (select trim(tel)
            from xq_phone
           where usage = '2'
             and pid = upper(trim(x.apid))
             and rownum = 1) tb_hometel,
         (select job
            from xq_person
           where id = x.apid
             and rownum = 1) tb_job,
         (select trim(tel)
            from xq_phone
           where usage = '8'
             and pid = upper(trim(x.apid))
             and rownum = 1) tb_unittel,
         (select trim(tel)
            from xq_phone
           where type = '2'
             and pid = upper(x.apid)
             and rownum = 1) tb_mobiletel
    from (select t.application_id,
                 t.idorg,
                 t.agent_id,
                 t.appno,
                 t.app_status, --投保单状态
                 t.acus_name,
                 t.acus_licno,
                 t.icus_name,
                 t.icus_licno,
                 t.total_fee,
                 rsk.policyno,
                 rsk.opdate,
                 rsk.saleattr,
                 rsk.classcode,
                 rsk.polist,
                 rsk.begdate, --保单责任起期
                 rsk.empno,
                 rsk.insured_source_id,
                 rsk.owner_source_id,
                 rsk.pid,
                 rsk.apid,
                 rsk.aperson_id,
                 rsk.branch
            from tb_application t
            join (select appno,
                        policyno,
                        opdate,
                        saleattr,
                        classcode,
                        polist,
                        begdate,
                        empno,
                        insured_source_id,
                        owner_source_id,
                        pid,
                        apid,
                        aperson_id,
                        branch
                   from (select *
          from xq_riskcon
         where appf = '1'
           and opdate >= startdate
           and opdate <= enddate) r
 where exists (select 1
          from xq_riskclass p
         where p.classcode = r.classcode
           and p.timestr = '1')) rsk
              on t.policyno = rsk.policyno) x,
         xq_moneysch xm,
         xq_dict xqdict,
         xq_empno xe,
         t_app_status tas
   where (x.policyno = xm.policyno(+) and x.classcode=xm.classcode(+))
     and x.saleattr = xqdict.id(+)
     and x.empno = xe.empno(+)
     and x.app_status = tas.status_code(+);

  v_info cur_info%ROWTYPE;


BEGIN
  --删除掉已存在的数据，然后重新跑
  delete t_xq_cbj_list_report r where r.opdate>=sta_date and r.opdate<=end_date;
  commit;--提交数据

OPEN cur_info(sta_date,end_date);
  LOOP
    FETCH cur_info
      INTO v_info;
    EXIT WHEN cur_info%NOTFOUND;

    --客户邮寄地址,客户邮寄地址邮编
    BEGIN
      BEGIN
        SELECT TRIM(ADDR), TRIM(ZIP)
          INTO v_post_address, v_post_zip
          FROM XQ_ADDRESS
         WHERE USAGE = 1
           AND PID = UPPER(TRIM(v_info.APID))
           AND ROWNUM = 1;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_post_address := '';
          v_post_zip     := '';
      END;

      BEGIN
        if v_post_address is null then
          SELECT TRIM(ADDR), TRIM(ZIP)
            INTO v_post_address, v_post_zip
            FROM XQ_ADDRESS
           WHERE USAGE = 1
             AND PERSON_ID = v_info.APERSON_ID
             AND ROWNUM = 1;
           end if;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_post_address := '';
          v_post_zip     := '';
      END;

      BEGIN
        if v_post_address is null then
          SELECT TRIM(ADDR), TRIM(ZIP)
            INTO v_post_address, v_post_zip
            FROM XQ_ADDRESS
           WHERE USAGE = 1
             AND SOURCE_PERSON_ID = v_info.OWNER_SOURCE_ID
             AND ROWNUM = 1;
           end if;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_post_address := '';
          v_post_zip     := '';
      END;

      BEGIN
        if v_post_address is null then
          SELECT TRIM(ADDR), TRIM(ZIP)
            INTO v_post_address, v_post_zip
            FROM XQ_ADDRESS
           WHERE USAGE = 1
             AND ID15 = UPPER(TRIM(v_info.APID))
             AND ROWNUM = 1;
           end if;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_post_address := '';
          v_post_zip     := '';
      END;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_post_address := '';
        v_post_zip     := '';
    END;

    --客户地址,客户地址邮编
    BEGIN
      BEGIN
        SELECT TRIM(ADDR), TRIM(ZIP)
          INTO v_addr_address, v_addr_zip
          FROM XQ_ADDRESS
         WHERE USAGE = 2
           AND PID = UPPER(TRIM(v_info.APID))
           AND ROWNUM = 1;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_addr_address := '';
          v_addr_zip     := '';
      END;

      BEGIN
        if v_addr_address is null then
          SELECT TRIM(ADDR), TRIM(ZIP)
            INTO v_addr_address, v_addr_zip
            FROM XQ_ADDRESS
           WHERE USAGE = 2
             AND PERSON_ID = v_info.APERSON_ID
             AND ROWNUM = 1;
           end if;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_addr_address := '';
          v_addr_zip     := '';
      END;

      BEGIN
        if v_addr_address is null then
          SELECT TRIM(ADDR), TRIM(ZIP)
            INTO v_addr_address, v_addr_zip
            FROM XQ_ADDRESS
           WHERE USAGE = 2
             AND SOURCE_PERSON_ID = v_info.OWNER_SOURCE_ID
             AND ROWNUM = 1;
           end if;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_addr_address := '';
          v_addr_zip     := '';
      END;

      BEGIN
        if v_addr_address is null then
          SELECT TRIM(ADDR), TRIM(ZIP)
            INTO v_addr_address, v_addr_zip
            FROM XQ_ADDRESS
           WHERE USAGE = 2
             AND ID15 = UPPER(TRIM(v_info.APID))
             AND ROWNUM = 1;
           end if;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          v_addr_address := '';
          v_addr_zip     := '';
      END;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_addr_address := '';
        v_addr_zip     := '';
    END;

    --投保人家庭电话
    BEGIN
      v_tb_hometel := v_info.tb_hometel;

      if v_tb_hometel is null then
       select (select trim(tel)
                 from xq_phone
                where usage = '2'
                  and person_id = v_info.aperson_id
                  and rownum = 1)
         into v_tb_hometel
         from dual;
      end if;

      if v_tb_hometel is null then
       select (select trim(tel)
                 from xq_phone
                where usage = '2'
                  and source_person_id = v_info.owner_source_id
                  and rownum = 1)
         into v_tb_hometel
         from dual;
      end if;

       if v_tb_hometel is null then
       select (select trim(tel)
                 from xq_phone
                where usage = '2'
                  and id15 = upper(trim(v_info.apid))
                  and rownum = 1)
         into v_tb_hometel
         from dual;
      end if;

     EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_tb_hometel := '';
    END;

    --投保人单位电话
    BEGIN
      v_tb_unittel := v_info.tb_unittel;

      if v_tb_unittel is null then
       select (select trim(tel)
                 from xq_phone
                where usage = '8'
                  and person_id = v_info.aperson_id
                  and rownum = 1)
         into v_tb_unittel
         from dual;
      end if;

      if v_tb_unittel is null then
       select (select trim(tel)
                 from xq_phone
                where usage = '8'
                  and source_person_id = v_info.owner_source_id
                  and rownum = 1)
         into v_tb_unittel
         from dual;
      end if;

      if v_tb_unittel is null then
       select (select trim(tel)
                 from xq_phone
                where usage = '8'
                  and id15 = upper(trim(v_info.apid))
                  and rownum = 1)
         into v_tb_unittel
         from dual;
      end if;

     EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_tb_unittel := '';
    END;

   --投保人手机号码
    BEGIN
      v_tb_mobiletel := v_info.tb_mobiletel;

      if v_tb_mobiletel is null then
       select (select trim(tel)
                 from xq_phone
                where TYPE = '2'
                  and person_id = v_info.aperson_id
                  and rownum = 1)
         into v_tb_mobiletel
         from dual;
      end if;

      if v_tb_mobiletel is null then
       select (select trim(tel)
                 from xq_phone
                where TYPE = '2'
                  and source_person_id = v_info.owner_source_id
                  and rownum = 1)
         into v_tb_mobiletel
         from dual;
      end if;

      if v_tb_mobiletel is null then
       select (select trim(tel)
                 from xq_phone
                where TYPE = '2'
                  and id15 = upper(trim(v_info.apid))
                  and rownum = 1)
         into v_tb_mobiletel
         from dual;
      end if;

     EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_tb_mobiletel := '';
    END;

    --投保人职业
    BEGIN
      v_tb_job := v_info.tb_job;

      if v_tb_job is null then
       select (select JOB
                 from XQ_PERSON
                where SOURCE_PERSON_ID = v_info.OWNER_SOURCE_ID
                  and rownum = 1)
         into v_tb_job
         from dual;
      end if;

      if v_tb_job is null then
       select (select JOB
                 from XQ_PERSON
                where PERSON_ID = v_info.APERSON_ID
                  and rownum = 1)
         into v_tb_job
         from dual;
      end if;

      if v_tb_job is null then
       select (select JOB
                 from XQ_PERSON
                where ID15 = v_info.APID
                  and rownum = 1)
         into v_tb_job
         from dual;
      end if;

      select (select name
               from shcpic_metier sm
              where sm.code = v_tb_job
                and rownum = 1)
       into v_job_name
       from dual;

     EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_tb_job := '';
        v_job_name := '';
    END;

   --缴费方式,支付形式,缴费年限
   BEGIN
     SELECT (select p.item_code from xq_dict p where p.id = PAYCODE) PAYCODE,
            (select p.item_name from xq_dict p where p.id = SETCODE) SETCODE,
            YEARNUM
       INTO v_paycode, v_setcode, v_yearnum
       FROM XQ_PREREC
      WHERE POLICYNO = v_info.POLICYNO
        AND CLASSCODE = v_info.classcode
        AND PCODE = '2'
        AND ROWNUM = 1;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_paycode := '';
        v_setcode := '';
        v_yearnum := 0;
    END;

    BEGIN
      select d.item_name
        into v_item_paycode
        from xq_dict d
       where d.parent_id = 7
         and d.item_code = v_paycode
         AND ROWNUM = 1;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_item_paycode := '';
    END;


   --取扣款银行、扣款账号
   BEGIN
     SELECT BANKCODE, BANKNO
          INTO V_BANKCODE, V_BANKNO
          FROM XQ_CHARGE_FAILURE
         WHERE POLICYNO = V_INFO.POLICYNO
           AND BRANCH = V_INFO.BRANCH
           AND ROWNUM = 1;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_bankcode := '';
        v_bankno := '';
    END;
    --应缴期次 累计缴费
    SELECT MAX(YEARS),
           sum(case
                 when PCODE IN
                      ('1', '2', '4', '5', '8', 'A', 'B', 'C', 'D', 'E', 'F') then
                  AMOUNT
                 else
                  0
               end) sumamount
      INTO v_years, v_sumamount
      FROM XQ_PREREC
     WHERE POLICYNO = v_info.POLICYNO;

    --单期缴费
    SELECT SUM(INITIAL_AMOUNT)
        INTO v_singleAmount
        FROM XQ_RISKCON
       WHERE POLICYNO = v_info.POLICYNO;

    --理赔次数
    SELECT COUNT(*)
        INTO v_linum
        FROM XQ_REALPAYRC
       WHERE (DELCODE LIKE '1%' OR DELCODE LIKE 'A%') --理赔
         AND DELCODE NOT IN ('A50', 'A65')
         AND POLICYNO = v_info.POLICYNO
         AND CLASSCODE = v_info.CLASSCODE
         AND BRANCH = v_info.BRANCH;

      --保单总保费（年化新保）=单期缴费*年缴费频率
      /*1  701  7  趸缴  01  0
        2  702  7  月缴  10  0
        3  703  7  季缴  11  0
        4  704  7  半年缴  12  0
        5  705  7  年缴  13  0
        6  706  7  其它一  14  0
        7  707  7  其它二  15  0
        8  750  7  其它  other  0 */
      SELECT ONEAMOUNT*(decode(v_paycode, '10', 12, '11', 4, '12',2,'13', 01,1))
        INTO v_nh_total_fee
        FROM (SELECT SUM(A.INITIAL_AMOUNT) ONEAMOUNT  --PIECES * NPAYLEN
                FROM XQ_RISKCON A
               WHERE POLICYNO = v_info.POLICYNO
               GROUP BY POLICYNO
              UNION
              SELECT NULL FROM DUAL)
       WHERE ROWNUM < 2
       ORDER BY ONEAMOUNT DESC NULLS LAST;

       /*SELECT SUM(INITIAL_AMOUNT) *
              (decode(v_paycode, '10', 12, '11', 4, '12', 2, '13', 1, 1))
         INTO v_nh_total_fee
         FROM XQ_RISKCON
        WHERE POLICYNO = v_info.POLICYNO;*/

     --保单总保额
     select sum(amount) into v_total_fee
       from tb_app_prd_info t
      where t.application_id = v_info.application_id;

      --保单状态
    BEGIN
      select d.item_name
        into v_polist
        from xq_dict d
       where d.parent_id = 1
         and d.id = v_info.polist
         AND ROWNUM = 1;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_polist := '';
    END;

    --分公司
    BEGIN
      select sc1.company_name
        into v_company_name
        from shcpic_company sc, (select * from shcpic_company) sc1
       where sc.company_code = v_info.idorg
         and sc.parent_company_id = sc1.id
         AND ROWNUM = 1;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        v_company_name := '';
    END;

    begin
    insert into t_xq_cbj_list_report
      (opdate, idorg, saleattr, agent_id, emp_name, policyno, appno, classcode, classname, acus_name,
      acus_licno, icus_name, icus_licno, tb_job, rectele, tb_hometel, tb_unittel, tb_mobiletel, post_address,
      post_zip, addr_address, addr_zip, polist, setcode, delfrm, bankcode, bankno, begdate, nextdate, years,
      sumamount, singleamount, yearnum, linum, nh_total_fee, total_fee, create_date, update_date)
    values
      (v_info.opdate, v_company_name, v_info.saleattr_name, v_info.agent_id, v_info.name, v_info.policyno, v_info.appno, v_info.classcode, v_info.classname,v_info.acus_name,
      v_info.acus_licno, v_info.icus_name, v_info.icus_licno, v_job_name, v_info.rectele, v_tb_hometel, v_tb_unittel, v_tb_mobiletel, v_post_address,
      v_post_zip, v_addr_address, v_addr_zip, v_polist,v_item_paycode, v_setcode, v_bankcode, v_bankno, v_info.begdate, v_info.nextdate, v_years,
      v_sumamount, v_singleAmount, v_yearnum, v_linum, v_nh_total_fee, v_total_fee, sysdate, null);

      v_insert_rows :=v_insert_rows+1;

      exception
        when others then
          begin -- 遇到异常捕获处理
            p_xq_log_in_err('IDS','P_XQ_CBD_REPORT_IN',
                  'policyno:'||v_info.POLICYNO||' classcode:'||v_info.classcode,
                  '插入表t_xq_cbj_list_report数据'||sqlerrm);--写日志
            v_error_rows :=v_error_rows+1;
          end;
      end;
      COMMIT;--提交数据
  END LOOP;
  COMMIT;
  CLOSE cur_info;

  --添加数据库成功日志
  time_after :=Dbms_Utility.get_time;
  p_xq_log_suc('IDS',
              'P_XQ_CBD_REPORT_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '保单生效时间'||sta_date||'-'||end_date||',执行过程持续时间:'||(time_after-time_before)/100||'秒',
              sqlerrm);

  EXCEPTION
  WHEN OTHERS THEN
   begin
        rollback;

        if cur_info%isopen then
          CLOSE cur_info;
        end if;

        rollback;

        dbms_output.put_line('P_XQ_CBD_REPORT_IN ERROR'||sqlerrm);

        --添加数据库失败日志
        time_after :=Dbms_Utility.get_time;
        p_xq_log_err('IDS',
            'P_XQ_CBD_REPORT_IN',
            v_insert_rows,
            v_error_rows,
            v_update_rows,
            '保单生效时间'||sta_date||'-'||end_date||',执行过程持续时间:'||(time_after-time_before)/100||'秒',
            sqlerrm);
   end;
END P_XQ_CBD_REPORT_IN;
/

prompt
prompt Creating procedure P_XQ_CHARGE_FAILURE_IN
prompt =========================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_CHARGE_FAILURE_IN IS
  /*
  ******************************************************
  *  存储过程名 ：XQ_CHARGE_FAILURE
  *  建立日期   ：2012-08-21
  *  作者       ：QINYUNLONG
  *  模块       ：IDS
  *  描述       ：批量处理CHARGE_FAILURE
  */
  V_UPDATE_ROWS NUMBER(18) := 0;
  V_INSERT_ROWS NUMBER(18) := 0;
  V_ERROR_ROWS  NUMBER(18) := 0;

  TIME_BEFORE BINARY_INTEGER := DBMS_UTILITY.GET_TIME; --过程开始时间(毫秒)
  TIME_AFTER  BINARY_INTEGER; --过程结束时间(毫秒)

  V_MINTSTAMP TIMESTAMP; --最小日期TIMESTAMP
  V_MAXTSTAMP TIMESTAMP; --最大日期TIMESTAMP
  V_MINDATE   DATE; --最小日期
  V_MAXDATE   DATE; --最大日期

  CURSOR CUR_INFO(STARTDATE DATE, ENDDATE DATE) IS
    SELECT *
      FROM CHARGE_FAILURE C
     WHERE C.ETL_TIME >= STARTDATE
       AND C.ETL_TIME < ENDDATE
       AND EXISTS
     (SELECT 1
              FROM XQ_RISKCON B
             WHERE C.POLICYNO = B.POLICYNO
               AND B.CLASSCODE IN (SELECT P.CLASSCODE
                                     FROM XQ_RISKCLASS P
                                    WHERE P.TIMESTR = '1'));

  V_INFO CUR_INFO%ROWTYPE;

BEGIN
  --查询临时表最大和最小日期
  SELECT MIN(TEM.ETL_TIME), MAX(TEM.ETL_TIME)
    INTO V_MINTSTAMP, V_MAXTSTAMP
    FROM CHARGE_FAILURE TEM;
  V_MINDATE := TO_DATE(TO_CHAR(V_MINTSTAMP, 'YYYY-MM-DD'), 'YYYY-MM-DD');
  V_MAXDATE := TO_DATE(TO_CHAR(V_MAXTSTAMP, 'YYYY-MM-DD'), 'YYYY-MM-DD');

  LOOP
    EXIT WHEN V_MINDATE > V_MAXDATE OR V_MINDATE IS NULL;

    OPEN CUR_INFO(V_MINDATE, V_MINDATE + 1);
    LOOP
      FETCH CUR_INFO
        INTO V_INFO;
      EXIT WHEN CUR_INFO%NOTFOUND;

      BEGIN
        INSERT INTO XQ_CHARGE_FAILURE
          (ID,
           SNO,
           TYPEID,
           POLICYNO,
           BANKCODE,
           BANKNO,
           PID,
           NAME,
           AMOUNT,
           STATUS,
           REASON,
           COVER1,
           COVER2,
           APPDATE,
           TRANSFER_REASON,
           BEGTIME,
           ENDTIME,
           BRANCH,
           ETL_TIME,
           SRC_SYS,
           CREATE_DATE)
        VALUES
          (SEQ_XQ_CHARGE_FAILURE.NEXTVAL,
           V_INFO.SNO,
           V_INFO.TYPEID,
           V_INFO.POLICYNO,
           V_INFO.BANKCODE,
           V_INFO.BANKNO,
           V_INFO.PID,
           V_INFO.NAME,
           V_INFO.AMOUNT,
           V_INFO.STATUS,
           V_INFO.REASON,
           V_INFO.COVER1,
           V_INFO.COVER2,
           V_INFO.APPDATE,
           V_INFO.TRANSFER_REASON,
           V_INFO.BEGTIME,
           V_INFO.ENDTIME,
           V_INFO.BRANCH,
           V_INFO.ETL_TIME,
           V_INFO.SRC_SYS,
           SYSDATE);

        V_INSERT_ROWS := V_INSERT_ROWS + 1;
      EXCEPTION
        WHEN OTHERS THEN
          BEGIN
            P_XQ_LOG_IN_ERR('IDS',
                            'XQ_CHARGE_FAILURE',
                            'POLICYNO=' || V_INFO.POLICYNO || '   PID=' ||
                            V_INFO.PID || '  COVER1=' || V_INFO.COVER1,
                            '插入表XQ_CHARGE_FAILURE数据' || SQLERRM); --写日志
            V_ERROR_ROWS := V_ERROR_ROWS + 1;
          END;
      END;
    END LOOP;

    COMMIT;

    CLOSE CUR_INFO;

    --删除当日重复的脏数据
    DELETE XQ_CHARGE_FAILURE
     WHERE XQ_CHARGE_FAILURE.ETL_TIME >= V_MINDATE
       AND XQ_CHARGE_FAILURE.ETL_TIME < (V_MINDATE + 1)
       AND XQ_CHARGE_FAILURE.ID NOT IN
           (SELECT MAX(R.ID)
              FROM XQ_CHARGE_FAILURE R
             WHERE R.ETL_TIME >= V_MINDATE
               AND R.ETL_TIME < (V_MINDATE + 1)
             GROUP BY R.SNO,
                      R.TYPEID,
                      R.POLICYNO,
                      R.BANKCODE,
                      R.BANKNO,
                      R.PID,
                      R.NAME,
                      R.AMOUNT,
                      R.STATUS,
                      R.REASON,
                      R.COVER1,
                      R.COVER2,
                      R.APPDATE,
                      R.TRANSFER_REASON,
                      R.BEGTIME,
                      R.ENDTIME,
                      R.BRANCH,
                      R.ETL_TIME,
                      R.SRC_SYS);
    COMMIT;

    V_MINDATE := V_MINDATE + 1;

  END LOOP;

  COMMIT;

  DBMS_OUTPUT.PUT_LINE('XQ_CHARGE_FAILURE中数据更新 ' || V_UPDATE_ROWS ||
                       '行，数据插入 ' || V_INSERT_ROWS || '行,失败' ||
                       V_ERROR_ROWS || '行');

  --添加数据库成功日志
  TIME_AFTER := DBMS_UTILITY.GET_TIME;
  P_XQ_LOG_SUC('IDS',
               'XQ_CHARGE_FAILURE',
               V_INSERT_ROWS,
               V_ERROR_ROWS,
               V_UPDATE_ROWS,
               '执行过程持续时间:' || (TIME_AFTER - TIME_BEFORE) / 100 || '秒',
               SQLERRM);

EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      IF CUR_INFO%ISOPEN THEN
        CLOSE CUR_INFO;
      END IF;
      --添加数据库失败日志
      TIME_AFTER := DBMS_UTILITY.GET_TIME;
      P_XQ_LOG_ERR('IDS',
                   'XQ_CHARGE_FAILURE',
                   V_INSERT_ROWS,
                   V_ERROR_ROWS,
                   V_UPDATE_ROWS,
                   '执行过程持续时间:' || (TIME_AFTER - TIME_BEFORE) / 100 || '秒',
                   SQLERRM);
    END;
END P_XQ_CHARGE_FAILURE_IN;
/

prompt
prompt Creating procedure P_XQ_CUSTOM_INFO_COPY_DATA
prompt =============================================
prompt
create or replace procedure unicall.P_XQ_CUSTOM_INFO_COPY_DATA is
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_CUSTOM_INFO_COPY_DATA
  *  建立日期   ：2012-06-11
  *  作者       ：yangguoqi
  *  模块       ：IDS
  *  描述       ：根据IDS每天供数插入临时表person_temp、phone_temp、address_temp、riskcon_temp、riskclass_temp记录
  *----------------------------------------------------
  *  序号   日期    修改人    修改原因
  *  1  2012-07-23 yangguoqi  移动到106生产库运行
  *  2
  ******************************************************
  */
  v_person_rows number(18) := 0;

  v_phone_rows number(18) := 0;

  v_address_rows number(18) := 0;

  v_riskcon_rows number(18) := 0;

  v_riskclass_rows number(18) := 0;

  v_error_rows  number(18) := 0;

  time_before binary_integer :=Dbms_Utility.get_time;--过程开始时间
  time_after binary_integer;--过程结束时间

begin

  --插入表person_temp数据
  begin

    for c_r in (select sno, typeid, person_id, persontype, bthdate, diedate, edulevel,
      sex, income, company, marriage, smoker, blood, ethnicity,hdesp, customerid, name, job,
      drvcard, country, residence, id, id15, idtype, cust_id05, source_person_id, reg_date,
      begtime, endtime, branch, etl_time, src_sys from person) loop
      begin
        insert into person_temp(sno, typeid, person_id, persontype, bthdate, diedate, edulevel,
          sex, income, company, marriage, smoker, blood, ethnicity,hdesp, customerid, name, job,
          drvcard, country, residence, id, id15, idtype, cust_id05, source_person_id, reg_date,
          begtime, endtime, branch, etl_time, src_sys)
        values(c_r.sno, c_r.typeid, c_r.person_id, c_r.persontype, c_r.bthdate, c_r.diedate, c_r.edulevel,
          c_r.sex, c_r.income, c_r.company, c_r.marriage, c_r.smoker, c_r.blood, c_r.ethnicity,c_r.hdesp, c_r.customerid,
          c_r.name, c_r.job, c_r.drvcard, c_r.country, c_r.residence, c_r.id, c_r.id15, c_r.idtype, c_r.cust_id05,
          c_r.source_person_id, c_r.reg_date, c_r.begtime, c_r.endtime, c_r.branch, c_r.etl_time, c_r.src_sys );

      EXCEPTION
        WHEN OTHERS THEN
          begin
            p_xq_log_in_err('IDS','P_XQ_CUSTOM_INFO_COPY_DATA',c_r.source_person_id,'插入表person_temp数据'||sqlerrm);--主键写进日志
            v_error_rows :=v_error_rows+1;
          end;
      end;
      v_person_rows :=v_person_rows+1;
      if mod(v_person_rows,5000)=0 then
         commit;--批量提交记录
      end if;
      end loop;
   end;
   commit;


  --插入表phone_temp数据
  begin

    for c_r in (select sno, typeid, areacode, countrycode, tel, ext, type, telnumber, usage, person_id,
        pid, idtype, purpose, seq, source_person_id, id15, begtime, endtime,
        branch, etl_time, src_sys from phone) loop
        begin
        insert into phone_temp(sno, typeid, areacode, countrycode, tel, ext, type, telnumber, usage, person_id,
          pid, idtype, purpose, seq, source_person_id, id15, begtime, endtime,
          branch, etl_time, src_sys)
        values(c_r.sno, c_r.typeid, c_r.areacode, c_r.countrycode, c_r.tel, c_r.ext, c_r.type, c_r.telnumber,
          c_r.usage, c_r.person_id,c_r.pid, c_r.idtype, c_r.purpose, c_r.seq, c_r.source_person_id,
          c_r.id15, c_r.begtime, c_r.endtime, c_r.branch, c_r.etl_time, c_r.src_sys);

   EXCEPTION
        WHEN OTHERS THEN
          begin
            p_xq_log_in_err('IDS','P_XQ_CUSTOM_INFO_COPY_DATA',
            'usage:'||c_r.usage ||' source_person_id:'||c_r.source_person_id ||' seq:'||c_r.seq
            ,'插入表phone_temp数据'||sqlerrm);--主键写进日志
         v_error_rows :=v_error_rows+1;
          end;
      end;
      v_phone_rows :=v_phone_rows+1;
      if mod(v_phone_rows,5000)=0 then
         commit;--批量提交记录
      end if;
      end loop;
   end;
   commit;

  --插入表address_temp数据
  begin
    for c_r in (select sno, typeid, country, city, region, subregion,street, subaddr, zip, addr,
            usage, person_id, pid, idtype, purpose, seq, source_person_id,
            id15, begtime, endtime, branch, etl_time, src_sys from address) loop

       begin

       insert into address_temp(sno, typeid, country, city, region, subregion,street, subaddr, zip, addr,
            usage, person_id, pid, idtype, purpose, seq, source_person_id,
            id15, begtime, endtime, branch, etl_time, src_sys)
       values (c_r.sno,c_r.typeid,c_r.country,c_r.city,c_r.region,c_r.subregion,c_r.street,c_r.subaddr,c_r.zip,
            c_r.addr,c_r.usage,c_r.person_id,c_r.pid,c_r.idtype,c_r.purpose,c_r.seq,c_r.source_person_id,
            c_r.id15,c_r.begtime,c_r.endtime,c_r.branch,c_r.etl_time,c_r.src_sys);

      EXCEPTION
            WHEN OTHERS THEN
              begin
                p_xq_log_in_err('IDS','P_XQ_CUSTOM_INFO_COPY_DATA',
                'usage:'||c_r.usage ||' source_person_id:'||c_r.source_person_id ||' seq:'||c_r.seq
                ,'插入表address_temp数据'||sqlerrm);--主键写进日志
                v_error_rows :=v_error_rows+1;
          end;
      end;
      v_address_rows :=v_address_rows+1;
      if mod(v_address_rows,5000)=0 then
         commit;--批量提交记录
      end if;
      end loop;
   end;
   commit;


--插入表riskcon_temp数据
  begin

    for c_r in (select sno,typeid,aperson_id,apid,aidtype,riskcon_id,gcon_id,gpolicyno,deskpay,saleattr,renewid,renewdate,begdate,stopdate,polist,
                    reason,policyno,appno,currency,pieces,appf,opdate,tmount,oper_id,operno,empno_id,empno,csr_id,csrno,classcode,appdate,comnum,
                    person_id,idtype,pid,job,sharetype,specagr,discount,iscard,npaylen,stdrate,unstdrate,dcdm,prelname,bankflag,payseq,benparam,
                    sale_prod_code,owner_source_id,insured_source_id,workno,comb_policy_no,app_age,begtime,endtime,branch,etl_time,src_sys,sub_agt_no,
                    o_classcode,cross_sale_ind,prem_rate_level,ill_score from riskcon r) loop

       begin

       insert into riskcon_temp(sno,typeid,aperson_id,apid,aidtype,riskcon_id,gcon_id,gpolicyno,deskpay,saleattr,renewid,renewdate,begdate,stopdate,polist,
              reason,policyno,appno,currency,pieces,appf,opdate,tmount,oper_id,operno,empno_id,empno,csr_id,csrno,classcode,appdate,comnum,
              person_id,idtype,pid,job,sharetype,specagr,discount,iscard,npaylen,stdrate,unstdrate,dcdm,prelname,bankflag,payseq,benparam,
              sale_prod_code,owner_source_id,insured_source_id,workno,comb_policy_no,app_age,begtime,endtime,branch,etl_time,src_sys,sub_agt_no,
              o_classcode,cross_sale_ind,prem_rate_level,ill_score)
       values (c_r.sno,c_r.typeid,c_r.aperson_id,c_r.apid,c_r.aidtype,c_r.riskcon_id,c_r.gcon_id,c_r.gpolicyno,c_r.deskpay,c_r.saleattr,c_r.renewid,c_r.renewdate,c_r.begdate,c_r.stopdate,c_r.polist,c_r.
              reason,c_r.policyno,c_r.appno,c_r.currency,c_r.pieces,c_r.appf,c_r.opdate,c_r.tmount,c_r.oper_id,c_r.operno,c_r.empno_id,c_r.empno,c_r.csr_id,c_r.csrno,c_r.classcode,c_r.appdate,c_r.comnum,c_r.
              person_id,c_r.idtype,c_r.pid,c_r.job,c_r.sharetype,c_r.specagr,c_r.discount,c_r.iscard,c_r.npaylen,c_r.stdrate,c_r.unstdrate,c_r.dcdm,c_r.prelname,c_r.bankflag,c_r.payseq,c_r.benparam,c_r.
              sale_prod_code,c_r.owner_source_id,c_r.insured_source_id,c_r.workno,c_r.comb_policy_no,c_r.app_age,c_r.begtime,c_r.endtime,c_r.branch,c_r.etl_time,c_r.src_sys,c_r.sub_agt_no,c_r.
              o_classcode,c_r.cross_sale_ind,c_r.prem_rate_level,c_r.ill_score);

      EXCEPTION
            WHEN OTHERS THEN
              begin
                p_xq_log_in_err('IDS','P_XQ_CUSTOM_INFO_COPY_DATA',
                'sno:'||c_r.sno ||' policyno:'||c_r.policyno
                ,'插入表riskcon_temp数据'||sqlerrm);--主键写进日志
                v_error_rows :=v_error_rows+1;
          end;
      end;
      v_riskcon_rows :=v_riskcon_rows+1;
      if mod(v_riskcon_rows,5000)=0 then
         commit;--批量提交记录
      end if;
      end loop;
   end;
   commit;

  --插入表riskclass_temp数据
  begin

    for c_r in (select o_classcode,classcode,permdays,riskattr,riskcode,classname,timestr,grpattr,appflag,apptype,deldays,prttype,
                       clmcode,riskname,end_date,begtime,endtime,branch,etl_time,src_sys from riskclass) loop

       begin

       insert into riskclass_temp(o_classcode,classcode,permdays,riskattr,riskcode,classname,timestr,grpattr,appflag,apptype,deldays,prttype,
                                  clmcode,riskname,end_date,begtime,endtime,branch,etl_time,src_sys)
       values (c_r.o_classcode,c_r.classcode,c_r.permdays,c_r.riskattr,c_r.riskcode,c_r.classname,c_r.timestr,c_r.grpattr,c_r.appflag,c_r.apptype,c_r.deldays,c_r.prttype,c_r.
               clmcode,c_r.riskname,c_r.end_date,c_r.begtime,c_r.endtime,c_r.branch,c_r.etl_time,c_r.src_sys);

      EXCEPTION
            WHEN OTHERS THEN
              begin
                p_xq_log_in_err('IDS','P_XQ_CUSTOM_INFO_COPY_DATA',
                'classcode:'||c_r.classcode ||' o_classcode:'||c_r.o_classcode
                ,'插入表riskclass_temp数据'||sqlerrm);--主键写进日志
                v_error_rows :=v_error_rows+1;
          end;
      end;
      v_riskclass_rows :=v_riskclass_rows+1;
      if mod(v_riskclass_rows,5000)=0 then
         commit;--批量提交记录
      end if;
      end loop;
   end;
   commit;

   --添加数据库成功日志
   time_after :=Dbms_Utility.get_time;
   p_xq_log_suc('IDS','P_XQ_CUSTOM_INFO_COPY_DATA',0,0,v_error_rows,'插入person_temp:'||v_person_rows
   ||'行,插入phone_temp:'||v_phone_rows||'行,插入address_temp:'||v_address_rows||'行,插入riskcon_temp:'||v_riskcon_rows||'行,插入riskclass_temp:'||v_riskclass_rows||'行,执行过程持续时间:'||(time_after-time_before)/100||'秒',sqlerrm);

EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;
       dbms_output.put_line('P_XQ_CUSTOM_INFO_COPY_DATA过程执行ERROR'||sqlerrm);
       --添加数据库错误日志
       time_after :=Dbms_Utility.get_time;
       p_xq_log_err('IDS','P_XQ_CUSTOM_INFO_COPY_DATA',0,0,v_error_rows,'插入person_temp:'||v_person_rows
       ||'行,插入phone_temp:'||v_phone_rows||'行,插入address_temp:'||v_address_rows||'行,插入riskcon_temp:'||v_riskcon_rows||'行,插入riskclass_temp:'||v_riskclass_rows||'行,执行过程持续时间:'||(time_after-time_before)/100||'秒',sqlerrm);

   end;
end P_XQ_CUSTOM_INFO_COPY_DATA;
/

prompt
prompt Creating procedure P_XQ_EMPNO_IN
prompt ================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_EMPNO_IN IS

  i             integer := 1;
  v_id          number(20) := 0;
  v_begtime     number(11) := 0;
  v_riskoncount integer := 0;

  v_status number(10) := 0;

  v_insert_rows number(18) := 0;
  v_update_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  CURSOR cur_info IS
    select * from xq_empno_temp a;
  v_info cur_info%rowtype;

BEGIN

  select o.nextvalue into v_id from c_id_bro o where o.name = 'xq_empno';

  open cur_info;
  loop
    fetch cur_info
      into v_info;
    exit when cur_info%notfound;

    select count(b.sno)
      into v_riskoncount
      from xq_riskcon b
     where b.empno = v_info.empno and rownum = 1;

    if v_riskoncount > 0 then
    begin
      select (select a.begtime
                from xq_empno a
               where a.empno = v_info.empno
                 and rownum = 1)
        into v_begtime
        from dual;

      if (trim(v_info.status) = '1' or trim(v_info.status) = '6') then
        v_status := 1901;--状态为有效
      else
        v_status := 1902;--状态为无效
      end if;

      if v_begtime > 0 then

        if v_info.begtime > v_begtime then
          --update
          begin
            update xq_empno a
               set a.TYPEID     = v_info.TYPEID,
                   a.EMPNO_ID   = v_info.EMPNO_ID,
                   a.PERSON_ID  = v_info.PERSON_ID,
                   a.STATUS_IDS = v_info.STATUS,
                   a.NAME       = v_info.NAME,
                   a.DEGREENO   = v_info.DEGREENO,
                   a.INDATE     = v_info.INDATE,
                   a.OUTDATE    = v_info.OUTDATE,
                   a.REGDATE    = v_info.REGDATE,
                   a.DEGDATE    = v_info.DEGDATE,
                   a.PID        = v_info.PID,
                   a.BEGDATE    = v_info.BEGDATE,
                   a.ENDDATE    = v_info.ENDDATE,
                   a.EDU_LEVEL  = v_info.EDU_LEVEL,
                   a.BEGTIME    = v_info.BEGTIME,
                   a.ENDTIME    = v_info.ENDTIME,
                   a.BRANCH     = v_info.BRANCH,
                   a.ETL_TIME   = v_info.ETL_TIME,
                   a.SRC_SYS    = v_info.SRC_SYS,
                   a.C_AGT_IND  = v_info.C_AGT_IND,
                   a.status     = v_status
             where a.empno = v_info.empno;

             v_update_rows :=v_update_rows+1;
          exception
            when others then
              -- 遇到异常做一些处理
              begin
                p_xq_log_in_err('IDS','P_XQ_EMPNO_IN',
                v_info.empno,
                '更新表xq_empno数据'||sqlerrm);--写日志
                v_error_rows :=v_error_rows+1;
              end;
          end;
        end if;

      else
        --insert
        begin
          insert into xq_empno
            (SNO,
             TYPEID,
             EMPNO_ID,
             PERSON_ID,
             EMPNO,
             STATUS_IDS,
             NAME,
             DEGREENO,
             INDATE,
             OUTDATE,
             REGDATE,
             DEGDATE,
             PID,
             BEGDATE,
             ENDDATE,
             EDU_LEVEL,
             BEGTIME,
             ENDTIME,
             BRANCH,
             ETL_TIME,
             SRC_SYS,
             C_AGT_IND,
             STATUS)
          values
            (v_id,
             v_info.TYPEID,
             v_info.EMPNO_ID,
             v_info.PERSON_ID,
             v_info.EMPNO,
             v_info.STATUS,
             v_info.NAME,
             v_info.DEGREENO,
             v_info.INDATE,
             v_info.OUTDATE,
             v_info.REGDATE,
             v_info.DEGDATE,
             v_info.PID,
             v_info.BEGDATE,
             v_info.ENDDATE,
             v_info.EDU_LEVEL,
             v_info.BEGTIME,
             v_info.ENDTIME,
             v_info.BRANCH,
             v_info.ETL_TIME,
             v_info.SRC_SYS,
             v_info.C_AGT_IND,
             v_status);

        exception
          when others then
            -- 遇到异常做一些处理
            begin
              p_xq_log_in_err('IDS','P_XQ_EMPNO_IN',
              v_info.empno,
              '插入表xq_empno数据'||sqlerrm);--写日志
              v_error_rows :=v_error_rows+1;
            end;
        end;
        v_insert_rows :=v_insert_rows+1;
        v_id := v_id + 1;

      end if;

        commit;

      i := i + 1;
    end;
    end if;
  end loop;
  update c_id_bro o set o.nextvalue = v_id where o.name = 'xq_empno';
  commit;
  close cur_info;
  --添加数据库成功日志
  p_xq_log_suc('IDS',
              'P_XQ_EMPNO_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);

exception
  when others then
    begin
      rollback;

      if cur_info%isopen then
        CLOSE cur_info;
      end if;
      dbms_output.put_line('P_XQ_EMPNO_IN cur error'||sqlerrm);
      --添加数据库失败日志
      p_xq_log_err('IDS',
              'P_XQ_EMPNO_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);
    end;

END P_XQ_EMPNO_IN;
/

prompt
prompt Creating procedure P_XQ_INVALID_IN
prompt ==================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_INVALID_IN IS

  coun_id     number(18) := 0;
  v_appname   varchar2(120) := '';
  v_setcode   number(10);
  v_nextdate  date;
  v_polistids char(2);
  v_paycode   number(10);

  CURSOR cur_info IS
    SELECT *
      FROM xq_app b
     where (length(TRANSLATE(b.appno, '0123456789' || b.appno, '0123456789')) =
           length(b.appno) or b.appno like '%DX%')
       and b.polist = 202;
  v_info cur_info%ROWTYPE;

BEGIN
  --获取xq_invalid--id值
  select b.nextvalue
    into coun_id
    from c_id_bro b
   where b.name = 'xq_invalid_app';

  OPEN cur_info;
  LOOP
    FETCH cur_info
      INTO v_info;
    EXIT WHEN cur_info%NOTFOUND;

    --从xq_person表取客户名称
    select (select c.name
              from xq_person c
             where c.person_id = v_info.person_id
               and rownum = 1)
      into v_appname
      from dual;

    --从xq_moneysch表取 支付方式
    select (select c.setcode
              from xq_moneysch c
             where c.policyno = v_info.policyno
               and rownum = 1)
      into v_setcode
      from dual;

    --从xq_moneysch表取 下次缴费日
    select (select c.nextdate
              from xq_moneysch c
             where c.policyno = v_info.policyno
               and rownum = 1)
      into v_nextdate
      from dual;

    --从xq_moneysch表取 缴费方式
    select (select c.paysch
              from xq_moneysch c
             where c.policyno = v_info.policyno
               and rownum = 1)
      into v_paycode
      from dual;

    --从xq_riskcon表取 ids状态
    select (select c.polist_ids
              from xq_riskcon c
             where c.policyno = v_info.policyno
               and c.appf = '1'
               and rownum = 1)
      into v_polistids
      from dual;

    --insert
    coun_id := coun_id + 1;
    begin

      insert into xq_invalid_app
        (XQ_INVALID_APP_ID,
         XQ_APP_ID,
         POLICYNO,
         APPNO,
         APERSON_ID,
         APID,
         AIDTYPE,
         RISKCON_ID,
         SALEATTR,
         SALEPRJ,
         SALEAREA,
         BEGDATE,
         STOPDATE,
         POLIST,
         PIECES,
         OPDATE,
         RENEWDATE,
         TMOUNT,
         PERSON_ID,
         IDTYPE,
         PID,
         APPDATE,
         APNAME,
         SETCODE,
         NEXT_DATE,
         STATUS,
         OWE_AMOUNT,
         INVALID_DATE,
         POLIST_IDS,
         PAYCODE)
      values
        (coun_id,
         v_info.XQ_APP_ID,
         v_info.POLICYNO,
         v_info.APPNO,
         v_info.APERSON_ID,
         v_info.APID,
         v_info.AIDTYPE,
         v_info.RISKCON_ID,
         v_info.SALEATTR,
         v_info.SALEPRJ,
         v_info.SALEAREA,
         v_info.BEGDATE,
         v_info.STOPDATE,
         v_info.POLIST,
         v_info.PIECES,
         v_info.OPDATE,
         v_info.RENEWDATE,
         v_info.TMOUNT,
         v_info.PERSON_ID,
         v_info.IDTYPE,
         v_info.PID,
         v_info.APPDATE,
         v_appname,
         v_setcode,
         v_nextdate,
         '1401',
         v_info.TMOUNT,
         to_date(to_char(v_info.etl_time, 'yyyy-mm-dd'), 'yyyy-mm-dd'),
         v_polistids,
         v_paycode);
    exception
      when others then
        -- 遇到异常做一些处理
        begin
          dbms_output.put_line('data error :' || v_info.policyno);
        end;
    end;

    COMMIT;
  END LOOP;

  CLOSE cur_info;
  update c_id_bro b
     set b.nextvalue = coun_id
   where b.name = 'xq_invalid_app';
  commit;

exception
  when others then
    begin
      dbms_output.put_line('cur error');
    end;

END P_XQ_INVALID_IN;
/

prompt
prompt Creating procedure P_XQ_MONEYSCH_IN
prompt ===================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_MONEYSCH_IN IS
  --更新或插入续收系统 缴费/给付计划表
  v_app_id  number(18) := 0;
  v_begtime number(18) := 0;
  v_sno     number(18) := 0;
  coun_id   number(18) := 0;

  v_insert_rows number(18) := 0;
  v_update_rows number(18) := 0;
  v_error_rows  number(18) := 0;
  CURSOR cur_info IS
    SELECT * FROM moneysch;
  v_info cur_info%ROWTYPE;

BEGIN
  select b.nextvalue
    into coun_id
    from c_id_bro b
   where b.name = 'xq_moneysch';
  OPEN cur_info;
  LOOP
    FETCH cur_info
      INTO v_info;
    EXIT WHEN cur_info%NOTFOUND;

    select (select p.xq_app_id
              from xq_app p
             where p.policyno = v_info.policyno
               and rownum = 1)
      into v_app_id
      from dual;
    IF v_app_id > 0 THEN

      select (select c.sno
                from xq_moneysch c
               where c.policyno = v_info.policyno
                 and c.classcode = v_info.classcode
                 and rownum = 1)
        into v_sno
        from dual;

      IF v_sno > 0 THEN

        select (select c.begtime
                  from xq_moneysch c
                 where c.sno = v_sno
                   and rownum = 1)
          into v_begtime
          from dual;

        IF v_info.begtime > v_begtime THEN
          --update xq_moneysch
          begin
            update xq_moneysch a
               set a.typeid            = v_info.typeid,
                   a.con_id            = v_info.con_id,
                   a.policyno          = v_info.policyno,
                   a.classcode         = v_info.classcode,
                   a.paysch            = v_info.paysch,
                   a.delsch            = v_info.delsch,
                   a.setcode           = v_info.setcode,
                   a.delfrm            = v_info.delfrm,
                   a.begdate           = v_info.begdate,
                   a.nretdate          = v_info.nretdate,
                   a.pbdate            = v_info.pbdate,
                   a.pedate            = v_info.pedate,
                   a.nextdate          = v_info.nextdate,
                   a.benefit_inc       = v_info.benefit_inc,
                   a.reczip            = v_info.reczip,
                   a.recaddr           = v_info.recaddr,
                   a.rectele           = v_info.rectele,
                   a.appointed_bp_date = v_info.appointed_bp_date,
                   a.prem_term         = v_info.prem_term,
                   a.bp_option         = v_info.bp_option,
                   a.etl_time          = v_info.etl_time,
                   a.begtime           = v_info.begtime,
                   a.endtime           = v_info.endtime,
                   a.src_sys           = v_info.src_sys
             where a.SNO = v_sno;
             v_update_rows :=v_update_rows+1;
          exception
            when others then
              -- 遇到异常做一些处理
              begin
                p_xq_log_in_err('IDS','P_XQ_MONEYSCH_IN',
                  v_sno,
                  '更新表xq_moneysch数据'||sqlerrm);--写日志
                v_error_rows :=v_error_rows+1;
              end;
          end;
        END IF;
      else
        --insert xq_moneysch
        coun_id := coun_id + 1;
        begin
          insert into xq_moneysch
            (SNO,
             typeid,
             con_id,
             policyno,
             classcode,
             paysch,
             delsch,
             setcode,
             delfrm,
             begdate,
             nretdate,
             pbdate,
             pedate,
             nextdate,
             benefit_inc,
             reczip,
             recaddr,
             rectele,
             appointed_bp_date,
             prem_term,
             bp_option,
             etl_time,
             begtime,
             endtime,
             src_sys,
             INITIAL_PAYSCH)
          values
            (coun_id,
             v_info.typeid,
             v_info.con_id,
             v_info.policyno,
             v_info.classcode,
             v_info.paysch,
             v_info.delsch,
             v_info.setcode,
             v_info.delfrm,
             v_info.begdate,
             v_info.nretdate,
             v_info.pbdate,
             v_info.pedate,
             v_info.nextdate,
             v_info.benefit_inc,
             v_info.reczip,
             v_info.recaddr,
             v_info.rectele,
             v_info.appointed_bp_date,
             v_info.prem_term,
             v_info.bp_option,
             v_info.etl_time,
             v_info.begtime,
             v_info.endtime,
             v_info.src_sys,
             v_info.paysch);

             v_insert_rows :=v_insert_rows+1;
        exception
          when others then
            -- 遇到异常做一些处理
            begin
              p_xq_log_in_err('IDS','P_XQ_MONEYSCH_IN',
                  'policyno:'||v_info.policyno||' classcode:'||v_info.classcode,
                  '插入表xq_moneysch数据'||sqlerrm);--写日志
              v_error_rows :=v_error_rows+1;
            end;
        end;
      END IF;
    END IF;
    COMMIT;
  END LOOP;
  CLOSE cur_info;
  update c_id_bro b set b.nextvalue = coun_id where b.name = 'xq_moneysch';
  commit;

  --添加数据库成功日志
  p_xq_log_suc('IDS',
              'P_XQ_MONEYSCH_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);
EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;

      if cur_info%isopen then
        CLOSE cur_info;
      end if;
      rollback;
      update c_id_bro t
         set t.nextvalue = coun_id
       where t.name = 'xq_moneysch';
      commit;
      dbms_output.put_line('P_XQ_MONEYSCH_IN ERROR'||sqlerrm);
      --添加数据库失败日志
      p_xq_log_err('IDS',
              'P_XQ_MONEYSCH_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);
    end;
END P_XQ_MONEYSCH_IN;
/

prompt
prompt Creating procedure P_XQ_PERSON_IN
prompt =================================
prompt
create or replace procedure unicall.P_XQ_PERSON_IN is
  v_count   number(18);
  v_id      number(18);
  v_sno     number(18);
  v_begtime NUMBER(11);
  v_idtype  number(10);

  v_insert_rows number(18) := 0;
  v_update_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  cursor cur_person is
    select * from person;
  v_person cur_person%rowtype;

begin
  -- 取主 值
  select t.nextvalue into v_id from c_id_bro t where t.name = 'xq_person';

  open cur_person;
  loop
    fetch cur_person
      into v_person;
    exit when cur_person%notfound;

    select (select t.sno
              from xq_riskcon t
             where t.owner_source_id = v_person.SOURCE_PERSON_ID
               and rownum = 1)
      into v_count
      from dual;

    if v_count is null then
      select (select t.sno
                from xq_riskcon t
               where t.insured_source_id = v_person.SOURCE_PERSON_ID
                 and rownum = 1)
        into v_count
        from dual;
    end if;

    if v_count is null then
         select (select t.sno
                from xq_riskcon t
               where t.apid = v_person.id
                 and rownum = 1)
        into v_count
        from dual;
    end if;

    if v_count is null then
         select (select t.sno
                from xq_riskcon t
               where t.apid = v_person.id15
                 and rownum = 1)
        into v_count
        from dual;
    end if;

    if v_count is null then
         select (select t.sno
                from xq_riskcon t
               where t.pid = v_person.id
                 and rownum = 1)
        into v_count
        from dual;
    end if;

    if v_count is null then
         select (select t.sno
                from xq_riskcon t
               where t.pid = v_person.id15
                 and rownum = 1)
        into v_count
        from dual;
    end if;

    if v_count > 0 then
      select (select t.sno
                from xq_person t
               where t.source_person_id = v_person.SOURCE_PERSON_ID
                 and rownum = 1)
        into v_sno
        from dual;

      if trim(v_person.idtype) = '1' then
        v_idtype := 1101;
      else
        -- 件类型对应字典 ID
        select (select t.id
                  from xq_dict t
                 where t.parent_id = 11
                   and t.item_code = v_person.idtype)
          into v_idtype
          from dual;

        if v_idtype is null then
          v_idtype := 1150;
        end if;
      end if;

      if v_sno is null then
        --未查到 插入
        begin
          insert into xq_person
            (sno,
             person_id,
             persontype,
             bthdate,
             diedate,
             edulevel,
             sex,
             income,
             company,
             marriage,
             smoker,
             blood,
             ethnicity,
             hdesp,
             customerid,
             name,
             job,
             drvcard,
             country,
             residence,
             id,
             id15,
             idtype,
             etl_time,
             idtype_ids,
             source_person_id,
             branch,
             begtime,
             endtime,
             src_sys)
          values
            (v_id,
             v_person.person_id,
             v_person.persontype,
             v_person.bthdate,
             v_person.diedate,
             v_person.edulevel,
             v_person.sex,
             v_person.income,
             v_person.company,
             v_person.marriage,
             v_person.smoker,
             v_person.blood,
             v_person.ethnicity,
             v_person.hdesp,
             v_person.customerid,
             v_person.name,
             v_person.job,
             v_person.drvcard,
             v_person.country,
             v_person.residence,
             v_person.id,
             v_person.id15,
             v_idtype,
             v_person.etl_time,
             v_person.idtype,
             v_person.source_person_id,
             v_person.branch,
             v_person.begtime,
             v_person.endtime,
             v_person.src_sys);

        exception
          when others then
            --  到异常做一些处理
            begin
              p_xq_log_in_err('IDS','P_XQ_PERSON_IN',
                  v_person.source_person_id,
                  '插入表xq_person数据'||sqlerrm);--写日志
              v_error_rows :=v_error_rows+1;
            end;
        end;
        v_insert_rows :=v_insert_rows+1;
        v_id := v_id + 1;
      else
        select (select t.begtime
                  from xq_person t
                 where t.source_person_id = v_person.SOURCE_PERSON_ID
                   and rownum = 1)
          into v_begtime
          from dual;

        if v_person.begtime > v_begtime then
          --更新
          begin
            update xq_person t
               set t.person_id        = v_person.person_id,
                   t.persontype       = v_person.persontype,
                   t.bthdate          = v_person.bthdate,
                   t.diedate          = v_person.diedate,
                   t.edulevel         = v_person.edulevel,
                   t.sex              = v_person.sex,
                   t.income           = v_person.income,
                   t.company          = v_person.company,
                   t.marriage         = v_person.marriage,
                   t.smoker           = v_person.smoker,
                   t.blood            = v_person.blood,
                   t.ethnicity        = v_person.ethnicity,
                   t.hdesp            = v_person.hdesp,
                   t.customerid       = v_person.customerid,
                   t.name             = v_person.name,
                   t.job              = v_person.job,
                   t.drvcard          = v_person.drvcard,
                   t.country          = v_person.country,
                   t.residence        = v_person.residence,
                   t.id               = v_person.id,
                   t.id15             = v_person.id15,
                   t.idtype           = v_idtype,
                   t.etl_time         = v_person.etl_time,
                   t.idtype_ids       = v_person.idtype,
                   t.source_person_id = v_person.source_person_id,
                   t.branch           = v_person.branch,
                   t.begtime          = v_person.begtime,
                   t.endtime          = v_person.endtime,
                   t.src_sys          = v_person.src_sys
             where t.sno = v_sno;

             v_update_rows :=v_update_rows+1;
          exception
            when others then
              --  到异常做一些处理
              begin
                p_xq_log_in_err('IDS','P_XQ_PERSON_IN',
                                v_sno,'更新表xq_person数据'||sqlerrm);--写日志
                v_error_rows :=v_error_rows+1;
              end;
          end;

        end if;
      end if;

      commit;

    end if;
  end loop;
  close cur_person;

  update c_id_bro t set t.nextvalue = v_id where t.name = 'xq_person';
  commit;
  --添加数据库成功日志
  p_xq_log_suc('IDS',
              'P_XQ_PERSON_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);
EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;

      if cur_person%isopen then
        CLOSE cur_person;
      end if;

      update c_id_bro t set t.nextvalue = v_id where t.name = 'xq_person';
      commit;

      dbms_output.put_line('P_XQ_PERSON_IN ERROR :' ||sqlerrm);

      --添加数据库失败日志
       p_xq_log_err('IDS',
              'P_XQ_PERSON_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);
    end;

end P_XQ_PERSON_IN;
/

prompt
prompt Creating procedure P_XQ_PERSON_IN_EVERY_DAY
prompt ===========================================
prompt
create or replace procedure unicall.P_XQ_PERSON_IN_EVERY_DAY is
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_PERSON_IN_EVERY_DAY
  *  建立日期   ：2012-06-04
  *  作者       ：yangguoqi
  *  模块       ：IDS
  *  描述       ：每天同步person_temp表数据到xq_person
  *----------------------------------------------------
  *  序号   日期    修改人    修改原因
  *  1
  *  2
  ******************************************************
  */

  v_update_rows number(18) := 0;
  v_insert_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  v_all_update_rows number(18) := 0;

  v_all_insert_rows number(18) := 0;

  v_all_append_rows number(18) := 0;

  v_count       varchar2(20);
  v_id          number(18);
  v_sno         varchar2(20);
  v_begtime     NUMBER(11) := 0;
  v_idtype      number(10);
  v_idtype_temp varchar2(20);

  v_p_person_id        number(20);
  v_p_persontype       number(20);
  v_p_bthdate          date;
  v_p_diedate          date;
  v_p_edulevel         char(2);
  v_p_sex              char(1);
  v_p_income           number(20, 6);
  v_p_company          varchar2(90);
  v_p_marriage         char(3);
  v_p_smoker           char(1);
  v_p_blood            number(20);
  v_p_ethnicity        char(2);
  v_p_hdesp            char(1);
  v_p_customerid       varchar2(40);
  v_p_name             varchar2(120);
  v_p_job              char(7);
  v_p_drvcard          varchar2(2);
  v_p_country          char(2);
  v_p_residence        varchar2(90);
  v_p_id               varchar2(40);
  v_p_id15             varchar2(40);
  v_p_idtype           char(2);
  v_p_source_person_id varchar2(20);
  v_p_begtime          number(11);
  v_p_endtime          number(11);
  v_p_branch           char(14);
  v_p_etl_time         date;
  v_p_src_sys          varchar2(20);

  cursor cur_person is
    select owner_source_id, insured_source_id, apid, pid, classcode
      from (select owner_source_id,
                   insured_source_id,
                   apid,
                   pid,
                   classcode,
                   row_number() over(partition by r.policyno, r.classcode order by r.sno) rn
              from xq_riskcon r
             where exists (select p.classcode
                      from xq_riskclass p
                     where p.classcode = r.classcode
                       and p.timestr = '1'))
     where rn = 1;

  cursor cur_all_person is
    select sno,
           typeid,
           person_id,
           persontype,
           bthdate,
           diedate,
           edulevel,
           sex,
           income,
           company,
           marriage,
           smoker,
           blood,
           ethnicity,
           hdesp,
           customerid,
           name,
           job,
           drvcard,
           country,
           residence,
           id,
           id15,
           idtype,
           cust_id05,
           source_person_id,
           reg_date,
           begtime,
           endtime,
           branch,
           etl_time,
           src_sys
      from person_temp r
     where exists (select 1
              from xq_all_person s
             where r.source_person_id = s.source_person_id
               and r.begtime > s.begtime);

  v_riskcon    cur_person%rowtype;
  v_all_person cur_all_person%rowtype;

begin
  delete person_temp t   --删除重复记录
         where t.rowid not in
         (select max(rowid)
            from person_temp r
           group by r.source_person_id);
  commit;
  --同步数据到个人全量信息表中
  open cur_all_person;
  loop
    fetch cur_all_person
      into v_all_person;
    exit when cur_all_person%notfound;

    --更新全量表中存在的信息
    begin
      --为了提高效率这里不再判断begtime是否大于
      update xq_all_person
         set typeid     = v_all_person.typeid,
             person_id  = v_all_person.person_id,
             persontype = v_all_person.persontype,
             bthdate    = v_all_person.bthdate,
             diedate    = v_all_person.diedate,
             edulevel   = v_all_person.edulevel,
             sex        = v_all_person.sex,
             income     = v_all_person.income,
             company    = v_all_person.company,
             marriage   = v_all_person.marriage,
             smoker     = v_all_person.smoker,
             blood      = v_all_person.blood,
             ethnicity  = v_all_person.ethnicity,
             hdesp      = v_all_person.hdesp,
             customerid = v_all_person.customerid,
             name       = v_all_person.name,
             job        = v_all_person.job,
             drvcard    = v_all_person.drvcard,
             country    = v_all_person.country,
             residence  = v_all_person.residence,
             id         = v_all_person.id,
             id15       = v_all_person.id15,
             idtype     = v_all_person.idtype,
             cust_id05  = v_all_person.cust_id05,
             reg_date   = v_all_person.reg_date,
             begtime    = v_all_person.begtime,
             endtime    = v_all_person.endtime,
             branch     = v_all_person.branch,
             etl_time   = v_all_person.etl_time,
             src_sys    = v_all_person.src_sys
       where source_person_id = v_all_person.source_person_id;

    exception
      when others then
        v_error_rows := v_error_rows + 1;
        -- 遇到异常做一些处理
        begin
          p_xq_log_in_err('IDS','P_XQ_PERSON_IN_EVERY_DAY',
                v_all_person.source_person_id
                ,'更新表xq_all_person数据'||sqlerrm);--把主键放进日志中
        end;
    end;

    v_all_update_rows := v_all_update_rows + 1;

  end loop;
  close cur_all_person;

  commit;

  --插入全量表不存在记录

  for c_r in (select sno, typeid, person_id, persontype, bthdate, diedate, edulevel, sex, income,
                    company, marriage, smoker, blood, ethnicity, hdesp, customerid, name, job, drvcard,
                    country, residence, id, id15, idtype, cust_id05, source_person_id, reg_date, begtime,
                    endtime, branch, etl_time, src_sys
          from person_temp r
               where not exists
               (select 1
                        from xq_all_person s
                       where r.source_person_id = s.source_person_id)) loop

  begin

      insert into xq_all_person(sno, typeid, person_id, persontype, bthdate, diedate, edulevel, sex, income,
                    company, marriage, smoker, blood, ethnicity, hdesp, customerid, name, job, drvcard,
                    country, residence, id, id15, idtype, cust_id05, source_person_id, reg_date, begtime,
                    endtime, branch, etl_time, src_sys)
      values(c_r.sno,c_r.typeid,c_r.person_id,c_r.persontype,c_r.bthdate,c_r.diedate,c_r.edulevel,c_r.sex,c_r.income,
            c_r.company,c_r.marriage,c_r.smoker,c_r.blood,c_r.ethnicity,c_r.hdesp,c_r.customerid,
            c_r.name,c_r.job,c_r.drvcard,c_r.country,c_r.residence,c_r.id,c_r.id15,c_r.idtype,c_r.cust_id05,
            c_r.source_person_id,c_r.reg_date,c_r.begtime,c_r.endtime,c_r.branch,c_r.etl_time,c_r.src_sys);

      v_all_insert_rows := v_all_insert_rows + 1;

      EXCEPTION
            WHEN OTHERS THEN
              begin
                p_xq_log_in_err('IDS','P_XQ_PERSON_IN_EVERY_DAY',
                c_r.source_person_id
                ,'插入表xq_all_person数据'||sqlerrm);--把主键放进日志中
                v_error_rows := v_error_rows + 1;
              end;
      end;
    if mod(v_all_insert_rows, 5000) = 0 then
      commit;--提交记录
    end if;
  end loop;

  commit;

  --获取主键值
  select t.nextvalue into v_id from c_id_bro t where t.name = 'xq_person';

  open cur_person;
  loop
    fetch cur_person
      into v_riskcon;
    exit when cur_person%notfound;

    select (select t.source_person_id
              from person_temp t
             where t.source_person_id = v_riskcon.owner_source_id
               and rownum = 1)
      into v_count
      from dual;

    if v_count is null then
      select (select t.source_person_id
                from person_temp t
               where t.source_person_id = v_riskcon.insured_source_id
                 and rownum = 1)
        into v_count
        from dual;
    end if;
    if v_count is null then
      select (select t.source_person_id
                from person_temp t
               where t.id = v_riskcon.apid
                 and rownum = 1)
        into v_count
        from dual;
    end if;

    if v_count is null then
      select (select t.source_person_id
                from person_temp t
               where t.id = v_riskcon.pid
                 and rownum = 1)
        into v_count
        from dual;
    end if;

    if v_count is null then
      select (select t.source_person_id
                from person_temp t
               where t.id15 = v_riskcon.apid
                 and rownum = 1)
        into v_count
        from dual;
    end if;

    if v_count is null then
      select (select t.source_person_id
                from person_temp t
               where t.id15 = v_riskcon.pid
                 and rownum = 1)
        into v_count
        from dual;
    end if;

    --查询在xq_person 中是否存在该记录
    select (select t.source_person_id
              from xq_person t
             where t.source_person_id = v_count
               and rownum = 1)
      into v_sno
      from dual;

    if v_count is not null then
      if v_sno is null then
        --未查到，插入
        begin
          insert into xq_person
            (sno,
             person_id,
             persontype,
             bthdate,
             diedate,
             edulevel,
             sex,
             income,
             company,
             marriage,
             smoker,
             blood,
             ethnicity,
             hdesp,
             customerid,
             name,
             job,
             drvcard,
             country,
             residence,
             id,
             id15,
             idtype,
             etl_time,
             idtype_ids,
             source_person_id,
             branch,
             begtime,
             endtime,
             src_sys)
            select v_id,
                   person_id,
                   persontype,
                   bthdate,
                   diedate,
                   edulevel,
                   sex,
                   income,
                   company,
                   marriage,
                   smoker,
                   blood,
                   ethnicity,
                   hdesp,
                   customerid,
                   name,
                   job,
                   drvcard,
                   country,
                   residence,
                   id,
                   id15,
                   nvl(decode(r.idtype,
                              '1',
                              '1101',
                              (select t.id
                                 from xq_dict t
                                where t.parent_id = 11
                                  and item_code = r.idtype
                                  and rownum = 1)),
                       1150) idtype_c,
                   etl_time,
                   idtype,
                   source_person_id,
                   branch,
                   begtime,
                   endtime,
                   src_sys
              from person_temp r
             where r.source_person_id = v_count
               and rownum = 1;

        exception
          when others then
            v_error_rows := v_error_rows + 1;
            -- 遇到异常做一些处理
            begin
              p_xq_log_in_err('IDS','P_XQ_PERSON_IN_EVERY_DAY',
                v_count
                ,'插入表xq_person数据'||sqlerrm);--把主键放进日志中
            end;
        end;
        v_insert_rows := v_insert_rows + 1;
        v_id          := v_id + 1;
      else
        select (select t.begtime
                  from xq_person t
                 where t.source_person_id = v_count
                   and rownum = 1)
          into v_begtime
          from dual;

        --初始化该条记录的身份证类型
        select (select t.idtype
                  from person_temp t
                 where t.source_person_id = v_count
                   and rownum = 1)
          into v_idtype_temp
          from dual;

        if trim(v_idtype_temp) = '1' then
          v_idtype := 1101;
        else
          --证件类型对应字典表ID
          if v_idtype_temp is not null then
            select (select t.id
                      from xq_dict t
                     where t.parent_id = 11
                       and t.item_code = v_idtype_temp)
              into v_idtype
              from dual;
          end if;

          if v_idtype is null then
            v_idtype := 1150;
          end if;
        end if;

        select t.person_id,
               t.persontype,
               t.bthdate,
               t.diedate,
               t.edulevel,
               t.sex,
               t.income,
               t.company,
               t.marriage,
               t.smoker,
               t.blood,
               t.ethnicity,
               t.hdesp,
               t.customerid,
               t.name,
               t.job,
               t.drvcard,
               t.country,
               t.residence,
               t.id,
               t.id15,
               t.etl_time,
               t.idtype,
               t.source_person_id,
               t.branch,
               t.begtime,
               t.endtime,
               t.src_sys
          into v_p_person_id,
               v_p_persontype,
               v_p_bthdate,
               v_p_diedate,
               v_p_edulevel,
               v_p_sex,
               v_p_income,
               v_p_company,
               v_p_marriage,
               v_p_smoker,
               v_p_blood,
               v_p_ethnicity,
               v_p_hdesp,
               v_p_customerid,
               v_p_name,
               v_p_job,
               v_p_drvcard,
               v_p_country,
               v_p_residence,
               v_p_id,
               v_p_id15,
               v_p_etl_time,
               v_p_idtype,
               v_p_source_person_id,
               v_p_branch,
               v_p_begtime,
               v_p_endtime,
               v_p_src_sys
          from person_temp t
         where t.source_person_id = v_count
           and rownum = 1;

        if v_p_begtime > v_begtime then
          --更新
          begin
            update xq_person t
               set t.person_id  = v_p_person_id,
                   t.persontype = v_p_persontype,
                   t.bthdate    = v_p_bthdate,
                   t.diedate    = v_p_diedate,
                   t.edulevel   = v_p_edulevel,
                   t.sex        = v_p_sex,
                   t.income     = v_p_income,
                   t.company    = v_p_company,
                   t.marriage   = v_p_marriage,
                   t.smoker     = v_p_smoker,
                   t.blood      = v_p_blood,
                   t.ethnicity  = v_p_ethnicity,
                   t.hdesp      = v_p_hdesp,
                   t.customerid = v_p_customerid,
                   t.name       = v_p_name,
                   t.job        = v_p_job,
                   t.drvcard    = v_p_drvcard,
                   t.country    = v_p_country,
                   t.residence  = v_p_residence,
                   t.id         = v_p_id,
                   t.id15       = v_p_id15,
                   t.idtype     = v_idtype,
                   t.etl_time   = v_p_etl_time,
                   t.idtype_ids = v_p_idtype,
                   t.branch     = v_p_branch,
                   t.begtime    = v_p_begtime,
                   t.endtime    = v_p_endtime,
                   t.src_sys    = v_p_src_sys
             where t.source_person_id = v_count;

          exception
            when others then
              v_error_rows := v_error_rows + 1;
              -- 遇到异常做一些处理
              begin
                p_xq_log_in_err('IDS','P_XQ_PERSON_IN_EVERY_DAY',
                  v_count
                  ,'更新表xq_person数据'||sqlerrm);--把主键放进日志中
              end;
          end;

          v_update_rows := v_update_rows + 1;

        end if;
      end if;
    else--没有找到信息
      /**
      * 1.在person_temp 表没有找到 2.在xq_all_person表是否找到
      */
      if v_sno is null then

        select (select t.source_person_id
                  from xq_all_person t
                 where t.source_person_id = v_riskcon.owner_source_id
                   and not exists
                 (select 1
                          from xq_person q
                         where q.source_person_id = t.source_person_id)
                   and rownum = 1)
          into v_sno
          from dual;

        if v_sno is null then
          select (select t.source_person_id
                    from xq_all_person t
                   where t.source_person_id = v_riskcon.insured_source_id
                     and not exists
                   (select 1
                            from xq_person q
                           where q.source_person_id = t.source_person_id)
                     and rownum = 1)
            into v_sno
            from dual;
        end if;

        if v_sno is null then
          select (select t.source_person_id
                    from xq_all_person t
                   where t.id = v_riskcon.apid
                     and not exists
                   (select 1
                            from xq_person q
                           where q.source_person_id = t.source_person_id)
                     and rownum = 1)
            into v_sno
            from dual;
        end if;

        if v_sno is null then
          select (select t.source_person_id
                    from xq_all_person t
                   where t.id = v_riskcon.pid
                     and not exists
                   (select 1
                            from xq_person q
                           where q.source_person_id = t.source_person_id)
                     and rownum = 1)
            into v_sno
            from dual;
        end if;

        if v_sno is null then
          select (select t.source_person_id
                    from xq_all_person t
                   where t.id15 = v_riskcon.apid
                     and not exists
                   (select 1
                            from xq_person q
                           where q.source_person_id = t.source_person_id)
                     and rownum = 1)
            into v_sno
            from dual;
        end if;

        if v_sno is null then
          select (select t.source_person_id
                    from xq_all_person t
                   where t.id15 = v_riskcon.pid
                     and not exists
                   (select 1
                            from xq_person q
                           where q.source_person_id = t.source_person_id)
                     and rownum = 1)
            into v_sno
            from dual;
        end if;

        if v_sno is not null then
          --插入记录到xq_person 表
          begin
            insert into xq_person
              (sno,
               person_id,
               persontype,
               bthdate,
               diedate,
               edulevel,
               sex,
               income,
               company,
               marriage,
               smoker,
               blood,
               ethnicity,
               hdesp,
               customerid,
               name,
               job,
               drvcard,
               country,
               residence,
               id,
               id15,
               idtype,
               etl_time,
               idtype_ids,
               source_person_id,
               branch,
               begtime,
               endtime,
               src_sys)
              select v_id,
                     person_id,
                     persontype,
                     bthdate,
                     diedate,
                     edulevel,
                     sex,
                     income,
                     company,
                     marriage,
                     smoker,
                     blood,
                     ethnicity,
                     hdesp,
                     customerid,
                     name,
                     job,
                     drvcard,
                     country,
                     residence,
                     id,
                     id15,
                     nvl(decode(r.idtype,
                                '1',
                                '1101',
                                (select t.id
                                   from xq_dict t
                                  where t.parent_id = 11
                                    and item_code = r.idtype
                                    and rownum = 1)),
                         1150) idtype_c,
                     etl_time,
                     idtype,
                     source_person_id,
                     branch,
                     begtime,
                     endtime,
                     src_sys
                from xq_all_person r
               where r.source_person_id = v_sno
                 and rownum = 1;

          exception
            when others then
              v_error_rows := v_error_rows + 1;
              -- 遇到异常做一些处理
              begin
                p_xq_log_in_err('IDS','P_XQ_PERSON_IN_EVERY_DAY',
                  v_sno
                  ,'插入表xq_person数据'||sqlerrm);--把主键放进日志中
              end;
          end;

          v_id              := v_id + 1;
          v_insert_rows := v_insert_rows + 1;

        else--在全量中找到并在xq_person也找到 做更新
          select (select t.source_person_id
                    from xq_all_person t
                   where t.source_person_id = v_riskcon.owner_source_id
                     and exists
                   (select 1
                            from xq_person q
                           where q.source_person_id = t.source_person_id)
                     and rownum = 1)
            into v_count
            from dual;

          if v_count is null then
            select (select t.source_person_id
                      from xq_all_person t
                     where t.source_person_id = v_riskcon.insured_source_id
                       and exists
                     (select 1
                              from xq_person q
                             where q.source_person_id = t.source_person_id)
                       and rownum = 1)
              into v_count
              from dual;
          end if;

          if v_count is null then
            select (select t.source_person_id
                      from xq_all_person t
                     where t.id = v_riskcon.apid
                       and exists
                     (select 1
                              from xq_person q
                             where q.source_person_id = t.source_person_id)
                       and rownum = 1)
              into v_count
              from dual;
          end if;

          if v_count is null then
            select (select t.source_person_id
                      from xq_all_person t
                     where t.id = v_riskcon.pid
                       and exists
                     (select 1
                              from xq_person q
                             where q.source_person_id = t.source_person_id)
                       and rownum = 1)
              into v_count
              from dual;
          end if;

          if v_count is null then
            select (select t.source_person_id
                      from xq_all_person t
                     where t.id15 = v_riskcon.apid
                       and exists
                     (select 1
                              from xq_person q
                             where q.source_person_id = t.source_person_id)
                       and rownum = 1)
              into v_count
              from dual;
          end if;

          select (select t.begtime
                    from xq_person t
                   where t.source_person_id = v_count
                     and rownum = 1)
            into v_begtime
            from dual;

          --初始化该条记录的身份证类型
          select (select t.idtype
                    from xq_all_person t
                   where t.source_person_id = v_count
                     and rownum = 1)
            into v_idtype_temp
            from dual;

          if trim(v_idtype_temp) = '1' then
            v_idtype := 1101;
          else
            --证件类型对应字典表ID
            if v_idtype_temp is not null then
              select (select t.id
                        from xq_dict t
                       where t.parent_id = 11
                         and t.item_code = v_idtype_temp)
                into v_idtype
                from dual;
            end if;

            if v_idtype is null then
              v_idtype := 1150;
            end if;
          end if;
         if v_count is not null then
          select t.person_id,
                 t.persontype,
                 t.bthdate,
                 t.diedate,
                 t.edulevel,
                 t.sex,
                 t.income,
                 t.company,
                 t.marriage,
                 t.smoker,
                 t.blood,
                 t.ethnicity,
                 t.hdesp,
                 t.customerid,
                 t.name,
                 t.job,
                 t.drvcard,
                 t.country,
                 t.residence,
                 t.id,
                 t.id15,
                 t.etl_time,
                 t.idtype,
                 t.source_person_id,
                 t.branch,
                 t.begtime,
                 t.endtime,
                 t.src_sys
            into v_p_person_id,
                 v_p_persontype,
                 v_p_bthdate,
                 v_p_diedate,
                 v_p_edulevel,
                 v_p_sex,
                 v_p_income,
                 v_p_company,
                 v_p_marriage,
                 v_p_smoker,
                 v_p_blood,
                 v_p_ethnicity,
                 v_p_hdesp,
                 v_p_customerid,
                 v_p_name,
                 v_p_job,
                 v_p_drvcard,
                 v_p_country,
                 v_p_residence,
                 v_p_id,
                 v_p_id15,
                 v_p_etl_time,
                 v_p_idtype,
                 v_p_source_person_id,
                 v_p_branch,
                 v_p_begtime,
                 v_p_endtime,
                 v_p_src_sys
            from xq_all_person t
           where t.source_person_id = v_count
             and rownum = 1;
           end if ;

          if v_p_begtime > v_begtime and v_count is not null then
            --更新
            begin
              update xq_person t
                 set t.person_id  = v_p_person_id,
                     t.persontype = v_p_persontype,
                     t.bthdate    = v_p_bthdate,
                     t.diedate    = v_p_diedate,
                     t.edulevel   = v_p_edulevel,
                     t.sex        = v_p_sex,
                     t.income     = v_p_income,
                     t.company    = v_p_company,
                     t.marriage   = v_p_marriage,
                     t.smoker     = v_p_smoker,
                     t.blood      = v_p_blood,
                     t.ethnicity  = v_p_ethnicity,
                     t.hdesp      = v_p_hdesp,
                     t.customerid = v_p_customerid,
                     t.name       = v_p_name,
                     t.job        = v_p_job,
                     t.drvcard    = v_p_drvcard,
                     t.country    = v_p_country,
                     t.residence  = v_p_residence,
                     t.id         = v_p_id,
                     t.id15       = v_p_id15,
                     t.idtype     = v_idtype,
                     t.etl_time   = v_p_etl_time,
                     t.idtype_ids = v_p_idtype,
                     t.branch     = v_p_branch,
                     t.begtime    = v_p_begtime,
                     t.endtime    = v_p_endtime,
                     t.src_sys    = v_p_src_sys
               where t.source_person_id = v_count;

            exception
              when others then
                -- 遇到异常做一些处理
                begin
                  p_xq_log_in_err('IDS','P_XQ_PERSON_IN_EVERY_DAY',
                  v_count
                  ,'更新表xq_person数据'||sqlerrm);--把主键放进日志中
                  v_error_rows := v_error_rows + 1;
                end;
            end;

            v_update_rows := v_update_rows + 1;
          end if;
        end if;
      end if;
    end if;
    commit;--提交数据
  end loop;
  close cur_person;

  commit;--提交数据

  --把以上漏掉有效个人信息 批量插入
  for c_p in (select person_id,
                     persontype,
                     bthdate,
                     diedate,
                     edulevel,
                     sex,
                     income,
                     company,
                     marriage,
                     smoker,
                     blood,
                     ethnicity,
                     hdesp,
                     customerid,
                     name,
                     job,
                     drvcard,
                     country,
                     residence,
                     id,
                     id15,
                     nvl(decode(r.idtype,
                                '1',
                                '1101',
                                (select t.id
                                   from xq_dict t
                                  where t.parent_id = 11
                                    and item_code = r.idtype
                                    and rownum = 1)),
                         1150) idtype_c,
                     etl_time,
                     idtype,
                     source_person_id,
                     branch,
                     begtime,
                     endtime,
                     src_sys
                from person_temp r
               where not exists
               (select 1
                        from xq_person p
                       where r.source_person_id = p.source_person_id)
                 and exists
               (select 1
                        from (select owner_source_id, insured_source_id,
                              apid, pid,classcode from xq_riskcon r
                              where exists (select p.classcode from xq_riskclass p
                                    where p.classcode = r.classcode
                                     and p.timestr = '1')) p
                       where p.owner_source_id = r.source_person_id
                          or p.insured_source_id = r.source_person_id
                          or p.apid = r.id
                          or p.pid = r.id15
                          or p.apid = r.id15
                          or p.pid = r.id)) loop
    begin
    insert into xq_person
      (sno,
       person_id,
       persontype,
       bthdate,
       diedate,
       edulevel,
       sex,
       income,
       company,
       marriage,
       smoker,
       blood,
       ethnicity,
       hdesp,
       customerid,
       name,
       job,
       drvcard,
       country,
       residence,
       id,
       id15,
       idtype,
       etl_time,
       idtype_ids,
       source_person_id,
       branch,
       begtime,
       endtime,
       src_sys)
    values
      (v_id,
       c_p.person_id,
       c_p.persontype,
       c_p.bthdate,
       c_p.diedate,
       c_p.edulevel,
       c_p.sex,
       c_p.income,
       c_p.company,
       c_p.marriage,
       c_p.smoker,
       c_p.blood,
       c_p.ethnicity,
       c_p.hdesp,
       c_p.customerid,
       c_p.name,
       c_p.job,
       c_p.drvcard,
       c_p.country,
       c_p.residence,
       c_p.id,
       c_p.id15,
       c_p.idtype_c,
       c_p.etl_time,
       c_p.idtype,
       c_p.source_person_id,
       c_p.branch,
       c_p.begtime,
       c_p.endtime,
       c_p.src_sys);

       EXCEPTION
            WHEN OTHERS THEN
              begin
                 p_xq_log_in_err('IDS','P_XQ_PERSON_IN_EVERY_DAY',
                  c_p.source_person_id
                  ,'插入表xq_person数据'||sqlerrm);--把主键放进日志中
                v_error_rows := v_error_rows + 1;
              end;
      end;
    v_id              := v_id + 1;
    v_all_append_rows := v_all_append_rows + 1;

  end loop;

  commit;--提交记录

  update c_id_bro t set t.nextvalue = v_id where t.name = 'xq_person';
  commit;
  --日志记录执行情况
  dbms_output.put_line('P_XQ_PERSON_IN_EVERY_DAY中数据更新 ' || v_update_rows ||
                       '行，数据插入 ' || v_insert_rows || '行,失败' ||
                       v_error_rows || '行,大数据量表更新' || v_all_update_rows ||
                       '行,大数据量表插入' || v_all_insert_rows || '行，补充插入' ||
                       v_all_append_rows || '行');

  --添加数据库成功日志
  p_xq_log_suc('IDS',
               'P_XQ_PERSON_IN_EVERY_DAY',
               (v_insert_rows + v_all_insert_rows + v_all_append_rows),
               v_error_rows,
               v_update_rows,
               'P_XQ_PERSON_IN_EVERY_DAY中数据更新 ' || v_update_rows ||
                       '行，数据插入 ' || v_insert_rows || '行,失败' ||
                       v_error_rows || '行,大数据量表更新' || v_all_update_rows ||
                       '行,大数据量表插入' || v_all_insert_rows || '行，补充插入' ||
                       v_all_append_rows || '行',
               sqlerrm);

EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;

      if cur_person%isopen then
        CLOSE cur_person;
      end if;

      if cur_all_person%isopen then
        close cur_all_person;
      end if;

      rollback;
      dbms_output.put_line('P_XQ_PERSON_IN_EVERY_DAY 全局异常 ERROR' ||
                           sqlerrm);
      --添加数据库失败日志
      p_xq_log_err('IDS',
                   'P_XQ_PERSON_IN_EVERY_DAY',
                   (v_insert_rows + v_all_insert_rows + v_all_append_rows),
                   v_error_rows,
                   v_update_rows,
                   'P_XQ_PERSON_IN_EVERY_DAY中数据更新 ' || v_update_rows ||
                       '行，数据插入 ' || v_insert_rows || '行,失败' ||
                       v_error_rows || '行,大数据量表更新' || v_all_update_rows ||
                       '行,大数据量表插入' || v_all_insert_rows || '行，补充插入' ||
                       v_all_append_rows || '行',
                   sqlerrm);
      update c_id_bro t set t.nextvalue = v_id where t.name = 'xq_person';
      commit;
    end;
end P_XQ_PERSON_IN_EVERY_DAY;
/

prompt
prompt Creating procedure P_XQ_PERSON_IN_NOT_BK
prompt ========================================
prompt
create or replace procedure unicall.P_XQ_PERSON_IN_NOT_BK is

  v_sno     number(18) := 0;
  v_begtime NUMBER(11) := 0;
  v_idtype  number(10);

  cursor cur_person is
    select * from person p where p.endtime = 99991231999;
  v_person cur_person%rowtype;

begin
  open cur_person;
  loop
    fetch cur_person
      into v_person;
    exit when cur_person%notfound;

    select (select t.sno
              from xq_person t
             where t.source_person_id = v_person.SOURCE_PERSON_ID || '001'
               and t.id = v_person.id
               and rownum = 1)
      into v_sno
      from dual;

    if v_sno is not null then
      if trim(v_person.idtype) = '1' then
        v_idtype := 1101;
      else
        --证件类型对应字典表ID
        select (select t.id
                  from xq_dict t
                 where t.parent_id = 11
                   and t.item_code = v_person.idtype)
          into v_idtype
          from dual;

        if v_idtype is null then
          v_idtype := 1150;
        end if;
      end if;

      --获取begtime值
      select (select t.begtime
                from xq_person t
               where t.sno = v_sno)
        into v_begtime
        from dual;

      if v_person.begtime > v_begtime then
        --更新
        begin
          update xq_person t
             set t.person_id        = v_person.person_id,
                 t.persontype       = v_person.persontype,
                 t.bthdate          = v_person.bthdate,
                 t.diedate          = v_person.diedate,
                 t.edulevel         = v_person.edulevel,
                 t.sex              = v_person.sex,
                 t.income           = v_person.income,
                 t.company          = v_person.company,
                 t.marriage         = v_person.marriage,
                 t.smoker           = v_person.smoker,
                 t.blood            = v_person.blood,
                 t.ethnicity        = v_person.ethnicity,
                 t.hdesp            = v_person.hdesp,
                 t.customerid       = v_person.customerid,
                 t.name             = v_person.name,
                 t.job              = v_person.job,
                 t.drvcard          = v_person.drvcard,
                 t.country          = v_person.country,
                 t.residence        = v_person.residence,
                 t.id15             = v_person.id15,
                 t.idtype           = v_idtype,
                 t.etl_time         = v_person.etl_time,
                 t.idtype_ids       = v_person.idtype,
                 t.branch           = v_person.branch,
                 t.begtime          = v_person.begtime,
                 t.endtime          = v_person.endtime,
                 t.src_sys          = v_person.src_sys
           where t.source_person_id = v_person.SOURCE_PERSON_ID || '001'
             and t.id = v_person.id;

        exception
          when others then
            -- 遇到异常做一些处理
            begin
              dbms_output.put_line('data error :' ||
                                   v_person.source_person_id || '--' ||
                                   v_person.sno);
            end;
        end;
      end if;
      commit;

    end if;
  end loop;
  close cur_person;

EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;
      dbms_output.put_line('ERROR');
    end;

end P_XQ_PERSON_IN_NOT_BK;
/

prompt
prompt Creating procedure P_XQ_PHONE_IN
prompt ================================
prompt
create or replace procedure unicall.P_XQ_PHONE_IN is
  v_count   number(18);
  v_id      number(18);
  v_sno     number(18);
  v_begtime NUMBER(11);
  v_idtype  number(10);

  v_insert_rows number(18) := 0;
  v_update_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  cursor cur_phone is
    select * from phone;
  v_phone cur_phone%rowtype;

begin
  --获取主键值
  select t.nextvalue into v_id from c_id_bro t where t.name = 'xq_phone';

  open cur_phone;
  loop
    fetch cur_phone
      into v_phone;
    exit when cur_phone%notfound;

    select (select p.sno
            from xq_person p
           where p.SOURCE_PERSON_ID = v_phone.SOURCE_PERSON_ID
             and rownum = 1)
    into v_count
    from dual;

    if v_count > 0 then
      select (select t.sno
                from xq_phone t
               where t.usage = v_phone.usage
                 and t.source_person_id = v_phone.source_person_id
                 and t.seq = v_phone.seq
                 and rownum = 1)
        into v_sno
        from dual;

      if trim(v_phone.idtype) = '1' then
        v_idtype := 1101;
      else
        --证件类型对应字典表ID
        select (select t.id
                  from xq_dict t
                 where t.parent_id = 11
                   and t.item_code = v_phone.idtype)
          into v_idtype
          from dual;

        if v_idtype is null then
          v_idtype := 1150;
        end if;
      end if;

      if v_sno is null then
        --未查到，插入
        begin
          insert into xq_phone
            (sno,
             areacode,
             countrycode,
             tel,
             ext,
             type,
             telnumber,
             usage,
             person_id,
             pid,
             idtype,
             id15,
             etl_time,
             idtype_ids,
             source_person_id,
             begtime,
             endtime,
             src_sys,
             seq)
          values
            (v_id,
             v_phone.areacode,
             v_phone.countrycode,
             v_phone.tel,
             v_phone.ext,
             v_phone.type,
             v_phone.telnumber,
             v_phone.usage,
             v_phone.person_id,
             v_phone.pid,
             v_idtype,
             v_phone.id15,
             v_phone.etl_time,
             v_phone.idtype,
             v_phone.source_person_id,
             v_phone.begtime,
             v_phone.endtime,
             v_phone.src_sys,
             v_phone.seq);

        exception
          when others then
            -- 遇到异常做一些处理
            begin
              dbms_output.put_line('data error :' ||
                                   v_phone.source_person_id || '--' ||
                                   v_phone.sno);
              v_error_rows :=v_error_rows+1;
            end;
        end;
        v_insert_rows :=v_insert_rows+1;
        v_id := v_id + 1;
      else
        select (select t.begtime
                  from xq_phone t
                 where t.usage = v_phone.usage
                   and t.source_person_id = v_phone.source_person_id
                   and t.seq = v_phone.seq
                   and rownum = 1)
          into v_begtime
          from dual;

        if v_phone.begtime > v_begtime then
          --更新
          begin
            update xq_phone t
               set t.areacode         = v_phone.areacode,
                   t.countrycode      = v_phone.countrycode,
                   t.tel              = v_phone.tel,
                   t.ext              = v_phone.ext,
                   t.type             = v_phone.type,
                   t.telnumber        = v_phone.telnumber,
                   t.usage            = v_phone.usage,
                   t.person_id        = v_phone.person_id,
                   t.pid              = v_phone.pid,
                   t.idtype           = v_idtype,
                   t.id15             = v_phone.id15,
                   t.etl_time         = v_phone.etl_time,
                   t.idtype_ids       = v_phone.idtype,
                   t.source_person_id = v_phone.source_person_id,
                   t.begtime          = v_phone.begtime,
                   t.endtime          = v_phone.endtime,
                   t.src_sys          = v_phone.src_sys,
                   t.seq              = v_phone.seq
             where t.sno = v_sno;

             v_update_rows :=v_update_rows+1;
          exception
            when others then
              -- 遇到异常做一些处理
              begin
                 p_xq_log_in_err('IDS','P_XQ_PHONE_IN',
                  'usage:'||v_phone.usage||' source_person_id:'||v_phone.source_person_id||' seq:'||v_phone.seq,
                  '插入表xq_phone数据'||sqlerrm);--写日志
                v_error_rows :=v_error_rows+1;
              end;
          end;

        end if;
      end if;

      commit;

    end if;
  end loop;
  close cur_phone;

  update c_id_bro t set t.nextvalue = v_id where t.name = 'xq_phone';
  commit;
  --添加数据库成功日志
  p_xq_log_suc('IDS',
              'P_XQ_PHONE_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);
EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;

      if cur_phone%isopen then
        CLOSE cur_phone;
      end if;

      update c_id_bro t set t.nextvalue = v_id where t.name = 'xq_phone';
      commit;

      --添加数据库失败日志
      p_xq_log_err('IDS',
              'P_XQ_PHONE_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);
    end;

end P_XQ_PHONE_IN;
/

prompt
prompt Creating procedure P_XQ_PHONE_IN_EVERY_DAY
prompt ==========================================
prompt
create or replace procedure unicall.P_XQ_PHONE_IN_EVERY_DAY is
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_PHONE_IN_EVERY_DAY
  *  建立日期   ：2012-06-04
  *  作者       ：yangguoqi
  *  模块       ：IDS
  *  描述       ：每天同步phone_temp表数据到xq_phone
  *----------------------------------------------------
  *  序号   日期    修改人    修改原因
  *  1
  *  2
  ******************************************************
  */
  v_update_rows number(18) := 0;
  v_insert_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  v_all_insert_rows number(18) := 0;
  v_all_update_rows number(18) := 0;

  v_id      number(18);

  cursor cur_all_phone is
    select *
      from phone_temp r
     where exists (select 1
              from xq_all_phone s
             where s.usage=r.usage and s.source_person_id = r.source_person_id and s.seq=r.seq
             and r.begtime>s.begtime);

  v_all_phone cur_all_phone%rowtype;

begin

  delete phone_temp t   --删除重复记录
         where t.rowid not in
         (select max(rowid)
            from phone_temp r
           group by r.usage,r.source_person_id,r.seq);
  commit;
  --同步数据到个人全量信息表中
  open cur_all_phone;
  loop
    fetch cur_all_phone
      into v_all_phone;
    exit when cur_all_phone%notfound;

    --更新全量表中存在的信息
    begin
      --为了提高效率这里不再判断begtime是否大于
      update xq_all_phone r
         set r.sno              = v_all_phone.sno,
             r.typeid           = v_all_phone.typeid,
             r.areacode         = v_all_phone.areacode,
             r.countrycode      = v_all_phone.countrycode,
             r.tel              = v_all_phone.tel,
             r.ext              = v_all_phone.ext,
             r.type             = v_all_phone.type,
             r.telnumber        = v_all_phone.telnumber,
             r.person_id        = v_all_phone.person_id,
             r.pid              = v_all_phone.pid,
             r.idtype           = v_all_phone.idtype,
             r.purpose          = v_all_phone.purpose,
             r.id15             = v_all_phone.id15,
             r.begtime          = v_all_phone.begtime,
             r.endtime          = v_all_phone.endtime,
             r.branch           = v_all_phone.branch,
             r.etl_time         = v_all_phone.etl_time,
             r.src_sys          = v_all_phone.src_sys
       where r.usage=v_all_phone.usage and r.source_person_id = v_all_phone.source_person_id
        and r.seq=v_all_phone.seq;

    exception
      when others then
        v_error_rows := v_error_rows + 1;
        -- 遇到异常做一些处理
        begin
          p_xq_log_in_err('IDS','P_XQ_PHONE_IN_EVERY_DAY',
                'usage:'||v_all_phone.usage ||' source_person_id:'||v_all_phone.source_person_id ||' seq:'||v_all_phone.seq
                ,'更新表xq_all_phone数据'||sqlerrm);--把主键放进日志中
          v_error_rows := v_error_rows + 1;
        end;
    end;

    v_all_update_rows := v_all_update_rows + 1;

  end loop;
  close cur_all_phone;
  commit;--批量提交记录

  --插入全量表不存在记录

  for c_r in (select sno,typeid,areacode,countrycode,tel,ext,type,telnumber,usage,person_id,pid,idtype,
           purpose,seq,source_person_id,id15,begtime,endtime,branch,etl_time,src_sys
        from phone_temp r
       where not exists (select 1
                from xq_all_phone s
                where s.usage=r.usage and s.source_person_id = r.source_person_id and s.seq=r.seq)) loop

  begin

      insert into xq_all_phone(sno,typeid,areacode,countrycode,tel,ext,type,telnumber,usage,person_id,pid,idtype,
         purpose,seq,source_person_id,id15,begtime,endtime,branch,etl_time,src_sys)
      values(c_r.sno,c_r.typeid,c_r.areacode,c_r.countrycode,c_r.tel,c_r.ext,c_r.type,c_r.telnumber,c_r.usage,
            c_r.person_id,c_r.pid,c_r.idtype,c_r.purpose,c_r.seq,c_r.source_person_id,c_r.id15,c_r.begtime,
            c_r.endtime,c_r.branch,c_r.etl_time,c_r.src_sys);

      v_all_insert_rows := v_all_insert_rows + 1;
      v_id := v_id + 1;
      EXCEPTION
            WHEN OTHERS THEN
              begin
                p_xq_log_in_err('IDS','P_XQ_PHONE_IN_EVERY_DAY',
                'usage:'||c_r.usage ||' source_person_id:'||c_r.source_person_id ||' seq:'||c_r.seq
                ,'插入表xq_all_phone数据'||sqlerrm);--把主键放进日志中
                v_error_rows := v_error_rows + 1;
              end;
      end;
    if mod(v_all_insert_rows, 5000) = 0 then
        commit;--批量提交记录
    end if;
  end loop;
  commit;--提交记录

  --更新xp_phone记录begtime小的
  for c_r in (select sno,typeid,areacode,countrycode,tel,ext,type,telnumber,usage,person_id,pid,
                     nvl(decode(r.idtype,
                                '1',
                                '1101',
                                (select t.id
                                   from xq_dict t
                                  where t.parent_id = 11
                                    and item_code = r.idtype
                                    and rownum = 1)),
                         1150) idtype_c,idtype,
                      purpose,seq,source_person_id,id15,begtime,endtime,branch,etl_time,src_sys
                      from xq_all_phone r
                     where exists (select 1
                              from xq_phone s
                             where s.usage = r.usage
                               and s.source_person_id = r.source_person_id
                               and s.seq = r.seq
                               and r.begtime > s.begtime)) loop
      begin

        update xq_phone t
               set t.areacode         = c_r.areacode,
                   t.countrycode      = c_r.countrycode,
                   t.tel              = c_r.tel,
                   t.ext              = c_r.ext,
                   t.type             = c_r.type,
                   t.telnumber        = c_r.telnumber,
                   t.person_id        = c_r.person_id,
                   t.pid              = c_r.pid,
                   t.idtype           = c_r.idtype_c,
                   t.id15             = c_r.id15,
                   t.etl_time         = c_r.etl_time,
                   t.idtype_ids       = c_r.idtype,
                   t.begtime          = c_r.begtime,
                   t.endtime          = c_r.endtime,
                   t.src_sys          = c_r.src_sys
             where t.usage = c_r.usage
                   and t.source_person_id = c_r.source_person_id
                   and t.seq = c_r.seq
                   and rownum = 1;

      v_update_rows := v_update_rows + 1;

      EXCEPTION
            WHEN OTHERS THEN
              begin
                p_xq_log_in_err('IDS','P_XQ_PHONE_IN_EVERY_DAY',
                'usage:'||c_r.usage ||' source_person_id:'||c_r.source_person_id ||' seq:'||c_r.seq
                ,'更新表xq_phone数据'||sqlerrm);--把主键放进日志中
                v_error_rows := v_error_rows + 1;
              end;
      end;
      end loop;
      commit;

    --获取主键值
    select t.nextvalue+1 into v_id from c_id_bro t where t.name = 'xq_phone';

    --数据插入
    for c_r in (select sno,typeid,areacode,countrycode,tel,ext,type,telnumber,usage,person_id,pid,
                     nvl(decode(r.idtype,
                                '1',
                                '1101',
                                (select t.id
                                   from xq_dict t
                                  where t.parent_id = 11
                                    and item_code = r.idtype
                                    and rownum = 1)),
                         1150) idtype_c,idtype,
                      purpose,seq,source_person_id,id15,begtime,endtime,branch,etl_time,src_sys
                from xq_all_phone r
               where exists (select 1
                        from xq_person s
                       where r.source_person_id = s.source_person_id)
                 and not exists (select 1
                        from xq_phone p
                       where r.usage = p.usage
                         and r.source_person_id = p.source_person_id
                         and r.seq = p.seq)) loop

      begin

      insert into xq_phone(sno,areacode,countrycode,tel,ext,type,telnumber,usage,person_id,pid,idtype,
             id15,etl_time,idtype_ids,source_person_id,begtime,endtime,src_sys,seq)
      values(v_id,c_r.areacode,c_r.countrycode,c_r.tel,c_r.ext,c_r.type,c_r.telnumber,c_r.usage,c_r.person_id,
            c_r.pid,c_r.idtype_c,c_r.id15,c_r.etl_time,c_r.idtype,c_r.source_person_id,c_r.begtime,
            c_r.endtime,c_r.src_sys,c_r.seq);

      v_insert_rows := v_insert_rows + 1;
      v_id := v_id + 1;
      EXCEPTION
            WHEN OTHERS THEN
              begin
                p_xq_log_in_err('IDS','P_XQ_PHONE_IN_EVERY_DAY',
                'usage:'||c_r.usage ||' source_person_id:'||c_r.source_person_id ||' seq:'||c_r.seq
                ,'插入表xq_phone数据'||sqlerrm);--把主键放进日志中
                v_error_rows := v_error_rows + 1;
              end;
      end;
      commit;
      end loop;
  commit;--批量提交记录

  update c_id_bro t set t.nextvalue = v_id where t.name = 'xq_phone';
  commit;

  dbms_output.put_line('P_XQ_PERSON_IN_EVERY_DAY中数据更新 ' || v_update_rows ||
                       '行，数据插入 ' || v_insert_rows || '行,失败' ||
                       v_error_rows || '行,大数据量表插入' || v_all_insert_rows || '行,大数据量表更新'
                       || v_all_update_rows || '行');

  --添加数据库成功日志
  p_xq_log_suc('IDS',
              'P_XQ_PHONE_IN_EVERY_DAY',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              'P_XQ_PERSON_IN_EVERY_DAY中数据更新 ' || v_update_rows ||
                       '行，数据插入 ' || v_insert_rows || '行,失败' ||
                       v_error_rows || '行,大数据量表插入' || v_all_insert_rows || '行,大数据量表更新'
                       || v_all_update_rows || '行',
              sqlerrm);
EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;

      if cur_all_phone%isopen then
        close cur_all_phone;
      end if;

      rollback;

      dbms_output.put_line('P_XQ_PHONE_IN_EVERY_DAY全局异常ERROR' || sqlerrm);

      --添加数据库失败日志
      p_xq_log_err('IDS',
              'P_XQ_PHONE_IN_EVERY_DAY',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              'P_XQ_PERSON_IN_EVERY_DAY中数据更新 ' || v_update_rows ||
                       '行，数据插入 ' || v_insert_rows || '行,失败' ||
                       v_error_rows || '行,大数据量表插入' || v_all_insert_rows || '行,大数据量表更新'
                       || v_all_update_rows || '行',
              sqlerrm);
      update c_id_bro t set t.nextvalue = v_id where t.name = 'xq_phone';
      commit;
    end;

end P_XQ_PHONE_IN_EVERY_DAY;
/

prompt
prompt Creating procedure P_XQ_PHONE_IN_NOT_BK
prompt =======================================
prompt
create or replace procedure unicall.P_XQ_PHONE_IN_NOT_BK is
  v_sno     number(18);
  v_begtime NUMBER(11);
  v_idtype  number(10);

  cursor cur_phone is
    select * from phone p where p.endtime = 99991231999;
  v_phone cur_phone%rowtype;

begin

  open cur_phone;
  loop
    fetch cur_phone
      into v_phone;
    exit when cur_phone%notfound;

    select (select t.sno
              from xq_phone t
             where t.source_person_id = v_phone.SOURCE_PERSON_ID || '001'
               and t.pid = v_phone.pid
               and t.usage = v_phone.usage
               and rownum = 1)
      into v_sno
      from dual;

    if v_sno is not null then

      if trim(v_phone.idtype) = '1' then
        v_idtype := 1101;
      else
        --证件类型对应字典表ID
        select (select t.id
                  from xq_dict t
                 where t.parent_id = 11
                   and t.item_code = v_phone.idtype)
          into v_idtype
          from dual;
        if v_idtype is null then
          v_idtype := 1150;
        end if;
      end if;
      --获取begtime值
      select (select t.begtime
                from xq_phone t
               where t.sno = v_sno)
        into v_begtime
        from dual;

      if v_phone.begtime > v_begtime then
        --更新
        begin
          update xq_phone t
             set t.areacode    = v_phone.areacode,
                 t.countrycode = v_phone.countrycode,
                 t.tel         = v_phone.tel,
                 t.ext         = v_phone.ext,
                 t.type        = v_phone.type,
                 t.telnumber   = v_phone.telnumber,
                 t.person_id   = v_phone.person_id,
                 t.idtype      = v_idtype,
                 t.id15        = v_phone.id15,
                 t.etl_time    = v_phone.etl_time,
                 t.idtype_ids  = v_phone.idtype,
                 t.begtime     = v_phone.begtime,
                 t.endtime     = v_phone.endtime,
                 t.src_sys     = v_phone.src_sys
           where t.source_person_id = v_phone.SOURCE_PERSON_ID || '001'
             and t.pid = v_phone.pid
             and t.usage = v_phone.usage;

        exception
          when others then
            -- 遇到异常做一些处理
            begin
              dbms_output.put_line('data error :' ||
                                   v_phone.source_person_id || '--' ||
                                   v_phone.sno);
            end;
        end;
      end if;
      commit;
    end if;
  end loop;
  close cur_phone;

EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;
      dbms_output.put_line('ERROR');
    end;

end P_XQ_PHONE_IN_NOT_BK;
/

prompt
prompt Creating procedure P_XQ_PLC_PRM_TRANS_ACCT_IN
prompt =============================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_PLC_PRM_TRANS_ACCT_IN IS
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_PLC_PRM_TRANS_ACCT_IN
  *  建立日期   ：2012-10-10
  *  作者       ：QINYUNLONG
  *  模块       ：IDS
  *  描述       ：批量处理 保单缴费帐号
  */
  V_BEGTIME               NUMBER(11) := 0;
  V_PLC_PRM_TRANS_ACCT_ID NUMBER(20) := 0;

  V_INSERT_ROWS NUMBER(18) := 0;
  V_UPDATE_ROWS NUMBER(18) := 0;
  V_ERROR_ROWS  NUMBER(18) := 0;

  CURSOR CUR_INFO IS
    SELECT *
      FROM PLC_PRM_TRANS_ACCT P
     WHERE EXISTS (SELECT * FROM XQ_APP A WHERE A.POLICYNO = P.POLICY_NO);
  V_INFO CUR_INFO%ROWTYPE;

BEGIN
  OPEN CUR_INFO;
  LOOP
    FETCH CUR_INFO
      INTO V_INFO;
    EXIT WHEN CUR_INFO%NOTFOUND;

    SELECT (SELECT C.PLC_PRM_TRANS_ACCT_ID
              FROM XQ_PLC_PRM_TRANS_ACCT C
             WHERE C.POLICY_NO = V_INFO.POLICY_NO
               AND C.ACCOUNT_USAGE = V_INFO.ACCOUNT_USAGE
               AND ROWNUM = 1)
      INTO V_PLC_PRM_TRANS_ACCT_ID
      FROM DUAL;

    IF V_PLC_PRM_TRANS_ACCT_ID > 0 THEN
      SELECT (SELECT C.BEGTIME
                FROM XQ_PLC_PRM_TRANS_ACCT C
               WHERE C.PLC_PRM_TRANS_ACCT_ID = V_PLC_PRM_TRANS_ACCT_ID
                 AND ROWNUM = 1)
        INTO V_BEGTIME
        FROM DUAL;

      IF V_INFO.BEGTIME > V_BEGTIME THEN
        --UPDATE XQ_PLC_PRM_TRANS_ACCT
        BEGIN
          UPDATE XQ_PLC_PRM_TRANS_ACCT A
             SET A.SNO           = V_INFO.SNO,
                 A.POLICY_NO     = V_INFO.POLICY_NO,
                 A.ACCOUNT_USAGE = V_INFO.ACCOUNT_USAGE,
                 A.ACCOUNT_NO    = V_INFO.ACCOUNT_NO,
                 A.BANK_CODE     = V_INFO.BANK_CODE,
                 A.BANK_NAME     = V_INFO.BANK_NAME,
                 A.OWNER_ID      = V_INFO.OWNER_ID,
                 A.CURRENCY      = V_INFO.CURRENCY,
                 A.OPEN_DATE     = V_INFO.OPEN_DATE,
                 A.OPER_DATE     = V_INFO.OPER_DATE,
                 A.OPER_NO       = V_INFO.OPER_NO,
                 A.BEGTIME       = V_INFO.BEGTIME,
                 A.ENDTIME       = V_INFO.ENDTIME,
                 A.BRANCH        = V_INFO.BRANCH,
                 A.ETL_TIME      = V_INFO.ETL_TIME,
                 A.SRC_SYS       = V_INFO.SRC_SYS,
                 A.UPDATE_DATE   = SYSDATE

           WHERE A.PLC_PRM_TRANS_ACCT_ID = V_PLC_PRM_TRANS_ACCT_ID;

          V_UPDATE_ROWS := V_UPDATE_ROWS + 1;
        EXCEPTION
          WHEN OTHERS THEN
            -- 遇到异常做一些处理
            BEGIN
              V_ERROR_ROWS := V_ERROR_ROWS + 1;
              P_XQ_LOG_IN_ERR('IDS',
                              'P_XQ_PLC_PRM_TRANS_ACCT_IN',
                              'PLC_PRM_TRANS_ACCT_ID=' ||
                              V_PLC_PRM_TRANS_ACCT_ID || ' POLICY_NO=' ||
                              V_INFO.POLICY_NO || ' ACCOUNT_USAGE=' ||
                              V_INFO.ACCOUNT_USAGE,
                              '更新表XQ_PLC_PRM_TRANS_ACCT数据' || SQLERRM); --写日志
            END;
        END;
      END IF;
    ELSE
      --INSERT XQ_PLC_PRM_TRANS_ACCT
      BEGIN
        INSERT INTO XQ_PLC_PRM_TRANS_ACCT
          (PLC_PRM_TRANS_ACCT_ID,
           SNO,
           POLICY_NO,
           ACCOUNT_USAGE,
           ACCOUNT_NO,
           BANK_CODE,
           BANK_NAME,
           OWNER_ID,
           CURRENCY,
           OPEN_DATE,
           OPER_DATE,
           OPER_NO,
           BEGTIME,
           ENDTIME,
           BRANCH,
           ETL_TIME,
           SRC_SYS,
           CREATE_DATE)
        VALUES
          (SEQ_XQ_PLC_PRM_TRANS_ACCT.NEXTVAL,
           V_INFO.SNO,
           V_INFO.POLICY_NO,
           V_INFO.ACCOUNT_USAGE,
           V_INFO.ACCOUNT_NO,
           V_INFO.BANK_CODE,
           V_INFO.BANK_NAME,
           V_INFO.OWNER_ID,
           V_INFO.CURRENCY,
           V_INFO.OPEN_DATE,
           V_INFO.OPER_DATE,
           V_INFO.OPER_NO,
           V_INFO.BEGTIME,
           V_INFO.ENDTIME,
           V_INFO.BRANCH,
           V_INFO.ETL_TIME,
           V_INFO.SRC_SYS,
           SYSDATE);

        V_INSERT_ROWS := V_INSERT_ROWS + 1;

      EXCEPTION
        WHEN OTHERS THEN
          -- 遇到异常做一些处理
          BEGIN
            V_ERROR_ROWS := V_ERROR_ROWS + 1;
            P_XQ_LOG_IN_ERR('IDS',
                            'P_XQ_PLC_PRM_TRANS_ACCT_IN',
                            ' POLICYNO=:' || V_INFO.POLICY_NO ||
                            ' ACCOUNT_USAGE=:' || V_INFO.ACCOUNT_USAGE,
                            '插入表XQ_PLC_PRM_TRANS_ACCT数据' || SQLERRM); --写日志
          END;
      END;
    END IF;
    COMMIT;
  END LOOP;
  CLOSE CUR_INFO;

  --添加数据库成功日志
  P_XQ_LOG_SUC('IDS',
               'P_XQ_PLC_PRM_TRANS_ACCT_IN',
               V_INSERT_ROWS,
               V_ERROR_ROWS,
               V_UPDATE_ROWS,
               '数据丢失0条',
               SQLERRM);

EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      IF CUR_INFO%ISOPEN THEN
        CLOSE CUR_INFO;
      END IF;
      --添加数据库失败日志
      P_XQ_LOG_ERR('IDS',
                   'P_XQ_PLC_PRM_TRANS_ACCT_IN',
                   V_INSERT_ROWS,
                   V_ERROR_ROWS,
                   V_UPDATE_ROWS,
                   '数据丢失0条',
                   SQLERRM);
    END;
END P_XQ_PLC_PRM_TRANS_ACCT_IN;
/

prompt
prompt Creating procedure P_XQ_PREREC_DELETE_LOOPBYDATE
prompt ================================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_PREREC_DELETE_LOOPBYDATE IS
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_PREREC_DELETE_LOOPBYDATE
  *  建立日期   ：2012-05-15
  *  作者       ：yangguoqi
  *  模块       ：IDS
  *  描述       ：根据每天日期来循环删除财务实收信息XQ_PREREC重复记录
  *----------------------------------------------------
  *  修改历史   日期    修改人    修改原因
  *  序号
  *   1
  ******************************************************
  */
  MINDATE DATE; --最小日期
  MAXDATE DATE; --最大日期
BEGIN
  SELECT MIN(TEM.ETL_TIME), MAX(TEM.ETL_TIME)
    INTO MINDATE, MAXDATE
    FROM PREREC TEM;
  MINDATE := TO_DATE(TO_CHAR(MINDATE, 'YYYY-MM-DD'), 'YYYY-MM-DD');
  MAXDATE := TO_DATE(TO_CHAR(sysdate+1, 'YYYY-MM-DD'), 'YYYY-MM-DD');
  --如果有当日重复的脏数据，就删除
  LOOP
    EXIT WHEN MINDATE > MAXDATE or MINDATE is null;
    DELETE XQ_PREREC
     WHERE XQ_PREREC.ETL_TIME >= MINDATE
       AND XQ_PREREC.ETL_TIME < (MINDATE + 1)
       AND XQ_PREREC.SNO NOT IN
           (SELECT MAX(R.SNO)
              FROM XQ_PREREC R
             WHERE R.ETL_TIME >= MINDATE
               AND R.ETL_TIME < (MINDATE + 1)
             GROUP BY R.TYPEID,
                      R.CON_ID,
                      R.POLICYNO,
                      R.CLASSCODE,
                      R.AMOUNT,
                      R.STDRATE,
                      R.UNSTDRATE,
                      R.YEARNUM,
                      R.PAYCODE,
                      R.SETCODE,
                      R.PCODE,
                      R.PAYDATE,
                      R.YEARS,
                      R.COVER1,
                      R.COVER2,
                      R.SOURCE_PAYIN_ACTVTY_ID,
                      R.ETL_TIME,
                      R.PAYCODE_IDS,
                      R.SETCODE_IDS,
                      R.BEGTIME,
                      R.ENDTIME,
                      R.SRC_SYS,
                      R.CHECK_ID,
                      R.CHECKNO,
                      R.CURRENCY,
                      R.MOVEWHY,
                      R.OPER_ID,
                      R.OPERNO,
                      R.EMPNO_ID,
                      R.EMPNO,
                      R.CSR_ID,
                      R.CSRNO,
                      R.DEPTNO,
                      R.SECKEY,
                      R.INNER_SETTLE_IND,
                      R.BRANCH,
                      R.SALE_MODE,
                      R.THE_THRDPRT,
                      R.JOB,
                      R.BUSI_BRANCH,
                      R.FIN_PROC_TYPE,
                      R.INSRNC_RATE);
    MINDATE := MINDATE + 1;
    COMMIT;
  END LOOP;
  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      DBMS_OUTPUT.PUT_LINE('====P_XQ_PREREC_DELETE_LOOPBYDATE执行删除财务实收信息XQ_PREREC重复记录时异常========');
      ROLLBACK;
    END;
END P_XQ_PREREC_DELETE_LOOPBYDATE;
/

prompt
prompt Creating procedure P_XQ_PREREC_IN
prompt =================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_PREREC_IN IS
  --插入续收系统 财务实收信息表
  v_app_id  number(18) := 0;
  coun_id   number(18) := 0;
  v_paycode number(10) := 0;
  v_setcode number(10) := 0;

  v_insert_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  CURSOR cur_info IS
    SELECT * FROM prerec;
  v_info cur_info%ROWTYPE;

BEGIN
  select b.nextvalue
    into coun_id
    from c_id_bro b
   where b.name = 'xq_prerec';
  OPEN cur_info;
  LOOP
    FETCH cur_info
      INTO v_info;
    EXIT WHEN cur_info%NOTFOUND;

    select (select c.xq_app_id
              from xq_app c
             where c.policyno = v_info.policyno
               and rownum = 1)
      into v_app_id
      from dual;
    IF v_app_id > 0 THEN
      --insert xq_prerec
      select (select t.id
                from xq_dict t
               where t.parent_id = 7
                 and t.item_code = v_info.paycode
                 and rownum = 1)
        into v_paycode
        from dual;

        if v_paycode is null then
          v_paycode := 750;
        end if;

      select (select t.id
                from xq_dict t
               where t.parent_id = 12
                 and t.item_code = trim(v_info.setcode)
                 and rownum = 1)
        into v_setcode
        from dual;

        if v_setcode is null then
          v_setcode := 1250;
        end if;

      coun_id := coun_id + 1;
      begin
        insert into xq_prerec
          (SNO,
           TYPEID,
           CON_ID,
           POLICYNO,
           CLASSCODE,
           AMOUNT,
           STDRATE,
           UNSTDRATE,
           YEARNUM,
           PAYCODE,
           SETCODE,
           PCODE,
           PAYDATE,
           YEARS,
           COVER1,
           COVER2,
           SOURCE_PAYIN_ACTVTY_ID,
           ETL_TIME,
           PAYCODE_IDS,
           SETCODE_IDS,
           BEGTIME,
           ENDTIME,
           SRC_SYS,
           CHECK_ID,
           CHECKNO,
           CURRENCY,
           MOVEWHY,
           OPER_ID,
           OPERNO,
           EMPNO_ID,
           EMPNO,
           CSR_ID,
           CSRNO,
           DEPTNO,
           SECKEY,
           INNER_SETTLE_IND,
           BRANCH,
           SALE_MODE,
           THE_THRDPRT,
           JOB,
           BUSI_BRANCH,
           FIN_PROC_TYPE,
           INSRNC_RATE)
        values
          (coun_id,
           v_info.TYPEID,
           v_info.CON_ID,
           v_info.POLICYNO,
           v_info.CLASSCODE,
           v_info.AMOUNT,
           v_info.STDRATE,
           v_info.UNSTDRATE,
           v_info.YEARNUM,
           v_paycode,
           v_setcode,
           v_info.PCODE,
           v_info.PAYDATE,
           v_info.YEARS,
           v_info.COVER1,
           v_info.COVER2,
           v_info.SOURCE_PAYIN_ACTVTY_ID,
           v_info.ETL_TIME,
           v_info.PAYCODE,
           v_info.SETCODE,
           v_info.BEGTIME,
           v_info.ENDTIME,
           v_info.SRC_SYS,
           v_info.CHECK_ID,
           v_info.CHECKNO,
           v_info.CURRENCY,
           v_info.MOVEWHY,
           v_info.OPER_ID,
           v_info.OPERNO,
           v_info.EMPNO_ID,
           v_info.EMPNO,
           v_info.CSR_ID,
           v_info.CSRNO,
           v_info.DEPTNO,
           v_info.SECKEY,
           v_info.INNER_SETTLE_IND,
           v_info.BRANCH,
           v_info.SALE_MODE,
           v_info.THE_THRDPRT,
           v_info.JOB,
           v_info.BUSI_BRANCH,
           v_info.FIN_PROC_TYPE,
           v_info.INSRNC_RATE);

           v_insert_rows :=v_insert_rows+1;
      exception
        when others then
          -- 遇到异常做一些处理
          begin
            p_xq_log_in_err('IDS','P_XQ_PREREC_IN',
                  'policyno:'||v_info.POLICYNO||' classcode:'||v_info.classcode,
                  '插入表xq_prerec数据'||sqlerrm);--写日志
            v_error_rows :=v_error_rows+1;
          end;
      end;
    END IF;
    COMMIT;
  END LOOP;
  CLOSE cur_info;
  update c_id_bro b set b.nextvalue = coun_id where b.name = 'xq_prerec';
  commit;
  --添加数据库成功日志
  p_xq_log_suc('IDS',
              'P_XQ_PREREC_IN',
              v_insert_rows,
              v_error_rows,
              0,
              '数据丢失0条',
              sqlerrm);

EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;

      if cur_info%isopen then
        CLOSE cur_info;
      end if;
      rollback;
      update c_id_bro t set t.nextvalue = coun_id where t.name = 'xq_prerec';
      commit;
      dbms_output.put_line('P_XQ_PREREC_IN ERROR'||sqlerrm);
      --添加数据库失败日志
      p_xq_log_err('IDS',
              'P_XQ_PREREC_IN',
              v_insert_rows,
              v_error_rows,
              0,
              '数据丢失0条',
              sqlerrm);
    end;
END P_XQ_PREREC_IN;
/

prompt
prompt Creating procedure P_XQ_REALPAYRC_IN
prompt ====================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_REALPAYRC_IN IS
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_REALPAYRC_IN
  *  建立日期   ：2012-08-21
  *  作者       ：QINYUNLONG
  *  模块       ：IDS
  *  描述       ：批量处理REALPAYRC
  */
  V_UPDATE_ROWS NUMBER(18) := 0;
  V_INSERT_ROWS NUMBER(18) := 0;
  V_ERROR_ROWS  NUMBER(18) := 0;

  TIME_BEFORE BINARY_INTEGER := DBMS_UTILITY.GET_TIME; --过程开始时间(毫秒)
  TIME_AFTER  BINARY_INTEGER; --过程结束时间(毫秒)

  V_MINTSTAMP TIMESTAMP; --最小日期TIMESTAMP
  V_MAXTSTAMP TIMESTAMP; --最大日期TIMESTAMP
  V_MINDATE   DATE; --最小日期
  V_MAXDATE   DATE; --最大日期

  CURSOR CUR_INFO(STARTDATE DATE, ENDDATE DATE) IS
    SELECT *
      FROM REALPAYRC R
     WHERE R.ETL_TIME >= STARTDATE
       AND R.ETL_TIME < ENDDATE
       AND EXISTS
     (SELECT 1
              FROM XQ_RISKCON B
             WHERE R.POLICYNO = B.POLICYNO
               AND B.CLASSCODE IN (SELECT P.CLASSCODE
                                     FROM XQ_RISKCLASS P
                                    WHERE P.TIMESTR = '1'));

  V_INFO CUR_INFO%ROWTYPE;

BEGIN
  --查询临时表最大和最小日期
  SELECT MIN(TEM.ETL_TIME), MAX(TEM.ETL_TIME)
    INTO V_MINTSTAMP, V_MAXTSTAMP
    FROM REALPAYRC TEM;
  V_MINDATE := TO_DATE(TO_CHAR(V_MINTSTAMP, 'YYYY-MM-DD'), 'YYYY-MM-DD');
  V_MAXDATE := TO_DATE(TO_CHAR(V_MAXTSTAMP, 'YYYY-MM-DD'), 'YYYY-MM-DD');

  LOOP
    EXIT WHEN V_MINDATE > V_MAXDATE OR V_MINDATE IS NULL;

    OPEN CUR_INFO(V_MINDATE, V_MINDATE + 1);
    LOOP
      FETCH CUR_INFO
        INTO V_INFO;
      EXIT WHEN CUR_INFO%NOTFOUND;

      BEGIN
        INSERT INTO XQ_REALPAYRC
          (ID,
           SNO,
           TYPEID,
           CON_ID,
           POLICYNO,
           CLASSCODE,
           CHECK_ID,
           CHECKNO,
           AMOUNT,
           CURRENCY,
           GENDATE,
           DELFRM,
           SETCODE,
           MOVEWHY,
           DELCODE,
           TYPENO,
           REGDATE,
           AGENT_ID,
           AGENTNO,
           OPER_ID,
           OPERNO,
           DEPTNO,
           DOCPRO,
           DOCNO,
           PERSON_ID,
           PID,
           IDTYPE,
           PAYTIME,
           SECKEY,
           SOURCE_PAYOUT_ACTVTY_ID,
           BEGTIME,
           ENDTIME,
           BRANCH,
           ETL_TIME,
           SRC_SYS,
           SALE_MODE,
           THE_THRDPRT,
           EMPNO,
           CSRNO,
           JOB,
           BUSI_BRANCH,
           FIN_PROC_TYPE,
           INSRNC_RATE,
           CREATE_DATE)
        VALUES
          (SEQ_XQ_REALPAYRC.NEXTVAL,
           V_INFO.SNO,
           V_INFO.TYPEID,
           V_INFO.CON_ID,
           V_INFO.POLICYNO,
           V_INFO.CLASSCODE,
           V_INFO.CHECK_ID,
           V_INFO.CHECKNO,
           V_INFO.AMOUNT,
           V_INFO.CURRENCY,
           V_INFO.GENDATE,
           V_INFO.DELFRM,
           V_INFO.SETCODE,
           V_INFO.MOVEWHY,
           V_INFO.DELCODE,
           V_INFO.TYPENO,
           V_INFO.REGDATE,
           V_INFO.AGENT_ID,
           V_INFO.AGENTNO,
           V_INFO.OPER_ID,
           V_INFO.OPERNO,
           V_INFO.DEPTNO,
           V_INFO.DOCPRO,
           V_INFO.DOCNO,
           V_INFO.PERSON_ID,
           V_INFO.PID,
           V_INFO.IDTYPE,
           V_INFO.PAYTIME,
           V_INFO.SECKEY,
           V_INFO.SOURCE_PAYOUT_ACTVTY_ID,
           V_INFO.BEGTIME,
           V_INFO.ENDTIME,
           V_INFO.BRANCH,
           V_INFO.ETL_TIME,
           V_INFO.SRC_SYS,
           V_INFO.SALE_MODE,
           V_INFO.THE_THRDPRT,
           V_INFO.EMPNO,
           V_INFO.CSRNO,
           V_INFO.JOB,
           V_INFO.BUSI_BRANCH,
           V_INFO.FIN_PROC_TYPE,
           V_INFO.INSRNC_RATE,
           SYSDATE);

        V_INSERT_ROWS := V_INSERT_ROWS + 1;
      EXCEPTION
        WHEN OTHERS THEN
          BEGIN
            P_XQ_LOG_IN_ERR('IDS',
                            'P_XQ_REALPAYRC_IN',
                            'POLICYNO=' || V_INFO.POLICYNO ||
                            '   CLASSCODE=' || V_INFO.CLASSCODE,
                            '插入表XQ_REALPAYRC数据' || SQLERRM); --写日志
            V_ERROR_ROWS := V_ERROR_ROWS + 1;
          END;
      END;
    END LOOP;

    COMMIT;

    CLOSE CUR_INFO;

    --删除当日重复的脏数据
    DELETE XQ_REALPAYRC
     WHERE XQ_REALPAYRC.ETL_TIME >= V_MINDATE
       AND XQ_REALPAYRC.ETL_TIME < (V_MINDATE + 1)
       AND XQ_REALPAYRC.ID NOT IN
           (SELECT MAX(R.ID)
              FROM XQ_REALPAYRC R
             WHERE R.ETL_TIME >= V_MINDATE
               AND R.ETL_TIME < (V_MINDATE + 1)
             GROUP BY R.SNO,
                      R.TYPEID,
                      R.CON_ID,
                      R.POLICYNO,
                      R.CLASSCODE,
                      R.CHECK_ID,
                      R.CHECKNO,
                      R.AMOUNT,
                      R.CURRENCY,
                      R.GENDATE,
                      R.DELFRM,
                      R.SETCODE,
                      R.MOVEWHY,
                      R.DELCODE,
                      R.TYPENO,
                      R.REGDATE,
                      R.AGENT_ID,
                      R.AGENTNO,
                      R.OPER_ID,
                      R.OPERNO,
                      R.DEPTNO,
                      R.DOCPRO,
                      R.DOCNO,
                      R.PERSON_ID,
                      R.PID,
                      R.IDTYPE,
                      R.PAYTIME,
                      R.SECKEY,
                      R.SOURCE_PAYOUT_ACTVTY_ID,
                      R.BEGTIME,
                      R.ENDTIME,
                      R.BRANCH,
                      R.ETL_TIME,
                      R.SRC_SYS,
                      R.SALE_MODE,
                      R.THE_THRDPRT,
                      R.EMPNO,
                      R.CSRNO,
                      R.JOB,
                      R.BUSI_BRANCH,
                      R.FIN_PROC_TYPE,
                      R.INSRNC_RATE);
    COMMIT;

    V_MINDATE := V_MINDATE + 1;

  END LOOP;

  COMMIT;

  --9999表示IDS技术删除,小于0数据处理成红冲
  UPDATE XQ_REALPAYRC R SET R.AMOUNT = 0 WHERE R.TYPEID <'0';
  COMMIT;

  /*DELETE FROM XQ_REALPAYRC R WHERE R.TYPEID ='9999';
  COMMIT;*/

  DBMS_OUTPUT.PUT_LINE('P_XQ_REALPAYRC_IN中数据更新 ' || V_UPDATE_ROWS ||
                       '行，数据插入 ' || V_INSERT_ROWS || '行,失败' ||
                       V_ERROR_ROWS || '行');

  --添加数据库成功日志
  TIME_AFTER := DBMS_UTILITY.GET_TIME;
  P_XQ_LOG_SUC('IDS',
               'P_XQ_REALPAYRC_IN',
               V_INSERT_ROWS,
               V_ERROR_ROWS,
               V_UPDATE_ROWS,
               '执行过程持续时间:' || (TIME_AFTER - TIME_BEFORE) / 100 || '秒',
               SQLERRM);

EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      IF CUR_INFO%ISOPEN THEN
        CLOSE CUR_INFO;
      END IF;
      --添加数据库失败日志
      TIME_AFTER := DBMS_UTILITY.GET_TIME;
      P_XQ_LOG_ERR('IDS',
                   'P_XQ_REALPAYRC_IN',
                   V_INSERT_ROWS,
                   V_ERROR_ROWS,
                   V_UPDATE_ROWS,
                   '执行过程持续时间:' || (TIME_AFTER - TIME_BEFORE) / 100 || '秒',
                   SQLERRM);
    END;
END P_XQ_REALPAYRC_IN;
/

prompt
prompt Creating procedure P_XQ_REMINDER_DATE_CORRECT
prompt =============================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_REMINDER_DATE_CORRECT IS

  -- 对应缴件进行分组，找出重复数据且IDS状态最大的数据。
  cursor cur_reminder1 is
    select *
      from (select r.status as status,
                   r.policyno,
                   r.cover1,
                   r.status_ids_var,
                   r.reminder_id,
                   r.use_ali_id,
                   max(r.use_ali_id) over(partition by r.policyno, r.cover1) as old_use_ali_id,
                   row_number() over(partition by r.policyno, r.cover1 order by r.status_ids_var desc, reminder_id asc) as rownun,
                   count(1) over(partition by r.policyno, r.cover1) as count1
              from (select *
                      from xq_reminder r
                     where r.status < 407
                        or r.status is null) r)
     where (count1 > 1 and rownun = 1)
        or (count1 = 1 and status is null);
  v_reminder1 cur_reminder1%rowtype;

  v_status_ids_var varchar2(10) := '0';

begin
  open cur_reminder1;
  loop
    fetch cur_reminder1
      into v_reminder1;
    exit when cur_reminder1%notfound;

    -- IDS状态 到 续收状态的 转变
    if v_reminder1.status is null and
       v_reminder1.status_ids_var is not null then
      v_status_ids_var := trim(v_reminder1.status_ids_var);
      if v_status_ids_var = '0' or v_status_ids_var = '1' or
         v_status_ids_var = '2' then
        update xq_reminder r
           set r.status = 401
         where r.reminder_id = v_reminder1.reminder_id;
      elsif trim(v_reminder1.status_ids_var) = '3' then
        update xq_reminder r
           set r.status = 404
         where r.reminder_id = v_reminder1.reminder_id;
      end if;
    end if;
    --commit;
    --将同一责任起期的其他数据，状态更新为408
    update xq_reminder r
       set r.status = 408
     where r.policyno = v_reminder1.policyno
       and r.cover1 = v_reminder1.cover1
       and r.reminder_id <> v_reminder1.reminder_id
       and (r.status < 407 or r.status is null);

    --分配座度
    if v_reminder1.use_ali_id is null and
       v_reminder1.old_use_ali_id is not null then
      update xq_reminder r
         set r.use_ali_id = v_reminder1.old_use_ali_id
       where r.reminder_id = v_reminder1.reminder_id;
    end if;
    commit;
  end loop;
  close cur_reminder1;

  update xq_reminder r
     set r.status = 402
   where r.status = 401
     and r.use_ali_id is not null;
  commit;

EXCEPTION
  WHEN OTHERS THEN
    begin
      dbms_output.put_line(sqlerrm || sqlcode);
    end;

END P_XQ_REMINDER_DATE_CORRECT;
/

prompt
prompt Creating procedure P_XQ_REMINDER_RENOVATE_AMOUNT
prompt ================================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_Reminder_Renovate_Amount IS

  v_amount      NUMBER(20,4) :=0;
  v_classcode   CHAR(8);
   i            integer := 0;

  cursor cur_reminder is

     select  x.policyno, x.cover1, max(x.amount) as amount from xq_reminder x where x.status not in ('408', '407') group by x.policyno, x.cover1;

     reminder_cursor cur_reminder%rowtype;

begin

  open cur_reminder;
  loop
    fetch cur_reminder
      into reminder_cursor;
    exit when cur_reminder%notfound;

     begin

      for s in (select max(c.amount) as amount , max(c.stdrate) as stdrate , max(c.unstdrate) as unstdrate , c.classcode
            from xq_sprerec c
           where c.policyno = reminder_cursor.policyno
             and c.cover1 = reminder_cursor.cover1 group by c.policyno, c.cover1, c.classcode)
      loop
         if  v_classcode is not null and s.classcode <> v_classcode  then
           v_amount := (s.amount + s.stdrate + s.unstdrate) + v_amount;
           i := 1;
         end if;
         if  v_classcode is  null then
           v_amount := (s.amount + s.stdrate + s.unstdrate) + v_amount;
         end if;
         v_classcode := s.classcode;
      end loop;

      IF i = 1 THEN
        IF v_amount > 0 THEN
          if v_amount <> reminder_cursor.amount THEN
            update xq_reminder r set r.amount = v_amount where r.policyno = reminder_cursor.policyno and r.cover1 = reminder_cursor.cover1 and r.status not in ('408', '407');
            commit;
          end if;
        end if;
      end if;

      v_amount := 0;
      v_classcode := null;
      i := 0;

    exception
      when others then
        -- 遇到异常做一些处理
        begin
          dbms_output.put_line('ERROR');
        end;
    end;
  end loop;
  close cur_reminder;

end P_XQ_Reminder_Renovate_Amount;
/

prompt
prompt Creating procedure P_XQ_REMINDER_REPORT
prompt =======================================
prompt
create or replace procedure unicall.p_xq_reminder_report(i_cur_Date    in varchar2,
                                                 i_report_type in varchar2,
                                                 i_paycode     in varchar2,
                                                 o_flag        out integer) is
  v_count_size integer := 0;
  v_cur_date   date := to_date(i_cur_Date, 'yyyy-mm-dd');
  v_other      varchar2(10) := '其他';
  v_total      varchar2(10) := '总计';
  v_offset     integer;
  v_paycode    varchar2(200);
begin

  select count(1)
    into v_count_size
    from xq_reminder_report rp
   where rp.cur_date = v_cur_date
     and rp.report_type = i_report_type
     and rp.paycode = i_paycode;
  if v_count_size > 0 then
    delete from xq_reminder_report rp
     where rp.cur_date = v_cur_date
       and rp.report_type = i_report_type
       and rp.paycode = i_paycode;
    commit;
  end if;

  if i_report_type = '00' then
    v_offset := 0;
  elsif i_report_type = '01' then
    v_offset := -1;
  elsif i_report_type = '02' then
    v_offset := -2;
  end if;

  if i_paycode = '00' then
    v_paycode := 702;
  elsif i_paycode = '01' then
    v_paycode := 703;
  elsif i_paycode = '02' then
    v_paycode := 705;
  end if;

  -- 插入所有续收坐席的统计结果
  for a in (select cu.use_ali_id   use_ali_id,
                   cu.use_nam      use_nam,
                   cu.cat_nam      grpname,
                   cu.gro_id       grpid,
                   four.st         fst,
                   four.rt         frt,
                   four.rate       frate,
                   seven.st        sst,
                   seven.rt        srt,
                   seven.rate      srate,
                   thirteen.st     tst,
                   thirteen.rt     trt,
                   thirteen.rate   trate,
                   total.st        ttst,
                   total.rt        ttrt,
                   total.rate      ttrate,
                   twentyfive.st   tfst,
                   twentyfive.rt   tfrt,
                   twentyfive.rate tfrate
              from (select cu.use_nam, cu.use_ali_id, cc.cat_nam, cg.gro_id -- 坐席信息
                      from c_use cu,
                           (select * from c_use_gro where gro_id <> 9005) cg,
                           c_cat cc
                     where cu.use_id = cg.use_id(+)
                       and cg.gro_id = cc.cat_id(+)
                       and cu.use_flag = '1') cu,
                   (select nvl(s.samount, 0) st, -- 4 个月
                           nvl(r.ramount, 0) rt,
                           decode(s.samount,
                                  0,
                                  null,
                                  null,
                                  null,
                                  to_char(round(nvl(r.ramount, 0) / s.samount,
                                                4) * 100,
                                          'FM990.0099') || '%') rate,
                           s.use_ali_id
                      from (select sum(amount) samount, use_ali_id ---- 4 个月应收select sum(s.initial_amount) amount from xq_riskcon s where s.policyno=xtp.policyno
                              from (select xtp.amount amount, use_ali_id
                                      from (select amount, use_ali_id, policyno
                                              from (select rs.amount,
                                                           rs.policyno,
                                                           xr.use_ali_id
                                                      from (select sum(rs.initial_amount) amount,
                                                                   rs.policyno
                                                              from xq_riskcon rs
                                                             where rs.polist_ids <> '9'
                                                               and rs.classcode in
                                                                   (select cs.classcode
                                                                      from xq_riskclass cs
                                                                     where cs.timestr = '1')
                                                               and to_char(rs.begdate-1,
                                                                           'yyyy-mm') =
                                                                   to_char(add_months(v_cur_date,
                                                                                      (-3 +
                                                                                      v_offset)),
                                                                           'yyyy-mm')
                                                             group by rs.policyno) rs,
                                                           XQ_REMINDER xr
                                                     WHERE rs.policyno =
                                                           xr.policyno
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where rs.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time -1<
                                                                   trunc(xr.task_date,
                                                                         'MONTH'))
                                                       and xr.status in
                                                           (402,
                                                            403,
                                                            404,
                                                            406)
                                                       and trim(xr.pcode) in
                                                           ('1',
                                                            '2',
                                                            '4',
                                                            '5',
                                                            '6')
                                                       and exists
                                                     (select 1
                                                              from xq_moneysch my
                                                             where xr.policyno =
                                                                   my.policyno
                                                               and my.initial_paysch = '10')
                                                       and (xr.use_ali_id is not null)
                                                       and (xr.is_delete is null)
                                                       and to_char(xr.cover1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (0 +
                                                                              v_offset)),
                                                                   'yyyy-mm'))) xtp)
                             group by use_ali_id) s,
                           (select sum(amount) ramount, use_ali_id -- 4 个月实收
                              from (select xtp.amount amount, use_ali_id
                                      from (select amount, use_ali_id, policyno
                                              from (select rs.amount,
                                                           rs.policyno,
                                                           xr.use_ali_id
                                                      from (select sum(rs.initial_amount) amount,
                                                                   rs.policyno
                                                              from xq_riskcon rs
                                                             where rs.polist_ids <> '9'
                                                               and rs.classcode in
                                                                   (select cs.classcode
                                                                      from xq_riskclass cs
                                                                     where cs.timestr = '1')
                                                               and to_char(rs.begdate-1,
                                                                           'yyyy-mm') =
                                                                   to_char(add_months(v_cur_date,
                                                                                      (-3 +
                                                                                      v_offset)),
                                                                           'yyyy-mm')
                                                             group by rs.policyno) rs,
                                                           XQ_REMINDER xr
                                                     WHERE rs.policyno =
                                                           xr.policyno
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where rs.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time -1<
                                                                   trunc(xr.task_date,
                                                                         'MONTH'))
                                                       and xr.status = 404
                                                       and trim(xr.pcode) in
                                                           ('1',
                                                            '2',
                                                            '4',
                                                            '5',
                                                            '6')
                                                       and exists
                                                     (select 1
                                                              from xq_moneysch my
                                                             where xr.policyno =
                                                                   my.policyno
                                                               and my.initial_paysch = '10')
                                                       and (xr.use_ali_id is not null)
                                                       and (xr.is_delete is null)
                                                       and to_char(xr.cover1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (0 +
                                                                              v_offset)),
                                                                   'yyyy-mm'))) xtp)
                             group by use_ali_id) r
                     where s.use_ali_id = r.use_ali_id(+)) four,
                   (select nvl(s.samount, 0) st, -- 7 个月
                           nvl(r.ramount, 0) rt,
                           decode(s.samount,
                                  0,
                                  null,
                                  null,
                                  null,
                                  to_char(round(nvl(r.ramount, 0) / s.samount,
                                                4) * 100,
                                          'FM990.0099') || '%') rate,
                           s.use_ali_id
                      from (select sum(amount) samount, use_ali_id -- 7 个月应收
                              from (select xtp.amount amount, use_ali_id
                                      from (select amount, use_ali_id, policyno
                                              from (select rs.amount,
                                                           rs.policyno,
                                                           xr.use_ali_id
                                                      from (select sum(rs.initial_amount) amount,
                                                                   rs.policyno
                                                              from xq_riskcon rs
                                                             where rs.polist_ids <> '9'
                                                               and rs.classcode in
                                                                   (select cs.classcode
                                                                      from xq_riskclass cs
                                                                     where cs.timestr = '1')
                                                               and to_char(rs.begdate-1,
                                                                           'yyyy-mm') =
                                                                   to_char(add_months(v_cur_date,
                                                                                      (-6 +
                                                                                      v_offset)),
                                                                           'yyyy-mm')
                                                             group by rs.policyno) rs,
                                                           XQ_REMINDER xr
                                                     WHERE rs.policyno =
                                                           xr.policyno
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where rs.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH'))
                                                       and xr.status in
                                                           (402,
                                                            403,
                                                            404,
                                                            406)
                                                       and trim(xr.pcode) in
                                                           ('1',
                                                            '2',
                                                            '4',
                                                            '5',
                                                            '6')
                                                       and exists
                                                     (select 1
                                                              from xq_moneysch my
                                                             where xr.policyno =
                                                                   my.policyno
                                                               and my.initial_paysch = '10')
                                                       and (xr.use_ali_id is not null)
                                                       and (xr.is_delete is null)
                                                       and to_char(xr.cover1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (0 +
                                                                              v_offset)),
                                                                   'yyyy-mm'))) xtp)
                             group by use_ali_id) s,
                           (select sum(amount) ramount, use_ali_id -- 7 个月实收
                              from (select xtp.amount amount, use_ali_id
                                      from (select amount, use_ali_id, policyno
                                              from (select rs.amount,
                                                           rs.policyno,
                                                           xr.use_ali_id
                                                      from (select sum(rs.initial_amount) amount,
                                                                   rs.policyno
                                                              from xq_riskcon rs
                                                             where rs.polist_ids <> '9'
                                                               and rs.classcode in
                                                                   (select cs.classcode
                                                                      from xq_riskclass cs
                                                                     where cs.timestr = '1')
                                                               and to_char(rs.begdate-1,
                                                                           'yyyy-mm') =
                                                                   to_char(add_months(v_cur_date,
                                                                                      (-6 +
                                                                                      v_offset)),
                                                                           'yyyy-mm')
                                                             group by rs.policyno) rs,
                                                           XQ_REMINDER xr
                                                     WHERE rs.policyno =
                                                           xr.policyno
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where rs.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH'))
                                                       and xr.status = 404
                                                       and trim(xr.pcode) in
                                                           ('1',
                                                            '2',
                                                            '4',
                                                            '5',
                                                            '6')
                                                       and exists
                                                     (select 1
                                                              from xq_moneysch my
                                                             where xr.policyno =
                                                                   my.policyno
                                                               and my.initial_paysch = '10')
                                                       and (xr.use_ali_id is not null)
                                                       and (xr.is_delete is null)
                                                       and to_char(xr.cover1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (0 +
                                                                              v_offset)),
                                                                   'yyyy-mm'))) xtp)
                             group by use_ali_id) r
                     where s.use_ali_id = r.use_ali_id(+)) seven,
                   (select nvl(s.samount, 0) st, -- 13 个月
                           nvl(r.ramount, 0) rt,
                           decode(s.samount,
                                  0,
                                  null,
                                  null,
                                  null,
                                  to_char(round(nvl(r.ramount, 0) / s.samount,
                                                4) * 100,
                                          'FM990.0099') || '%') rate,
                           s.use_ali_id
                      from (select sum(amount) samount, use_ali_id -- 13 个月应收
                              from (select amount, use_ali_id
                                      from (select xr.amount,
                                                   xr.use_ali_id,
                                                   row_number() over(partition by xr.policyno, xr.cover1 order by xr.cover1 asc) rn
                                              from xq_reminder xr
                                             where exists
                                             (select 1
                                                      from xq_riskcon c
                                                     where c.policyno =
                                                           xr.policyno
                                                       and c.appf = '1'
                                                       and c.polist_ids <> '9'
                                                       and c.classcode in
                                                           (select cs.classcode
                                                              from xq_riskclass cs
                                                             where cs.timestr = '1')
                                                       and to_char(c.begdate-1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (-12 +
                                                                              v_offset)),
                                                                   'yyyy-mm')
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where c.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH')))
                                               and xr.status in
                                                   (402, 403, 404,406)
                                               and xr.paycode in (v_paycode)
                                               and trim(xr.pcode) in
                                                   ('1', '2', '4', '5', '6')
                                               and (xr.use_ali_id is not null)
                                               and (xr.is_delete is null)
                                               and to_char(xr.cover1, 'yyyy-mm') =
                                                   to_char(add_months(v_cur_date,
                                                                      (0 +
                                                                      v_offset)),
                                                           'yyyy-mm'))
                                     where rn = 1)
                             group by use_ali_id) s,
                           (select sum(amount) ramount, use_ali_id -- 13 个月实收
                              from (select amount, use_ali_id
                                      from (select xr.amount,
                                                   xr.use_ali_id,
                                                   row_number() over(partition by xr.policyno, xr.cover1 order by xr.cover1 asc) rn
                                              from xq_reminder xr
                                             where exists
                                             (select 1
                                                      from xq_riskcon c
                                                     where c.policyno =
                                                           xr.policyno
                                                       and c.appf = '1'
                                                       and c.polist_ids <> '9'
                                                       and c.classcode in
                                                           (select cs.classcode
                                                              from xq_riskclass cs
                                                             where cs.timestr = '1')
                                                       and to_char(c.begdate-1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (-12 +
                                                                              v_offset)),
                                                                   'yyyy-mm')
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where c.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH')))

                                               and xr.status = 404
                                               and xr.paycode in (v_paycode)
                                               and trim(xr.pcode) in
                                                   ('1', '2', '4', '5', '6')
                                               and (xr.use_ali_id is not null)
                                               and (xr.is_delete is null)
                                               and to_char(xr.cover1, 'yyyy-mm') =
                                                   to_char(add_months(v_cur_date,
                                                                      (0 +
                                                                      v_offset)),
                                                           'yyyy-mm'))
                                     where rn = 1)
                             group by use_ali_id) r
                     where s.use_ali_id = r.use_ali_id(+)) thirteen,
                   (select nvl(s.samount, 0) st, -- 25 个月
                           nvl(r.ramount, 0) rt,
                           decode(s.samount,
                                  0,
                                  null,
                                  null,
                                  null,
                                  to_char(round(nvl(r.ramount, 0) / s.samount,
                                                4) * 100,
                                          'FM990.0099') || '%') rate,
                           s.use_ali_id
                      from (select sum(amount) samount, use_ali_id -- 25 个月应收
                              from (select amount, use_ali_id
                                      from (select xr.amount,
                                                   xr.use_ali_id,
                                                   row_number() over(partition by xr.policyno, xr.cover1 order by xr.cover1 asc) rn
                                              from xq_reminder xr
                                             where exists
                                             (select 1
                                                      from xq_riskcon c
                                                     where c.policyno =
                                                           xr.policyno
                                                       and c.appf = '1'
                                                       and c.polist_ids <> '9'
                                                       and c.classcode in
                                                           (select cs.classcode
                                                              from xq_riskclass cs
                                                             where cs.timestr = '1')
                                                       and to_char(c.begdate-1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (-24 +
                                                                              v_offset)),
                                                                   'yyyy-mm')
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where c.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH')))
                                               and xr.status in
                                                   (402, 403,404,406)
                                               and xr.paycode in (v_paycode)
                                               and trim(xr.pcode) in
                                                   ('1', '2', '4', '5', '6')
                                               and (xr.use_ali_id is not null)
                                               and (xr.is_delete is null)
                                               and to_char(xr.cover1, 'yyyy-mm') =
                                                   to_char(add_months(v_cur_date,
                                                                      (0 +
                                                                      v_offset)),
                                                           'yyyy-mm'))
                                     where rn = 1)
                             group by use_ali_id) s,
                           (select sum(amount) ramount, use_ali_id -- 25 个月实收
                              from (select amount, use_ali_id
                                      from (select xr.amount,
                                                   xr.use_ali_id,
                                                   row_number() over(partition by xr.policyno, xr.cover1 order by xr.cover1 asc) rn
                                              from xq_reminder xr
                                             where exists
                                             (select 1
                                                      from xq_riskcon c
                                                     where c.policyno =
                                                           xr.policyno
                                                       and c.appf = '1'
                                                       and c.polist_ids <> '9'
                                                       and c.classcode in
                                                           (select cs.classcode
                                                              from xq_riskclass cs
                                                             where cs.timestr = '1')
                                                       and to_char(c.begdate-1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (-24 +
                                                                              v_offset)),
                                                                   'yyyy-mm')
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where c.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time -1<
                                                                   trunc(xr.task_date,
                                                                         'MONTH')))

                                               and xr.status = 404
                                               and xr.paycode in (v_paycode)
                                               and trim(xr.pcode) in
                                                   ('1', '2', '4', '5', '6')
                                               and (xr.use_ali_id is not null)
                                               and (xr.is_delete is null)
                                               and to_char(xr.cover1, 'yyyy-mm') =
                                                   to_char(add_months(v_cur_date,
                                                                      (0 +
                                                                      v_offset)),
                                                           'yyyy-mm'))
                                     where rn = 1)
                             group by use_ali_id) r
                     where s.use_ali_id = r.use_ali_id(+)) twentyfive,
                   (select nvl(s.samount, 0) st, -- 整体
                           nvl(r.ramount, 0) rt,
                           decode(s.samount,
                                  0,
                                  null,
                                  null,
                                  null,
                                  to_char(round(nvl(r.ramount, 0) / s.samount,
                                                4) * 100,
                                          'FM990.0099') || '%') rate,
                           s.use_ali_id
                      from (select sum(amount) samount, use_ali_id -- 整体应收
                              from (select amount, use_ali_id
                                      from (select xr.amount,
                                                   xr.use_ali_id,
                                                   row_number() over(partition by xr.policyno, xr.cover1 order by xr.cover1 asc) rn
                                              from xq_reminder xr
                                             where exists
                                             (select 1
                                                      from xq_riskcon c
                                                     where c.policyno =
                                                           xr.policyno
                                                       and c.appf = '1'
                                                       and c.polist_ids <> '9'
                                                       and c.classcode in
                                                           (select cs.classcode
                                                              from xq_riskclass cs
                                                             where cs.timestr = '1')
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where c.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH')))
                                               and xr.paycode in (v_paycode)
                                               and xr.status in
                                                   (402, 403, 404,406)
                                               and trim(xr.pcode) in
                                                   ('1', '2', '4', '5', '6')
                                               and (xr.use_ali_id is not null)
                                               and (xr.is_delete is null)
                                               and to_char(xr.cover1, 'yyyy-mm') =
                                                   to_char(add_months(v_cur_date,
                                                                      (0 +
                                                                      v_offset)),
                                                           'yyyy-mm'))
                                     where rn = 1)
                             group by use_ali_id) s,
                           (select sum(amount) ramount, use_ali_id -- 整体实收
                              from (select amount, use_ali_id
                                      from (select xr.amount,
                                                   xr.use_ali_id,
                                                   row_number() over(partition by xr.policyno, xr.cover1 order by xr.cover1 asc) rn
                                              from xq_reminder xr
                                             where exists
                                             (select 1
                                                      from xq_riskcon c
                                                     where c.policyno =
                                                           xr.policyno
                                                       and c.appf = '1'
                                                       and c.polist_ids <> '9'
                                                       and c.classcode in
                                                           (select cs.classcode
                                                              from xq_riskclass cs
                                                             where cs.timestr = '1')
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where c.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH')))
                                               and xr.paycode in (v_paycode)
                                               and xr.status = 404
                                               and trim(xr.pcode) in
                                                   ('1', '2', '4', '5', '6')
                                               and (xr.use_ali_id is not null)
                                               and (xr.is_delete is null)
                                               and to_char(xr.cover1, 'yyyy-mm') =
                                                   to_char(add_months(v_cur_date,
                                                                      (0 +
                                                                      v_offset)),
                                                           'yyyy-mm'))
                                     where rn = 1)
                             group by use_ali_id) r
                     where s.use_ali_id = r.use_ali_id(+)) total
             where cu.use_ali_id = four.use_ali_id(+)
               and cu.use_ali_id = seven.use_ali_id(+)
               and cu.use_ali_id = thirteen.use_ali_id(+)
               and cu.use_ali_id = twentyfive.use_ali_id(+)
               and cu.use_ali_id = total.use_ali_id(+)) loop
    insert into xq_reminder_report
      (id,
       cur_date,
       report_type,
       use_ali_id,
       use_nam,
       four_samount,
       four_ramount,
       four_rate,
       seven_samount,
       seven_ramount,
       seven_rate,
       thirteen_samount,
       thirteen_ramount,
       thirteen_rate,
       total_samount,
       total_ramount,
       total_rate,
       twentyfive_samount,
       twentyfive_ramount,
       twentyfive_rate,
       paycode,
       grpid,
       grpname)
    values
      (seq_xq_reminder_report.nextval,
       v_cur_date,
       i_report_type,
       a.use_ali_id,
       a.use_nam,
       a.fst,
       a.frt,
       a.frate,
       a.sst,
       a.srt,
       a.srate,
       a.tst,
       a.trt,
       a.trate,
       a.ttst,
       a.ttrt,
       a.ttrate,
       a.tfst,
       a.tfrt,
       a.tfrate,
       i_paycode,
       a.grpid,
       a.grpname);
  end loop;
  commit;

  -- 插入分组统计结果
  for b in (select rp.grpid,
                   rp.grpname,
                   nvl(sum(rp.four_samount), 0) fst,
                   nvl(sum(rp.four_ramount), 0) frt,
                   decode(sum(rp.four_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.four_ramount), 0) /
                                        sum(rp.four_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') frate,
                   nvl(sum(rp.seven_samount), 0) sst,
                   nvl(sum(rp.seven_ramount), 0) srt,
                   decode(sum(rp.seven_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.seven_ramount), 0) /
                                        sum(rp.seven_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') srate,
                   nvl(sum(rp.thirteen_samount), 0) tst,
                   nvl(sum(rp.thirteen_ramount), 0) trt,
                   decode(sum(rp.thirteen_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.thirteen_ramount), 0) /
                                        sum(rp.thirteen_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') trate,
                   nvl(sum(rp.twentyfive_samount), 0) tfst,
                   nvl(sum(rp.twentyfive_ramount), 0) tfrt,
                   decode(sum(rp.twentyfive_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.twentyfive_ramount), 0) /
                                        sum(rp.twentyfive_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') tfrate,
                   nvl(sum(rp.total_samount), 0) ttst,
                   nvl(sum(rp.total_ramount), 0) ttrt,
                   decode(sum(rp.total_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.total_ramount), 0) /
                                        sum(rp.total_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') ttrate
              from xq_reminder_report rp
             where rp.cur_date = v_cur_date
               and rp.report_type = i_report_type
               and rp.paycode = i_paycode
               and (rp.use_ali_id is not null)
               and (rp.grpid is not null)
             group by rp.grpid, rp.grpname) loop
    insert into xq_reminder_report
      (id,
       cur_date,
       report_type,
       use_nam,
       four_samount,
       four_ramount,
       four_rate,
       seven_samount,
       seven_ramount,
       seven_rate,
       thirteen_samount,
       thirteen_ramount,
       thirteen_rate,
       total_samount,
       total_ramount,
       total_rate,
       twentyfive_samount,
       twentyfive_ramount,
       twentyfive_rate,
       paycode,
       grpid,
       grpname)
    values
      (seq_xq_reminder_report.nextval,
       v_cur_date,
       i_report_type,
       b.grpname,
       b.fst,
       b.frt,
       b.frate,
       b.sst,
       b.srt,
       b.srate,
       b.tst,
       b.trt,
       b.trate,
       b.ttst,
       b.ttrt,
       b.ttrate,
       b.tfst,
       b.tfrt,
       b.tfrate,
       i_paycode,
       b.grpid,
       b.grpname);
  end loop;
  commit;

  -- 插入没有组别的坐席的统计结果
  for c in (select nvl(sum(rp.four_samount), 0) fst,
                   nvl(sum(rp.four_ramount), 0) frt,
                   decode(sum(rp.four_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.four_ramount), 0) /
                                        sum(rp.four_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') frate,
                   nvl(sum(rp.seven_samount), 0) sst,
                   nvl(sum(rp.seven_ramount), 0) srt,
                   decode(sum(rp.seven_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.seven_ramount), 0) /
                                        sum(rp.seven_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') srate,
                   nvl(sum(rp.thirteen_samount), 0) tst,
                   nvl(sum(rp.thirteen_ramount), 0) trt,
                   decode(sum(rp.thirteen_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.thirteen_ramount), 0) /
                                        sum(rp.thirteen_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') trate,
                   nvl(sum(rp.twentyfive_samount), 0) tfst,
                   nvl(sum(rp.twentyfive_ramount), 0) tfrt,
                   decode(sum(rp.twentyfive_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.twentyfive_ramount), 0) /
                                        sum(rp.twentyfive_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') tfrate,
                   nvl(sum(rp.total_samount), 0) ttst,
                   nvl(sum(rp.total_ramount), 0) ttrt,
                   decode(sum(rp.total_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.total_ramount), 0) /
                                        sum(rp.total_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') ttrate
              from xq_reminder_report rp
             where rp.cur_date = v_cur_date
               and rp.report_type = i_report_type
               and rp.paycode = i_paycode
               and (rp.use_ali_id is not null)
               and (rp.grpid is null)
             group by rp.cur_date, rp.report_type, rp.paycode) loop
    insert into xq_reminder_report
      (id,
       cur_date,
       report_type,
       use_nam,
       four_samount,
       four_ramount,
       four_rate,
       seven_samount,
       seven_ramount,
       seven_rate,
       thirteen_samount,
       thirteen_ramount,
       thirteen_rate,
       total_samount,
       total_ramount,
       total_rate,
       twentyfive_samount,
       twentyfive_ramount,
       twentyfive_rate,
       paycode)
    values
      (seq_xq_reminder_report.nextval,
       v_cur_date,
       i_report_type,
       v_other,
       c.fst,
       c.frt,
       c.frate,
       c.sst,
       c.srt,
       c.srate,
       c.tst,
       c.trt,
       c.trate,
       c.ttst,
       c.ttrt,
       c.ttrate,
       c.tfst,
       c.tfrt,
       c.tfrate,
       i_paycode);
  end loop;
  commit;

  -- 插入总计统计结果
  for d in (select nvl(sum(rp.four_samount), 0) fst,
                   nvl(sum(rp.four_ramount), 0) frt,
                   decode(sum(rp.four_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.four_ramount), 0) /
                                        sum(rp.four_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') frate,
                   nvl(sum(rp.seven_samount), 0) sst,
                   nvl(sum(rp.seven_ramount), 0) srt,
                   decode(sum(rp.seven_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.seven_ramount), 0) /
                                        sum(rp.seven_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') srate,
                   nvl(sum(rp.thirteen_samount), 0) tst,
                   nvl(sum(rp.thirteen_ramount), 0) trt,
                   decode(sum(rp.thirteen_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.thirteen_ramount), 0) /
                                        sum(rp.thirteen_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') trate,
                   nvl(sum(rp.twentyfive_samount), 0) tfst,
                   nvl(sum(rp.twentyfive_ramount), 0) tfrt,
                   decode(sum(rp.twentyfive_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.twentyfive_ramount), 0) /
                                        sum(rp.twentyfive_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') tfrate,
                   nvl(sum(rp.total_samount), 0) ttst,
                   nvl(sum(rp.total_ramount), 0) ttrt,
                   decode(sum(rp.total_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.total_ramount), 0) /
                                        sum(rp.total_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') ttrate
              from xq_reminder_report rp
             where rp.cur_date = v_cur_date
               and rp.report_type = i_report_type
               and rp.paycode = i_paycode
               and (rp.use_ali_id is not null)
             group by rp.cur_date, rp.report_type, rp.paycode) loop
    insert into xq_reminder_report
      (id,
       cur_date,
       report_type,
       use_nam,
       four_samount,
       four_ramount,
       four_rate,
       seven_samount,
       seven_ramount,
       seven_rate,
       thirteen_samount,
       thirteen_ramount,
       thirteen_rate,
       total_samount,
       total_ramount,
       total_rate,
       twentyfive_samount,
       twentyfive_ramount,
       twentyfive_rate,
       paycode)
    values
      (seq_xq_reminder_report.nextval,
       v_cur_date,
       i_report_type,
       v_total,
       d.fst,
       d.frt,
       d.frate,
       d.sst,
       d.srt,
       d.srate,
       d.tst,
       d.trt,
       d.trate,
       d.ttst,
       d.ttrt,
       d.ttrate,
       d.tfst,
       d.tfrt,
       d.tfrate,
       i_paycode);
  end loop;
  commit;

  o_flag := 1;

exception
  when others then
    begin
      dbms_output.put_line('error');
      commit;
    end;
end p_xq_reminder_report;
/

prompt
prompt Creating procedure P_XQ_REMINDER_REPORT_2
prompt =========================================
prompt
create or replace procedure unicall.p_xq_reminder_report_2(i_cur_Date    in varchar2,
                                                   i_report_type in varchar2,
                                                   i_paycode     in varchar2,
                                                   o_flag        out integer) is
  v_count_size integer := 0;
  v_cur_date   date := to_date(i_cur_Date, 'yyyy-mm-dd');
  v_other      varchar2(10) := '其他';
  v_total      varchar2(10) := '总计';
  v_offset     integer;
begin

  select count(1)
    into v_count_size
    from xq_reminder_report rp
   where rp.cur_date = v_cur_date
     and rp.report_type = i_report_type
     and rp.paycode = i_paycode;
  if v_count_size > 0 then
    delete from xq_reminder_report rp
     where rp.cur_date = v_cur_date
       and rp.report_type = i_report_type
       and rp.paycode = i_paycode;
    commit;
  end if;

  if i_report_type = '00' then
    v_offset := 0;
  elsif i_report_type = '01' then
    v_offset := -1;
  elsif i_report_type = '02' then
    v_offset := -2;
  end if;

  -- 插入所有续收坐席的统计结果
  for a in (select cu.use_ali_id   use_ali_id,
                   cu.use_nam      use_nam,
                   cu.cat_nam      grpname,
                   cu.gro_id       grpid,
                   four.st         fst,
                   four.rt         frt,
                   four.rate       frate,
                   seven.st        sst,
                   seven.rt        srt,
                   seven.rate      srate,
                   thirteen.st     tst,
                   thirteen.rt     trt,
                   thirteen.rate   trate,
                   total.st        ttst,
                   total.rt        ttrt,
                   total.rate      ttrate,
                   twentyfive.st   tfst,
                   twentyfive.rt   tfrt,
                   twentyfive.rate tfrate
              from (select cu.use_nam, cu.use_ali_id, cc.cat_nam, cg.gro_id -- 坐席信息
                      from c_use cu,
                           (select * from c_use_gro where gro_id <> 9005) cg,
                           c_cat cc
                     where cu.use_id = cg.use_id(+)
                       and cg.gro_id = cc.cat_id(+)
                       and cu.use_flag = '1') cu,
                   (select nvl(s.samount, 0) st, -- 4 个月
                           nvl(r.ramount, 0) rt,
                           decode(s.samount,
                                  0,
                                  null,
                                  null,
                                  null,
                                  to_char(round(nvl(r.ramount, 0) / s.samount,
                                                4) * 100,
                                          'FM990.0099') || '%') rate,
                           s.use_ali_id
                      from (select sum(amount) samount, use_ali_id -- 4 个月应收
                              from (select xtp.amount amount, use_ali_id
                                      from (select amount, use_ali_id, policyno
                                              from (select rs.amount,
                                                           rs.policyno,
                                                           xr.use_ali_id
                                                      from (select sum(rs.initial_amount) amount,
                                                                   rs.policyno
                                                              from xq_riskcon rs
                                                             where rs.polist_ids <> '9'
                                                               and rs.classcode in
                                                                   (select cs.classcode
                                                                      from xq_riskclass cs
                                                                     where cs.timestr = '1')
                                                               and to_char(rs.begdate-1,
                                                                           'yyyy-mm') =
                                                                   to_char(add_months(v_cur_date,
                                                                                      (-3 +
                                                                                      v_offset)),
                                                                           'yyyy-mm')
                                                             group by rs.policyno) rs,
                                                           XQ_REMINDER xr
                                                     WHERE rs.policyno =
                                                           xr.policyno
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where rs.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH'))
                                                       and xr.status in(402,403,404,406)
                                                       and trim(xr.pcode) in('1','2','4','5','6')
                                                       and exists
                                                     (select 1
                                                              from xq_moneysch my
                                                             where xr.policyno =
                                                                   my.policyno
                                                               and my.initial_paysch = '10')
                                                       and (xr.use_ali_id is not null)
                                                       and (xr.is_delete is null)
                                                       and to_char(xr.cover1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (0 +
                                                                              v_offset)),
                                                                   'yyyy-mm'))) xtp)
                             group by use_ali_id) s,
                           (select sum(amount) ramount, use_ali_id -- 4 个月实收
                              from (select xtp.amount amount, use_ali_id
                                      from (select amount, use_ali_id, policyno
                                              from (select rs.amount,
                                                           rs.policyno,
                                                           xr.use_ali_id
                                                      from (select sum(rs.initial_amount) amount,
                                                                   rs.policyno
                                                              from xq_riskcon rs
                                                             where rs.polist_ids <> '9'
                                                               and rs.classcode in
                                                                   (select cs.classcode
                                                                      from xq_riskclass cs
                                                                     where cs.timestr = '1')
                                                               and to_char(rs.begdate-1,
                                                                           'yyyy-mm') =
                                                                   to_char(add_months(v_cur_date,
                                                                                      (-3 +
                                                                                      v_offset)),
                                                                           'yyyy-mm')
                                                             group by rs.policyno) rs,
                                                           XQ_REMINDER xr
                                                     WHERE rs.policyno =
                                                           xr.policyno
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where rs.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in('3', 'B', '7','8','9', 'C','4','5', '6','F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH'))
                                                       and xr.status = 404
                                                       and trim(xr.pcode) in
                                                           ('1',
                                                            '2',
                                                            '4',
                                                            '5',
                                                            '6')
                                                       and exists
                                                     (select 1
                                                              from xq_moneysch my
                                                             where xr.policyno =
                                                                   my.policyno
                                                               and my.initial_paysch = '10')
                                                       and (xr.use_ali_id is not null)
                                                       and (xr.is_delete is null)
                                                       and to_char(xr.cover1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (0 +
                                                                              v_offset)),
                                                                   'yyyy-mm'))) xtp)
                             group by use_ali_id) r
                     where s.use_ali_id = r.use_ali_id(+)) four,
                   (select nvl(s.samount, 0) st, -- 7 个月
                           nvl(r.ramount, 0) rt,
                           decode(s.samount,
                                  0,
                                  null,
                                  null,
                                  null,
                                  to_char(round(nvl(r.ramount, 0) / s.samount,
                                                4) * 100,
                                          'FM990.0099') || '%') rate,
                           s.use_ali_id
                      from (select sum(amount) samount, use_ali_id -- 7 个月应收
                              from (select xtp.amount amount, use_ali_id
                                      from (select amount, use_ali_id, policyno
                                              from (select rs.amount,
                                                           rs.policyno,
                                                           xr.use_ali_id
                                                      from (select sum(rs.initial_amount) amount,
                                                                   rs.policyno
                                                              from xq_riskcon rs
                                                             where rs.polist_ids <> '9'
                                                               and rs.classcode in
                                                                   (select cs.classcode
                                                                      from xq_riskclass cs
                                                                     where cs.timestr = '1')
                                                               and to_char(rs.begdate-1,
                                                                           'yyyy-mm') =
                                                                   to_char(add_months(v_cur_date,
                                                                                      (-6 +
                                                                                      v_offset)),
                                                                           'yyyy-mm')
                                                             group by rs.policyno) rs,
                                                           XQ_REMINDER xr
                                                     WHERE rs.policyno =
                                                           xr.policyno
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where rs.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time -1<
                                                                   trunc(xr.task_date,
                                                                         'MONTH'))
                                                       and xr.status in
                                                           (402,
                                                            403,
                                                            404,
                                                            406)
                                                       and trim(xr.pcode) in
                                                           ('1',
                                                            '2',
                                                            '4',
                                                            '5',
                                                            '6')
                                                       and exists
                                                     (select 1
                                                              from xq_moneysch my
                                                             where xr.policyno =
                                                                   my.policyno
                                                               and my.initial_paysch = '10')
                                                       and (xr.use_ali_id is not null)
                                                       and (xr.is_delete is null)
                                                       and to_char(xr.cover1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (0 +
                                                                              v_offset)),
                                                                   'yyyy-mm'))) xtp)
                             group by use_ali_id) s,
                           (select sum(amount) ramount, use_ali_id -- 7 个月实收
                              from (select xtp.amount amount, use_ali_id
                                      from (select amount, use_ali_id, policyno
                                              from (select rs.amount,
                                                           rs.policyno,
                                                           xr.use_ali_id
                                                      from (select sum(rs.initial_amount) amount,
                                                                   rs.policyno
                                                              from xq_riskcon rs
                                                             where rs.polist_ids <> '9'
                                                               and rs.classcode in
                                                                   (select cs.classcode
                                                                      from xq_riskclass cs
                                                                     where cs.timestr = '1')
                                                               and to_char(rs.begdate-1,
                                                                           'yyyy-mm') =
                                                                   to_char(add_months(v_cur_date,
                                                                                      (-6 +
                                                                                      v_offset)),
                                                                           'yyyy-mm')
                                                             group by rs.policyno) rs,
                                                           XQ_REMINDER xr
                                                     WHERE rs.policyno =
                                                           xr.policyno
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where rs.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH'))
                                                       and xr.status = 404
                                                       and trim(xr.pcode) in
                                                           ('1',
                                                            '2',
                                                            '4',
                                                            '5',
                                                            '6')
                                                       and exists
                                                     (select 1
                                                              from xq_moneysch my
                                                             where xr.policyno =
                                                                   my.policyno
                                                               and my.initial_paysch = '10')
                                                       and (xr.use_ali_id is not null)
                                                       and (xr.is_delete is null)
                                                       and to_char(xr.cover1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (0 +
                                                                              v_offset)),
                                                                   'yyyy-mm'))) xtp)
                             group by use_ali_id) r
                     where s.use_ali_id = r.use_ali_id(+)) seven,
                   (select nvl(s.samount, 0) st, -- 13 个月
                           nvl(r.ramount, 0) rt,
                           decode(s.samount,
                                  0,
                                  null,
                                  null,
                                  null,
                                  to_char(round(nvl(r.ramount, 0) / s.samount,
                                                4) * 100,
                                          'FM990.0099') || '%') rate,
                           s.use_ali_id
                      from (select sum(amount) samount, use_ali_id -- 13 个月应收
                              from (select amount, use_ali_id
                                      from (select xr.amount,
                                                   xr.use_ali_id,
                                                   row_number() over(partition by xr.policyno, xr.cover1 order by xr.cover1 asc) rn
                                              from xq_reminder xr
                                             where exists
                                             (select 1
                                                      from xq_riskcon c
                                                     where c.policyno =
                                                           xr.policyno
                                                       and c.appf = '1'
                                                       and c.polist_ids <> '9'
                                                       and c.classcode in
                                                           (select cs.classcode
                                                              from xq_riskclass cs
                                                             where cs.timestr = '1')
                                                       and to_char(c.begdate-1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (-12 +
                                                                              v_offset)),
                                                                   'yyyy-mm')
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where c.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH')))
                                               and xr.status in
                                                   (402, 403, 404,406)
                                               and xr.paycode in (702, 703, 705)
                                               and trim(xr.pcode) in
                                                   ('1', '2', '4', '5', '6')
                                               and (xr.use_ali_id is not null)
                                               and (xr.is_delete is null)
                                               and to_char(xr.cover1, 'yyyy-mm') =
                                                   to_char(add_months(v_cur_date,
                                                                      (0 +
                                                                      v_offset)),
                                                           'yyyy-mm'))
                                     where rn = 1)
                             group by use_ali_id) s,
                           (select sum(amount) ramount, use_ali_id -- 13 个月实收
                              from (select amount, use_ali_id
                                      from (select xr.amount,
                                                   xr.use_ali_id,
                                                   row_number() over(partition by xr.policyno, xr.cover1 order by xr.cover1 asc) rn
                                              from xq_reminder xr
                                             where exists
                                             (select 1
                                                      from xq_riskcon c
                                                     where c.policyno =
                                                           xr.policyno
                                                       and c.appf = '1'
                                                       and c.polist_ids <> '9'
                                                       and c.classcode in
                                                           (select cs.classcode
                                                              from xq_riskclass cs
                                                             where cs.timestr = '1')
                                                       and to_char(c.begdate-1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (-12 +
                                                                              v_offset)),
                                                                   'yyyy-mm')
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where c.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH')))

                                               and xr.status = 404
                                               and xr.paycode in (702, 703, 705)
                                               and trim(xr.pcode) in
                                                   ('1', '2', '4', '5', '6')
                                               and (xr.use_ali_id is not null)
                                               and (xr.is_delete is null)
                                               and to_char(xr.cover1, 'yyyy-mm') =
                                                   to_char(add_months(v_cur_date,
                                                                      (0 +
                                                                      v_offset)),
                                                           'yyyy-mm'))
                                     where rn = 1)
                             group by use_ali_id) r
                     where s.use_ali_id = r.use_ali_id(+)) thirteen,
                   (select nvl(s.samount, 0) st, -- 25 个月
                           nvl(r.ramount, 0) rt,
                           decode(s.samount,
                                  0,
                                  null,
                                  null,
                                  null,
                                  to_char(round(nvl(r.ramount, 0) / s.samount,
                                                4) * 100,
                                          'FM990.0099') || '%') rate,
                           s.use_ali_id
                      from (select sum(amount) samount, use_ali_id -- 25 个月应收
                              from (select amount, use_ali_id
                                      from (select xr.amount,
                                                   xr.use_ali_id,
                                                   row_number() over(partition by xr.policyno, xr.cover1 order by xr.cover1 asc) rn
                                              from xq_reminder xr
                                             where exists
                                             (select 1
                                                      from xq_riskcon c
                                                     where c.policyno =
                                                           xr.policyno
                                                       and c.appf = '1'
                                                       and c.polist_ids <> '9'
                                                       and c.classcode in
                                                           (select cs.classcode
                                                              from xq_riskclass cs
                                                             where cs.timestr = '1')
                                                       and to_char(c.begdate-1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (-24 +
                                                                              v_offset)),
                                                                   'yyyy-mm')
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where c.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH')))
                                               and xr.status in
                                                   (402, 403, 404,406)
                                               and xr.paycode in (702, 703, 705)
                                               and trim(xr.pcode) in
                                                   ('1', '2', '4', '5', '6')
                                               and (xr.use_ali_id is not null)
                                               and (xr.is_delete is null)
                                               and to_char(xr.cover1, 'yyyy-mm') =
                                                   to_char(add_months(v_cur_date,
                                                                      (0 +
                                                                      v_offset)),
                                                           'yyyy-mm'))
                                     where rn = 1)
                             group by use_ali_id) s,
                           (select sum(amount) ramount, use_ali_id -- 25 个月实收
                              from (select amount, use_ali_id
                                      from (select xr.amount,
                                                   xr.use_ali_id,
                                                   row_number() over(partition by xr.policyno, xr.cover1 order by xr.cover1 asc) rn
                                              from xq_reminder xr
                                             where exists
                                             (select 1
                                                      from xq_riskcon c
                                                     where c.policyno =
                                                           xr.policyno
                                                       and c.appf = '1'
                                                       and c.polist_ids <> '9'
                                                       and c.classcode in
                                                           (select cs.classcode
                                                              from xq_riskclass cs
                                                             where cs.timestr = '1')
                                                       and to_char(c.begdate-1,
                                                                   'yyyy-mm') =
                                                           to_char(add_months(v_cur_date,
                                                                              (-24 +
                                                                              v_offset)),
                                                                   'yyyy-mm')
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where c.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH')))

                                               and xr.status = 404
                                               and xr.paycode in (702, 703, 705)
                                               and trim(xr.pcode) in
                                                   ('1', '2', '4', '5', '6')
                                               and (xr.use_ali_id is not null)
                                               and (xr.is_delete is null)
                                               and to_char(xr.cover1, 'yyyy-mm') =
                                                   to_char(add_months(v_cur_date,
                                                                      (0 +
                                                                      v_offset)),
                                                           'yyyy-mm'))
                                     where rn = 1)
                             group by use_ali_id) r
                     where s.use_ali_id = r.use_ali_id(+)) twentyfive,
                   (select nvl(s.samount, 0) st, -- 整体
                           nvl(r.ramount, 0) rt,
                           decode(s.samount,
                                  0,
                                  null,
                                  null,
                                  null,
                                  to_char(round(nvl(r.ramount, 0) / s.samount,
                                                4) * 100,
                                          'FM990.0099') || '%') rate,
                           s.use_ali_id
                      from (select sum(amount) samount, use_ali_id -- 整体应收
                              from (select amount, use_ali_id
                                      from (select xr.amount,
                                                   xr.use_ali_id,
                                                   row_number() over(partition by xr.policyno, xr.cover1 order by xr.cover1 asc) rn
                                              from xq_reminder xr
                                             where exists
                                             (select 1
                                                      from xq_riskcon c
                                                     where c.policyno =
                                                           xr.policyno
                                                       and c.appf = '1'
                                                       and c.polist_ids <> '9'
                                                       and c.classcode in
                                                           (select cs.classcode
                                                              from xq_riskclass cs
                                                             where cs.timestr = '1')
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where c.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time -1<
                                                                   trunc(xr.task_date,
                                                                         'MONTH')))
                                               and xr.paycode in (702, 703, 705)
                                               and xr.status in
                                                   (402, 403, 404,406)
                                               and trim(xr.pcode) in
                                                   ('1', '2', '4', '5', '6')
                                               and (xr.use_ali_id is not null)
                                               and (xr.is_delete is null)
                                               and to_char(xr.cover1, 'yyyy-mm') =
                                                   to_char(add_months(v_cur_date,
                                                                      (0 +
                                                                      v_offset)),
                                                           'yyyy-mm'))
                                     where rn = 1)
                             group by use_ali_id) s,
                           (select sum(amount) ramount, use_ali_id -- 整体实收
                              from (select amount, use_ali_id
                                      from (select xr.amount,
                                                   xr.use_ali_id,
                                                   row_number() over(partition by xr.policyno, xr.cover1 order by xr.cover1 asc) rn
                                              from xq_reminder xr
                                             where exists
                                             (select 1
                                                      from xq_riskcon c
                                                     where c.policyno =
                                                           xr.policyno
                                                       and c.appf = '1'
                                                       and c.polist_ids <> '9'
                                                       and c.classcode in
                                                           (select cs.classcode
                                                              from xq_riskclass cs
                                                             where cs.timestr = '1')
                                                       and not exists
                                                     (select 1
                                                              from xq_riskcon cc
                                                             where c.policyno =
                                                                   cc.policyno
                                                               and cc.polist_ids in
                                                                   ('3',
                                                                    'B',
                                                                    '7',
                                                                    '8',
                                                                    '9',
                                                                    'C',
                                                                    '4',
                                                                    '5',
                                                                    '6',
                                                                    'F')

                                                               and cc.etl_time-1 <
                                                                   trunc(xr.task_date,
                                                                         'MONTH')))
                                               and xr.paycode in (702, 703, 705)
                                               and xr.status = 404
                                               and trim(xr.pcode) in
                                                   ('1', '2', '4', '5', '6')
                                               and (xr.use_ali_id is not null)
                                               and (xr.is_delete is null)
                                               and to_char(xr.cover1, 'yyyy-mm') =
                                                   to_char(add_months(v_cur_date,
                                                                      (0 +
                                                                      v_offset)),
                                                           'yyyy-mm'))
                                     where rn = 1)
                             group by use_ali_id) r
                     where s.use_ali_id = r.use_ali_id(+)) total
             where cu.use_ali_id = four.use_ali_id(+)
               and cu.use_ali_id = seven.use_ali_id(+)
               and cu.use_ali_id = thirteen.use_ali_id(+)
               and cu.use_ali_id = twentyfive.use_ali_id(+)
               and cu.use_ali_id = total.use_ali_id(+)) loop
    insert into xq_reminder_report
      (id,
       cur_date,
       report_type,
       use_ali_id,
       use_nam,
       four_samount,
       four_ramount,
       four_rate,
       seven_samount,
       seven_ramount,
       seven_rate,
       thirteen_samount,
       thirteen_ramount,
       thirteen_rate,
       total_samount,
       total_ramount,
       total_rate,
       twentyfive_samount,
       twentyfive_ramount,
       twentyfive_rate,
       paycode,
       grpid,
       grpname)
    values
      (seq_xq_reminder_report.nextval,
       v_cur_date,
       i_report_type,
       a.use_ali_id,
       a.use_nam,
       a.fst,
       a.frt,
       a.frate,
       a.sst,
       a.srt,
       a.srate,
       a.tst,
       a.trt,
       a.trate,
       a.ttst,
       a.ttrt,
       a.ttrate,
       a.tfst,
       a.tfrt,
       a.tfrate,
       i_paycode,
       a.grpid,
       a.grpname);
  end loop;
  commit;

  -- 插入分组统计结果
  for b in (select rp.grpid,
                   rp.grpname,
                   nvl(sum(rp.four_samount), 0) fst,
                   nvl(sum(rp.four_ramount), 0) frt,
                   decode(sum(rp.four_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.four_ramount), 0) /
                                        sum(rp.four_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') frate,
                   nvl(sum(rp.seven_samount), 0) sst,
                   nvl(sum(rp.seven_ramount), 0) srt,
                   decode(sum(rp.seven_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.seven_ramount), 0) /
                                        sum(rp.seven_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') srate,
                   nvl(sum(rp.thirteen_samount), 0) tst,
                   nvl(sum(rp.thirteen_ramount), 0) trt,
                   decode(sum(rp.thirteen_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.thirteen_ramount), 0) /
                                        sum(rp.thirteen_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') trate,
                   nvl(sum(rp.twentyfive_samount), 0) tfst,
                   nvl(sum(rp.twentyfive_ramount), 0) tfrt,
                   decode(sum(rp.twentyfive_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.twentyfive_ramount), 0) /
                                        sum(rp.twentyfive_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') tfrate,
                   nvl(sum(rp.total_samount), 0) ttst,
                   nvl(sum(rp.total_ramount), 0) ttrt,
                   decode(sum(rp.total_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.total_ramount), 0) /
                                        sum(rp.total_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') ttrate
              from xq_reminder_report rp
             where rp.cur_date = v_cur_date
               and rp.report_type = i_report_type
               and rp.paycode = i_paycode
               and (rp.use_ali_id is not null)
               and (rp.grpid is not null)
             group by rp.grpid, rp.grpname) loop
    insert into xq_reminder_report
      (id,
       cur_date,
       report_type,
       use_nam,
       four_samount,
       four_ramount,
       four_rate,
       seven_samount,
       seven_ramount,
       seven_rate,
       thirteen_samount,
       thirteen_ramount,
       thirteen_rate,
       total_samount,
       total_ramount,
       total_rate,
       twentyfive_samount,
       twentyfive_ramount,
       twentyfive_rate,
       paycode,
       grpid,
       grpname)
    values
      (seq_xq_reminder_report.nextval,
       v_cur_date,
       i_report_type,
       b.grpname,
       b.fst,
       b.frt,
       b.frate,
       b.sst,
       b.srt,
       b.srate,
       b.tst,
       b.trt,
       b.trate,
       b.ttst,
       b.ttrt,
       b.ttrate,
       b.tfst,
       b.tfrt,
       b.tfrate,
       i_paycode,
       b.grpid,
       b.grpname);
  end loop;
  commit;

  -- 插入没有组别的坐席的统计结果
  for c in (select nvl(sum(rp.four_samount), 0) fst,
                   nvl(sum(rp.four_ramount), 0) frt,
                   decode(sum(rp.four_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.four_ramount), 0) /
                                        sum(rp.four_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') frate,
                   nvl(sum(rp.seven_samount), 0) sst,
                   nvl(sum(rp.seven_ramount), 0) srt,
                   decode(sum(rp.seven_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.seven_ramount), 0) /
                                        sum(rp.seven_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') srate,
                   nvl(sum(rp.thirteen_samount), 0) tst,
                   nvl(sum(rp.thirteen_ramount), 0) trt,
                   decode(sum(rp.thirteen_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.thirteen_ramount), 0) /
                                        sum(rp.thirteen_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') trate,
                   nvl(sum(rp.twentyfive_samount), 0) tfst,
                   nvl(sum(rp.twentyfive_ramount), 0) tfrt,
                   decode(sum(rp.twentyfive_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.twentyfive_ramount), 0) /
                                        sum(rp.twentyfive_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') tfrate,
                   nvl(sum(rp.total_samount), 0) ttst,
                   nvl(sum(rp.total_ramount), 0) ttrt,
                   decode(sum(rp.total_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.total_ramount), 0) /
                                        sum(rp.total_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') ttrate
              from xq_reminder_report rp
             where rp.cur_date = v_cur_date
               and rp.report_type = i_report_type
               and rp.paycode = i_paycode
               and (rp.use_ali_id is not null)
               and (rp.grpid is null)
             group by rp.cur_date, rp.report_type, rp.paycode) loop
    insert into xq_reminder_report
      (id,
       cur_date,
       report_type,
       use_nam,
       four_samount,
       four_ramount,
       four_rate,
       seven_samount,
       seven_ramount,
       seven_rate,
       thirteen_samount,
       thirteen_ramount,
       thirteen_rate,
       total_samount,
       total_ramount,
       total_rate,
       twentyfive_samount,
       twentyfive_ramount,
       twentyfive_rate,
       paycode)
    values
      (seq_xq_reminder_report.nextval,
       v_cur_date,
       i_report_type,
       v_other,
       c.fst,
       c.frt,
       c.frate,
       c.sst,
       c.srt,
       c.srate,
       c.tst,
       c.trt,
       c.trate,
       c.ttst,
       c.ttrt,
       c.ttrate,
       c.tfst,
       c.tfrt,
       c.tfrate,
       i_paycode);
  end loop;
  commit;

  -- 插入总计统计结果
  for d in (select nvl(sum(rp.four_samount), 0) fst,
                   nvl(sum(rp.four_ramount), 0) frt,
                   decode(sum(rp.four_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.four_ramount), 0) /
                                        sum(rp.four_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') frate,
                   nvl(sum(rp.seven_samount), 0) sst,
                   nvl(sum(rp.seven_ramount), 0) srt,
                   decode(sum(rp.seven_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.seven_ramount), 0) /
                                        sum(rp.seven_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') srate,
                   nvl(sum(rp.thirteen_samount), 0) tst,
                   nvl(sum(rp.thirteen_ramount), 0) trt,
                   decode(sum(rp.thirteen_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.thirteen_ramount), 0) /
                                        sum(rp.thirteen_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') trate,
                   nvl(sum(rp.twentyfive_samount), 0) tfst,
                   nvl(sum(rp.twentyfive_ramount), 0) tfrt,
                   decode(sum(rp.twentyfive_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.twentyfive_ramount), 0) /
                                        sum(rp.twentyfive_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') tfrate,
                   nvl(sum(rp.total_samount), 0) ttst,
                   nvl(sum(rp.total_ramount), 0) ttrt,
                   decode(sum(rp.total_samount),
                          0,
                          null,
                          null,
                          null,
                          to_char(round(nvl(sum(rp.total_ramount), 0) /
                                        sum(rp.total_samount),
                                        4) * 100,
                                  'FM990.0099') || '%') ttrate
              from xq_reminder_report rp
             where rp.cur_date = v_cur_date
               and rp.report_type = i_report_type
               and rp.paycode = i_paycode
               and (rp.use_ali_id is not null)
             group by rp.cur_date, rp.report_type, rp.paycode) loop
    insert into xq_reminder_report
      (id,
       cur_date,
       report_type,
       use_nam,
       four_samount,
       four_ramount,
       four_rate,
       seven_samount,
       seven_ramount,
       seven_rate,
       thirteen_samount,
       thirteen_ramount,
       thirteen_rate,
       total_samount,
       total_ramount,
       total_rate,
       twentyfive_samount,
       twentyfive_ramount,
       twentyfive_rate,
       paycode)
    values
      (seq_xq_reminder_report.nextval,
       v_cur_date,
       i_report_type,
       v_total,
       d.fst,
       d.frt,
       d.frate,
       d.sst,
       d.srt,
       d.srate,
       d.tst,
       d.trt,
       d.trate,
       d.ttst,
       d.ttrt,
       d.ttrate,
       d.tfst,
       d.tfrt,
       d.tfrate,
       i_paycode);
  end loop;
  commit;

  o_flag := 1;

exception
  when others then
    begin
      dbms_output.put_line('error');
      commit;
    end;
end p_xq_reminder_report_2;
/

prompt
prompt Creating procedure P_XQ_REMINDER_SCRAP
prompt ======================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_REMINDER_SCRAP IS

  i             integer := 1;
  v_count       integer := 0;

  CURSOR cur_info IS
    select c.*
       from sprerec c, xq_app p
      where c.endtime = 99991231999
        and c.policyno = p.policyno;
  v_info cur_info%rowtype;

BEGIN

  open cur_info;
  loop
    fetch cur_info
      into v_info;
    exit when cur_info%notfound;

    select count(r.reminder_id)
      into v_count
      from xq_reminder r
     where v_info.begtime > r.begtime
       and v_info.cover1 <> r.cover1
       and v_info.policyno = r.policyno
       and v_info.source_payin_actvty_id = r.source_payin_actvty_id
       and r.is_delete is null;

    if v_count > 0 then
      --update
      begin
       update xq_reminder r
          set r.status = 407, r.status_ids_var = v_info.status
        where v_info.begtime > r.begtime
          and v_info.cover1 <> r.cover1
          and v_info.policyno = r.policyno
          and v_info.source_payin_actvty_id = r.source_payin_actvty_id
          and r.is_delete is null;

      exception
        when others then
          -- 遇到异常做一些处理
          begin
            dbms_output.put_line('data error :' || v_info.sno || 'v_count :' || v_count);
          end;
      end;
      --if mod(i, 1000) = 0 then
      commit;
      -- end if;
      i := i + 1;
    end if;

  end loop;
  commit;
  close cur_info;
exception
  when others then
    begin
      dbms_output.put_line('cur error');
      commit;
    end;

END P_XQ_REMINDER_SCRAP;
/

prompt
prompt Creating procedure P_XQ_RESERVE_REPORT_IN
prompt =========================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_RESERVE_REPORT_IN(
 sta_date date--统计开始日期
) IS
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_RESERVE_REPORT_IN
  *  建立日期   ：2012-09-24
  *  作者       ：yangguoqi
  *  模块       ：报表
  *  描述       ：预约任务和问题件统计报表
  *----------------------------------------------------
  *  序号   日期    修改人    修改原因
  *  1
  *  2
  ******************************************************
  */

  v_insert_rows number(18) := 0;
  v_update_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  time_before binary_integer :=Dbms_Utility.get_time;--过程开始时间(毫秒)
  time_after binary_integer;--过程结束时间(毫秒)

  CURSOR cur_info IS
    select r.dx_org_id dx_org_id,
         (select org_name from tb_organization t1 where t1.org_type = '05' and t1.org_id= r.dx_org_id) dx_org_name, --电销中心
          n.prj_id prj_org_id,
         (select t1.prj_name from t_project_info t1 where t1.prj_id = n.prj_id) prj_org_name, --所属项目
          r.use_ali_id use_ali_id,--预约坐席
         count(*) sum_amount,--预约数
         sum(case when status=1002 then 1 else 0 end) yy_suc_amount,--预约成功数
         sum(case when status=1005 then 1 else 0 end) jjps_amount,--拒绝配送数
         sum(case when status=1003 then 1 else 0 end) wlxd_amount,--未联系到数量
         sum(case when is_pro=1    then 1 else 0 end) wtj_amount,--问题件数量
      --   sum(case when is_pro=2 then 1 else 0 end) wtj_suc_amount--问题件处理成功数
         sum(
         case
           when (select count(1) from tb_problem pp
             where pp.reserve_task_id = r.id)=0 then
           0
         when (select count(1) from tb_problem pp
             where pp.status = '3' and pp.reserve_task_id = r.id)>0 then
           0
         else
           1
         end
         ) wtj_suc_amount--问题件处理成功数


    from tb_reserve_task r,tb_application n
   where r.application_id = n.application_id
     and r.cre_time >= sta_date
     and r.cre_time < sta_date+1
     and r.use_ali_id is not null      -- yyh add ,未分配坐席不需要
     group by r.dx_org_id, --电销中心
         n.prj_id, --所属项目
         r.use_ali_id;

  v_info cur_info%ROWTYPE;

BEGIN
  --删除已存在当天报表数据，然后重新跑
  delete t_xq_reserve_list_report r where r.cre_time >= sta_date and r.cre_time < sta_date+1;
  commit;--提交数据

OPEN cur_info;
  LOOP
    FETCH cur_info
      INTO v_info;
    EXIT WHEN cur_info%NOTFOUND;

    begin

    --插入记录
    insert into t_xq_reserve_list_report
      (cre_time, dx_org_id,dx_org_name, prj_org_id,prj_org_name, use_ali_id, sum_amount, yy_suc_amount,
       jjps_amount, wlxd_amount, wtj_amount, wtj_suc_amount,
       rate_yy,
       rate_wtj)
    values
      (sta_date,v_info.dx_org_id, v_info.dx_org_name, v_info.prj_org_id, v_info.prj_org_name, v_info.use_ali_id, v_info.sum_amount, v_info.yy_suc_amount,
      v_info.jjps_amount, v_info.wlxd_amount, v_info.wtj_amount, v_info.wtj_suc_amount,
      (CASE WHEN v_info.sum_amount=0 THEN 0  WHEN v_info.yy_suc_amount/v_info.sum_amount=1 then 100 WHEN v_info.yy_suc_amount/v_info.sum_amount is null then 0 ELSE round(100*v_info.yy_suc_amount/v_info.sum_amount,2) end),
      (CASE WHEN v_info.wtj_amount=0 THEN 0  WHEN v_info.wtj_suc_amount/v_info.wtj_amount=1 then 100 WHEN v_info.wtj_suc_amount/v_info.wtj_amount is null then 0 ELSE round(100*v_info.wtj_suc_amount/v_info.wtj_amount,2) end));

      v_insert_rows :=v_insert_rows+1;

      exception
        when others then
          begin -- 遇到异常捕获处理
            p_xq_log_in_err('IDS','P_XQ_RESERVE_REPORT_IN',
                  '',
                  '插入表t_xq_cbj_list_report数据'||sqlerrm);--写日志
            v_error_rows :=v_error_rows+1;
          end;
      end;
      COMMIT;--提交数据
  END LOOP;
  COMMIT;
  CLOSE cur_info;

  --添加数据库成功日志
  time_after :=Dbms_Utility.get_time;
  p_xq_log_suc('IDS',
              'P_XQ_RESERVE_REPORT_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '预约任务报表统计时间'||sta_date||',执行过程持续时间:'||(time_after-time_before)/100||'秒',
              sqlerrm);

  EXCEPTION
  WHEN OTHERS THEN
   begin
        rollback;

        if cur_info%isopen then
          CLOSE cur_info;
        end if;

        rollback;

        dbms_output.put_line('P_XQ_RESERVE_REPORT_IN ERROR'||sqlerrm);

        --添加数据库失败日志
        time_after :=Dbms_Utility.get_time;
        p_xq_log_err('IDS',
            'P_XQ_RESERVE_REPORT_IN',
            v_insert_rows,
            v_error_rows,
            v_update_rows,
            '预约任务报表'||sta_date||',执行过程持续时间:'||(time_after-time_before)/100||'秒',
            sqlerrm);
   end;
END P_XQ_RESERVE_REPORT_IN;
/

prompt
prompt Creating procedure P_XQ_RISKON_FULL_IN
prompt ======================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_RISKON_FULL_IN IS

  --v_active_code_id number(18) := 0;
  v_begtime        number(18) := 0;
  v_sno            number(18);
  coun_id          number(18) := 0;

  v_AIDTYPE     number(10);
  v_SALEATTR    number(10);
  v_POLIST      number(10);
  v_IDTYPE      number(10);

  v_insert_rows number(18) := 0;
  v_update_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  CURSOR cur_info IS
   SELECT *
     FROM riskcon b;

  v_info cur_info%ROWTYPE;

BEGIN
  select b.nextvalue
    into coun_id
    from c_id_bro b
   where b.name = 'xq_riskcon_full';
  OPEN cur_info;
  LOOP
    FETCH cur_info
      INTO v_info;
    EXIT WHEN cur_info%NOTFOUND;

     select (select c.sno
              from xq_riskcon_full c
             where c.policyno = v_info.policyno
               and c.classcode = v_info.classcode
               and rownum = 1) into v_sno  from dual;

       --证件类型对应字典表ID
    if trim(v_info.aidtype) = '1' then
       v_AIDTYPE := 1101;
    else
      begin
        select (select t.id
                  from xq_dict t
                 where t.parent_id = 11
                   and t.item_code = v_info.aidtype)
          into v_AIDTYPE
          from dual;

        if v_AIDTYPE is null then
           v_AIDTYPE := 1150;
        end if;
      end;
    end if;

    --销售渠道对应字典表ID
    select (select t.id
              from xq_dict t
             where t.parent_id = 6
               and t.item_code = v_info.saleattr)
      into v_SALEATTR
      from dual;

      if v_SALEATTR is null then
         v_SALEATTR := 650;
      end if;

    --保单状态对应字典表ID
    select (select t.id
              from xq_dict t
             where t.parent_id = 1
               and t.item_code = v_info.polist)
      into v_POLIST
      from dual;

      if v_POLIST is null then
         v_POLIST := 150;
      end if;

    --证件类型对应字典表ID
    if trim(v_info.idtype) = '1' then
       v_IDTYPE := 1101;
    else
      begin
        select (select t.id
                  from xq_dict t
                 where t.parent_id = 11
                   and t.item_code = v_info.idtype)
          into v_IDTYPE
          from dual;

          if v_IDTYPE is null then
             v_IDTYPE := 1150;
          end if;
      end;
    end if;

    IF v_sno > 0 THEN

     select (select c.begtime
              from xq_riskcon_full c
             where c.policyno = v_info.policyno
               and c.classcode = v_info.classcode
               and rownum = 1) into v_begtime  from dual;

      IF v_info.begtime > v_begtime THEN
        --update
        begin

          update xq_riskcon_full a
             set a.POLICYNO          = v_info.POLICYNO,
                 a.APPNO             = v_info.APPNO,
                 a.APERSON_ID        = v_info.APERSON_ID,
                 a.APID              = v_info.APID,
                 a.AIDTYPE_IDS       = v_info.AIDTYPE,
                 a.RISKCON_ID        = v_info.RISKCON_ID,
                 a.SALEATTR_IDS      = v_info.SALEATTR,
                 a.BEGDATE           = v_info.BEGDATE,
                 a.STOPDATE          = v_info.STOPDATE,
                 a.POLIST_IDS        = v_info.POLIST,
                 a.PIECES            = v_info.PIECES,
                 a.OPDATE            = v_info.OPDATE,
                 a.RENEWDATE         = v_info.RENEWDATE,
                 a.TMOUNT            = v_info.TMOUNT,
                 a.PERSON_ID         = v_info.PERSON_ID,
                 a.IDTYPE_IDS        = v_info.IDTYPE,
                 a.PID               = v_info.PID,
                 a.APPDATE           = v_info.APPDATE,
                 a.APPF              = v_info.APPF,
                 a.CLASSCODE         = v_info.CLASSCODE,
                 a.RENEWID           = v_info.RENEWID,
                 a.SALE_PROD_CODE    = v_info.SALE_PROD_CODE,
                 a.NPAYLEN           = v_info.NPAYLEN,
                 a.STDRATE           = v_info.STDRATE,
                 a.UNSTDRATE         = v_info.UNSTDRATE,
                 a.ETL_TIME          = v_info.ETL_TIME,
                 a.TYPEID            = v_info.TYPEID,
                 a.GCON_ID           = v_info.GCON_ID,
                 a.GPOLICYNO         = v_info.GPOLICYNO,
                 a.DESKPAY           = v_info.DESKPAY,
                 a.REASON            = v_info.REASON,
                 a.CURRENCY          = v_info.CURRENCY,
                 a.OPER_ID           = v_info.OPER_ID,
                 a.OPERNO            = v_info.OPERNO,
                 a.EMPNO_ID          = v_info.EMPNO_ID,
                 a.EMPNO             = v_info.EMPNO,
                 a.CSR_ID            = v_info.CSR_ID,
                 a.CSRNO             = v_info.CSRNO,
                 a.COMNUM            = v_info.COMNUM,
                 a.JOB               = v_info.JOB,
                 a.SHARETYPE         = v_info.SHARETYPE,
                 a.SPECAGR           = v_info.SPECAGR,
                 a.DISCOUNT          = v_info.DISCOUNT,
                 a.ISCARD            = v_info.ISCARD,
                 a.DCDM              = v_info.DCDM,
                 a.PRELNAME          = v_info.PRELNAME,
                 a.BANKFLAG          = v_info.BANKFLAG,
                 a.PAYSEQ            = v_info.PAYSEQ,
                 a.BENPARAM          = v_info.BENPARAM,
                 a.OWNER_SOURCE_ID   = v_info.OWNER_SOURCE_ID,
                 a.INSURED_SOURCE_ID = v_info.INSURED_SOURCE_ID,
                 a.WORKNO            = v_info.WORKNO,
                 a.COMB_POLICY_NO    = v_info.COMB_POLICY_NO,
                 a.APP_AGE           = v_info.APP_AGE,
                 a.BEGTIME           = v_info.BEGTIME,
                 a.ENDTIME           = v_info.ENDTIME,
                 a.BRANCH            = v_info.BRANCH,
                 a.SRC_SYS           = v_info.SRC_SYS,
                 a.SUB_AGT_NO        = v_info.SUB_AGT_NO,
                 a.aidtype           = v_AIDTYPE,
                 a.saleattr          = v_SALEATTR,
                 a.polist            = v_POLIST,
                 a.idtype            = v_IDTYPE
           where a.SNO = v_sno;

           v_update_rows :=v_update_rows+1;
           exception
           when others then
            -- 遇到异常做一些处理
              begin
               p_xq_log_in_err('IDS','P_XQ_RISKON_FULL_IN',v_sno,'更新表xq_riskcon_full数据'||sqlerrm);
               v_error_rows :=v_error_rows+1;
              end;
       end;
      END IF;
    else
      --insert
      coun_id := coun_id + 1;
      begin

        insert into xq_riskcon_full
          (SNO,
           POLICYNO,
           APPNO,
           APERSON_ID,
           APID,
           AIDTYPE_IDS, -- 对应 riskcon.AIDTYPE
           RISKCON_ID,
           SALEATTR_IDS, -- 对应 riskcon.SALEATTR
           BEGDATE,
           STOPDATE,
           POLIST_IDS, -- 对应 riskcon.POLIST
           PIECES,
           OPDATE,
           RENEWDATE,
           TMOUNT,
           PERSON_ID,
           IDTYPE_IDS, -- 对应 riskcon.IDTYPE
           PID,
           APPDATE,
           APPF,
           CLASSCODE,
           RENEWID,
           SALE_PROD_CODE,
           NPAYLEN,
           STDRATE,
           UNSTDRATE,
           ETL_TIME,
           TYPEID,
           GCON_ID,
           GPOLICYNO,
           DESKPAY,
           REASON,
           CURRENCY,
           OPER_ID,
           OPERNO,
           EMPNO_ID,
           EMPNO,
           CSR_ID,
           CSRNO,
           COMNUM,
           JOB,
           SHARETYPE,
           SPECAGR,
           DISCOUNT,
           ISCARD,
           DCDM,
           PRELNAME,
           BANKFLAG,
           PAYSEQ,
           BENPARAM,
           OWNER_SOURCE_ID,
           INSURED_SOURCE_ID,
           WORKNO,
           COMB_POLICY_NO,
           APP_AGE,
           BEGTIME,
           ENDTIME,
           BRANCH,
           SRC_SYS,
           SUB_AGT_NO,
           AIDTYPE,
           SALEATTR,
           POLIST,
           IDTYPE,
           INITIAL_AMOUNT
           )
        values
          (coun_id,
           v_info.POLICYNO,
           v_info.APPNO,
           v_info.APERSON_ID,
           v_info.APID,
           v_info.AIDTYPE,
           v_info.RISKCON_ID,
           v_info.SALEATTR,
           v_info.BEGDATE,
           v_info.STOPDATE,
           v_info.POLIST,
           v_info.PIECES,
           v_info.OPDATE,
           v_info.RENEWDATE,
           v_info.TMOUNT,
           v_info.PERSON_ID,
           v_info.IDTYPE,
           v_info.PID,
           v_info.APPDATE,
           v_info.APPF,
           v_info.CLASSCODE,
           v_info.RENEWID,
           v_info.SALE_PROD_CODE,
           v_info.NPAYLEN,
           v_info.STDRATE,
           v_info.UNSTDRATE,
           v_info.ETL_TIME,
           v_info.TYPEID,
           v_info.GCON_ID,
           v_info.GPOLICYNO,
           v_info.DESKPAY,
           v_info.REASON,
           v_info.CURRENCY,
           v_info.OPER_ID,
           v_info.OPERNO,
           v_info.EMPNO_ID,
           v_info.EMPNO,
           v_info.CSR_ID,
           v_info.CSRNO,
           v_info.COMNUM,
           v_info.JOB,
           v_info.SHARETYPE,
           v_info.SPECAGR,
           v_info.DISCOUNT,
           v_info.ISCARD,
           v_info.DCDM,
           v_info.PRELNAME,
           v_info.BANKFLAG,
           v_info.PAYSEQ,
           v_info.BENPARAM,
           v_info.OWNER_SOURCE_ID,
           v_info.INSURED_SOURCE_ID,
           v_info.WORKNO,
           v_info.COMB_POLICY_NO,
           v_info.APP_AGE,
           v_info.BEGTIME,
           v_info.ENDTIME,
           v_info.BRANCH,
           v_info.SRC_SYS,
           v_info.SUB_AGT_NO,
           v_AIDTYPE,
           v_SALEATTR,
           v_POLIST,
           v_IDTYPE,
           v_info.NPAYLEN*v_info.PIECES);

           v_insert_rows :=v_insert_rows+1;
           exception
           when others then
            -- 遇到异常做一些处理
              begin
               p_xq_log_in_err('IDS','P_XQ_RISKON_FULL_IN','policyno:'||v_info.policyno||' classcode'||v_info.classcode,
               '插入表xq_riskcon_full数据'||sqlerrm);
               v_error_rows :=v_error_rows+1;
              end;
      end;
    END IF;

    COMMIT;
  END LOOP;



  CLOSE cur_info;
  update c_id_bro b
     set b.nextvalue = coun_id
   where b.name = 'xq_riskcon_full';
  commit;

  --添加数据库成功日志
  p_xq_log_suc('IDS','P_XQ_RISKON_FULL_IN',v_insert_rows,v_error_rows,v_update_rows,
              '数据丢失0条',sqlerrm);
  EXCEPTION
  when others then
    begin
      rollback;

      update c_id_bro b
         set b.nextvalue = coun_id
       where b.name = 'xq_riskcon_full';
      commit;

      if cur_info%isopen then
        CLOSE cur_info;
      end if;

      rollback;
      dbms_output.put_line('P_XQ_RISKON_FULL_IN cur error'||sqlerrm);
      --添加数据库失败日志
       p_xq_log_err('IDS','P_XQ_RISKON_FULL_IN',v_insert_rows,v_error_rows,v_update_rows,
              '数据丢失0条',sqlerrm);
    end;

END P_XQ_RISKON_FULL_IN;
/

prompt
prompt Creating procedure P_XQ_RISKON_IN
prompt =================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_RISKON_IN IS

  --v_active_code_id number(18) := 0;
  v_begtime        number(18) := 0;
  v_sno            number(18);
  coun_id          number(18) := 0;

  v_AIDTYPE     number(10);
  v_SALEATTR    number(10);
  v_POLIST      number(10);
  v_IDTYPE      number(10);

  v_insert_rows number(18) := 0;
  v_update_rows number(18) := 0;
  v_error_rows  number(18) := 0;

  CURSOR cur_info IS
   SELECT *
     FROM riskcon b
    where b.saleattr in ('61', '62', '63', '64','10','13','15','31','32','33','35','51','52')
      and b.classcode in
          (select p.classcode from xq_riskclass p where p.timestr = '1');
  v_info cur_info%ROWTYPE;

BEGIN
  select b.nextvalue
    into coun_id
    from c_id_bro b
   where b.name = 'xq_riskcon';
  OPEN cur_info;
  LOOP
    FETCH cur_info
      INTO v_info;
    EXIT WHEN cur_info%NOTFOUND;

     select (select c.sno
              from xq_riskcon c
             where c.policyno = v_info.policyno
               and c.classcode = v_info.classcode
               and rownum = 1) into v_sno  from dual;

       --证件类型对应字典表ID
    if trim(v_info.aidtype) = '1' then
       v_AIDTYPE := 1101;
    else
      begin
        select (select t.id
                  from xq_dict t
                 where t.parent_id = 11
                   and t.item_code = v_info.aidtype)
          into v_AIDTYPE
          from dual;

        if v_AIDTYPE is null then
           v_AIDTYPE := 1150;
        end if;
      end;
    end if;

    --销售渠道对应字典表ID
    select (select t.id
              from xq_dict t
             where t.parent_id = 6
               and t.item_code = v_info.saleattr)
      into v_SALEATTR
      from dual;

      if v_SALEATTR is null then
         v_SALEATTR := 650;
      end if;

    --保单状态对应字典表ID
    select (select t.id
              from xq_dict t
             where t.parent_id = 1
               and t.item_code = v_info.polist)
      into v_POLIST
      from dual;

      if v_POLIST is null then
         v_POLIST := 150;
      end if;

    --证件类型对应字典表ID
    if trim(v_info.idtype) = '1' then
       v_IDTYPE := 1101;
    else
      begin
        select (select t.id
                  from xq_dict t
                 where t.parent_id = 11
                   and t.item_code = v_info.idtype)
          into v_IDTYPE
          from dual;

          if v_IDTYPE is null then
             v_IDTYPE := 1150;
          end if;
      end;
    end if;

    IF v_sno > 0 THEN

     select (select c.begtime
              from xq_riskcon c
             where c.policyno = v_info.policyno
               and c.classcode = v_info.classcode
               and rownum = 1) into v_begtime  from dual;

      IF v_info.begtime > v_begtime THEN
        --update
        begin

          update xq_riskcon a
             set a.POLICYNO          = v_info.POLICYNO,
                 a.APPNO             = v_info.APPNO,
                 a.APERSON_ID        = v_info.APERSON_ID,
                 a.APID              = v_info.APID,
                 a.AIDTYPE_IDS       = v_info.AIDTYPE,
                 a.RISKCON_ID        = v_info.RISKCON_ID,
                 a.SALEATTR_IDS      = v_info.SALEATTR,
                 a.BEGDATE           = v_info.BEGDATE,
                 a.STOPDATE          = v_info.STOPDATE,
                 a.POLIST_IDS        = v_info.POLIST,
                 a.PIECES            = v_info.PIECES,
                 a.OPDATE            = v_info.OPDATE,
                 a.RENEWDATE         = v_info.RENEWDATE,
                 a.TMOUNT            = v_info.TMOUNT,
                 a.PERSON_ID         = v_info.PERSON_ID,
                 a.IDTYPE_IDS        = v_info.IDTYPE,
                 a.PID               = v_info.PID,
                 a.APPDATE           = v_info.APPDATE,
                 a.APPF              = v_info.APPF,
                 a.CLASSCODE         = v_info.CLASSCODE,
                 a.RENEWID           = v_info.RENEWID,
                 a.SALE_PROD_CODE    = v_info.SALE_PROD_CODE,
                 a.NPAYLEN           = v_info.NPAYLEN,
                 a.STDRATE           = v_info.STDRATE,
                 a.UNSTDRATE         = v_info.UNSTDRATE,
                 a.ETL_TIME          = v_info.ETL_TIME,
                 a.TYPEID            = v_info.TYPEID,
                 a.GCON_ID           = v_info.GCON_ID,
                 a.GPOLICYNO         = v_info.GPOLICYNO,
                 a.DESKPAY           = v_info.DESKPAY,
                 a.REASON            = v_info.REASON,
                 a.CURRENCY          = v_info.CURRENCY,
                 a.OPER_ID           = v_info.OPER_ID,
                 a.OPERNO            = v_info.OPERNO,
                 a.EMPNO_ID          = v_info.EMPNO_ID,
                 a.EMPNO             = v_info.EMPNO,
                 a.CSR_ID            = v_info.CSR_ID,
                 a.CSRNO             = v_info.CSRNO,
                 a.COMNUM            = v_info.COMNUM,
                 a.JOB               = v_info.JOB,
                 a.SHARETYPE         = v_info.SHARETYPE,
                 a.SPECAGR           = v_info.SPECAGR,
                 a.DISCOUNT          = v_info.DISCOUNT,
                 a.ISCARD            = v_info.ISCARD,
                 a.DCDM              = v_info.DCDM,
                 a.PRELNAME          = v_info.PRELNAME,
                 a.BANKFLAG          = v_info.BANKFLAG,
                 a.PAYSEQ            = v_info.PAYSEQ,
                 a.BENPARAM          = v_info.BENPARAM,
                 a.OWNER_SOURCE_ID   = v_info.OWNER_SOURCE_ID,
                 a.INSURED_SOURCE_ID = v_info.INSURED_SOURCE_ID,
                 a.WORKNO            = v_info.WORKNO,
                 a.COMB_POLICY_NO    = v_info.COMB_POLICY_NO,
                 a.APP_AGE           = v_info.APP_AGE,
                 a.BEGTIME           = v_info.BEGTIME,
                 a.ENDTIME           = v_info.ENDTIME,
                 a.BRANCH            = v_info.BRANCH,
                 a.SRC_SYS           = v_info.SRC_SYS,
                 a.SUB_AGT_NO        = v_info.SUB_AGT_NO,
                 a.aidtype           = v_AIDTYPE,
                 a.saleattr          = v_SALEATTR,
                 a.polist            = v_POLIST,
                 a.idtype            = v_IDTYPE
           where a.SNO = v_sno;

           v_update_rows :=v_update_rows+1;
           exception
           when others then
            -- 遇到异常做一些处理
              begin
               p_xq_log_in_err('IDS','P_XQ_RISKON_IN',v_sno,'更新表xq_riskcon数据'||sqlerrm);
               v_error_rows :=v_error_rows+1;
              end;
       end;
      END IF;
    else
      --insert
      coun_id := coun_id + 1;
      begin

        insert into xq_riskcon
          (SNO,
           POLICYNO,
           APPNO,
           APERSON_ID,
           APID,
           AIDTYPE_IDS, -- 对应 riskcon.AIDTYPE
           RISKCON_ID,
           SALEATTR_IDS, -- 对应 riskcon.SALEATTR
           BEGDATE,
           STOPDATE,
           POLIST_IDS, -- 对应 riskcon.POLIST
           PIECES,
           OPDATE,
           RENEWDATE,
           TMOUNT,
           PERSON_ID,
           IDTYPE_IDS, -- 对应 riskcon.IDTYPE
           PID,
           APPDATE,
           APPF,
           CLASSCODE,
           RENEWID,
           SALE_PROD_CODE,
           NPAYLEN,
           STDRATE,
           UNSTDRATE,
           ETL_TIME,
           TYPEID,
           GCON_ID,
           GPOLICYNO,
           DESKPAY,
           REASON,
           CURRENCY,
           OPER_ID,
           OPERNO,
           EMPNO_ID,
           EMPNO,
           CSR_ID,
           CSRNO,
           COMNUM,
           JOB,
           SHARETYPE,
           SPECAGR,
           DISCOUNT,
           ISCARD,
           DCDM,
           PRELNAME,
           BANKFLAG,
           PAYSEQ,
           BENPARAM,
           OWNER_SOURCE_ID,
           INSURED_SOURCE_ID,
           WORKNO,
           COMB_POLICY_NO,
           APP_AGE,
           BEGTIME,
           ENDTIME,
           BRANCH,
           SRC_SYS,
           SUB_AGT_NO,
           AIDTYPE,
           SALEATTR,
           POLIST,
           IDTYPE,
           INITIAL_AMOUNT
           )
        values
          (coun_id,
           v_info.POLICYNO,
           v_info.APPNO,
           v_info.APERSON_ID,
           v_info.APID,
           v_info.AIDTYPE,
           v_info.RISKCON_ID,
           v_info.SALEATTR,
           v_info.BEGDATE,
           v_info.STOPDATE,
           v_info.POLIST,
           v_info.PIECES,
           v_info.OPDATE,
           v_info.RENEWDATE,
           v_info.TMOUNT,
           v_info.PERSON_ID,
           v_info.IDTYPE,
           v_info.PID,
           v_info.APPDATE,
           v_info.APPF,
           v_info.CLASSCODE,
           v_info.RENEWID,
           v_info.SALE_PROD_CODE,
           v_info.NPAYLEN,
           v_info.STDRATE,
           v_info.UNSTDRATE,
           v_info.ETL_TIME,
           v_info.TYPEID,
           v_info.GCON_ID,
           v_info.GPOLICYNO,
           v_info.DESKPAY,
           v_info.REASON,
           v_info.CURRENCY,
           v_info.OPER_ID,
           v_info.OPERNO,
           v_info.EMPNO_ID,
           v_info.EMPNO,
           v_info.CSR_ID,
           v_info.CSRNO,
           v_info.COMNUM,
           v_info.JOB,
           v_info.SHARETYPE,
           v_info.SPECAGR,
           v_info.DISCOUNT,
           v_info.ISCARD,
           v_info.DCDM,
           v_info.PRELNAME,
           v_info.BANKFLAG,
           v_info.PAYSEQ,
           v_info.BENPARAM,
           v_info.OWNER_SOURCE_ID,
           v_info.INSURED_SOURCE_ID,
           v_info.WORKNO,
           v_info.COMB_POLICY_NO,
           v_info.APP_AGE,
           v_info.BEGTIME,
           v_info.ENDTIME,
           v_info.BRANCH,
           v_info.SRC_SYS,
           v_info.SUB_AGT_NO,
           v_AIDTYPE,
           v_SALEATTR,
           v_POLIST,
           v_IDTYPE,
           v_info.NPAYLEN*v_info.PIECES);

           v_insert_rows :=v_insert_rows+1;
           exception
           when others then
            -- 遇到异常做一些处理
              begin
               p_xq_log_in_err('IDS','P_XQ_RISKON_IN','policyno:'||v_info.policyno||' classcode'||v_info.classcode,
               '插入表xq_riskcon数据'||sqlerrm);
               v_error_rows :=v_error_rows+1;
              end;
      end;
    END IF;

    COMMIT;
  END LOOP;

    update xq_riskcon e
       set e.xq_app_id = (select p.xq_app_id
                            from xq_app p
                           where p.policyno = e.policyno
                             and rownum = 1);

  commit;

  CLOSE cur_info;
  update c_id_bro b
     set b.nextvalue = coun_id
   where b.name = 'xq_riskcon';
  commit;

  --添加数据库成功日志
  p_xq_log_suc('IDS','P_XQ_RISKON_IN',v_insert_rows,v_error_rows,v_update_rows,
              '数据丢失0条',sqlerrm);
  EXCEPTION
  when others then
    begin
      rollback;

      if cur_info%isopen then
        CLOSE cur_info;
      end if;

      rollback;
      dbms_output.put_line('P_XQ_RISKON_IN cur error'||sqlerrm);
      --添加数据库失败日志
       p_xq_log_err('IDS','P_XQ_RISKON_IN',v_insert_rows,v_error_rows,v_update_rows,
              '数据丢失0条',sqlerrm);
    end;

END P_XQ_RISKON_IN;
/

prompt
prompt Creating procedure P_XQ_SPREREC_IN
prompt ==================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_SPREREC_IN IS
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_SPREREC_IN
  *  建立日期   ：2012-05-11
  *  作者       ：yangguoqi
  *  模块       ：IDS
  *  描述       ：补充未更新到续期表XQ_SPREREC记录
  * 1.循环日期变量
  * 2.删除重复记录xq_sprerec
  * 3.字典表处理
  * 4.逻辑判断 update/insert
  * 5.日志记录
  * 6.把xq_reminder表找不到数据行标记为删除
  */
  v_update_rows   number(18) := 0;
  v_insert_rows   number(18) := 0;
  v_error_rows   number(18) := 0;

  v_begtime number(11) := 0;
  v_sno     number(18) := 0;
  coun_id   number(18) := 0;

  v_IDTYPE    number(10);
  V_MINTSTAMP timestamp; --最小日期timestamp
  V_MAXTSTAMP timestamp; --最大日期timestamp
  v_MINDATE   DATE; --最小日期
  v_MAXDATE   DATE; --最大日期

  v_status         number(10);
  v_paycode        number(10);
  v_setcode        number(10);
  v_reminderId     number(18);
  v_reminderStatus number(10);

  i integer := 0;


  CURSOR cur_info(startdate date, enddate date) IS
    select  sno, typeid, con_id, policyno, classcode, amount,
      stdrate, unstdrate, currency, prndate,
      yearnum, paycode, setcode, status, movewhy,
      pcode, verdate, cover1, cover2, oper_id,
      operno, empno_id, empno, deptno,
      person_id, apid, idtype, years,
      source_payin_actvty_id, begtime, endtime, branch,
      etl_time, src_sys, pos_no
      from sprerec s
     where s.etl_time >= startdate
       and s.etl_time < enddate
       and s.endtime = '99991231999' --只取有效数据
       and s.paycode <> '01'
       and exists(SELECT 1
              FROM xq_riskcon b
             where s.policyno = b.policyno
               and b.classcode in (select p.classcode
                                     from xq_riskclass p
                                    where p.timestr = '1'));

  v_info cur_info%ROWTYPE;

BEGIN
  --查询临时表最大和最小日期
  SELECT MIN(TEM.ETL_TIME), MAX(TEM.ETL_TIME)
    INTO V_MINTSTAMP, V_MAXTSTAMP
    FROM sprerec TEM ;
  V_MINDATE := TO_DATE(TO_CHAR(V_MINTSTAMP, 'YYYY-MM-DD'), 'YYYY-MM-DD');
  V_MAXDATE := TO_DATE(TO_CHAR(V_MAXTSTAMP, 'YYYY-MM-DD'), 'YYYY-MM-DD');

  select b.nextvalue
    into coun_id
    from c_id_bro b
   where b.name = 'xq_sprerec';

  LOOP
    EXIT WHEN V_MINDATE > V_MAXDATE or V_MINDATE is null;

     --删除重复记录
     delete from xq_sprerec a
     where a.SOURCE_PAYIN_ACTVTY_ID in
           (select SOURCE_PAYIN_ACTVTY_ID
              from sprerec b
             where b.endtime < 99991231999 and  to_date(to_char(b.etl_time,'yyyy-mm-dd'),'yyyy-mm-dd')=V_MINDATE
               and not exists
             (select 1
                      from sprerec c
                     where b.SOURCE_PAYIN_ACTVTY_ID = c.SOURCE_PAYIN_ACTVTY_ID
                       and c.endtime = 99991231999 and to_date(to_char(c.etl_time,'yyyy-mm-dd'),'yyyy-mm-dd')=V_MINDATE))
          and exists(SELECT 1
             FROM xq_riskcon b
            where b.policyno = a.policyno
              and b.polist in (102, 110, 113, 114, 116)
              and b.classcode in
                  (select p.classcode from xq_riskclass p where p.timestr = '1'));
       commit;

    OPEN cur_info(V_MINDATE, V_MINDATE + 1);
    LOOP
      FETCH cur_info
        INTO v_info;
      EXIT WHEN cur_info%NOTFOUND;

          select (select c.sno
                    from xq_sprerec c
                   where c.source_payin_actvty_id =
                         trim(v_info.source_payin_actvty_id)
                     and rownum = 1)
            into v_sno
            from dual;

  select nvl(max(case --状态
                   when t.parent_id = 3 and t.item_code = trim(v_info.status) then
                    t.id
                   else
                    null
                 end),
             350) status,
         nvl(max(case --paycode
                   when t.parent_id = 7 and t.item_code = trim(v_info.paycode) then
                    t.id
                   else
                    null
                 end),
             750) paycode,
         nvl(max(case --setcode
                   when t.parent_id = 12 and t.item_code = trim(v_info.setcode) then
                    t.id
                   else
                    null
                 end),
             1250) setcode
    into v_status, v_paycode, v_setcode
    from xq_dict t;

        --证件类型对应字典表ID
        if trim(v_info.idtype) = '1' then
          v_IDTYPE := 1101;
        else
          begin
            select (select t.id
                      from xq_dict t
                     where t.parent_id = 11
                       and t.item_code = v_info.idtype)
              into v_IDTYPE
              from dual;

            if v_IDTYPE is null then
              v_IDTYPE := 1150;
            end if;
          end;
        end if;

      begin
        --填充reminder表记录
        select trem.reminder_id, trem.status
          into v_reminderId, v_reminderStatus
          from xq_reminder trem
         where trem.policyno = v_info.policyno
           and trem.cover1 = v_info.cover1
           and trem.is_delete is null--有效数据
           and rownum = 1;

        exception when NO_DATA_FOUND then
           v_reminderId :=null;
           v_reminderStatus :=null;

       end;

        IF v_sno > 0 THEN
             select (select c.begtime
                       from xq_sprerec c
                      where c.source_payin_actvty_id =
                            trim(v_info.source_payin_actvty_id)
                        and rownum = 1)
               into v_begtime
               from dual;

          IF v_info.begtime > v_begtime THEN
            --update
            begin

              update xq_sprerec a
                 set
                     a.reminder_id            = v_reminderId,
                     a.policyno               = v_info.policyno,
                     a.status                 = v_reminderStatus,
                     a.status_ids             = v_status,
                     a.classcode              = v_info.classcode,
                     a.amount                 = v_info.amount,
                     a.stdrate                = v_info.stdrate,
                     a.unstdrate              = v_info.unstdrate,
                     a.prndate                = v_info.prndate,
                     a.yearnum                = v_info.yearnum,
                     a.paycode                = v_paycode,
                     a.setcode                = v_setcode,
                     a.pcode                  = v_info.pcode,
                     a.verdate                = v_info.verdate,
                     a.cover1                 = v_info.cover1,
                     a.cover2                 = v_info.cover2,
                     a.person_id              = v_info.person_id,
                     a.apid                   = v_info.apid,
                     a.idtype                 = v_IDTYPE,
                     a.years                  = v_info.years,
                     a.etl_time               = v_info.etl_time,
                     a.status_ids_var         = v_info.status,
                     a.paycode_ids            = v_info.paycode,
                     a.setcode_ids            = v_info.setcode,
                     a.idtype_ids             = v_info.idtype,
                     a.begtime                = v_info.begtime,
                     a.endtime                = v_info.endtime,
                     a.src_sys                = v_info.src_sys
               where a.source_payin_actvty_id = v_info.source_payin_actvty_id;

            v_update_rows :=v_update_rows+1;
            --dbms_output.put_line('P_XQ_SPREREC_IN中 line UPDATE : ' ||v_info.source_payin_actvty_id);
            exception
              when others then

                v_error_rows:=v_error_rows+1;

                -- 遇到异常做一些处理
                begin
                  p_xq_log_in_err('IDS','P_XQ_SPREREC_IN',
                  v_info.source_payin_actvty_id || ' '|| v_info.policyno || ' ' || v_info.classcode,
                  '更新表xq_sprerec数据'||sqlerrm);--写日志
                end;
            end;
          END IF;
        else
          --insert 主键编号加1
          coun_id := coun_id + 1;

          begin

            insert into xq_sprerec
              (SNO,
               reminder_id,
               policyno,
               status,
               status_ids,
               classcode,
               amount,
               stdrate,
               unstdrate,
               prndate,
               yearnum,
               paycode,
               setcode,
               pcode,
               verdate,
               cover1,
               cover2,
               person_id,
               apid,
               idtype,
               years,
               source_payin_actvty_id,
               etl_time,
               status_ids_var,
               paycode_ids,
               setcode_ids,
               idtype_ids,
               begtime,
               endtime,
               src_sys)
            values
              (coun_id,
               v_reminderId,
               v_info.policyno,
               v_reminderStatus,
               v_status,
               v_info.classcode,
               v_info.amount,
               v_info.stdrate,
               v_info.unstdrate,
               v_info.prndate,
               v_info.yearnum,
               v_paycode,
               v_setcode,
               v_info.pcode,
               v_info.verdate,
               v_info.cover1,
               v_info.cover2,
               v_info.person_id,
               v_info.apid,
               v_IDTYPE,
               v_info.years,
               v_info.source_payin_actvty_id,
               v_info.etl_time,
               v_info.status,
               v_info.paycode,
               v_info.setcode,
               v_info.idtype,
               v_info.begtime,
               v_info.endtime,
               v_info.src_sys);

           v_insert_rows :=v_insert_rows+1;
          --dbms_output.put_line('P_XQ_SPREREC_IN中 line INSERT : ' ||v_info.source_payin_actvty_id);
          exception
            when others then
               v_error_rows:=v_error_rows+1;
              -- 遇到异常做一些处理
              --ROLLBACK; --数据回滚
              begin
                p_xq_log_in_err('IDS','P_XQ_SPREREC_IN',
                  v_info.source_payin_actvty_id || ' '|| v_info.policyno || ' ' || v_info.classcode,
                  '插入表xq_sprerec数据'||sqlerrm);--写日志
              end;
          end;
        END IF;
    END LOOP;

    COMMIT;

    CLOSE cur_info;

    V_MINDATE := V_MINDATE + 1;

  END LOOP;

  update c_id_bro b set b.nextvalue = coun_id where b.name = 'xq_sprerec';

  commit;
  --把 xq_reminder表找不到数据且保单状态为有效数据标记为删除
   update xq_reminder x
   set x.is_delete = '1', x.del_date = sysdate
  where x.reminder_id in
        (select r.reminder_id
           from xq_reminder r
          where not exists (select 1
                   from xq_sprerec q
                  where r.policyno = q.policyno
                    and r.cover1 = q.cover1))
    and exists(SELECT 1
           FROM xq_riskcon b
          where b.policyno = x.policyno
            and b.polist in (102, 110, 113, 114, 116)
            and b.classcode in
                (select p.classcode from xq_riskclass p where p.timestr = '1'))
    and x.status in (401, 402, 403, 404, 405, 406)
    and x.is_delete is null;

      commit;

  dbms_output.put_line('P_XQ_SPREREC_IN中数据更新 '||v_update_rows||'行，数据插入 '||v_insert_rows||'行,失败'||v_error_rows||'行');

  --添加数据库成功日志
  p_xq_log_suc('IDS',
              'P_XQ_SPREREC_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);


     --1 根据policyno和cover1 处理状态为407的记录
     for c_r in (select r.policyno,r.reminder_id,r.status,r.cover1,r.use_ali_id,r.task_date
                  from xq_reminder r
                 where r.status=407
                   and to_char(r.cover1,'YYYY-MM') = to_char(sysdate,'YYYY-MM')
                   and r.is_delete is null and r.use_ali_id is not null
                   and r.pcode in ('1', '2', '4', '5', '6')
             ) loop
      update xq_reminder r
         set r.use_ali_id = c_r.use_ali_id,
             r.task_date  = c_r.task_date,
             r.status     = decode(r.status,
                                   401,
                                   402,
                                   r.status)
       where r.reminder_id =
             (select max(reminder_id)
                from xq_reminder p
               where p.policyno = c_r.policyno
                 and to_char(p.cover1,'YYYY-MM') = to_char(sysdate,'YYYY-MM')
                 and p.is_delete is null
                 and p.use_ali_id is null
                 and p.status not in (407,408)
                 and p.pcode in ('1', '2', '4', '5', '6'));

    end loop;
    commit; --提交数据

      --2 根据policyno和cover1检索被失效记录恢复坐席
    for c_r in (select *
                  from xq_reminder r
                 where r.is_delete = 1
                   and r.status not in (407, 408)
                   and r.use_ali_id is not null
                   and r.pcode in ('1', '2', '4', '5', '6')) loop

      update xq_reminder r
         set r.use_ali_id = c_r.use_ali_id,
             r.task_date  = c_r.task_date,
             r.status     = decode(c_r.status,
                                   401,
                                   402,
                                   c_r.status)
       where r.reminder_id =
             (select max(reminder_id)
                from xq_reminder p
               where p.policyno = c_r.policyno
                 and p.cover1 = c_r.cover1
                 and p.is_delete is null
                 and p.use_ali_id is null
                 and p.status not in (407, 408)
                 and p.pcode in ('1', '2', '4', '5', '6'));

    end loop;
    commit; --提交数据

    --3 根据policyno和当月cover1检索被失效记录
    for c_r in (select r.policyno,r.reminder_id,r.status,r.cover1,r.use_ali_id,r.task_date
                  from xq_reminder r
                 where r.is_delete = 1
                   and r.status not in (408)
                   and r.use_ali_id is not null
                   and to_char(r.cover1,'YYYY-MM') = to_char(sysdate,'YYYY-MM')
                   and r.pcode in ('1', '2', '4', '5', '6')
                ) loop
      update xq_reminder r
         set r.use_ali_id = c_r.use_ali_id,
             r.task_date  = c_r.task_date,
             r.status     = decode(c_r.status,
                                   401,
                                   402,
                                   r.status)
       where r.reminder_id =
             (select max(reminder_id)
                from xq_reminder p
               where p.policyno = c_r.policyno
                 and to_char(p.cover1,'YYYY-MM') = to_char(sysdate,'YYYY-MM')
                 and p.is_delete is null
                 and p.use_ali_id is null
                 and p.status not in (407,408)
                 and p.pcode in ('1', '2', '4', '5', '6'));

    end loop;
    commit; --提交数据

    --更新由于数据延时导致失效前分单的数据
     while i < 12 loop
       begin
          update xq_reminder s
             set s.use_ali_id = null, s.task_date = null, s.status ='406'
           where s.status not in (407, 408)
             and s.is_delete is null
             and s.task_date is not null
             and exists(SELECT 1
                    FROM xq_app b
                   where s.policyno = b.policyno
                     and substr(b.begtime, 0, 6) = to_char(add_months(sysdate,-i),'YYYYMM')
                     and to_char(s.task_date, 'YYYYMMDD') >= substr(b.begtime, 0, 8)
                     and b.polist in ('202','203','205'));
           commit;
           i:= i + 1;
        exception
          when others then
            begin
              dbms_output.put_line(sqlerrm);
            end;
        end;
      end loop;

EXCEPTION
  when others then
    begin

     ROLLBACK; --数据回滚

      update c_id_bro b set b.nextvalue = coun_id where b.name = 'xq_sprerec';
      commit;

      if cur_info%isopen then
        CLOSE cur_info;
      end if;

      dbms_output.put_line('P_XQ_SPREREC_IN_APPEND=====ERROR '||SQLERRM);
      --添加数据库失败日志
      p_xq_log_err('IDS',
              'P_XQ_SPREREC_IN',
              v_insert_rows,
              v_error_rows,
              v_update_rows,
              '数据丢失0条',
              sqlerrm);
    end;

END P_XQ_SPREREC_IN;
/

prompt
prompt Creating procedure P_XQ_SYSTASK_INVALID
prompt =======================================
prompt
create or replace procedure unicall.P_XQ_SYSTASK_INVALID(to_task_status in number,valid_status in number) is  --to_task_status ：为待分配 1401 ，valid_status：已分配 1402

   /*未分配失效保单按照客户归类并按费用倒序，参数游标*/
   cursor cur_invalid_app_cus(to_task_status number) is
   select aidtype,apid,sum(tmount) tmount  from  xq_invalid_app
   where  status=to_task_status group by aidtype,apid order by tmount desc;--本月月底包括之前的待分配失效保单
   v_invalid_app_cus cur_invalid_app_cus%rowtype;
begin

 -- 失效保单复效失败，分配给最近一次分配的座席（已离职的人员由系统管理员进行手工调配）
 for a in(
  select *
  from (select xia.aidtype,
               xia.apid,
               xia.use_ali_id,
         xia.invalid_date,
         xia.task_date,
               row_number() over(partition by xia.policyno order by xia.invalid_date desc) rn
          from xq_invalid_app xia
         where xia.reinstate = '0'
           and (xia.use_ali_id is not null)
           and xia.policyno in (select xia.policyno
                                  from xq_invalid_app xia
                                 where xia.status = to_task_status))
  where rn = 1
 )loop
   update xq_invalid_app set use_ali_id = a.use_ali_id, status = valid_status, task_date = a.task_date, invalid_date = a.invalid_date
   where aidtype = a.aidtype and apid = a.apid and status = to_task_status;
 end loop;
 commit;

 delete c_use_temp_invalid;
 commit;

 insert into c_use_temp_invalid select u.use_ali_id,xr.tmount from c_use u ,
     (select use_ali_id,sum(xr.tmount)  tmount from xq_invalid_app xr group by use_ali_id) xr
     where u.use_ali_id=xr.use_ali_id(+) and u.rig_sta_id=3 and u.use_flag='1' and u.is_task = '1'
     and not exists (select 1 from c_use_par p where p.cat_id in(802007,802008,802009) and p.val='1' and  p.use_id =u.use_id) order by xr.tmount;

 commit;


 begin
    open cur_invalid_app_cus(to_task_status);
 loop
   for v_use_level in(select u.use_ali_id,u.tmount from c_use_temp_invalid u order by u.tmount asc)
     loop
         fetch cur_invalid_app_cus into v_invalid_app_cus;  /*本月失效保单按客户倒序，分配给续期代表*/
         exit when  cur_invalid_app_cus%notfound;
         update xq_invalid_app  set  use_ali_id=v_use_level.use_ali_id, status=valid_status ,task_date=sysdate where aidtype=v_invalid_app_cus.aidtype
         and apid=v_invalid_app_cus.apid and status=to_task_status;
     end loop;
     commit;
     /*如果找不到未分配数据，跳出循环*/
     if cur_invalid_app_cus%rowcount = 0 then
      exit;
     end if;
     exit when  cur_invalid_app_cus%notfound;
 end loop;
 close cur_invalid_app_cus;
 exception
 when others then
       if cur_invalid_app_cus%isopen then
       close cur_invalid_app_cus;
       end if;
 end;

 if cur_invalid_app_cus%isopen  then
 close cur_invalid_app_cus;
 end if;


end P_XQ_SYSTASK_INVALID;
/

prompt
prompt Creating procedure P_XQ_SYSTASK_INVALIDPERIOD
prompt =============================================
prompt
create or replace procedure unicall.P_XQ_SYSTASK_INVALIDPERIOD is  --to_task_status ：为待分配 401 ，valid_status：已分配 402
   first_day  date;/*第一个帐期*/
   two_day  date;/*第二个帐期*/
   three_day date;/*第三个帐期*/
   four_day date;/*第四个帐期*/
   five_day date;/*第五个帐期*/
   six_day date;/*第六个帐期*/
   max_id NUMBER(16);

begin

  --获取上个月的第一天
    --获取xq_invalid--id值
  select b.nextvalue
    into max_id
    from c_id_bro b
   where b.name = 'xq_invapp_period';

   for v_invalid_app_cus in(select * from xq_invalid_app)
     loop
         first_day:=v_invalid_app_cus.invalid_date+30;
         two_day:=first_day+31;
         three_day:=two_day+31;
         four_day:=three_day+91;
         five_day:=four_day+181;
         six_day:=five_day+366;

         max_id:=max_id+1;
         insert into  XQ_INVAPP_PERIOD (xq_invalid_app_period_id,xq_invalid_app_id,Period_Value,Begin_Date,End_Date)
         values(max_id,v_invalid_app_cus.xq_invalid_app_id,1501,v_invalid_app_cus.invalid_date,first_day);

         max_id:=max_id+1;
         insert into  XQ_INVAPP_PERIOD (xq_invalid_app_period_id,xq_invalid_app_id,Period_Value,Begin_Date,End_Date)
         values(max_id,v_invalid_app_cus.xq_invalid_app_id,1502,first_day+1,two_day);

         max_id:=max_id+1;
         insert into  XQ_INVAPP_PERIOD (xq_invalid_app_period_id,xq_invalid_app_id,Period_Value,Begin_Date,End_Date)
         values(max_id,v_invalid_app_cus.xq_invalid_app_id,1503,two_day+1,three_day);

         max_id:=max_id+1;
         insert into  XQ_INVAPP_PERIOD (xq_invalid_app_period_id,xq_invalid_app_id,Period_Value,Begin_Date,End_Date)
         values(max_id,v_invalid_app_cus.xq_invalid_app_id,1504,three_day+1,four_day);

         max_id:=max_id+1;
         insert into  XQ_INVAPP_PERIOD (xq_invalid_app_period_id,xq_invalid_app_id,Period_Value,Begin_Date,End_Date)
         values(max_id,v_invalid_app_cus.xq_invalid_app_id,1505,four_day+1,five_day);

         max_id:=max_id+1;
         insert into  XQ_INVAPP_PERIOD (xq_invalid_app_period_id,xq_invalid_app_id,Period_Value,Begin_Date,End_Date)
         values(max_id,v_invalid_app_cus.xq_invalid_app_id,1506,five_day+1,six_day);
         commit;

     end loop;
end P_XQ_SYSTASK_INVALIDPERIOD;
/

prompt
prompt Creating procedure P_XQ_SYSTASK_REMINDER
prompt ========================================
prompt
create or replace procedure unicall.p_xq_systask_reminder(to_task_status in number,
                                                                                      valid_status   in number,
                                                                                      v_beginDate    varchar2,
                                                                                      v_endDate      varchar2) is
  --to_task_status ：为待分配 401 ，valid_status：已分配 402
  ave_point                 number(20, 6);
  last_mon_first_day   date; /*上月第一天*/
  curr_mon_first_day   date; /*本月第一天*/
  next_mon_first_day  date; /*下月第一天*/
  v_use_count             int;  /*有效用户的数量*/
  tmp_total                 number(20, 6):= 0.0; /*当前用坐席总费用*/
  beginDate               date;
  endDate                  date;
  sql_str                      varchar2(50):='';
  flag                          int:=0;
  min_assigned_amt  number(20,6):=0; /*已分配金额最小值*/

  /*欠缴件按照续收代表及其客户，参数游标*/
  /*cursor cur_use_cus(startdate date, enddate date, valid_status number) is
    select use_ali_id, apid, idtype
      from xq_reminder
     where is_delete is null
       and cover1 >= startdate
       and cover1 < enddate
       and status = valid_status
     group by use_ali_id, apid, idtype;*/

  cursor cur_use_cus(startdate date, enddate date, valid_status number) is
     select use_ali_id, apid, idtype
       from (select use_ali_id,
                    apid,
                    idtype,
                    row_number() over(partition by apid, idtype order by task_date desc nulls last) rn
               from xq_reminder
              where is_delete is null
                and cover1 >= startdate
                and cover1 < enddate
                and status = valid_status)
      where rn = 1;
  v_use_cus cur_use_cus%rowtype;

  /*应缴件按照客户归类费用倒序，参数游标*/
  cursor cur_reminder_cus(startdate date, enddate date, to_task_status number) is
    select idtype, apid, sum(amount) amount
      from xq_reminder
     where is_delete is null
       and cover1 >= startdate
       and cover1 < enddate
       and status = to_task_status
     group by idtype, apid
     order by amount desc; --本月月底包括以前的待分配应缴件
  v_reminder_cus cur_reminder_cus%rowtype;
begin

  /*last_mon_first_day := trunc(add_months(sysdate, -1), 'mm');*/
  last_mon_first_day := trunc(add_months(sysdate, -3), 'mm');--三个月内应缴件，分配给原座席
  curr_mon_first_day := trunc(sysdate, 'mm');
  next_mon_first_day := trunc(add_months(sysdate, +1), 'mm');
  beginDate          := nvl(to_date(v_beginDate, 'yyyy-mm-dd'),curr_mon_first_day);
  endDate            := nvl(to_date(v_endDate, 'yyyy-mm-dd'),next_mon_first_day);

  /*把失效保单对应的应缴件置为失效状态*/
  begin
    update xq_reminder x
     set x.status = '406'
     where x.policyno in
         (select policyno
            from xq_app xa
           where xa.polist in ('202', '203', '205'))
     and x.status in ('401', '402', '403')
     and to_char(x.cover1, 'YYYY-MM') <= to_char(sysdate, 'YYYY-MM');
    commit;
  end;
  /*清空临时表:生产库上不能使用truncate命令，所以这里只能使用delete*/
  sql_str:='delete from sys_task_users_tmp';
  execute immediate sql_str;
  commit;
  /*向临时表中插入坐席信息*/
  begin
    insert into sys_task_users_tmp(user_ali_id,amount)
           select use_ali_id, 0 amount from (
                  select u.use_ali_id
                      from c_use u
                      where u.rig_sta_id = 3
                       and u.use_flag = '1'
                       and u.is_task = '1'
                       and not exists
                     (select 1 from c_use_par p
                             where p.cat_id in (802007, 802008, 802009)
                               and p.val = '1'
                               and p.use_id = u.use_id)
                    minus
                    /*select use_ali_id from xq_reminder
                     where is_delete is null
                       and cover1 >= last_mon_first_day
                       and cover1 < curr_mon_first_day
                       and status = valid_status*/
                   select use_ali_id
                     from (select use_ali_id,
                                  row_number() over(partition by apid, idtype order by task_date desc nulls last) rn
                             from xq_reminder
                            where is_delete is null
                              and cover1 >= last_mon_first_day
                              and cover1 < curr_mon_first_day
                              and status = valid_status)
                    where rn = 1
              ) t;
    commit;
  end;
  begin
  insert into sys_task_users_tmp(user_ali_id,amount)
         select xr.use_ali_id, sum(xr.amount) amount
            from xq_reminder xr
           where is_delete is null
             and cover1 >= last_mon_first_day
             and cover1 < curr_mon_first_day
             and status = valid_status
             and exists
             (select 1 from c_use u
                   where u.use_ali_id = xr.use_ali_id
                     and u.use_flag = '1'
                     and u.is_task = '1'
                     and u.rig_sta_id = 3
                     and not exists
                   (select 1
                            from c_use_par p
                           where p.cat_id in (802007, 802008, 802009)
                             and p.val = '1'
                             and p.use_id = u.use_id)
              )
           group by use_ali_id
           order by amount asc;
  commit;
  end;
  /*均分点，按照续收代表上月欠缴最多费用*/
  select nvl(max(m.amount), 0)
    into ave_point
    from (select sum(r1.amount) amount
            from xq_reminder r1
           where is_delete is null
             and r1.cover1 >= last_mon_first_day
             and r1.cover1 < curr_mon_first_day
             and r1.status = valid_status
           group by r1.use_ali_id) m;
  if ave_point > 0 then
    /*首先，上月未完成应缴件，本月应缴件该客户所有应缴件分配给该坐席*/
    /*上月应缴件，按照续收代表和客户归类 */
    open cur_use_cus(last_mon_first_day, curr_mon_first_day, valid_status);
    begin
      loop
        fetch cur_use_cus
          into v_use_cus;
        exit when cur_use_cus%notfound;
        select count(1)
          into v_use_count
          from c_use u
         where u.rig_sta_id = 3
           and u.use_flag = '1'
           and u.use_ali_id = v_use_cus.use_ali_id
           and not exists (select 1
                  from c_use_par p
                 where p.cat_id in (802007, 802008, 802009)
                   and p.val = '1'
                   and p.use_id = u.use_id);
        if v_use_count is not null and v_use_count > 0 then
          /*判断有效用户*/
          update xq_reminder
             set use_ali_id = v_use_cus.use_ali_id,
                 status     = valid_status,
                 task_date  = sysdate
           where is_delete is null
             and apid = v_use_cus.apid
             and cover1 >= beginDate
             and cover1 < endDate
             and status = to_task_status
             and idtype = v_use_cus.idtype;
        end if;
      end loop;
    exception
      when others then
        null;
    end;
    commit;

    if cur_use_cus%isopen then
      close cur_use_cus;
    end if;

    if cur_reminder_cus%isopen=false then
       open cur_reminder_cus(beginDate, endDate, to_task_status);
    end if;
    begin
      loop
        /*for循环结合游标使用，游标自动打开或关闭*/
        /*如果达到均分点的金额的最小值大于均分点,退出循环*/
        select min(assigned_amt) into min_assigned_amt from sys_task_users_tmp;
        if min_assigned_amt >=ave_point then
           exit;
        end if;
        for user_info  in (select user_ali_id,  amount  from sys_task_users_tmp order by amount asc) loop

        if cur_reminder_cus%notfound then
           exit;
        end if;

         if  flag=0 then
              fetch cur_reminder_cus into v_reminder_cus;
              exit when cur_reminder_cus%notfound;
          end if;
          /*达到均分点的坐席退出*/
          select  assigned_amt into tmp_total from sys_task_users_tmp where user_ali_id=user_info.user_ali_id;
          if tmp_total>=ave_point then
                   flag:=1;
          else
                   flag:=0;
          end if;
          if flag=0 then
            update xq_reminder  set use_ali_id=user_info.user_ali_id, status=valid_status, task_date=sysdate
             where is_delete is null
               and idtype = v_reminder_cus.idtype
               and apid = v_reminder_cus.apid
               and cover1 >= beginDate
               and cover1 < endDate
               and status = to_task_status;
               /*更改此坐席的已分配额度*/
               begin
                 update sys_task_users_tmp syut set  syut.assigned_amt = syut.assigned_amt+v_reminder_cus.amount
                   where syut.user_ali_id=user_info.user_ali_id;
                   commit;
               end;
             end if;

        end loop;
        exit when cur_reminder_cus%notfound;
      end loop;
      commit;
    end;
    /*按均分点轮盘结束*/
  end if;

  /*按照坐席级别排序倒序,轮盘式分配*/
  begin
    if cur_reminder_cus%isopen = false then
      open cur_reminder_cus(beginDate, endDate, to_task_status);
    end if;
    loop
      for v_use_level in (select cu.use_ali_id, cu.use_level
                            from c_use cu
                           where cu.rig_sta_id = 3
                             and cu.use_flag = '1'
                             and cu.is_task = '1'
                             and not exists
                           (select 1
                                    from c_use_par p
                                   where p.cat_id in (802007, 802008, 802009)
                                     and p.val = '1'
                                     and p.use_id = cu.use_id)
                           order by use_level desc) loop
        fetch cur_reminder_cus
          into v_reminder_cus; /*本月应缴件按客户倒序*/
        exit when cur_reminder_cus%notfound;
        update xq_reminder
           set use_ali_id = v_use_level.use_ali_id,
               status     = valid_status,
               task_date  = sysdate
         where is_delete is null
           and idtype = v_reminder_cus.idtype
           and apid = v_reminder_cus.apid
           and cover1 >= beginDate
           and cover1 < endDate
           and status = to_task_status;
      end loop;
      commit;
      exit when cur_reminder_cus%notfound;
    end loop;
  exception
    when others then
      null;
  end;
  if cur_use_cus%isopen then
    close cur_use_cus;
  end if;
  if cur_reminder_cus%isopen then
    close cur_reminder_cus;
  end if;
end p_xq_systask_reminder;
/

prompt
prompt Creating procedure P_XQ_SYSTASK_REMINDER_0607
prompt =============================================
prompt
create or replace procedure unicall.p_xq_systask_reminder_0607(to_task_status in number,
                                                        valid_status   in number,
                                                        v_beginDate    varchar2,
                                                        v_endDate      varchar2) is
  --to_task_status ：为待分配 401 ，valid_status：已分配 402
  ave_point          number(20, 6);
  last_mon_first_day date; /*上月第一天*/
  curr_mon_first_day date; /*本月第一天*/
  next_mon_first_day date; /*下月第一天*/
  v_use_count        int;  /*有效用户的数量*/
  tmp_total          number(20, 6); /*当前用坐席总费用*/
  beginDate          date;
  endDate            date;
  radix              number(3, 2) := 1.20; /*基数*/
  user_cnt           int := 0; /*坐席总数*/
  sql_str            varchar2(50):='';

  /*欠缴件按照续收代表及其客户，参数游标*/
  cursor cur_use_cus(startdate date, enddate date, valid_status number) is
    select use_ali_id, apid, idtype
      from xq_reminder
     where is_delete is null
       and cover1 >= startdate
       and cover1 < enddate
       and status = valid_status
     group by use_ali_id, apid, idtype;
  v_use_cus cur_use_cus%rowtype;

  /*应缴件按照客户归类费用倒序，参数游标*/
  cursor cur_reminder_cus(startdate date, enddate date, to_task_status number) is
    select idtype, apid, sum(amount) amount
      from xq_reminder
     where is_delete is null
       and cover1 >= startdate
       and cover1 < enddate
       and status = to_task_status
     group by idtype, apid
     order by amount desc; --本月月底包括以前的待分配应缴件
  v_reminder_cus cur_reminder_cus%rowtype;

begin
  last_mon_first_day := trunc(add_months(sysdate, -1), 'mm');
  curr_mon_first_day := trunc(sysdate, 'mm');
  next_mon_first_day := trunc(add_months(sysdate, +1), 'mm');
  beginDate          := nvl(to_date(v_beginDate, 'yyyy-mm-dd'),curr_mon_first_day);
  endDate            := nvl(to_date(v_endDate, 'yyyy-mm-dd'),next_mon_first_day);

  /*把失效保单对应的应缴件置为失效状态*/
  begin
    update xq_reminder x
     set x.status = '406'
     where x.policyno in
         (select policyno
            from xq_app xa
           where xa.polist in ('202', '203', '205'))
     and x.status in ('401', '402', '403')
     and to_char(x.cover1, 'YYYY-MM') <= to_char(sysdate, 'YYYY-MM');
    commit;
  end;

  /*清空临时表:生产库上不能使用truncate命令，所以这里只能使用delete*/
  sql_str:='delete from sys_task_users_tmp';
  execute immediate sql_str;
  commit;

  /*向临时表中插入坐席信息*/
  begin
    insert into sys_task_users_tmp
           select use_ali_id, 0 amount from (
                  select u.use_ali_id
                      from c_use u
                      where u.rig_sta_id = 3
                       and u.use_flag = '1'
                       and not exists
                     (select 1 from c_use_par p
                             where p.cat_id in (802007, 802008, 802009)
                               and p.val = '1'
                               and p.use_id = u.use_id)
                    minus
                    select use_ali_id from xq_reminder
                     where is_delete is null
                       and cover1 >= last_mon_first_day
                       and cover1 < curr_mon_first_day
                       and status = valid_status
              ) t;
    commit;
  end;
  begin
  insert into sys_task_users_tmp
         select xr.use_ali_id, sum(xr.amount) amount
            from xq_reminder xr
           where is_delete is null
             and cover1 >= last_mon_first_day
             and cover1 < curr_mon_first_day
             and status = valid_status
             and exists
             (select 1 from c_use u
                   where u.use_ali_id = xr.use_ali_id
                     and u.use_flag = '1'
                     and u.rig_sta_id = 3
                     and not exists
                   (select 1
                            from c_use_par p
                           where p.cat_id in (802007, 802008, 802009)
                             and p.val = '1'
                             and p.use_id = u.use_id)
              )
           group by use_ali_id
           order by amount asc;
  commit;
  end;
  /*均分点，按照续收代表上月欠缴最多费用*/
  select nvl(max(m.amount), 0)
    into ave_point
    from (select sum(r1.amount) amount
            from xq_reminder r1
           where is_delete is null
             and r1.cover1 >= last_mon_first_day
             and r1.cover1 < curr_mon_first_day
             and r1.status = valid_status
           group by r1.use_ali_id) m;

  select count(1) into user_cnt from  sys_task_users_tmp;
  ave_point := ave_point * user_cnt * radix;

  /*查询本月未分配的应缴件按客户归类，费用倒序*/
  open cur_reminder_cus(beginDate, endDate, to_task_status);

  if ave_point > 0 then
    /*首先，上月未完成应缴件，本月应缴件该客户所有应缴件分配给该坐席*/
    /*上月应缴件，按照续收代表和客户归类 */
    open cur_use_cus(last_mon_first_day, curr_mon_first_day, valid_status);
    begin
      loop
        fetch cur_use_cus
          into v_use_cus;
        exit when cur_use_cus%notfound;
        select count(1)
          into v_use_count
          from c_use u
         where u.rig_sta_id = 3
           and u.use_flag = '1'
           and u.use_ali_id = v_use_cus.use_ali_id
           and not exists (select 1
                  from c_use_par p
                 where p.cat_id in (802007, 802008, 802009)
                   and p.val = '1'
                   and p.use_id = u.use_id);
        if v_use_count is not null and v_use_count > 0 then
          /*判断有效用户*/
          update xq_reminder
             set use_ali_id = v_use_cus.use_ali_id,
                 status     = valid_status,
                 task_date  = sysdate
           where is_delete is null
             and apid = v_use_cus.apid
             and cover1 >= beginDate
             and cover1 < endDate
             and status = to_task_status
             and idtype = v_use_cus.idtype;
        end if;
      end loop;
    exception
      when others then
        null;
    end;
    commit;
    if cur_use_cus%isopen then
      close cur_use_cus;
    end if;

    if cur_reminder_cus%isopen=false then
       open cur_reminder_cus(beginDate, endDate, to_task_status);
    end if;
    begin
      loop
        if tmp_total>= ave_point then/*大于或等于均分点，退出按均分点轮盘*/
           exit;
        end if;
        /*for循环结合游标使用，游标自动打开或关闭*/
        for user_info  in (select user_ali_id,  amount  from sys_task_users_tmp order by amount asc) loop
          fetch cur_reminder_cus into v_reminder_cus;
          exit when cur_reminder_cus%notfound;

          update xq_reminder  set use_ali_id=user_info.user_ali_id, status=valid_status, task_date=sysdate
           where is_delete is null
             and idtype = v_reminder_cus.idtype
             and apid = v_reminder_cus.apid
             and cover1 >= beginDate
             and cover1 < endDate
             and status = to_task_status;
          tmp_total:= tmp_total + v_reminder_cus.amount;/*累加均分点*/

        end loop;
        exit when cur_reminder_cus%notfound;
      end loop;
      commit;
    end;
    /*按均分点轮盘结束*/
  end if;

  /*按照坐席级别排序倒序,轮盘式分配*/
  begin
    if cur_reminder_cus%isopen = false then
      open cur_reminder_cus(beginDate, endDate, to_task_status);
    end if;
    loop
      for v_use_level in (select cu.use_ali_id, cu.use_level
                            from c_use cu
                           where cu.rig_sta_id = 3
                             and cu.use_flag = '1'
                             and not exists
                           (select 1
                                    from c_use_par p
                                   where p.cat_id in (802007, 802008, 802009)
                                     and p.val = '1'
                                     and p.use_id = cu.use_id)
                           order by use_level desc) loop
        fetch cur_reminder_cus
          into v_reminder_cus; /*本月应缴件按客户倒序*/
        exit when cur_reminder_cus%notfound;
        update xq_reminder
           set use_ali_id = v_use_level.use_ali_id,
               status     = valid_status,
               task_date  = sysdate
         where is_delete is null
           and idtype = v_reminder_cus.idtype
           and apid = v_reminder_cus.apid
           and cover1 >= beginDate
           and cover1 < endDate
           and status = to_task_status;
      end loop;
      commit;
      exit when cur_reminder_cus%notfound;
    end loop;
  exception
    when others then
      null;
  end;
  if cur_use_cus%isopen then
    close cur_use_cus;
  end if;
  if cur_reminder_cus%isopen then
    close cur_reminder_cus;
  end if;
end p_xq_systask_reminder_0607;
/

prompt
prompt Creating procedure P_XQ_SYSTASK_REMINDER_EVERYDAY
prompt =================================================
prompt
create or replace procedure unicall.P_XQ_SYSTASK_REMINDER_EVERYDAY
(
       to_task_status in number,
       valid_status   in number,
       v_endDate      in varchar2
) is
   v_user_count int;
   endDate date;

   cursor c_user_customer(p_endDate date,p_valid_status number) is
      select rem.use_ali_id use_ali_id,rem.apid apid,rem.idtype idtype
      from xq_reminder rem
      where rem.cover1<=p_endDate
      and rem.status=p_valid_status
      and rem.is_delete is null
      group by use_ali_id,apid,idtype;

   v_cur_user_cus c_user_customer%rowtype;

   --应缴件按照客户分组，然后根据应缴金额倒序排列
   cursor c_reminder_customer(p_endDate date,p_to_task_status number) is
      select rem.idtype idtype,rem.apid apid ,sum(rem.amount) amt
      from xq_reminder rem
      where rem.cover1<=p_endDate
      and rem.status=p_to_task_status
      and rem.is_delete is null
      group by idtype,apid
      order by amt desc;

   v_cur_reminder_cus c_reminder_customer%rowtype;

begin

  /*把失效保单对应的应缴件置为失效状态*/
  begin
    update xq_reminder x
     set x.status = '406'
     where x.policyno in
         (select policyno
            from xq_app xa
           where xa.polist in ('202', '203', '205'))
     and x.status in ('401', '402', '403')
     and to_char(x.cover1, 'YYYY-MM') <= to_char(sysdate, 'YYYY-MM');
    commit;
  end;


  /*查询本月未分配的应缴件按客户归类，费用倒序*/
  endDate:=nvl(to_date(v_endDate,'yyyy-mm-dd'),sysdate);
  open c_reminder_customer(endDate,to_task_status);
  open c_user_customer(endDate, valid_status);
  begin
      loop
          fetch c_user_customer into v_cur_user_cus;
          exit when c_user_customer%notfound;

          select count(1) into v_user_count
           from c_use u
           where u.rig_sta_id = 3
           and u.use_flag = '1'
           and u.use_ali_id = v_cur_user_cus.use_ali_id
           and not exists(
              select 1   from c_use_par p
              where p.cat_id in (802007, 802008, 802009)
              and p.val = '1'
              and p.use_id = u.use_id
           );
           if v_user_count is not null and v_user_count > 0 then
          /**判断有效用户**/
           update xq_reminder
             set use_ali_id = v_cur_user_cus.use_ali_id, status = valid_status,task_date=sysdate
             where idtype = v_cur_user_cus.idtype
             and apid = v_cur_user_cus.apid
             and cover1 <= endDate
             and status = to_task_status
             and is_delete is null;
            end if;
      end loop;
      exception
      when others then
        null;
    end;
    commit;
    if c_user_customer%isopen then
       close c_user_customer;
    end if;
    /**按照坐席级别排序倒序,轮盘式分配**/
    begin
      if c_reminder_customer%isopen = false then
        open c_reminder_customer(endDate,to_task_status);
      end if;
      loop
        for v_use_level in (select cu.use_ali_id, cu.use_level
                            from c_use cu
                            where cu.rig_sta_id = 3
                            and cu.use_flag = '1'
                            and cu.is_task = '1'
                            and not exists
                              (
                                  select 1
                                  from c_use_par p
                                  where p.cat_id in (802007, 802008, 802009)
                                  and p.val = '1'
                                  and p.use_id = cu.use_id
                               )
                             order by use_level desc
                             )
          loop
             fetch c_reminder_customer into v_cur_reminder_cus; /**本月应缴件按客户倒序**/
             exit when c_reminder_customer%notfound;
             update xq_reminder
             set use_ali_id = v_use_level.use_ali_id, status = valid_status,task_date=sysdate
             where idtype = v_cur_reminder_cus.idtype
             and apid = v_cur_reminder_cus.apid
             and cover1 <= endDate
             and status = to_task_status
             and is_delete is null;
          end loop;
          commit;
        exit when c_reminder_customer%notfound;
      end loop;
    exception
      when others then
        null;
    end;
    if c_user_customer%isopen then
       close c_user_customer;
    end if;
    if c_reminder_customer%isopen then
       close c_reminder_customer;
    end if;
end P_XQ_SYSTASK_REMINDER_EVERYDAY;
/

prompt
prompt Creating procedure P_XQ_SYSTASK_REMINDER_HUAYI
prompt ==============================================
prompt
create or replace procedure unicall.p_xq_systask_reminder_huayi (to_task_status in number,
                                                         valid_status   in number,
                                                         v_beginDate    varchar2,
                                                         v_endDate      varchar2) is
  --to_task_status ：为待分配 401 ，valid_status：已分配 402
  ave_point          number(20, 6);
  last_mon_first_day date; /*上月第一天*/
  curr_mon_first_day date; /*本月第一天*/
  next_mon_first_day date; /*下月第一天*/
  v_use_count        int;  /*有效用户的数量*/
  tmp_total          number(20, 6); /*当前用坐席总费用*/
  beginDate date;
  endDate date;
  radix   number(3,2):=1.10; /*基数*/
  user_cnt int:=0; /*坐席总数*/

  /*欠缴件按照续收代表及其客户，参数游标*/
  cursor cur_use_cus(startdate date, enddate date, valid_status number) is
    select use_ali_id, apid, idtype
      from xq_reminder
     where is_delete is null
        and cover1 >= startdate
       and cover1 < enddate
       and status = valid_status
     group by use_ali_id, apid, idtype;
  v_use_cus cur_use_cus%rowtype;

  /*应缴件按照客户归类费用倒序，参数游标*/
  cursor cur_reminder_cus(startdate      date,
                          enddate        date,
                          to_task_status number) is
    select idtype, apid, sum(amount) amount
      from xq_reminder
     where is_delete is null
       and cover1 >=startdate
       and cover1 < enddate
       and status = to_task_status
     group by idtype, apid
     order by amount desc; --本月月底包括以前的待分配应缴件
  v_reminder_cus cur_reminder_cus%rowtype;

begin
  last_mon_first_day := trunc(add_months(sysdate, -1), 'mm');
  curr_mon_first_day := trunc(sysdate, 'mm');
  next_mon_first_day := trunc(add_months(sysdate, +1), 'mm');
  beginDate:= nvl(to_date(v_beginDate,'yyyy-mm-dd'),curr_mon_first_day);
  endDate:=nvl(to_date(v_endDate,'yyyy-mm-dd'),next_mon_first_day);

  /*创建临时表*/
  create global temporary table users_info
  (
     user_ali_id varchar2(20),
     amount number(20,6)
  ) on commit delete rows;

  --插入新坐席
  insert into users_info select u.use_ali_id,0 amount from (
              select u.use_ali_id from c_use u
                  where u.rig_sta_id = 3
                  and u.use_flag = '1'
                  and not exists
                (select 1
                         from c_use_par p
                        where p.cat_id in (802007, 802008, 802009)
                          and p.val = '1'
                          and p.use_id = u.use_id)
               minus
               select use_ali_id
                 from xq_reminder
                where is_delete is null
                  and cover1 >= last_mon_first_day
                  and cover1 < curr_mon_first_day
                  and status = valid_status
            );
   commit;
   insert into users_info select xr.use_ali_id, sum(xr.amount) amount
      from xq_reminder xr
     where is_delete is null
        and cover1 >= startdate
       and cover1 < enddate
       and status = valid_status
       and exists (select 1
              from c_use u
             where u.use_ali_id = xr.use_ali_id
               and u.use_flag = '1'
               and u.rig_sta_id = 3
               and not exists
             (select 1
                      from c_use_par p
                     where p.cat_id in (802007, 802008, 802009)
                       and p.val = '1'
                       and p.use_id = u.use_id))
     group by use_ali_id
     order by amount asc;
    commit;

  /*均分点，按照续收代表上月欠缴最多费用*/
  select nvl(max(m.amount),0)
    into ave_point
    from (select sum(r1.amount) amount
            from xq_reminder r1
           where r1.cover1 >= last_mon_first_day
             and r1.cover1 < curr_mon_first_day
             and r1.status = valid_status
           group by r1.use_ali_id) m;
   select count(1) into user_cnt from users_info;
   ave_point:= ave_point*user_cnt*radix;

  /*查询本月未分配的应缴件按客户归类，费用倒序*/
  open cur_reminder_cus(beginDate,endDate,to_task_status);

  if ave_point > 0 then
    /*首先，上月未完成应缴件，本月应缴件该客户所有应缴件分配给该坐席*/
    /*上月应缴件，按照续收代表和客户归类 */
    open cur_use_cus(last_mon_first_day, curr_mon_first_day, valid_status);
    begin
      loop
        fetch cur_use_cus
          into v_use_cus;
        exit when cur_use_cus%notfound;
        select count(1)
          into v_use_count
          from c_use u
         where u.rig_sta_id = 3
           and u.use_flag = '1'
           and u.use_ali_id = v_use_cus.use_ali_id
           and not exists (select 1 from c_use_par p
                 where p.cat_id in (802007, 802008, 802009)
                   and p.val = '1'
                   and p.use_id = u.use_id);
        if v_use_count is not null and v_use_count > 0 then
          /*判断有效用户*/
          update xq_reminder
             set use_ali_id = v_use_cus.use_ali_id, status = valid_status,task_date=sysdate
           where idtype = v_use_cus.idtype
             and apid = v_use_cus.apid
             and cover1>= beginDate
             and cover1 < endDate
             and status = to_task_status;
        end if;
      end loop;
    exception
      when others then
        null;
    end;
    commit;

    if cur_use_cus%isopen then
       close cur_use_cus;
    end if;

    begin

    /*按均分点轮盘开始*/
    if cur_reminder_cus%isopen = false then
      open cur_reminder_cus(beginDate,endDate,to_task_status);
    end if;

    loop
      for u1 in (select user_ali_id,amount from users_info) loop
        fetch cur_reminder_cus
          into v_reminder_cus;
        exit when cur_reminder_cus%notfound;
        update xq_reminder
           set use_ali_id = u1.user_ali_id, status = valid_status,task_date=sysdate
         where idtype = v_reminder_cus.idtype
           and apid = v_reminder_cus.apid
           and cover1 >= beginDate
           and cover1 < endDate
           and status = to_task_status;
           tmp_total:= tmp_total+v_reminder_cus.amount;
       end loop;
       commit;
       /*大于均分点,推出循环*/
       if tmp_total>=ave_point then
        exit;
       end if;
      exit when cur_reminder_cus%notfound;
    end loop;
  exception
    when others then
      null;
  end;
  /*按均分点轮盘结束*/
  end if;
  if cur_reminder_use%isopen then
    close cur_reminder_use;
  end if;
  /*按照坐席级别排序倒序,轮盘式分配*/
  begin
    if cur_reminder_cus%isopen = false then
      open cur_reminder_cus(beginDate,endDate,to_task_status);
    end if;
    loop
      for v_use_level in (select cu.use_ali_id, cu.use_level
                            from c_use cu
                           where cu.rig_sta_id = 3
                             and cu.use_flag = '1'
                             and not exists
                           (select 1 from c_use_par p
                                   where p.cat_id in (802007, 802008, 802009)
                                     and p.val = '1'
                                     and p.use_id = cu.use_id)
                           order by use_level desc) loop
        fetch cur_reminder_cus
          into v_reminder_cus; /*本月应缴件按客户倒序*/
        exit when cur_reminder_cus%notfound;
        update xq_reminder
           set use_ali_id = v_use_level.use_ali_id, status = valid_status,task_date=sysdate
         where idtype = v_reminder_cus.idtype
           and apid = v_reminder_cus.apid
           and cover1 >= beginDate
           and cover1 < endDate
           and status = to_task_status;
      end loop;
      commit;
      exit when cur_reminder_cus%notfound;
    end loop;
  exception
    when others then
      null;
  end;
  if cur_reminder_cus%isopen then
     close cur_reminder_cus;
  end if;
  if cur_use_cus%isopen then
    close cur_use_cus;
  end if;
  if cur_reminder_cus%isopen then
    close cur_reminder_cus;
  end if;
  if cur_reminder_use%isopen then
    close cur_reminder_use;
  end if;
end p_xq_systask_reminder_huayi;
/

prompt
prompt Creating procedure P_XQ_TEST_UPDATE_PRIMARY
prompt ===========================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_TEST_UPDATE_PRIMARY IS
  /*
  ******************************************************
  *  存储过程名 ：P_XQ_TEST_UPDATE_PRIMARY
  *  建立日期   ：2012-07-16
  *  作者       ：yangguoqi
  *  模块       ：测试UAT
  *  描述       ：统一更新主键sno在c_id_bro表中最大记录键值
  *----------------------------------------------------
  *  修改历史   日期    修改人    修改原因
  *  1
  *  2
  ******************************************************
  */
  v_excutesql varchar2(4000); --存储更新sql
  v_is_sno    varchar2(40); --存储是否存在sno列
  CURSOR cur_info IS
    SELECT * FROM c_id_bro;
  v_info cur_info%ROWTYPE;

begin

  OPEN cur_info;
  LOOP
    FETCH cur_info
      INTO v_info;
    EXIT WHEN cur_info%NOTFOUND;
  
    select (select column_name
              from user_tab_columns r
             where r.TABLE_NAME = upper(v_info.name)
               and column_name = 'SNO')
      into v_is_sno
      from dual;
  
    IF v_is_sno is not null THEN
    
      v_excutesql := 'update c_id_bro t set t.nextvalue = nvl((select max(sno) from ' ||
                     v_info.name || '),0) where t.name=:v_name';
    
      execute immediate v_excutesql
        using v_info.name;
      commit; --每条更新
    end if;
  end loop;
  close cur_info;

EXCEPTION
  WHEN OTHERS THEN
    begin
      rollback;
    
      if cur_info%isopen then
        CLOSE cur_info;
      end if;
    
      rollback;
    
      dbms_output.put_line('P_XQ_TEST_UPDATE_PRIMARY ERROR' || sqlerrm);
    
    end;
END P_XQ_TEST_UPDATE_PRIMARY;
/

prompt
prompt Creating procedure P_XQ_TRANSFER_UPDATE
prompt =======================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.P_XQ_TRANSFER_UPDATE IS
  v_chgconid       number(18) := 0;
  v_chgconid1      number(18) := 0;
  v_chgconid2      number(18) := 0;
  v_transferid     varchar2(11);
  v_pos_coun_id    number(18) := 0;
  v_pos_id_coun_id number(18) := 0;

  CURSOR cur_app_pos_info IS
    SELECT * FROM app_pos ap;
  v_app_pos_info cur_app_pos_info%ROWTYPE;

  CURSOR cur_app_pos_id_info IS
    SELECT * FROM app_pos_id ap;
  v_app_pos_id_info cur_app_pos_id_info%ROWTYPE;

BEGIN
  --通过app_con表更新xq_transfer表
  OPEN cur_app_pos_info;
  --从表c_id_bro，取出xq_riskcon主键值，存入变量 coun_id
  SELECT b.nextvalue
    INTO v_pos_coun_id
    FROM c_id_bro b
   WHERE b.name = 'xq_app_pos';

  LOOP
    FETCH cur_app_pos_info
      INTO v_app_pos_info;
    EXIT WHEN cur_app_pos_info%NOTFOUND;

    --从字典表xq_dict获取对应的id
    IF v_app_pos_info.changeid = '11' OR v_app_pos_info.changeid = '12' OR
       v_app_pos_info.changeid = '29' THEN
      SELECT (SELECT xd.id
                FROM xq_dict xd
               WHERE (xd.parent_id = 1701 OR xd.parent_id = 1702)
                 AND xd.item_code = v_app_pos_info.changeid || '01')
        INTO v_chgconid
        FROM dual;
      SELECT (SELECT xd.id
                FROM xq_dict xd
               WHERE (xd.parent_id = 1701 OR xd.parent_id = 1702)
                 AND xd.item_code = v_app_pos_info.changeid || '02')
        INTO v_chgconid1
        FROM dual;
      SELECT (SELECT xd.id
                FROM xq_dict xd
               WHERE (xd.parent_id = 1701 OR xd.parent_id = 1702)
                 AND xd.item_code = v_app_pos_info.changeid || '03')
        INTO v_chgconid2
        FROM dual;
    ELSE
      SELECT (SELECT xd.id
                FROM xq_dict xd
               WHERE (xd.parent_id = 1701 OR xd.parent_id = 1702)
                 AND xd.item_code = v_app_pos_info.changeid)
        INTO v_chgconid
        FROM dual;
    END IF;

    --根据policyno,app_con,record_time向正式表xq_transfer查询，将 transfer_id  分别存入变量 v_chgconid
    SELECT (SELECT x.transfer_id
              FROM xq_transfer x
             WHERE (x.app_con = v_chgconid OR x.app_con = v_chgconid1 OR
                   x.app_con = v_chgconid2)
               AND x.policyno = v_app_pos_info.policyno
               AND x.record_time < v_app_pos_info.procdate
               AND x.tran_sta <> '1604'
               AND rownum = 1)
      INTO v_transferid
      FROM dual;
    --如果正式表 xq_transfer 存在数据更新，否则跳过。
    IF v_transferid IS NOT NULL THEN
      BEGIN
        --更新xq_transfer表.tran_sta和tran_end_date两个字段
        UPDATE xq_transfer x
           SET x.tran_sta = '1604', x.tran_end_date = SYSDATE
         WHERE (x.app_con = v_chgconid OR x.app_con = v_chgconid1 OR
               x.app_con = v_chgconid2)
           AND x.policyno = v_app_pos_info.policyno
           AND x.record_time < v_app_pos_info.procdate
           AND x.tran_sta <> '1604';

        --插入表xq_app_pos
        v_pos_coun_id := v_pos_coun_id + 1;
        INSERT INTO xq_app_pos
          (SNO,
           TYPEID,
           CHANGEID,
           STATUS,
           PROCDATE,
           ABSTR,
           APPDATE,
           MODINO,
           CON_ID,
           POLICYNO,
           CLASSCODE,
           OPDATE,
           OPERID,
           OPERNO,
           OPER_ROLE,
           ID,
           NAME,
           VERI_NO,
           VERI_DATE,
           APP_CHANNEL,
           BEGTIME,
           ENDTIME,
           BRANCH,
           ETL_TIME,
           SRC_SYS)
        VALUES
          (v_pos_coun_id,
           v_app_pos_info.typeid,
           v_app_pos_info.changeid,
           v_app_pos_info.status,
           v_app_pos_info.procdate,
           v_app_pos_info.ABSTR,
           v_app_pos_info.APPDATE,
           v_app_pos_info.MODINO,
           v_app_pos_info.CON_ID,
           v_app_pos_info.POLICYNO,
           v_app_pos_info.CLASSCODE,
           v_app_pos_info.OPDATE,
           v_app_pos_info.OPERID,
           v_app_pos_info.OPERNO,
           v_app_pos_info.OPER_ROLE,
           v_app_pos_info.ID,
           v_app_pos_info.NAME,
           v_app_pos_info.VERI_NO,
           v_app_pos_info.VERI_DATE,
           v_app_pos_info.APP_CHANNEL,
           v_app_pos_info.BEGTIME,
           v_app_pos_info.ENDTIME,
           v_app_pos_info.BRANCH,
           v_app_pos_info.ETL_TIME,
           v_app_pos_info.SRC_SYS);
      EXCEPTION
        WHEN OTHERS THEN
          -- 遇到异常做一些处理
          BEGIN
            dbms_output.put_line('data error :' || v_app_pos_info.policyno);
          END;
      END;
      COMMIT;
    END IF;
  END LOOP;
  CLOSE cur_app_pos_info;
  --更新id表c_id_bro的值
  UPDATE c_id_bro b
     SET b.nextvalue = v_pos_coun_id
   WHERE b.name = 'xq_app_pos';
  COMMIT;

  --通过app_con_id表更新xq_transfer表
  OPEN cur_app_pos_id_info;
  --从表c_id_bro，取出xq_riskcon主键值，存入变量 coun_id
  SELECT b.nextvalue
    INTO v_pos_id_coun_id
    FROM c_id_bro b
   WHERE b.name = 'xq_app_pos_id';

  LOOP
    FETCH cur_app_pos_id_info
      INTO v_app_pos_id_info;
    EXIT WHEN cur_app_pos_id_info%NOTFOUND;

    --从字典表xq_dict获取对应的id
    IF v_app_pos_id_info.changeid = '11' OR v_app_pos_id_info.changeid = '12' OR
       v_app_pos_id_info.changeid = '29' THEN
      SELECT (SELECT xd.id
                FROM xq_dict xd
               WHERE (xd.parent_id = 1701 OR xd.parent_id = 1702)
                 AND xd.item_code = v_app_pos_id_info.changeid || '01')
        INTO v_chgconid
        FROM dual;
      SELECT (SELECT xd.id
                FROM xq_dict xd
               WHERE (xd.parent_id = 1701 OR xd.parent_id = 1702)
                 AND xd.item_code = v_app_pos_id_info.changeid || '02')
        INTO v_chgconid1
        FROM dual;
      SELECT (SELECT xd.id
                FROM xq_dict xd
               WHERE (xd.parent_id = 1701 OR xd.parent_id = 1702)
                 AND xd.item_code = v_app_pos_id_info.changeid || '03')
        INTO v_chgconid2
        FROM dual;
    ELSE
      SELECT (SELECT xd.id
                FROM xq_dict xd
               WHERE (xd.parent_id = 1701 OR xd.parent_id = 1702)
                 AND xd.item_code = v_app_pos_id_info.changeid)
        INTO v_chgconid
        FROM dual;
    END IF;
    --根据id或id15,app_con,record_time向正式表xq_transfer查询，将 transfer_id  分别存入变量 v_chgconid
    SELECT (SELECT x.transfer_id
              FROM xq_transfer x
             WHERE (x.app_con = v_chgconid OR x.app_con = v_chgconid1 OR
                   x.app_con = v_chgconid2)
               AND (x.apid = v_app_pos_id_info.id OR
                   x.apid = v_app_pos_id_info.id15)
               AND x.record_time < v_app_pos_id_info.procdate
               AND x.tran_sta <> '1604'
               AND rownum = 1)
      INTO v_transferid
      FROM dual;
    --如果正式表 xq_transfer 存在数据更新，否则跳过。
    IF v_transferid IS NOT NULL THEN
      BEGIN
        --更新xq_transfer表.tran_sta和tran_end_date两个字段
        UPDATE xq_transfer x
           SET x.tran_sta = '1604', x.tran_end_date = SYSDATE
         WHERE (x.app_con = v_chgconid OR x.app_con = v_chgconid1 OR
               x.app_con = v_chgconid2)
           AND (x.apid = v_app_pos_id_info.id OR
               x.apid = v_app_pos_id_info.id15)
           AND x.record_time < v_app_pos_id_info.procdate
           AND x.tran_sta <> '1604';
        --插入表xq_app_pos_id
        v_pos_id_coun_id := v_pos_id_coun_id + 1;
        INSERT INTO xq_app_pos_id
          (SNO,
           TYPEID,
           CHANGEID,
           STATUS,
           PROCDATE,
           ABSTR,
           APPDATE,
           MODINO,
           CON_ID,
           OID_NUM,
           ID,
           ID15,
           OPDATE,
           OPERID,
           OPERNO,
           OPER_ROLE,
           VERI_NO,
           VERI_DATE,
           APP_CHANNEL,
           BEGTIME,
           ENDTIME,
           BRANCH,
           ETL_TIME,
           SRC_SYS)
        VALUES
          (v_pos_id_coun_id,
           v_app_pos_id_info.TYPEID,
           v_app_pos_id_info.CHANGEID,
           v_app_pos_id_info.STATUS,
           v_app_pos_id_info.PROCDATE,
           v_app_pos_id_info.ABSTR,
           v_app_pos_id_info.APPDATE,
           v_app_pos_id_info.MODINO,
           v_app_pos_id_info.CON_ID,
           v_app_pos_id_info.OID_NUM,
           v_app_pos_id_info.ID,
           v_app_pos_id_info.ID15,
           v_app_pos_id_info.OPDATE,
           v_app_pos_id_info.OPERID,
           v_app_pos_id_info.OPERNO,
           v_app_pos_id_info.OPER_ROLE,
           v_app_pos_id_info.VERI_NO,
           v_app_pos_id_info.VERI_DATE,
           v_app_pos_id_info.APP_CHANNEL,
           v_app_pos_id_info.BEGTIME,
           v_app_pos_id_info.ENDTIME,
           v_app_pos_id_info.BRANCH,
           v_app_pos_id_info.ETL_TIME,
           v_app_pos_id_info.SRC_SYS);
      EXCEPTION
        WHEN OTHERS THEN
          -- 遇到异常做一些处理
          BEGIN
            dbms_output.put_line('data error :' || v_app_pos_id_info.id);
          END;
      END;
      COMMIT;
    END IF;
  END LOOP;
  CLOSE cur_app_pos_id_info;
  --更新id表c_id_bro的值
  UPDATE c_id_bro b
     SET b.nextvalue = v_pos_id_coun_id
   WHERE b.name = 'xq_app_pos_id';
  COMMIT;

EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      ROLLBACK;
      dbms_output.put_line('ERROR');
    END;
END P_XQ_TRANSFER_UPDATE;
/

prompt
prompt Creating procedure P_XQ_UPDATE_STATUS
prompt =====================================
prompt
create or replace procedure unicall.P_XQ_UPDATE_STATUS is

begin

     --更新xq_reminder表cover1大于等于next_date状态设置为未缴

      update xq_reminder rr
        set rr.status = 402
       where rr.reminder_id in
             (select xr.reminder_id
                from xq_reminder xr, xq_moneysch xm
               where xr.policyno = xm.policyno
                 and trunc(xr.cover1, 'mm') >= trunc(xm.nextdate, 'mm') --下次缴费月>应缴月
                 and xr.status in (404) --'待审核'，‘待催缴’
                 and xr.use_ali_id is not null
                 and xr.is_delete is null
                 and exists (select 1
                        from xq_riskcon r
                       where xr.policyno = r.policyno
                         and r.polist <> '107'
                         and r.classcode in
                             (select p.classcode
                                from xq_riskclass p
                               where p.timestr = '1')));

     commit;


     update xq_reminder rr
        set rr.status = 401
       where rr.reminder_id in
             (select xr.reminder_id
                from xq_reminder xr, xq_moneysch xm
               where xr.policyno = xm.policyno
                 and trunc(xr.cover1, 'mm') >= trunc(xm.nextdate, 'mm') --下次缴费月>应缴月
                 and xr.status in (404) --'待审核'，‘待催缴’
                 and xr.use_ali_id is null
                 and xr.is_delete is null
                 and exists (select 1
                        from xq_riskcon r
                       where xr.policyno = r.policyno
                         and r.polist <> '107'
                         and r.classcode in
                             (select p.classcode
                                from xq_riskclass p
                               where p.timestr = '1')));


        commit;

      --更新xq_reminder表cover1小于 next_date状态设置为404

      update xq_reminder rr
         set rr.status = 404
       where rr.reminder_id in
         (select xr.reminder_id
            from xq_reminder xr, xq_moneysch xm
           where xr.policyno = xm.policyno
             and trunc(xr.cover1, 'mm') < trunc(xm.nextdate, 'mm') --下次缴费月>应缴月
             and xr.status in (401,402,403,406)
             and xr.is_delete is null
             and exists (select 1
                    from xq_riskcon r
                   where xr.policyno = r.policyno
                     and r.polist <> '107'
                     and r.classcode in
                         (select p.classcode
                            from xq_riskclass p
                           where p.timestr = '1')));


      commit;


      --更新xq_reminder表cover1大于等于next_date状态并且保单状态等于生退保的设置为未缴

      update xq_reminder rr
        set rr.status = 402
       where rr.reminder_id in
             (select xr.reminder_id
                from xq_reminder xr, xq_moneysch xm
               where xr.policyno = xm.policyno
                 and xr.cover1 >= xm.nextdate --下次缴费月>应缴月
                 and xr.status in (404) --'待审核'，‘待催缴’
                 and xr.use_ali_id is not null
                 and xr.is_delete is null
                 and exists (select 1
                        from xq_riskcon r
                       where xr.policyno = r.policyno
                         and r.polist = '107'
                         and r.classcode in
                             (select p.classcode
                                from xq_riskclass p
                               where p.timestr = '1')));

     commit;


     update xq_reminder rr
        set rr.status = 401
       where rr.reminder_id in
             (select xr.reminder_id
                from xq_reminder xr, xq_moneysch xm
               where xr.policyno = xm.policyno
                 and xr.cover1 >= xm.nextdate --下次缴费月>应缴月
                 and xr.status in (404) --'待审核'，‘待催缴’
                 and xr.use_ali_id is null
                 and xr.is_delete is null
                 and exists (select 1
                        from xq_riskcon r
                       where xr.policyno = r.policyno
                         and r.polist = '107'
                         and r.classcode in
                             (select p.classcode
                                from xq_riskclass p
                               where p.timestr = '1')));


        commit;

    --更新xq_reminder表cover1小于 next_date状态并且保单状态等于生退保的设置为404
    update xq_reminder rr
       set rr.status = 404
     where rr.reminder_id in
       (select xr.reminder_id
          from xq_reminder xr, xq_moneysch xm
         where xr.policyno = xm.policyno
           and xr.cover1 < xm.nextdate
           and xr.status in (401,402,403,406)
           and xr.is_delete is null
           and exists (select 1
                  from xq_riskcon r
                 where xr.policyno = r.policyno
                   and r.polist = '107'
                   and r.classcode in
                       (select p.classcode
                          from xq_riskclass p
                         where p.timestr = '1')));
     commit;

    update xq_task_apply xta
       set xta.apply_sta = '0', xta.approve_use_ali = 'system' --'审核失败'
     where xta.apply_sta = '2' --'待审核'
       and exists (select 1
              from xq_reminder r
             where xta.reminder_id = r.reminder_id
               and r.status = 404);
    commit;

EXCEPTION
  when others then
    begin
       dbms_output.put_line('Error');
    end;

end P_XQ_UPDATE_STATUS;
/

prompt
prompt Creating procedure RESERVE_EXPORT
prompt =================================
prompt
create or replace procedure unicall.RESERVE_EXPORT(flag out varchar2) is

     sqlvar varchar2(30000) :='';
     type mycursor is ref cursor;
     mycur mycursor;
     myrow tb_reservetask_list%rowtype;
     v_insertsql varchar2(2000);

begin
     flag  := '1';
     sqlvar :='
       select c.app_date as app_date, -- 成交日期,
       c.appno as appno, -- 投保单号,
       decode(a.sale_src, ''04'', ''先收费'', ''05'', ''先出单'', '''') as app_typ, -- 保单类型,
       c.policyno as policyno,   --保单号,
       j.company_name as company_name, -- 地区,
       l.org_name as prj_name,-- 项目名称,
       (select t1.name
          from shcpic_insurance t1, shcpic_insurance_term_code t2
         where t1.id = t2.insurance_id
           and t2.insurance_code = g.ins_code
           and rownum = 1) insurance_name , -- 险种,
       b.tsrid as tsrid, -- 工号,
       b.acus_name as acus_name,-- 投保人姓名,
       b.acus_licno as acus_licno,-- 证件号码,
       h.adds_detail as adds_detail,-- 地址,
       b.acus_mob as con_value,-- 联系方式,
       b.total_fee as total_fee,-- 首期保费,
       decode(g.pay_typ,
              ''12'',
              b.total_fee * 2,
              ''11'',
              b.total_fee * 4,
              ''10'',
              b.total_fee * 6,
              b.total_fee) year_fee,-- 年化保费,

       f.cha_result as cha_result,-- 扣款结果,
       f.cha_time as chg_time,-- 扣款日期,
       a.next_call_time as next_call_time,-- 预约时间,
       d.item_name as reserve_result,-- 预约结果,
       (select count(1) from tb_reserve_dia_out r where r.task_id = a.id) as call_count,-- 拨打次数,
       a.use_ali_id as use_ali_id,-- 预约人员,
       to_char(a.cre_time,''yyyy-MM-dd'') as task_cre_date,-- 预约任务生成时间,
       (select j.item_name
          from tb_problem k, tb_dict j
         where k.deal_result = j.id
           and k.reserve_task_id = a.id
           and k.cre_time = e.cre_time
           and rownum = ''1'') as handle_result,-- 问题件处理结果,
       a.res_remark as res_remark,  -- 备注
       sysdate as cre_time

  from tb_reserve_task a,
       tb_application b,
       tb_app_dtl c,
       tb_dict d,
       (select m.reserve_task_id as reserve_task_id,
               max(m.cre_time) as cre_time
          from tb_problem m
         group by m.reserve_task_id) e,
       (select m.ins_no as ins_no,
               ''成功'' as cha_result,
               max(chg_time) as cha_time
          from t_ins_sta_his m
         where m.ins_sta = ''07''
         group by m.ins_no) f,
       (select * from tb_app_prd_info t1 where t1.main_flag = ''1'') g,
       (select m3.application_id  as application_id,
       m1.app_customer_id as app_customer_id,
       m2.adds_detail     as adds_detail
  from tb_application_customer m1,
       (select *
          from tb_app_customer_adds t1
         where t1.adds_id =
               (select max(t2.adds_id)
                  from tb_app_customer_adds t2
                 where t1.app_customer_id = t2.app_customer_id)) m2,
       tb_customer_app_rel m3
 where m1.customer_typ = ''01''
   and m1.app_customer_id = m2.app_customer_id
   and m1.con_addr_typ_id = m2.cus_adds_typ_id
   and m1.app_customer_id = m3.app_customer_id) h,

       (select * from shcpic_company t where t.parent_company_id = ''1'') j,
       shcpic_company k,
       tb_organization l

 where a.application_id = b.application_id
   and b.application_id = c.application_id
   and a.status = d.id(+)
   and a.id = e.reserve_task_id(+)
   and b.appno = f.ins_no(+)
   and b.application_id = g.application_id(+)
   and b.application_id = h.application_id(+)
   and b.idorg = k.company_code(+)
   and k.parent_company_id = j.id(+)
   and a.prj_org_id = l.org_id(+)';


   execute immediate 'delete from tb_reservetask_list';

  open mycur for sqlvar;

   begin
  loop
         fetch mycur into myrow;
         exit when mycur%notfound;
         v_insertsql  := 'insert into tb_reservetask_list(
                          APP_DATE,
                          APPNO         ,
                          APP_TYP        ,
                          POLICYNO       ,
                          COMPANY_NAME   ,
                          PRJ_NAME       ,
                          INSURANCE_NAME ,
                          TSRID          ,
                          ACUS_NAME      ,
                          ACUS_LICNO     ,
                          ADDS_DETAIL    ,
                          CON_VALUE      ,
                          TOTAL_FEE      ,
                          YEAR_FEE       ,
                          CHA_RESULT     ,
                          CHA_TIME       ,
                          NEXT_CALL_TIME ,
                          RESERVE_RESULT ,
                          CALL_COUNT     ,
                          USE_ALI_ID     ,
                          TASK_CRE_DATE  ,
                          HANDLE_RESULT  ,
                          RES_REMARK    ,
                          CRE_TIME   )
                          values ('''||myrow.app_date||''','''||myrow.appno;

         v_insertsql := v_insertsql ||''','''||myrow.app_typ||''','''||myrow.policyno||''','''||myrow.company_name;
         v_insertsql := v_insertsql ||''','''||myrow.prj_name||''','''||myrow.insurance_name||''','''||myrow.tsrid;
         v_insertsql := v_insertsql ||''','''||myrow.acus_name||''','''||myrow.acus_licno||''','''||myrow.adds_detail;
         v_insertsql := v_insertsql ||''','''||myrow.con_value||''','||myrow.total_fee||','||myrow.year_fee;
         v_insertsql := v_insertsql ||','''||myrow.cha_result||''','''||myrow.cha_time||''','''||myrow.next_call_time;
         v_insertsql := v_insertsql ||''','''||myrow.reserve_result||''','||myrow.call_count||','''||myrow.use_ali_id;
         v_insertsql := v_insertsql ||''','''||myrow.task_cre_date||''','''||myrow.handle_result||''','''||myrow.res_remark||''',sysdate)';

         execute immediate v_insertsql;
    end loop;
    commit;
     exception when others  then
       dbms_output.put_line(sqlerrm);
       flag := '0';
      rollback;

    end;

    if mycur%isopen then
      close mycur;
      end if;

end RESERVE_EXPORT;
/

prompt
prompt Creating procedure T_ACCOUNT_CHANGE
prompt ===================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.T_ACCOUNT_CHANGE
IS
 CURSOR C_ACCOUNT_CHANGE
        IS


SELECT P3.*,
 nvl(AC.ACCO_NO,'') AC_NO,
 CASE WHEN AC.ACCO_NO IS NOT NULL AND AC.ACCO_NO <> P3.ACCO_NO THEN TO_CHAR(SYSDATE,'YYYY-MM-DD')
   WHEN AC.IMPORTDATE IS NULL THEN TO_CHAR(SYSDATE,'YYYY-MM-DD')
   ELSE AC.IMPORTDATE END CHANGEDATE FROM (
select
 P1.AGENT_ID , -- 业务员工号
 P5.ORGNAME,--保单归属地分公司
 P7.RISKNAME CLASSNAME,--险种名称
 P1.APPNO,--投保单号
 P1.POLICYNO,--保单号
 P1.ACUS_NAME,--投保人姓名
 P8.APID,--身份证号码
 P2.FEE_ACC_BANK,--开户行
 P2.FEE_ACC_NO,--投保时缴费账号

 P3.REGDATE,--变更时间
 P3.BANKNAME, --现开户行
 P3.ACCO_NO, --现缴费账号
 P4.YEARS,--已缴费期数
 P6.NEXTDATE, --下次缴费日
 P1.TSRID --销售座席工号
 from ( SELECT * FROM TB_APPLICATION where IDDMTYPE=2002  )P1
LEFT JOIN TB_APP_DTL P2 ON P1.APPLICATION_ID = P2.APPLICATION_ID
INNER JOIN (
    SELECT POLICYNO,REGDATE,BANKCODE,BANKNAME,ACCO_NO FROM (
       SELECT XQ_ACCOUNT.*,ROW_NUMBER() OVER(PARTITION BY POLICYNO ORDER BY BEGTIME DESC) RN FROM XQ_ACCOUNT
       )   WHERE RN = 1
)  P3 ON P1.POLICYNO = P3.POLICYNO
LEFT JOIN ( --处理非月转年

select  POLICYNO
       ,CASE WHEN PAYSCH=13 THEN trunc(BEGINDATE/12)
       WHEN PAYSCH=12 THEN trunc(BEGINDATE/6)
         WHEN PAYSCH=11 THEN trunc(BEGINDATE/3)
           WHEN PAYSCH=10 THEN trunc(BEGINDATE/1)
             ELSE 1 END YEARS
       from (
 SELECT T1.POLICYNO
       ,T1.YEARS
       ,T2.PAYSCH,
       CASE WHEN trunc(PAYDATE,'MM') = TRUNC(OPDATE,'MM') THEN
       months_between(to_date(to_char(T1.PAYDATE,'yyyymm'),'yyyymm') , to_date(to_char(T3.OPDATE,'yyyymm'),'yyyymm'))+2
       ELSE
       months_between(to_date(to_char(T1.PAYDATE,'yyyymm'),'yyyymm') , to_date(to_char(T3.OPDATE,'yyyymm'),'yyyymm'))+1
       END
       BEGINDATE
       ,ROW_NUMBER() OVER(PARTITION BY T1.POLICYNO ORDER BY T1.SNO DESC) RN
        FROM (
           SELECT * FROM (
          SELECT XQ.POLICYNO,XQ.PAYDATE,XQ.CLASSCODE,XQ.YEARS,XQ.SNO,
          ROW_NUMBER() OVER(PARTITION BY XQ.POLICYNO,CLASSCODE ORDER BY XQ.PAYDATE DESC) RN FROM  XQ_PREREC XQ
          ) WHERE RN =1
         ) T1,
        XQ_MONEYSCH T2,
        XQ_RISKCON T3
  WHERE T1.POLICYNO = T2.POLICYNO
    AND T1.CLASSCODE = T2.CLASSCODE
    AND T1.POLICYNO = T3.POLICYNO
    AND T1.CLASSCODE = T3.CLASSCODE
    AND T3.APPF = '1'
 ) where rn=1

 )P4  ON P1.POLICYNO = P4.POLICYNO
LEFT JOIN (
     SELECT * FROM (
      SELECT  POLICYNO,APPNO,APID,BRANCH,CLASSCODE  ,ROW_NUMBER() OVER(PARTITION BY X.POLICYNO ORDER BY X.SNO DESC) RN FROM XQ_RISKCON X
      WHERE APPF='1'
      ) WHERE RN = 1
      ) P8 ON P8.POLICYNO = P1.POLICYNO
LEFT JOIN FF_COMPANY P5 ON P8.BRANCH = P5.ORGCODE
LEFT JOIN XQ_MONEYSCH P6 ON P1.POLICYNO = P6.POLICYNO AND P8.CLASSCODE = P6.CLASSCODE
LEFT JOIN (
      SELECT * FROM (
      SELECT  X.*  ,ROW_NUMBER() OVER(PARTITION BY X.CLASSCODE ORDER BY X.Riskname DESC) RN FROM XQ_RISKCLASS X
      ) WHERE RN = 1
) P7 ON P8.CLASSCODE = P7.CLASSCODE

WHERE p2.fee_acc_no <>  P3.ACCO_NO
) P3
LEFT JOIN ACCOUNT_CHANGE AC ON P3.POLICYNO = AC.POLICYNO
WHERE  P3.ACCO_NO<>AC.ACCO_NO or AC.ACCO_NO is null;

 C_ROW C_ACCOUNT_CHANGE%rowtype;
XH NUMBER := 0;
 NEW_ACC VARCHAR(50) ;
 OLD_ACC VARCHAR(50) ;
BEGIN

     OPEN C_ACCOUNT_CHANGE;

      LOOP
   --    FETCH C_RETURNLIST INTO USE_ALI_ID,AMOUNT,CALL_DATE,TASK_DATE,RETURNVIST_STA,BEGDATE,POLICYNO,USE_NAM,GRO_ID,CAT_NAM
        FETCH C_ACCOUNT_CHANGE INTO C_ROW;
        EXIT  WHEN C_ACCOUNT_CHANGE%NOTFOUND;
        XH:= XH+1;
          NEW_ACC:=c_row.ACCO_NO;
      OLD_ACC:=c_row.AC_NO;


          if NEW_ACC = OLD_ACC   THEN
               RETURN;
          ELSE

         insert into ACCOUNT_CHANGE values(c_row.AGENT_ID,c_row.ORGNAME,c_row.CLASSNAME,c_row.APPNO,
         c_row.POLICYNO,c_row.ACUS_NAME,c_row.APID,c_row.FEE_ACC_BANK,c_row.FEE_ACC_NO ,TO_CHAR(c_row.REGDATE,'yyyy-mm-dd'),
         c_row.BANKNAME,c_row.ACCO_NO,c_row.YEARS,TO_CHAR(c_row.NEXTDATE,'yyyy-mm-dd'),c_row.TSRID,
         to_char(sysdate(),'yyyy-mm-dd'),XH,C_ROW.CHANGEDATE);
         commit;


         END IF;



      END LOOP;
     CLOSE C_ACCOUNT_CHANGE;
  END T_ACCOUNT_CHANGE;
/

prompt
prompt Creating procedure T_DUNNING_INFO
prompt =================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.T_DUNNING_INFO IS
SALES_ORGANIZATION VARCHAR(100); -- 销售机构
THE_WORKSPACE VARCHAR(100) ; --所属职场
PROJECT_NAME VARCHAR(100); -- 项目名称
BRANCH_NAME   VARCHAR(100); -- 分公司
EMPNO_NO  VARCHAR(100); --个人工号
POLICY_NO VARCHAR(100) ; -- 保单号
APPNO_NO VARCHAR(100); -- 投保单号
CLASS_CODE VARCHAR(100);--险种代码
CLASS_NAME VARCHAR(100);--险种名称
TBR_NAME VARCHAR(50); --投保人姓名
TBR_ID VARCHAR(100) ; -- 投保人身份证号
BBR_NAME VARCHAR(50);-- 被保人姓名
BBR_ID VARCHAR (100) ;-- 被保人证件号码
POLICYNO_STATUS VARCHAR(20);--保单状态
WAYS_OF_PAYMENT VARCHAR(50);--支付方式
DEBIT_BANK VARCHAR(100); -- 扣款银行
DEBIT_NO VARCHAR(100); --扣款账号
BEGDATE VARCHAR(40); -- 责任起期
NEXTDATE VARCHAR(40); -- 下次缴费日
PAYMENT_PERIOD NUMBER(10);--已缴期次
PAYMENT_COUNT VARCHAR(100); -- 累计缴费
A_SINGLE_PERIOD_OF_PAYMENT VARCHAR(100); -- 单期缴费
PREM_TERM VARCHAR(40);--缴费年限
HPHONE VARCHAR (100) ;--家庭电话
MPHONE VARCHAR (100) ;--移动电话
PAY_PERIOD NUMBER(10);--欠缴期次
OUTSTANDING_AMOUNT VARCHAR(100);--欠缴金额

BRANCH_CODE   VARCHAR(100); -- 关联分公司
OPDATE DATE; -- 保单生效日期
--TEMP_POLICYNO VARCHAR(100); -- 临时存储保单号
PSCH   VARCHAR(50); -- 支付频率
PAY_WAY VARCHAR(20) ; -- 支付方式的代码存放
PER_ID VARCHAR(100); -- 临时存放个人客户表的SOURCE_PERSON_ID字段
V_ZXGH VARCHAR(100);
V_ZG VARCHAR(100);
V_OPDATE VARCHAR(50);
CURSOR C_CURSOR IS
              SELECT SALES_ORGAN,SALES_PROJECT,EMPNO,POLICYNO,APPNO,BEGDATE, OWNER_SOURCE_ID,
               INSURED_SOURCE_ID,CLASSCODE,BRANCH,OPDATE,APID, PID,PREM_TERM,NEXTDATE,PAYSCH,SETCODE,Polist,
               YEARS,CASE WHEN YEARS IS NOT NULL THEN  YJIAO-YEARS ELSE NULL END  QJIAO,YJIAO FROM (
              SELECT P2.SALES_ORGAN,P2.SALES_PROJECT,P1.EMPNO,P1.POLICYNO,P1.APPNO,
              TO_CHAR(P1.BEGDATE,'YYYY-MM-DD')BEGDATE,P6.
               OWNER_SOURCE_ID,P6.INSURED_SOURCE_ID,P6.CLASSCODE,P6.BRANCH,P6.OPDATE,P6.APID,P6.PID,P6.Polist,
               PREM_TERM,TO_CHAR(NEXTDATE,'YYYY-MM-DD')NEXTDATE,PAYSCH,SETCODE,
               CASE WHEN PAYSCH=13 THEN trunc(MONTHS_BETWEEN(TRUNC(P10.NEXTDATE+1, 'MM'), TRUNC(P6.BEGDATE, 'MM')) /12)
                  WHEN PAYSCH=12 THEN trunc(MONTHS_BETWEEN(TRUNC(P10.NEXTDATE+1, 'MM'), TRUNC(P6.BEGDATE, 'MM'))/6)
                     WHEN PAYSCH=11 THEN trunc(MONTHS_BETWEEN(TRUNC(P10.NEXTDATE+1, 'MM'), TRUNC(P6.BEGDATE, 'MM'))/3)
                         WHEN PAYSCH=10 THEN trunc(MONTHS_BETWEEN(TRUNC(P10.NEXTDATE+1, 'MM'), TRUNC(P6.BEGDATE, 'MM'))/1)
                           ELSE NULL END YEARS,
                             --应缴期次
                             CASE WHEN PAYSCH=13 THEN trunc(MONTHS_BETWEEN(TRUNC(SYSDATE, 'MM'), TRUNC(P6.BEGDATE, 'MM')) /12)
                  WHEN PAYSCH=12 THEN trunc(MONTHS_BETWEEN(TRUNC(SYSDATE, 'MM'), TRUNC(P6.BEGDATE, 'MM'))/6)
                     WHEN PAYSCH=11 THEN trunc(MONTHS_BETWEEN(TRUNC(SYSDATE, 'MM'), TRUNC(P6.BEGDATE, 'MM'))/3)
                         WHEN PAYSCH=10 THEN trunc(MONTHS_BETWEEN(TRUNC(SYSDATE, 'MM'), TRUNC(P6.BEGDATE, 'MM'))/1)
                           ELSE NULL END YJIAO


                FROM XQ_APP P1
               LEFT JOIN XQ_SALES_INFO P2 ON P1.EMPNO = P2.EMPNO
               INNER JOIN XQ_RISKCON P6 ON P1.POLICYNO = P6.POLICYNO
               INNER JOIN XQ_MONEYSCH P10 ON P1.POLICYNO = P10.POLICYNO AND P10.CLASSCODE = P6.CLASSCODE
               WHERE P6.APPF='1' --AND  P6.POLIST_IDS = '2' 取掉，要取所有保单
               AND P6.SALEATTR IN ('601', '603')
               AND MONTHS_BETWEEN(SYSDATE,P6.OPDATE) <= 5 AND PAYSCH= '10') TEMPTABLE;
       ROW_CURSOR C_CURSOR%ROWTYPE;
BEGIN
  DELETE DUNNING_REPORT;
  COMMIT;
  OPEN C_CURSOR;
  LOOP
    <<BEGIN_POINT>>
    FETCH C_CURSOR INTO ROW_CURSOR;
    EXIT WHEN C_CURSOR%NOTFOUND ;
    BEGIN
      SALES_ORGANIZATION := ROW_CURSOR.SALES_ORGAN;
      PROJECT_NAME := ROW_CURSOR.SALES_PROJECT;
      POLICY_NO := ROW_CURSOR.POLICYNO;
      APPNO_NO := ROW_CURSOR.APPNO;
      BEGDATE := ROW_CURSOR.BEGDATE;
      EMPNO_NO :=ROW_CURSOR.EMPNO;
     -- POLICYNO_STATUS := ROW_CURSOR.Polist_Ids;
      CLASS_CODE :=ROW_CURSOR.CLASSCODE;
      BRANCH_CODE :=ROW_CURSOR.BRANCH;
      OPDATE :=ROW_CURSOR.OPDATE;
      NEXTDATE := ROW_CURSOR.NEXTDATE;
      PREM_TERM :=ROW_CURSOR.PREM_TERM;
      PSCH :=ROW_CURSOR.PAYSCH;
      PAY_WAY :=ROW_CURSOR.SETCODE;
      -- 已缴期次
      PAYMENT_PERIOD := ROW_CURSOR.YEARS;
      -- 欠缴期次
      PAY_PERIOD := ROW_CURSOR.QJIAO;
 -- 通过USE_ALI_ID中间关联，来查找所属职场名称

            SELECT WORKPLACE_NAME INTO THE_WORKSPACE FROM (
        SELECT  P5.WORKPLACE_NAME FROM TB_APPLICATION P3  LEFT JOIN (
                SELECT USE_ALI_ID ,C_WORKPLACE_ID FROM(SELECT USE_ALI_ID ,C_WORKPLACE_ID,
                ROW_NUMBER() OVER(PARTITION BY USE_ALI_ID ORDER BY C_WORKPLACE_ID DESC)RN FROM C_USE
                          ) WHERE RN =1
                  ) P4 ON P3.TSRID = P4.USE_ALI_ID
        LEFT JOIN CPIC_WORKPLACE P5 ON P4.C_WORKPLACE_ID = P5.ID
        WHERE P3.APPNO =APPNO_NO
        UNION SELECT NULL FROM DUAL )WHERE ROWNUM<2 ORDER BY WORKPLACE_NAME DESC NULLS LAST;


 -- 获取主险的CLASSCODE，分公司的名称的编码
     /*    SELECT CLASSCODE,BRANCH,OPDATE INTO CLASS_CODE,BRANCH_CODE,OPDATE FROM (
            SELECT CLASSCODE,BRANCH,P6.OPDATE FROM XQ_RISKCON P6
            WHERE APPF='1' AND POLICYNO = POLICY_NO AND  POLIST_IDS = '2' AND SALEATTR IN ('601', '603')
            UNION SELECT NULL,NULL,NULL FROM DUAL
         )WHERE ROWNUM<2 ORDER BY CLASSCODE DESC NULLS LAST;*/
 -- 判断其必须为主险，且为月缴
      /*  IF CLASS_CODE IS NULL  THEN
          GOTO BEGIN_POINT;
        END IF;
        IF BRANCH_CODE IS NULL THEN
          GOTO BEGIN_POINT;
        END IF;*/
   -- 计算欠缴其次及欠缴金额
       /*   SELECT POLICYNO,NVL(SPAYCOUNT,0),NVL(SPAYAMOUNT,0) INTO TEMP_POLICYNO , PAY_PERIOD,OUTSTANDING_AMOUNT   FROM (
      SELECT POLICYNO,SPAYCOUNT,TO_CHAR(SPAYAMOUNT)SPAYAMOUNT  FROM(
      SELECT XS1.POLICYNO
              ,COUNT(DISTINCT XS1.COVER1) AS SPAYCOUNT
              ,SUM(XS1.AMOUNT) AS SPAYAMOUNT
          FROM XQ_SPREREC XS1
              ,(SELECT POLICYNO
                      ,MAX(NEXTDATE) NEXTDATE
                  FROM XQ_MONEYSCH
                 GROUP BY POLICYNO) XM1
         WHERE XS1.POLICYNO = XM1.POLICYNO
           AND XS1.COVER1 >= XM1.NEXTDATE
           AND (XS1.COVER1 - 1) <= SYSDATE
           AND XS1.STATUS_IDS_VAR IN ('0', '1', '2')
         GROUP BY XS1.POLICYNO)P13 WHERE POLICYNO = POLICY_NO
         UNION SELECT NULL,NULL,NULL FROM DUAL)
         WHERE ROWNUM<2 ORDER BY POLICYNO DESC NULLS LAST;*/
   -- 判断必须要有欠缴记录
   --     IF TEMP_POLICYNO IS NULL THEN
   --       GOTO BEGIN_POINT;
   --     END IF;
  -- 关联分公司的编码，获取分公司名称
          SELECT  ORGNAME INTO BRANCH_NAME FROM (
             SELECT ORGNAME  FROM  FF_COMPANY P7 WHERE ORGCODE = BRANCH_CODE
             UNION SELECT NULL FROM DUAL)WHERE ROWNUM<2 ORDER BY ORGNAME DESC NULLS LAST;
  -- 获取投保人姓名,投保人ID
          SELECT  NAME,ID,SOURCE_PERSON_ID INTO TBR_NAME,TBR_ID,PER_ID FROM (
            SELECT NAME,ID,P8.SOURCE_PERSON_ID FROM XQ_PERSON P8 WHERE SOURCE_PERSON_ID =ROW_CURSOR.OWNER_SOURCE_ID
              UNION SELECT NULL,NULL,NULL FROM DUAL )WHERE ROWNUM<2 ORDER BY NAME DESC NULLS LAST;
              --当投保人信息未取到，则按照如下条件重新查找
           IF TBR_NAME IS NULL THEN
              SELECT  NAME,ID,SOURCE_PERSON_ID INTO TBR_NAME,TBR_ID,PER_ID FROM (
                SELECT NAME,ID,P8.SOURCE_PERSON_ID  FROM XQ_PERSON P8 WHERE  P8.ID =ROW_CURSOR.APID
              UNION SELECT NULL,NULL,NULL FROM DUAL )WHERE ROWNUM<2 ORDER BY NAME DESC NULLS LAST;
           END IF;
               --当投保人信息依旧未取到，则按照如下条件再次重新查找
           IF TBR_NAME IS NULL THEN
              SELECT  NAME,ID,SOURCE_PERSON_ID INTO TBR_NAME,TBR_ID,PER_ID FROM (
                SELECT NAME,ID,P8.SOURCE_PERSON_ID  FROM XQ_PERSON P8 WHERE  P8.ID15 =ROW_CURSOR.APID
              UNION SELECT NULL,NULL,NULL FROM DUAL )WHERE ROWNUM<2 ORDER BY NAME DESC NULLS LAST;
           END IF;


  -- 获取被保人姓名 ,被保人ID
         SELECT  NAME,ID INTO BBR_NAME,BBR_ID FROM (
          SELECT NAME,ID  FROM XQ_PERSON P8 WHERE SOURCE_PERSON_ID = ROW_CURSOR.INSURED_SOURCE_ID
            UNION SELECT NULL,NULL FROM DUAL )WHERE ROWNUM<2 ORDER BY NAME DESC NULLS LAST;
              --当被保人信息未取到，则按照如下条件重新查找
           IF BBR_NAME IS NULL THEN
              SELECT  NAME,ID INTO BBR_NAME,BBR_ID FROM (
                SELECT NAME,ID  FROM XQ_PERSON P8 WHERE  P8.ID =ROW_CURSOR.PID
              UNION SELECT NULL,NULL FROM DUAL )WHERE ROWNUM<2 ORDER BY NAME DESC NULLS LAST;
           END IF;
               --当被保人信息依旧未取到，则按照如下条件再次重新查找
           IF BBR_NAME IS NULL THEN
              SELECT  NAME,ID INTO BBR_NAME,BBR_ID FROM (
                SELECT NAME,ID  FROM XQ_PERSON P8 WHERE  P8.ID15 =ROW_CURSOR.PID
              UNION SELECT NULL,NULL FROM DUAL )WHERE ROWNUM<2 ORDER BY NAME DESC NULLS LAST;
           END IF;


  -- 获取扣款银行名称，及账号
        SELECT  BANKNAME,ACCO_NO INTO DEBIT_BANK,DEBIT_NO FROM (
                  SELECT BANKNAME,ACCO_NO  FROM (
                     SELECT XQ_ACCOUNT.*,ROW_NUMBER() OVER(PARTITION BY POLICYNO ORDER BY BEGTIME DESC,SNO DESC) RN FROM XQ_ACCOUNT
                  ) P9   WHERE RN = 1 AND POLICYNO = POLICY_NO
          UNION SELECT NULL,NULL FROM DUAL )WHERE ROWNUM<2 ORDER BY BANKNAME DESC NULLS LAST;
  -- 获取下次缴费日,缴费方式
     /*     SELECT  TO_CHAR(NEXTDATE,'YYYY-MM-DD'),PREM_TERM,PAYSCH,SETCODE INTO NEXTDATE,PREM_TERM,PSCH,PAY_WAY FROM (
              SELECT P10.NEXTDATE,P10.PREM_TERM,PAYSCH,SETCODE  FROM XQ_MONEYSCH P10
                 WHERE POLICYNO = POLICY_NO AND CLASSCODE = CLASS_CODE
                   UNION SELECT NULL,NULL,NULL,NULL FROM DUAL )
           WHERE ROWNUM<2 ORDER BY NEXTDATE DESC NULLS LAST;
           IF PSCH <>'10' OR PSCH IS NULL THEN
               GOTO BEGIN_POINT;
           END IF;*/
  -- 获取已缴其次,累计缴费

     /*    SELECT  PAYSACH,SUMAMOUNT  INTO PAYMENT_PERIOD,PAYMENT_COUNT FROM (
             SELECT
               CASE WHEN  TRUNC(MAXPAYDATE, 'MM') = TRUNC(OPDATE, 'MM') THEN
               MONTHS_BETWEEN(TRUNC(MAXPAYDATE, 'MM'), TRUNC(OPDATE, 'MM')) + 2
               ELSE
                  MONTHS_BETWEEN(TRUNC(MAXPAYDATE, 'MM'), TRUNC(OPDATE, 'MM')) + 1
               END
               PAYSACH ,
              TO_CHAR(SUMAMOUNT)SUMAMOUNT
             FROM (SELECT MAX(PAYDATE) MAXPAYDATE ,SUM(AMOUNT) SUMAMOUNT FROM XQ_PREREC
             WHERE POLICYNO = POLICY_NO  GROUP BY POLICYNO) P11
             UNION SELECT NULL,NULL FROM DUAL )
          WHERE ROWNUM<2 ORDER BY SUMAMOUNT DESC NULLS LAST;*/
  --  获取单期缴费
              SELECT  ONEAMOUNT  INTO A_SINGLE_PERIOD_OF_PAYMENT FROM (
                 SELECT SUM(PIECES * NPAYLEN) ONEAMOUNT  FROM XQ_RISKCON A
                 WHERE POLICYNO = POLICY_NO GROUP BY POLICYNO
                  UNION SELECT NULL FROM DUAL )
          WHERE ROWNUM<2 ORDER BY ONEAMOUNT DESC NULLS LAST;


          IF PAYMENT_PERIOD IS NULL THEN
              PAYMENT_COUNT := NULL;
              ELSE
                --累计缴费
                  PAYMENT_COUNT := A_SINGLE_PERIOD_OF_PAYMENT * PAYMENT_PERIOD;
                -- 欠缴保费
                    OUTSTANDING_AMOUNT := (A_SINGLE_PERIOD_OF_PAYMENT*  ROW_CURSOR.YJIAO )-PAYMENT_COUNT;
          END IF;


   -- 获取用户联系方式_座机

         SELECT  TELNUMBER  INTO HPHONE FROM (
                 SELECT TELNUMBER  FROM (
                 SELECT SOURCE_PERSON_ID,TELNUMBER,ROW_NUMBER() OVER(PARTITION BY SOURCE_PERSON_ID ORDER BY BEGTIME DESC)RN
                 FROM XQ_PHONE  WHERE USAGE = '2'
                )C WHERE C.RN = 1 AND C.SOURCE_PERSON_ID =  PER_ID
             UNION SELECT NULL FROM DUAL )
          WHERE ROWNUM<2 ORDER BY TELNUMBER DESC NULLS LAST;
    -- 获取用户联系方式_手机
          SELECT  TELNUMBER  INTO MPHONE FROM (
                   SELECT TELNUMBER  FROM (
                    SELECT SOURCE_PERSON_ID,TELNUMBER,ROW_NUMBER() OVER(PARTITION BY SOURCE_PERSON_ID ORDER BY BEGTIME DESC)RN
                   FROM XQ_PHONE  WHERE USAGE = '1'
                   )C WHERE C.RN = 1 AND C.SOURCE_PERSON_ID =  PER_ID
                   UNION SELECT NULL FROM DUAL )
          WHERE ROWNUM<2 ORDER BY TELNUMBER DESC NULLS LAST;
     -- 获取险种名称
           SELECT  CLASSNAME  INTO CLASS_NAME FROM (
               SELECT CLASSNAME FROM ( SELECT O_CLASSCODE,MAX(CLASSNAME) CLASSNAME FROM XQ_RISKCLASS GROUP BY O_CLASSCODE)
                 XQ_RISKCLASS WHERE  XQ_RISKCLASS.O_CLASSCODE  = CLASS_CODE
                   UNION SELECT NULL FROM DUAL )
          WHERE ROWNUM<2 ORDER BY CLASSNAME DESC NULLS LAST;
     -- 获取支付方式名称
         SELECT  ITEM_NAME  INTO WAYS_OF_PAYMENT FROM (
               SELECT ITEM_NAME FROM XQ_DICT WHERE ITEM_CODE = PAY_WAY AND PARENT_ID = '12'
                   UNION SELECT NULL FROM DUAL )
          WHERE ROWNUM<2 ORDER BY ITEM_NAME DESC NULLS LAST;

         select d.item_name into POLICYNO_STATUS from xq_dict d where d.id=ROW_CURSOR.Polist and d.parent_id=1;

         V_OPDATE := TO_CHAR(ROW_CURSOR.OPDATE,'YYYY-MM-DD');--保单成交日期

         select TSRID into V_ZXGH   --坐席工号
             from (select TSRID
                     from tb_application a
                         where a.policyno = POLICY_NO
                    union
                   select null TSRID from dual)
         where rownum = 1;



         --根据坐席工号查找所在组的主管
         if  V_ZXGH  is not null then
                   select u.use_ali_id into V_ZG
                           from c_use_gro g, c_use u
                          where g.use_id=u.use_id
                          and u.use_flag='0'
                            and g.gro_id =
                                (select c.gro_id
                                   from c_use_gro c
                                  where c.use_id =
                                        (select u.use_id
                                           from c_use u
                                          where u.use_ali_id = V_ZXGH
                                            and rownum = 1)
                                    and c.gro_id <> 9005
                                    and rownum = 1)
                            and exists
                          (select 1
                                   from c_use_par r
                                  where g.use_id = r.use_id
                                    and r.cat_id = 802009);
            else
                V_ZG:='';

         end if;

           INSERT INTO DUNNING_REPORT VALUES(SALES_ORGANIZATION ,
THE_WORKSPACE ,
PROJECT_NAME,
BRANCH_NAME   ,
EMPNO_NO ,
POLICY_NO ,
APPNO_NO ,
CLASS_CODE ,
CLASS_NAME,
TBR_NAME ,
TBR_ID ,
BBR_NAME ,
BBR_ID ,
POLICYNO_STATUS ,
WAYS_OF_PAYMENT ,
DEBIT_BANK ,
DEBIT_NO ,
BEGDATE ,
NEXTDATE ,
PAYMENT_PERIOD ,
PAYMENT_COUNT ,
A_SINGLE_PERIOD_OF_PAYMENT ,
PREM_TERM ,
HPHONE ,
MPHONE  ,
PAY_PERIOD ,
OUTSTANDING_AMOUNT,
V_ZXGH,
V_ZG,
V_OPDATE
);
COMMIT;


     EXCEPTION
       WHEN NO_DATA_FOUND THEN
         BEGIN
           ROLLBACK;
           DBMS_OUTPUT.PUT_LINE(SQLERRM || ':' || SQLCODE);
           DBMS_OUTPUT.PUT_LINE(POLICY_NO);
        END;
    END;
  END LOOP;
  CLOSE C_CURSOR;

EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      ROLLBACK;
      CLOSE C_CURSOR;
      DBMS_OUTPUT.PUT_LINE(SQLERRM || ':' || SQLCODE);
    END;
END T_DUNNING_INFO;
/

prompt
prompt Creating procedure T_FXQD_INFO
prompt ==============================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.T_FXQD_INFO IS
  DATE_FLAG VARCHAR2(2) := TO_CHAR(SYSDATE, 'DD');
  DATE_DEL  VARCHAR2(20) := TO_CHAR(SYSDATE - TO_NUMBER(DATE_FLAG), 'YYYY-MM');
BEGIN
  DELETE FROM TEMP_FXQD_01;
  COMMIT;
  DELETE FROM TEMP_FXQD;
  COMMIT;

  INSERT INTO TEMP_FXQD_01
    (CURR_DATA
    ,TASK_DATE
    ,USE_NAM
    ,USE_ALI_ID
    ,GRO_ID
    ,CAT_NAM
    ,POLICYNO
    ,APPNO
    ,CLASSCODE
    ,CLASSNAME
    ,APPNAME
    ,POLIST_IDS
    ,POLIST_NAME
    ,PAYCODE
    ,PAYNAME
    ,BEGDATE
    ,NEXTDATE
    ,ONE_AMOUNT
    ,YEARNUM
    ,INVALID_DATE
    ,REINSTATE
    ,REINNAME
    ,PAYDATE
    ,ACC_AMOUNT
    ,CALL_USE_ALI
    ,CALL_DATE
    ,ITEM_NAME
    ,REMARK
    ,EMPNO
    ,SALES_ORGAN
    ,SALES_PROJECT)
    SELECT TRUNC(SYSDATE, 'DD') AS CURR_DATA
          ,XAP_RIS.TASK_DATE
          ,CUSE.USE_NAM
          ,XAP_RIS.USE_ALI_ID
          ,CUSE.GRO_ID
          ,CUSE.CAT_NAM
          ,XAP_RIS.POLICYNO
          ,XAP_RIS.APPNO
          ,RIS_MON.CLASSCODE
          ,RIS_MON.CLASSNAME
          ,XPO.NAME
          ,RIS_MON.POLIST_IDS
          ,RIS_MON.POLIST_NAME
          ,RIS_MON.PAYSCH
          ,RIS_MON.PAYNAME
          ,XA.BEGDATE
          ,RIS_MON.NEXTDATE
          ,OA.ONE_AMOUNT
          ,RIS_MON.PREM_TERM
          ,XAP_RIS.INVALID_DATE-1
          ,XAP_RIS.REINSTATE
          ,DECODE(XAP_RIS.REINSTATE, '1', '成功', '0', '失败', '') AS REINNAME
          ,XAP_RIS.PAYDATE
          ,XAP_RIS.ACC_AMOUNT
          ,XRUT.CALL_USE_ALI
          ,XRUT.CALL_DATE
          ,XRUT.ITEM_NAME
          ,XRUT.REMARK
          ,XA.EMPNO
          ,XSI.SALES_ORGAN
          ,XSI.SALES_PROJECT
      FROM TEMP_INVALID_APP XAP_RIS
          ,TEMP_ONE_AMOUNT OA
          ,XQ_APP XA
          ,(SELECT A.POLICYNO
                  ,A.CLASSCODE
                  ,A.POLIST_IDS
                  ,(SELECT MAX(XD1.ITEM_NAME)
                      FROM XQ_DICT XD1
                     WHERE XD1.PARENT_ID = 1
                       AND XD1.ITEM_CODE = TRIM(A.POLIST_IDS)) AS POLIST_NAME
                  ,B.NEXTDATE
                  ,B.PAYSCH
                  ,(SELECT MAX(XD2.ITEM_NAME)
                      FROM XQ_DICT XD2
                     WHERE XD2.PARENT_ID = 7
                       AND XD2.ITEM_CODE = TRIM(B.PAYSCH)) AS PAYNAME
                  ,B.PREM_TERM
                  ,(SELECT MAX(XR.CLASSNAME) FROM XQ_RISKCLASS XR WHERE XR.CLASSCODE = A.CLASSCODE) AS CLASSNAME
              FROM XQ_RISKCON A
                  ,XQ_MONEYSCH B
             WHERE A.POLICYNO = B.POLICYNO(+)
               AND A.CLASSCODE = B.CLASSCODE(+)
               AND A.APPF = '1') RIS_MON
          ,(SELECT POLICYNO
                  ,CALL_DATE
                  ,CALL_USE_ALI
                  ,ITEM_NAME
                  ,REMARK
              FROM (SELECT RET.CALL_DATE
                          ,RET.CALL_USE_ALI
                          ,XD.ITEM_NAME
                          ,RET.REMARK
                          ,XIA.POLICYNO
                          ,ROW_NUMBER() OVER(PARTITION BY XIA.POLICYNO ORDER BY RET.CALL_DATE DESC) RON
                      FROM XQ_INVALID_APP_RETURNVISIT RET
                          ,XQ_INVALID_APP XIA
                          ,XQ_DICT XD
                     WHERE RET.XQ_INVALID_APP_ID = XIA.XQ_INVALID_APP_ID
                       AND RET.RETURNVIST_STA = XD.ID)
             WHERE RON = 1) XRUT
          ,(SELECT USE_ALI_ID
                  ,USE_NAM
                  ,GRO_ID
                  ,CAT_NAM
              FROM (SELECT U.USE_ALI_ID
                          ,U.USE_NAM
                          ,G.GRO_ID
                          ,C.CAT_NAM
                      FROM C_USE U
                          ,C_USE_GRO G
                          ,C_CAT C
                     WHERE U.USE_ID = G.USE_ID(+)
                       AND G.GRO_ID = C.CAT_ID(+)
                       AND G.GRO_ID <> '9005'
                       AND U.USE_FLAG = '1')) CUSE
          ,XQ_PERSON XPO
          ,XQ_SALES_INFO XSI
     WHERE XAP_RIS.POLICYNO = OA.POLICYNO(+)
       AND XA.OWNER_SOURCE_ID = XPO.SOURCE_PERSON_ID(+)
       AND XAP_RIS.POLICYNO = XA.POLICYNO(+)
       AND XAP_RIS.POLICYNO = RIS_MON.POLICYNO(+)
       AND XAP_RIS.POLICYNO = XRUT.POLICYNO(+)
       AND XA.EMPNO = XSI.EMPNO(+)
       AND XAP_RIS.USE_ALI_ID = CUSE.USE_ALI_ID;
  COMMIT;

  INSERT INTO TEMP_FXQD
    (CURR_DATA
    ,TASK_MONTH
    ,TASK_DATE
    ,USE_NAM
    ,USE_ALI_ID
    ,GRO_ID
    ,CAT_NAM
    ,POLICYNO
    ,POLICYNUM
    ,APPNO
    ,CLASSCODE
    ,CLASSNAME
    ,APPNAME
    ,POLIST_IDS
    ,POLIST_NAME
    ,PAYCODE
    ,PAYNAME
    ,BEGDATE
    ,NEXTDATE
    ,ONE_AMOUNT
    ,YEARNUM
    ,INVALID_DATE
    ,REINSTATE
    ,REINNAME
    ,PAYDATE
    ,ACC_AMOUNT
    ,CALL_USE_ALI
    ,CALL_DATE
    ,ITEM_NAME
    ,REMARK
    ,EMPNO
    ,SALES_ORGAN
    ,SALES_PROJECT)
    SELECT TO_CHAR(CURR_DATA, 'YYYY-MM-DD')
          ,TO_CHAR(TASK_DATE, 'YYYY-MM') AS TASK_MONTH
          ,TO_CHAR(TASK_DATE, 'YYYY-MM-DD') AS TASK_DATE
          ,USE_NAM
          ,USE_ALI_ID
          ,GRO_ID
          ,CAT_NAM
          ,A.POLICYNO AS POLICYNO
          ,B.POLICYNUM AS POLICYNUM
          ,APPNO
          ,CLASSCODE
          ,CLASSNAME
          ,APPNAME
          ,POLIST_IDS
          ,POLIST_NAME
          ,PAYCODE
          ,PAYNAME
          ,BEGDATE
          ,NEXTDATE
          ,ONE_AMOUNT
          ,YEARNUM
          ,INVALID_DATE
          ,REINSTATE
          ,REINNAME
          ,PAYDATE
          ,ACC_AMOUNT
          ,CALL_USE_ALI
          ,CALL_DATE
          ,ITEM_NAME
          ,REMARK
          ,EMPNO
          ,SALES_ORGAN
          ,SALES_PROJECT
      FROM TEMP_FXQD_01 A
          ,(SELECT POLICYNO
                  ,COUNT(1) AS POLICYNUM
              FROM TEMP_FXQD_01
             GROUP BY POLICYNO) B
     WHERE A.POLICYNO = B.POLICYNO;
  COMMIT;
  --T+2数据延迟
  IF DATE_FLAG IN ('01', '02')
  THEN
    DELETE FROM TEMP_M_FXQD A WHERE A.CURR_MONTH = DATE_DEL;
    COMMIT;
    INSERT INTO TEMP_M_FXQD
      (CURR_MONTH
      ,TASK_MONTH
      ,TASK_DATE
      ,USE_NAM
      ,USE_ALI_ID
      ,GRO_ID
      ,CAT_NAM
      ,POLICYNO
      ,POLICYNUM
      ,APPNO
      ,CLASSCODE
      ,CLASSNAME
      ,APPNAME
      ,POLIST_IDS
      ,POLIST_NAME
      ,PAYCODE
      ,PAYNAME
      ,BEGDATE
      ,NEXTDATE
      ,ONE_AMOUNT
      ,YEARNUM
      ,INVALID_DATE
      ,REINSTATE
      ,REINNAME
      ,PAYDATE
      ,ACC_AMOUNT
      ,CALL_USE_ALI
      ,CALL_DATE
      ,ITEM_NAME
      ,REMARK
      ,CREATE_DATA
      ,EMPNO
      ,SALES_ORGAN
      ,SALES_PROJECT)
      SELECT DATE_DEL
            ,TASK_MONTH
            ,TASK_DATE
            ,USE_NAM
            ,USE_ALI_ID
            ,GRO_ID
            ,CAT_NAM
            ,POLICYNO
            ,POLICYNUM
            ,APPNO
            ,CLASSCODE
            ,CLASSNAME
            ,APPNAME
            ,POLIST_IDS
            ,POLIST_NAME
            ,PAYCODE
            ,PAYNAME
            ,BEGDATE
            ,NEXTDATE
            ,ONE_AMOUNT
            ,YEARNUM
            ,INVALID_DATE
            ,REINSTATE
            ,REINNAME
            ,PAYDATE
            ,ACC_AMOUNT
            ,CALL_USE_ALI
            ,CALL_DATE
            ,ITEM_NAME
            ,REMARK
            ,SYSDATE
            ,EMPNO
            ,SALES_ORGAN
            ,SALES_PROJECT
        FROM TEMP_FXQD;
    COMMIT;
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      ROLLBACK;
    END;

END T_FXQD_INFO;
/

prompt
prompt Creating procedure T_FXTJ_INFO
prompt ==============================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.T_FXTJ_INFO IS
  DATE_FLAG VARCHAR2(2) := TO_CHAR(SYSDATE, 'DD');
  DATE_DEL  VARCHAR2(20) := TO_CHAR(SYSDATE - TO_NUMBER(DATE_FLAG), 'YYYY-MM-DD');
  DATE_IN_M VARCHAR2(10) := SUBSTR(DATE_DEL, 1, 7);
  DATE_IN_Y VARCHAR2(10) := SUBSTR(DATE_DEL, 1, 4);
BEGIN
  --清空所有临时表
  DELETE FROM TEMP_INVALID_APP_01;
  COMMIT;
  DELETE FROM TEMP_INVALID_APP_02;
  COMMIT;
  DELETE FROM TEMP_INVALID_APP_03;
  COMMIT;
  DELETE FROM TEMP_INVALID_APP_04;
  COMMIT;
  DELETE FROM TEMP_ONE_AMOUNT;
  COMMIT;
  DELETE FROM TEMP_INVALID_APP;
  COMMIT;
  DELETE FROM TEMP_PREREC;
  COMMIT;
  DELETE FROM TEMP_FXTJ;
  COMMIT;
  DELETE FROM TEMP_M_TO_Y;
  COMMIT;
  DELETE FROM TEMP_Y_PREREC;
  COMMIT;

  INSERT INTO TEMP_INVALID_APP_01
    (TASK_DATE
    ,USE_ALI_ID
    ,POLICYNO
    ,APPNO
    ,INVALID_DATE
    ,REINSTATE
    ,REINNAME)
    SELECT TASK_DATE
          ,USE_ALI_ID
          ,POLICYNO
          ,APPNO
          ,INVALID_DATE
          ,REINSTATE
          ,DECODE(REINSTATE, '1', '成功', '0', '失败', '') AS REINNAME
      FROM (SELECT XP1.POLICYNO
                  ,XP1.APPNO
                  ,XP1.USE_ALI_ID
                  ,XP1.TASK_DATE
                  ,XP1.REINSTATE
                  ,XP1.PAYCODE
                  ,XP1.INVALID_DATE
                  ,ROW_NUMBER() OVER(PARTITION BY XP1.POLICYNO, XP1.INVALID_DATE ORDER BY XP1.INVALID_DATE DESC) RN1
              FROM XQ_INVALID_APP XP1)
     WHERE RN1 = 1;
  COMMIT;

  INSERT INTO TEMP_INVALID_APP_02
    (POLICYNO
    ,INVALID_DATE
    ,ROW_NOW
    ,ROW_NEXT)
    SELECT POLICYNO
          ,INVALID_DATE
          ,ROW_NOW
          ,ROW_NOW - 1 AS ROW_NEXT
      FROM (SELECT TASK_DATE
                  ,USE_ALI_ID
                  ,POLICYNO
                  ,APPNO
                  ,INVALID_DATE
                  ,REINSTATE
                  ,REINNAME
                  ,ROW_NUMBER() OVER(PARTITION BY T01.POLICYNO ORDER BY T01.INVALID_DATE) ROW_NOW
              FROM TEMP_INVALID_APP_01 T01);
  COMMIT;

  INSERT INTO TEMP_INVALID_APP_03
    (POLICYNO
    ,INVALID_DATE
    ,NEXT_INVALID_DATE)
    SELECT T01.POLICYNO
          ,T01.INVALID_DATE
          ,NVL(T02.INVALID_DATE, TO_DATE('9999-12-31', 'YYYY-MM-DD')) AS NEXT_INVALID_DATE
      FROM TEMP_INVALID_APP_02 T01
          ,TEMP_INVALID_APP_02 T02
     WHERE T01.POLICYNO = T02.POLICYNO(+)
       AND T01.ROW_NOW = T02.ROW_NEXT(+);
  COMMIT;

  INSERT INTO TEMP_M_TO_Y
    (POLICYNO)
    SELECT POLICYNO
      FROM (SELECT A1.POLICYNO
                  ,A1.PAYCODE
              FROM XQ_PREREC A1
             WHERE EXISTS (SELECT 1 FROM TEMP_INVALID_APP_01 A2 WHERE A1.POLICYNO = A2.POLICYNO)
             GROUP BY A1.POLICYNO
                     ,A1.PAYCODE) A3
     GROUP BY A3.POLICYNO
    HAVING COUNT(1) > 1;
  COMMIT;

  INSERT INTO TEMP_Y_PREREC
    (SNO
    ,POLICYNO
    ,AMOUNT
    ,PAYDATE
    ,RN)
    SELECT A.SNO
          ,A.POLICYNO
          ,A.AMOUNT
          ,A.PAYDATE
          ,DENSE_RANK() OVER(PARTITION BY A.POLICYNO ORDER BY A.PAYDATE) AS RN
      FROM XQ_PREREC A
     WHERE EXISTS (SELECT 1 FROM TEMP_M_TO_Y A1 WHERE A.POLICYNO = A1.POLICYNO)
       AND A.PCODE = '5'
       AND A.PAYCODE = '705';
  COMMIT;

  --计算实收保费
  INSERT INTO TEMP_PREREC
    (POLICYNO
    ,PAYDATE
    ,ACC_AMOUNT)
    SELECT A.POLICYNO
          ,A.PAYDATE
          ,SUM(A.AMOUNT) AS ACC_AMOUNT
      FROM XQ_PREREC A
     WHERE NOT EXISTS (SELECT 1
              FROM TEMP_Y_PREREC A2
             WHERE A.SNO = A2.SNO
               AND A2.RN = 1)
       AND EXISTS (SELECT 1 FROM TEMP_INVALID_APP_03 A1 WHERE A.POLICYNO = A1.POLICYNO)
       AND A.PCODE = '5'
     GROUP BY A.POLICYNO
             ,A.PAYDATE;
  COMMIT;

  INSERT INTO TEMP_INVALID_APP_04
    (POLICYNO
    ,INVALID_DATE
    ,PAYDATE
    ,ACC_AMOUNT)
    SELECT A.POLICYNO
          ,A.INVALID_DATE
          ,B.PAYDATE
          ,B.ACC_AMOUNT
      FROM TEMP_INVALID_APP_03 A
          ,TEMP_PREREC B
     WHERE A.POLICYNO = B.POLICYNO(+)
       AND A.INVALID_DATE <= B.PAYDATE(+)
       AND A.NEXT_INVALID_DATE > B.PAYDATE(+);
  COMMIT;

  INSERT INTO TEMP_INVALID_APP
    (TASK_DATE
    ,USE_ALI_ID
    ,POLICYNO
    ,APPNO
    ,INVALID_DATE
    ,REINSTATE
    ,REINNAME
    ,PAYDATE
    ,ACC_AMOUNT)
    SELECT A.TASK_DATE
          ,A.USE_ALI_ID
          ,A.POLICYNO
          ,A.APPNO
          ,A.INVALID_DATE
          ,A.REINSTATE
          ,A.REINNAME
          ,B.PAYDATE
          ,B.ACC_AMOUNT
      FROM TEMP_INVALID_APP_01 A
          ,TEMP_INVALID_APP_04 B
     WHERE A.POLICYNO = B.POLICYNO(+)
       AND A.INVALID_DATE = B.INVALID_DATE(+);
  COMMIT;
  --单期保费
  INSERT INTO TEMP_ONE_AMOUNT
    (POLICYNO
    ,ONE_AMOUNT)
    SELECT A.POLICYNO
          ,SUM(A.PIECES * A.NPAYLEN) AS ONE_AMOUNT
      FROM XQ_RISKCON A
     WHERE EXISTS (SELECT 1 FROM TEMP_INVALID_APP B WHERE A.POLICYNO = B.POLICYNO)
     GROUP BY A.POLICYNO;
  COMMIT;

  --入中间表
  INSERT INTO TEMP_FXTJ
    (CURR_DATA
    ,USE_ALI_ID
    ,USE_NAM
    ,POLICYNO
    ,TASK_DATE
    ,REINSTATE
    ,ONE_AMOUNT
    ,ACC_AMOUNT
    ,PAYDATE
    ,GRO_ID
    ,CAT_NAM
    ,INVALID_DATE)
    SELECT TRUNC(SYSDATE, 'DD') AS CURR_DATA
          ,A.USE_ALI_ID AS USE_ALI_ID
          ,USE_NAM
          ,A.POLICYNO AS POLICYNO
          ,TASK_DATE
          ,REINSTATE
          ,ONE_AMOUNT
          ,ACC_AMOUNT
          ,PAYDATE
          ,GRO_ID
          ,CAT_NAM
          ,A.INVALID_DATE AS INVALID_DATE
      FROM TEMP_INVALID_APP A
          ,TEMP_ONE_AMOUNT B
          ,(SELECT USE_ALI_ID
                  ,USE_NAM
                  ,GRO_ID
                  ,CAT_NAM
              FROM (SELECT U.USE_ALI_ID
                          ,U.USE_NAM
                          ,G.GRO_ID
                          ,C.CAT_NAM
                      FROM C_USE U
                          ,C_USE_GRO G
                          ,C_CAT C
                     WHERE U.USE_ID = G.USE_ID(+)
                       AND G.GRO_ID = C.CAT_ID(+)
                       AND G.GRO_ID <> '9005'
                       AND U.USE_FLAG = '1')) CUSE
     WHERE A.POLICYNO = B.POLICYNO(+)
       AND A.USE_ALI_ID = CUSE.USE_ALI_ID;
  COMMIT;

  --入备份表(当月复效情况)
  INSERT INTO TEMP_M_FXTJ
    (CURRDATE
    ,TASK_MONTH
    ,USE_ALI_ID
    ,USE_NAM
    ,DYFDJS
    ,DYFDBF
    ,DYFXJS
    ,DYFXBF
    ,DYJSLV
    ,DYBFLV
    ,DYSSJS
    ,DYSSBF
    ,DNFDJS
    ,DNFDBF
    ,DNFXJS
    ,DNFXBF
    ,DNJSLV
    ,DNBFLV
    ,DNSSJS
    ,DNSSBF
    ,GRO_ID
    ,CAT_NAM
    ,CREATE_DATE)
    SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') AS CURRDATE
          ,TASK_MONTH
          ,A.USE_ALI_ID
          ,A.USE_NAM
          ,A.DYFDJS
          ,A.DYFDBF
          ,A.DYFXJS
          ,A.DYFXBF
          ,ROUND(NVL(A.DYFXJS, 0) / DECODE(NVL(A.DYFDJS, 0), 0, 10000, A.DYFDJS), 4) AS DYJSLV
          ,ROUND(NVL(A.DYFXBF, 0) / DECODE(NVL(A.DYFDBF, 0), 0, 10000, A.DYFDBF), 4) AS DYBFLV
          ,A.DYSSJS
          ,A.DYSSBF
          ,A.DNFDJS
          ,A.DNFDBF
          ,A.DNFXJS
          ,A.DNFXBF
          ,ROUND(NVL(A.DNFXJS, 0) / DECODE(NVL(A.DNFDJS, 0), 0, 10000, A.DNFDJS), 4) AS DNJSLV
          ,ROUND(NVL(A.DNFXBF, 0) / DECODE(NVL(A.DNFDBF, 0), 0, 10000, A.DNFDBF), 4) AS DNBFLV
          ,A.DNSSJS
          ,A.DNSSBF
          ,A.GRO_ID
          ,A.CAT_NAM
          ,SYSDATE
      FROM (SELECT A1.USE_ALI_ID
                  ,MAX(A1.USE_NAM) AS USE_NAM
                  ,TO_CHAR(SYSDATE, 'YYYY-MM') TASK_MONTH
                  ,COUNT(CASE
                           WHEN TO_CHAR(A1.TASK_DATE, 'YYYY-MM') = TO_CHAR(SYSDATE, 'YYYY-MM') THEN
                            1
                         END) AS DYFDJS
                  ,SUM(CASE
                         WHEN TO_CHAR(A1.TASK_DATE, 'YYYY-MM') = TO_CHAR(SYSDATE, 'YYYY-MM') THEN
                          A1.ONE_AMOUNT
                       END) AS DYFDBF
                  ,COUNT(CASE
                           WHEN A1.REINSTATE = '1'
                                AND TO_CHAR(A1.TASK_DATE, 'YYYY-MM') = TO_CHAR(SYSDATE, 'YYYY-MM')
                                AND TO_CHAR(A1.PAYDATE, 'YYYY-MM') = TO_CHAR(SYSDATE, 'YYYY-MM') THEN
                            1
                         END) DYFXJS
                  ,SUM(CASE
                         WHEN A1.REINSTATE = '1'
                              AND TO_CHAR(A1.TASK_DATE, 'YYYY-MM') = TO_CHAR(SYSDATE, 'YYYY-MM')
                              AND TO_CHAR(A1.PAYDATE, 'YYYY-MM') = TO_CHAR(SYSDATE, 'YYYY-MM') THEN
                          A1.ONE_AMOUNT
                       END) AS DYFXBF
                  ,COUNT(CASE
                           WHEN A1.REINSTATE = '1'
                                AND TO_CHAR(A1.PAYDATE, 'YYYY-MM') = TO_CHAR(SYSDATE, 'YYYY-MM') THEN
                            1
                         END) DYSSJS
                  ,SUM(CASE
                         WHEN A1.REINSTATE = '1'
                              AND TO_CHAR(A1.PAYDATE, 'YYYY-MM') = TO_CHAR(SYSDATE, 'YYYY-MM') THEN
                          A1.ACC_AMOUNT
                       END) AS DYSSBF
                  ,COUNT(CASE
                           WHEN TO_CHAR(A1.TASK_DATE, 'YYYY') = TO_CHAR(SYSDATE, 'YYYY') THEN
                            1
                         END) AS DNFDJS
                  ,SUM(CASE
                         WHEN TO_CHAR(A1.TASK_DATE, 'YYYY') = TO_CHAR(SYSDATE, 'YYYY') THEN
                          A1.ONE_AMOUNT
                       END) AS DNFDBF
                  ,COUNT(CASE
                           WHEN A1.REINSTATE = '1'
                                AND TO_CHAR(A1.TASK_DATE, 'YYYY') = TO_CHAR(SYSDATE, 'YYYY')
                                AND TO_CHAR(A1.PAYDATE, 'YYYY') = TO_CHAR(SYSDATE, 'YYYY') THEN
                            1
                         END) DNFXJS
                  ,SUM(CASE
                         WHEN A1.REINSTATE = '1'
                              AND TO_CHAR(A1.TASK_DATE, 'YYYY') = TO_CHAR(SYSDATE, 'YYYY')
                              AND TO_CHAR(A1.PAYDATE, 'YYYY') = TO_CHAR(SYSDATE, 'YYYY') THEN
                          A1.ONE_AMOUNT
                       END) AS DNFXBF
                  ,COUNT(CASE
                           WHEN A1.REINSTATE = '1'
                                AND TO_CHAR(A1.PAYDATE, 'YYYY') = TO_CHAR(SYSDATE, 'YYYY') THEN
                            1
                         END) DNSSJS
                  ,SUM(CASE
                         WHEN A1.REINSTATE = '1'
                              AND TO_CHAR(A1.PAYDATE, 'YYYY') = TO_CHAR(SYSDATE, 'YYYY') THEN
                          A1.ACC_AMOUNT
                       END) AS DNSSBF
                  ,MAX(A1.GRO_ID) AS GRO_ID
                  ,MAX(A1.CAT_NAM) AS CAT_NAM
              FROM TEMP_FXTJ A1
             GROUP BY A1.USE_ALI_ID) A;
  COMMIT;

  --T+2数据延迟
  IF DATE_FLAG IN ('01', '02')
  THEN
    DELETE FROM TEMP_M_FXTJ A WHERE A.CURRDATE = DATE_DEL;
    COMMIT;

    INSERT INTO TEMP_M_FXTJ
      (CURRDATE
      ,TASK_MONTH
      ,USE_ALI_ID
      ,USE_NAM
      ,DYFDJS
      ,DYFDBF
      ,DYFXJS
      ,DYFXBF
      ,DYJSLV
      ,DYBFLV
      ,DYSSJS
      ,DYSSBF
      ,DNFDJS
      ,DNFDBF
      ,DNFXJS
      ,DNFXBF
      ,DNJSLV
      ,DNBFLV
      ,DNSSJS
      ,DNSSBF
      ,GRO_ID
      ,CAT_NAM
      ,CREATE_DATE)
      SELECT DATE_DEL AS CURRDATE
            ,TASK_MONTH
            ,A.USE_ALI_ID
            ,A.USE_NAM
            ,A.DYFDJS
            ,A.DYFDBF
            ,A.DYFXJS
            ,A.DYFXBF
            ,ROUND(NVL(A.DYFXJS, 0) / DECODE(NVL(A.DYFDJS, 0), 0, 10000, A.DYFDJS), 4) AS DYJSLV
            ,ROUND(NVL(A.DYFXBF, 0) / DECODE(NVL(A.DYFDBF, 0), 0, 10000, A.DYFDBF), 4) AS DYBFLV
            ,A.DYSSJS
            ,A.DYSSBF
            ,A.DNFDJS
            ,A.DNFDBF
            ,A.DNFXJS
            ,A.DNFXBF
            ,ROUND(NVL(A.DNFXJS, 0) / DECODE(NVL(A.DNFDJS, 0), 0, 10000, A.DNFDJS), 4) AS DNJSLV
            ,ROUND(NVL(A.DNFXBF, 0) / DECODE(NVL(A.DNFDBF, 0), 0, 10000, A.DNFDBF), 4) AS DNBFLV
            ,A.DNSSJS
            ,A.DNSSBF
            ,A.GRO_ID
            ,A.CAT_NAM
            ,SYSDATE
        FROM (SELECT A1.USE_ALI_ID
                    ,MAX(A1.USE_NAM) AS USE_NAM
                    ,DATE_IN_M TASK_MONTH
                    ,COUNT(CASE
                             WHEN TO_CHAR(A1.TASK_DATE, 'YYYY-MM') = DATE_IN_M THEN
                              1
                           END) AS DYFDJS
                    ,SUM(CASE
                           WHEN TO_CHAR(A1.TASK_DATE, 'YYYY-MM') = DATE_IN_M THEN
                            A1.ONE_AMOUNT
                         END) AS DYFDBF
                    ,COUNT(CASE
                             WHEN A1.REINSTATE = '1'
                                  AND TO_CHAR(A1.TASK_DATE, 'YYYY-MM') = DATE_IN_M
                                  AND TO_CHAR(A1.PAYDATE, 'YYYY-MM') = DATE_IN_M THEN
                              1
                           END) DYFXJS
                    ,SUM(CASE
                           WHEN A1.REINSTATE = '1'
                                AND TO_CHAR(A1.TASK_DATE, 'YYYY-MM') = DATE_IN_M
                                AND TO_CHAR(A1.PAYDATE, 'YYYY-MM') = DATE_IN_M THEN
                            A1.ONE_AMOUNT
                         END) AS DYFXBF
                    ,COUNT(CASE
                             WHEN A1.REINSTATE = '1'
                                  AND TO_CHAR(A1.PAYDATE, 'YYYY-MM') = DATE_IN_M THEN
                              1
                           END) DYSSJS
                    ,SUM(CASE
                           WHEN A1.REINSTATE = '1'
                                AND TO_CHAR(A1.PAYDATE, 'YYYY-MM') = DATE_IN_M THEN
                            A1.ACC_AMOUNT
                         END) AS DYSSBF
                    ,COUNT(CASE
                             WHEN TO_CHAR(A1.TASK_DATE, 'YYYY') = DATE_IN_Y THEN
                              1
                           END) AS DNFDJS
                    ,SUM(CASE
                           WHEN TO_CHAR(A1.TASK_DATE, 'YYYY') = DATE_IN_Y THEN
                            A1.ONE_AMOUNT
                         END) AS DNFDBF
                    ,COUNT(CASE
                             WHEN A1.REINSTATE = '1'
                                  AND TO_CHAR(A1.TASK_DATE, 'YYYY') = DATE_IN_Y
                                  AND TO_CHAR(A1.PAYDATE, 'YYYY') = DATE_IN_Y THEN
                              1
                           END) DNFXJS
                    ,SUM(CASE
                           WHEN A1.REINSTATE = '1'
                                AND TO_CHAR(A1.TASK_DATE, 'YYYY') = DATE_IN_Y
                                AND TO_CHAR(A1.PAYDATE, 'YYYY') = DATE_IN_Y THEN
                            A1.ONE_AMOUNT
                         END) AS DNFXBF
                    ,COUNT(CASE
                             WHEN A1.REINSTATE = '1'
                                  AND TO_CHAR(A1.PAYDATE, 'YYYY') = DATE_IN_Y THEN
                              1
                           END) DNSSJS
                    ,SUM(CASE
                           WHEN A1.REINSTATE = '1'
                                AND TO_CHAR(A1.PAYDATE, 'YYYY') = DATE_IN_Y THEN
                            A1.ACC_AMOUNT
                         END) AS DNSSBF
                    ,MAX(A1.GRO_ID) AS GRO_ID
                    ,MAX(A1.CAT_NAM) AS CAT_NAM
                FROM TEMP_FXTJ A1
               GROUP BY A1.USE_ALI_ID) A;
    COMMIT;
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    BEGIN
      ROLLBACK;
    END;
END T_FXTJ_INFO;
/

prompt
prompt Creating procedure T_RETURNLIST_INFO
prompt ====================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.T_RETURNLIST_INFO
IS
 CURSOR C_RETURNLIST
        IS

  SELECT
       --
REM.USE_ALI_ID,
--
REM.AMOUNT,
--
 CALL_DATE,
--
REM.TASK_DATE,
--
CASE WHEN VIS.RETURNVIST_STA is NULL  THEN 1999 ELSE VIS.RETURNVIST_STA END RETURNVIST_STA,
  --
APP.BEGDATE,
--
APP.POLICYNO,
--
C_USE.USE_NAM,
--
GRO.GRO_ID,
--
CAT.CAT_NAM
  FROM (

select * from (
select REMINDER_ID, USE_ALI_ID,AMOUNT,XQ_APP_ID,TASK_DATE,POLICYNO,cover1,
row_number() over(partition by policyno order by task_date desc nulls last ,cover1 desc ) rn
from XQ_REMINDER WHERE STATUS NOT IN ('401','407','408') AND IS_DELETE IS NULL
and task_date is not null
) XQ_REMINDER where rn = 1


) REM

LEFT JOIN (

SELECT VIS.REMINDER_ID,VIS.CALL_DATE,call_use_ali,policyno,
CASE WHEN VIS.RETURNVIST_STA IS NULL THEN 2000 ELSE VIS.RETURNVIST_STA END RETURNVIST_STA
FROM (
select * from (
select
xrt.call_date,
xrt.reminder_id,
xrt.RETURNVIST_STA,
xrt.call_use_ali,
xrt.policyno,
ROW_NUMBER() OVER(PARTITION BY xrt.policyno ORDER BY xrt.CALL_DATE DESC) RN
from XQ_RETURNVISIT xrt
) where rn =1) VIS) VIS ON VIS.POLICYNO = REM.POLICYNO AND VIS.CALL_USE_ALI = REM.USE_ALI_ID

INNER JOIN  (SELECT XQ_APP_ID,BEGDATE,POLICYNO FROM XQ_APP) APP ON APP.POLICYNO = REM.POLICYNO

INNER JOIN C_USE  ON C_USE.USE_ALI_ID = REM.USE_ALI_ID

INNER JOIN (select * from c_use_gro where gro_id<>'9005') GRO ON GRO.USE_ID = C_USE.USE_ID

INNER JOIN C_CAT CAT ON CAT.CAT_ID =GRO.GRO_ID;




 C_ROW C_RETURNLIST%rowtype;

BEGIN
       delete TEMP_XSHFMX ;
       commit;
     OPEN C_RETURNLIST;

      LOOP
   --    FETCH C_RETURNLIST INTO USE_ALI_ID,AMOUNT,CALL_DATE,TASK_DATE,RETURNVIST_STA,BEGDATE,POLICYNO,USE_NAM,GRO_ID,CAT_NAM
        FETCH C_RETURNLIST INTO C_ROW;
        EXIT  WHEN C_RETURNLIST%NOTFOUND;
        -- dbms_output.put_line(nvl(c_row.USE_ALI_ID,'')||'-'||nvl(c_row.AMOUNT,'')||'-'||nvl(c_row.POLICYNO,'')||'-'||nvl(c_row.CALL_DATE,''));
         --dbms_output.put_line(nvl(c_row.USE_ALI_ID,''));
         insert into TEMP_XSHFMX values(c_row.USE_ALI_ID,c_row.USE_NAM,c_row.POLICYNO,c_row.CALL_DATE,
         c_row.RETURNVIST_STA,c_row.AMOUNT,c_row.TASK_DATE,c_row.BEGDATE,c_row.GRO_ID ,c_row.CAT_NAM);
         commit;
      END LOOP;
     CLOSE C_RETURNLIST;
  END T_RETURNLIST_INFO;
/

prompt
prompt Creating procedure T_XSHF_INFO
prompt ==============================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.T_XSHF_INFO
IS
 CURSOR C_XSHF
        IS
SELECT DISTINCT
RE.USE_ALI_ID,
US.USE_NAM,
AP.POLICYNO,
-- 已回访
CASE WHEN PE.IS_SUCCESS IN ('1','0') THEN 1
  -- 未拨打
   WHEN RETURNVIST_STA IS NULL THEN 2
     --未接通
    WHEN RETURNVIST_STA IN ('1008','1009','1010','1011','1012') THEN 3
      -- 无需拨打
       WHEN RETURNVIST_STA ='1013' THEN 4 END RETURNVIST_STA,
NVL(RE.AMOUNT,0) AMOUNT,
PE.IS_SUCCESS,
RE.TASK_DATE,
GRO.GRO_ID,
CA.CAT_NAM,
RE.COVER1,
CASE WHEN ceil((sysdate - RE.COVER1)) = 10 THEN 10
    WHEN ceil((sysdate - RE.COVER1)) = 20 THEN 20
    WHEN ceil((sysdate - RE.COVER1)) = 30 THEN 30
    WHEN ceil((sysdate - RE.COVER1)) = 40 THEN 40
    WHEN ceil((sysdate - RE.COVER1)) = 50 THEN 50
      WHEN ceil((sysdate - RE.COVER1)) = 60 THEN 60
      END DAY_FLAG
FROM (SELECT * FROM XQ_REMINDER WHERE IS_DELETE IS NULL) RE
INNER JOIN XQ_APP  AP ON RE.Policyno = AP.Policyno
INNER JOIN   (
select reminder_id,  max(is_success)  is_success
 from XQ_PERIOD
 group by reminder_id
 )
 PE ON RE.REMINDER_ID = PE.REMINDER_ID AND RE.STATUS = 402
INNER JOIN C_USE US ON US.USE_ALI_ID = RE.USE_ALI_ID
INNER JOIN (select * from c_use_gro where gro_id<>'9005') GRO ON GRO.USE_ID =US.USE_ID
INNER JOIN C_CAT CA ON CA.CAT_ID =GRO.GRO_ID
LEFT JOIN  (

SELECT VIS.REMINDER_ID,VIS.CALL_DATE,call_use_ali,
CASE WHEN VIS.RETURNVIST_STA IS NULL THEN 2000 ELSE VIS.RETURNVIST_STA END RETURNVIST_STA
FROM (
select * from (
select
xrt.call_date,
xrt.reminder_id,
xrt.RETURNVIST_STA,
xrt.call_use_ali,
ROW_NUMBER() OVER(PARTITION BY xrt.REMINDER_ID ORDER BY xrt.CALL_DATE DESC) RN
from XQ_RETURNVISIT xrt
) where rn =1) VIS) VIS ON VIS.REMINDER_ID = RE.REMINDER_ID and vis.call_use_ali = re.use_ali_id

WHERE  (ceil((SYSDATE - RE.COVER1)) = 10 OR ceil((SYSDATE - RE.COVER1)) = 20 OR ceil((SYSDATE - RE.COVER1)) = 30 OR
ceil((SYSDATE - RE.COVER1)) = 40 OR ceil((SYSDATE - RE.COVER1)) = 50 OR ceil((SYSDATE - RE.COVER1)) = 60 );


 C_ROW C_XSHF%rowtype;

BEGIN
      -- EXECUTE   IMMEDIATE   'truncate table TEMP_XSHDGL ';
     OPEN C_XSHF;

      LOOP

        FETCH C_XSHF INTO C_ROW;
        EXIT  WHEN C_XSHF%NOTFOUND;
         insert into TEMP_XSHDGL values(TO_DATE(to_char(sysdate(),'yyyy-mm-dd'),'yyyy-mm-dd'),
         c_row.USE_ALI_ID,
         c_row.USE_NAM,
         c_row.POLICYNO,
         c_row.RETURNVIST_STA,
         c_row.AMOUNT,
         c_row.IS_SUCCESS,
         c_row.TASK_DATE,
         c_row.GRO_ID,
         c_row.CAT_NAM,
         c_row.COVER1,
         c_row.DAY_FLAG );
         commit;
      END LOOP;
     CLOSE C_XSHF;
  END T_XSHF_INFO;
/

prompt
prompt Creating procedure T_XSHF_INFO_B
prompt ================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.T_XSHF_INFO_B (v_is_need_delete in number,v_delete_date in  varchar,v_datev_date  in varchar )
IS
 CURSOR C_XSHF
        IS
SELECT DISTINCT
RE.USE_ALI_ID,
US.USE_NAM,
AP.POLICYNO,
-- 已回访
CASE WHEN PE.IS_SUCCESS IN ('1','0') THEN 1
  -- 未拨打
   WHEN RETURNVIST_STA IS NULL THEN 2
     --未接通
    WHEN RETURNVIST_STA IN ('1008','1009','1010','1011','1012') THEN 3
      -- 无需拨打
       WHEN RETURNVIST_STA ='1013' THEN 4 END RETURNVIST_STA,
NVL(RE.AMOUNT,0) AMOUNT,
PE.IS_SUCCESS,
RE.TASK_DATE,
GRO.GRO_ID,
CA.CAT_NAM,
RE.COVER1,
CASE WHEN ceil((to_DATE(v_datev_date, 'yyyy-mm-dd') - RE.COVER1)) = 9 THEN 10
    WHEN ceil((to_DATE(v_datev_date, 'yyyy-mm-dd') - RE.COVER1)) = 19 THEN 20
    WHEN ceil((to_DATE(v_datev_date, 'yyyy-mm-dd') - RE.COVER1)) = 29 THEN 30
    WHEN ceil((to_DATE(v_datev_date, 'yyyy-mm-dd') - RE.COVER1)) = 39 THEN 40
    WHEN ceil((to_DATE(v_datev_date, 'yyyy-mm-dd') - RE.COVER1)) = 49 THEN 50
      WHEN ceil((to_DATE(v_datev_date, 'yyyy-mm-dd') - RE.COVER1)) = 59 THEN 60
      END DAY_FLAG
FROM (SELECT * FROM XQ_REMINDER WHERE IS_DELETE IS NULL) RE
INNER JOIN XQ_APP  AP ON RE.Policyno = AP.Policyno
INNER JOIN   (
select reminder_id,  max(is_success)  is_success
 from XQ_PERIOD
 group by reminder_id
 )
 PE ON RE.REMINDER_ID = PE.REMINDER_ID AND RE.STATUS = 402
INNER JOIN C_USE US ON US.USE_ALI_ID = RE.USE_ALI_ID
INNER JOIN (select * from c_use_gro where gro_id<>'9005') GRO ON GRO.USE_ID =US.USE_ID
INNER JOIN C_CAT CA ON CA.CAT_ID =GRO.GRO_ID
LEFT JOIN  (

SELECT VIS.REMINDER_ID,VIS.CALL_DATE,call_use_ali,
CASE WHEN VIS.RETURNVIST_STA IS NULL THEN 2000 ELSE VIS.RETURNVIST_STA END RETURNVIST_STA
FROM (
select * from (
select
xrt.call_date,
xrt.reminder_id,
xrt.RETURNVIST_STA,
xrt.call_use_ali,
ROW_NUMBER() OVER(PARTITION BY xrt.REMINDER_ID ORDER BY xrt.CALL_DATE DESC) RN
from XQ_RETURNVISIT xrt
) where rn =1) VIS) VIS ON VIS.REMINDER_ID = RE.REMINDER_ID and vis.call_use_ali = re.use_ali_id

WHERE  (ceil((to_DATE(v_datev_date, 'yyyy-mm-dd') - RE.COVER1)) = 9 OR ceil((to_DATE(v_datev_date, 'yyyy-mm-dd') - RE.COVER1))

= 19 OR ceil((to_DATE(v_datev_date, 'yyyy-mm-dd') - RE.COVER1)) = 29 OR
ceil((to_DATE(v_datev_date, 'yyyy-mm-dd') - RE.COVER1)) = 39 OR ceil((to_DATE(v_datev_date, 'yyyy-mm-dd') - RE.COVER1)) =49 OR

ceil((to_DATE(v_datev_date, 'yyyy-mm-dd') - RE.COVER1)) = 59 );


 C_ROW C_XSHF%rowtype;

BEGIN
      -- EXECUTE   IMMEDIATE   'truncate table TEMP_XSHDGL ';
      -- 根据时间删除
      IF v_is_need_delete = 0 and v_delete_date is not null
        then
          begin
           delete TEMP_XSHDGL where CURR_DATA=to_DATE(v_delete_date, 'yyyy-mm-dd');
            commit;
      end;
       end if;

      -- 全部删除
         IF v_is_need_delete = 0 and v_delete_date is  null
        then
          begin
           delete TEMP_XSHDGL ;
            commit;
      end;
       end if;


        IF v_datev_date IS NOT NULL
        then
          begin


     OPEN C_XSHF;

      LOOP

        FETCH C_XSHF INTO C_ROW;
        EXIT  WHEN C_XSHF%NOTFOUND;
         insert into TEMP_XSHDGL values(to_DATE(v_datev_date, 'yyyy-mm-dd'),
         c_row.USE_ALI_ID,
         c_row.USE_NAM,
         c_row.POLICYNO,
         c_row.RETURNVIST_STA,
         c_row.AMOUNT,
         c_row.IS_SUCCESS,
         c_row.TASK_DATE,
         c_row.GRO_ID,
         c_row.CAT_NAM,
         c_row.COVER1,
         c_row.DAY_FLAG );
         commit;
      END LOOP;

     CLOSE C_XSHF;
     END;
      END IF;
  END T_XSHF_INFO_B;
/

prompt
prompt Creating procedure T_XSHF_USE
prompt =============================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.T_XSHF_USE(v_start_time in varchar,
                                       v_end_time   in varchar) IS

  CURSOR C_XSHF IS
    SELECT CEIL(TO_DATE(v_end_time, 'YYYY-MM-DD') -
                TO_DATE(v_start_time, 'YYYY-MM-DD')) DATACOUNT
      FROM DUAL;

  C_ROW     C_XSHF%rowtype;
  TIMECOUNT NUMBER := 0;
  TIMEVALUE NUMBER;
BEGIN
  OPEN C_XSHF;
  LOOP
    FETCH C_XSHF
      INTO C_ROW;
    EXIT WHEN C_XSHF%NOTFOUND;
    TIMEVALUE := C_ROW.DATACOUNT;
    WHILE TIMECOUNT < TIMEVALUE LOOP
      BEGIN
        T_XSHF_INFO_B(0,
                      TO_CHAR(TO_DATE(v_start_time, 'YYYY-MM-DD') +
                              TIMECOUNT,
                              'YYYY-MM-DD'),
                      TO_CHAR(TO_DATE(v_start_time, 'YYYY-MM-DD') +
                              TIMECOUNT,
                              'YYYY-MM-DD'));

        TIMECOUNT := TIMECOUNT + 1;
      END;
    END LOOP;
  END LOOP;

  CLOSE C_XSHF;

END T_XSHF_USE;
/

prompt
prompt Creating procedure UPDATE_REMINDER
prompt ==================================
prompt
CREATE OR REPLACE PROCEDURE UNICALL.UPDATE_REMINDER AS
BEGIN
  UPDATE XQ_REMINDER R
     SET R.APNAME = '客户甲'
   WHERE R.USE_ALI_ID = 'sunyi'
     AND ROWNUM < 10;
  COMMIT;
END;
/

prompt
prompt Creating procedure XQ_CONTINUATION_REPORT_1325
prompt ==============================================
prompt
create or replace procedure unicall.XQ_continuation_report_1325
(
 sta_date varchar,--统计日期
 sta_kind integer --统计类型 13/25个月
) is
  /*
  ******************************************************
  *  存储过程名 ：XQ_CONTINUATION_REPORT_1325
  *  建立日期   ：2012-04-5
  *  作者       ：huayi,baichuanyin,yangguoqi
  *  模块       ：续收报表-继续率报表
  *  描述       ：继续率报表统计13/25个月当月、宽一、宽末、累计
  *----------------------------------------------------
  *  序号 修改日期    修改人     修改原因
  *  1  2012-06-28  yangguoqi    增加月转年处理
  *  2
  ******************************************************
  */
 v_sta_date date;
 v_sta_kind integer:=nvl(sta_kind,13);

 --每年的1月1日
 v_first_day_of_year date := trunc(sysdate,'yyyy');
 v_current_month integer;
 v_begin_date date; --计算累计时的起始时间
 v_end_date   date; --计算累计时的截止时间

  /*维度*/
  cursor cur_branch is
     select x.branch orgcode ,f.sales_project,f.sales_organ, 0 as t
     from xq_riskcon x, xq_sales_info f
     where x.empno = f.empno(+)    --左关联
     and x.classcode in (select c.classcode from xq_riskclass c where c.timestr = '1')
     --and x.appf='1'
     group by x.branch ,f.sales_project,f.sales_organ ; --落地分公司
  cursor cur_emp is
     select distinct s.empno, 1 as t, s.sales_project, s.sales_organ, s.sales_classify from xq_sales_info s, xq_riskcon r
     where s.empno(+) = r.empno;--销售机构

  cur_b cur_branch%rowtype;
  cur_e cur_emp%rowtype;
begin
   if sta_date is null then
     v_sta_date:= sysdate;
   else
     v_sta_date:=to_date(sta_date,'yyyy-mm-dd');
   end if;
   v_first_day_of_year:=trunc(v_sta_date,'yyyy');
   v_current_month:=to_number(to_char(v_sta_date,'mm'));
   v_begin_date:= add_months(v_first_day_of_year,-(sta_kind+1));
   v_end_date:= add_months(v_begin_date,v_current_month);

   open cur_branch; --落地分公司
        loop
          fetch cur_branch into cur_b ;
          exit when cur_branch%notfound;
          if cur_b.sales_project is not null and cur_b.sales_organ is not null then
          insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
           select trim(cur_b.orgcode),cur_b.t,to_char(v_sta_date,'yyyy-mm'),sysdate,v_sta_kind,v_sta_kind,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                    then r.initial_amount
                    else null
                  end
              ),0) n1,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                    then r.initial_amount
                    else null
                  end
              ),0)d1,
              nvl(sum(
                 case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                    then r.initial_amount
                    else null
                  end
              ),0)n2,
              nvl(sum(
                   case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                    then r.initial_amount
                    else null
                  end
              ),0)d2,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                    then r.initial_amount
                    else null
                  end
              ),0)n3,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                    then r.initial_amount
                    else null
                  end
              ),0)d3,
              nvl(sum(
                  case
                    when r.begdate-1>=v_begin_date  and r.begdate-1<v_end_date
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                    then r.initial_amount
                    else null
                  end
              ),0)n4,
              nvl(sum(
                  case
                    when r.begdate-1>=v_begin_date  and r.begdate-1<v_end_date
                    then r.initial_amount
                    else null
                  end
              ),0)d4,trim(cur_b.sales_project),trim(cur_b.sales_organ),null
              from xq_riskcon r
              left join xq_moneysch m
               on r.policyno = m.policyno and r.classcode = m.classcode
               left join xq_sales_info f on r.empno = f.empno
               where m.initial_paysch in(10,11,13)--缴费方式
                and r.polist<>109        --犹豫期退保
                and m.paysch=m.initial_paysch --原始缴费方式和现在的缴费方式一样
                and r.classcode in(select p.classcode from xq_riskclass p where p.timestr = '1')
                and r.branch=cur_b.orgcode
                and f.sales_project = cur_b.sales_project
                and f.sales_organ = cur_b.sales_organ;

       --处理月转年
         insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
           select trim(cur_b.orgcode),cur_b.t,to_char(v_sta_date,'yyyy-mm'),sysdate,v_sta_kind,v_sta_kind,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                         and xr.status=404
                    then xr.amount
                    else null
                  end
              ),0) n1,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                    then xr.amount
                    else null
                  end
              ),0)d1,
              nvl(sum(
                 case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind))
                         and xr.status=404
                    then xr.amount
                    else null
                  end
              ),0)n2,
              nvl(sum(
                   case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind))
                    then xr.amount
                    else null
                  end
              ),0)d2,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                         and xr.status=404
                    then xr.amount
                    else null
                  end
              ),0)n3,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                    then xr.amount
                    else null
                  end
              ),0)d3,
              nvl(sum(
                  case
                    when r.begdate-1>=v_begin_date and r.begdate-1<v_end_date
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                         and xr.cover1>=v_begin_date and xr.cover1<v_end_date
                         and xr.status=404
                    then xr.amount
                    else null
                  end
              ),0)n4,
              nvl(sum(
                  case
                    when r.begdate-1>=v_begin_date  and r.begdate-1<v_end_date
                         and xr.cover1>=v_begin_date and xr.cover1<v_end_date
                    then xr.amount
                    else null
                  end
              ),0)d4,trim(cur_b.sales_project),trim(cur_b.sales_organ),'AAA'--null
              from xq_riskcon r
              inner join (select rm.policyno, rm.cover1, rm.reminder_id, rm.amount,rm.status,rm.paycode
                          from xq_reminder rm
                          where rm.STATUS IN (402, 403, 404, 405, 406)
                            AND (rm.IS_DELETE IS NULL)
                            AND TRIM(rm.PCODE) IN ('1', '2', '4', '5', '6')
                            AND rm.PAYCODE = 705
                            AND months_between(trunc(rm.cover2,'mm'),trunc(rm.cover1,'mm'))=12--年缴
              ) xr  on xr.policyno = r.policyno
              left join xq_moneysch m
               on r.policyno = m.policyno and r.classcode = m.classcode
              left join xq_sales_info f on r.empno = f.empno
               where r.polist<>109    --犹豫期退保
                and m.initial_paysch = '10'
                and m.paysch = '13'
                and r.classcode in(select p.classcode from xq_riskclass p where p.timestr = '1')
                and r.branch=cur_b.orgcode
                and f.sales_project = cur_b.sales_project
                and f.sales_organ = cur_b.sales_organ;

        else
                insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
           select trim(cur_b.orgcode),cur_b.t,to_char(v_sta_date,'yyyy-mm'),sysdate,v_sta_kind,v_sta_kind,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                    then r.initial_amount
                    else null
                  end
              ),0) n1,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                    then r.initial_amount
                    else null
                  end
              ),0)d1,
              nvl(sum(
                 case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                    then r.initial_amount
                    else null
                  end
              ),0)n2,
              nvl(sum(
                   case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                    then r.initial_amount
                    else null
                  end
              ),0)d2,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                    then r.initial_amount
                    else null
                  end
              ),0)n3,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                    then r.initial_amount
                    else null
                  end
              ),0)d3,
              nvl(sum(
                  case
                    when r.begdate-1>=v_begin_date  and r.begdate-1<v_end_date
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                    then r.initial_amount
                    else null
                  end
              ),0)n4,
              nvl(sum(
                  case
                    when r.begdate-1>=v_begin_date  and r.begdate-1<v_end_date
                    then r.initial_amount
                    else null
                  end
              ),0)d4,trim(cur_b.sales_project),trim(cur_b.sales_organ),null
              from xq_riskcon r
              left join xq_moneysch m
               on r.policyno = m.policyno and r.classcode = m.classcode
               left join xq_sales_info f on r.empno = f.empno
               where m.initial_paysch in(10,11,13)--缴费方式
                and r.polist<>109        --犹豫期退保
                and m.paysch=m.initial_paysch --原始缴费方式和现在的缴费方式一样
                and r.classcode in(select p.classcode from xq_riskclass p where p.timestr = '1')
                and r.branch=cur_b.orgcode
                and f.sales_project is null
                and f.sales_organ is null;

        --处理月转年
         insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
           select trim(cur_b.orgcode),cur_b.t,to_char(v_sta_date,'yyyy-mm'),sysdate,v_sta_kind,v_sta_kind,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                         and xr.status=404
                    then xr.amount
                    else null
                  end
              ),0) n1,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                    then xr.amount
                    else null
                  end
              ),0)d1,
              nvl(sum(
                 case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind))
                         and xr.status=404
                    then xr.amount
                    else null
                  end
              ),0)n2,
              nvl(sum(
                   case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind))
                    then xr.amount
                    else null
                  end
              ),0)d2,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                         and xr.status=404
                    then xr.amount
                    else null
                  end
              ),0)n3,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                    then xr.amount
                    else null
                  end
              ),0)d3,
              nvl(sum(
                  case
                    when r.begdate-1>=v_begin_date  and r.begdate-1<v_end_date
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                         and xr.cover1>=v_begin_date and xr.cover1<v_end_date
                         and xr.status=404
                    then xr.amount
                    else null
                  end
              ),0)n4,
              nvl(sum(
                  case
                    when r.begdate-1>=v_begin_date  and r.begdate-1<v_end_date
                    and xr.cover1>=v_begin_date and xr.cover1<v_end_date
                    then xr.amount
                    else null
                  end
              ),0)d4,trim(cur_b.sales_project),trim(cur_b.sales_organ),'AAA'--null
              from xq_riskcon r
              inner join (select rm.policyno, rm.cover1, rm.reminder_id, rm.amount,rm.status,rm.paycode
                          from xq_reminder rm
                          where rm.STATUS IN (402, 403, 404, 405, 406)
                            AND (rm.IS_DELETE IS NULL)
                            AND TRIM(rm.PCODE) IN ('1', '2', '4', '5', '6')
                            AND rm.PAYCODE = 705
                            AND months_between(trunc(rm.cover2,'mm'),trunc(rm.cover1,'mm'))=12--年缴
                ) xr  on xr.policyno = r.policyno
              left join xq_moneysch m
               on r.policyno = m.policyno and r.classcode = m.classcode
              left join xq_sales_info f on r.empno = f.empno
               where r.polist<>109    --犹豫期退保
                and m.initial_paysch = '10'
                and m.paysch = '13'
                and r.classcode in(select p.classcode from xq_riskclass p where p.timestr = '1')
                and r.branch=cur_b.orgcode
                and f.sales_project is null
                and f.sales_organ is null;
        end if;
        end loop;
        commit;
   close cur_branch;

   open cur_emp;--销售机构
        loop
          fetch cur_emp into cur_e ;
          exit when cur_emp%notfound;
          insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
           select  cur_e.empno,cur_e.t,to_char(v_sta_date,'yyyy-mm'),sysdate,v_sta_kind,v_sta_kind,
             nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                    then r.initial_amount
                    else null
                  end
              ),0)n1,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                    then r.initial_amount
                    else null
                  end
              ),0)d1,
              nvl(sum(
                 case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                    then r.initial_amount
                    else null
                  end
              ),0)n2,
              nvl(sum(
                   case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                    then r.initial_amount
                    else null
                  end
              ),0)d2,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                    then r.initial_amount
                    else null
                  end
              ),0)n3,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                    then r.initial_amount
                    else null
                  end
              ),0)d3,
              nvl(sum(
                  case
                    when r.begdate-1>=v_begin_date  and r.begdate-1<v_end_date
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                    then r.initial_amount
                    else null
                  end
              ),0)n4,
              nvl(sum(
                  case
                    when r.begdate-1>=v_begin_date and r.begdate-1<v_end_date
                    then r.initial_amount
                    else null
                  end
              ),0)d4,trim(cur_e.sales_project),trim(cur_e.sales_organ),trim(cur_e.sales_classify)
              from xq_riskcon r
              left join xq_moneysch m
                on r.policyno = m.policyno and r.classcode = m.classcode
                left join xq_sales_info f on r.empno = f.empno
                where m.initial_paysch in(10,11,13)
                and r.polist<>109
                and m.paysch=m.initial_paysch
                and r.classcode in(select p.classcode from xq_riskclass p where p.timestr = '1')
                and r.empno=cur_e.empno
                and f.sales_project = cur_e.sales_project
                and f.sales_organ = cur_e.sales_organ
                and f.sales_classify = cur_e.sales_classify;

         --处理月转年
          insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
           select  cur_e.empno,cur_e.t,to_char(v_sta_date,'yyyy-mm'),sysdate,v_sta_kind,v_sta_kind,
             nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                         and xr.status=404
                    then xr.amount
                    else null
                  end
              ),0)n1,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                    then xr.amount
                    else null
                  end
              ),0)d1,
              nvl(sum(
                 case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind))
                         and xr.status=404
                    then xr.amount
                    else null
                  end
              ),0)n2,
              nvl(sum(
                   case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind))
                    then xr.amount
                    else null
                  end
              ),0)d2,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm') and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                         and xr.status=404
                    then xr.amount
                    else null
                  end
              ),0)n3,
              nvl(sum(
                  case
                    when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm') and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                         and xr.cover1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm') and xr.cover1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                    then xr.amount
                    else null
                  end
              ),0)d3,
              nvl(sum(
                  case
                    when r.begdate-1>=v_begin_date and r.begdate-1<v_end_date
                         and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                         and xr.cover1>=v_begin_date and xr.cover1<v_end_date
                         and xr.status=404
                    then xr.amount
                    else null
                  end
              ),0)n4,
              nvl(sum(
                  case
                    when r.begdate-1>=v_begin_date and r.begdate-1<v_end_date
                         and xr.cover1>=v_begin_date and xr.cover1<v_end_date
                    then xr.amount
                    else null
                  end
              ),0)d4,trim(cur_e.sales_project),trim(cur_e.sales_organ),'AAA'--trim(cur_e.sales_classify)
              from xq_riskcon r
              inner join (select rm.policyno, rm.cover1, rm.reminder_id, rm.amount,rm.status,rm.paycode
                          from xq_reminder rm
                          where rm.STATUS IN (402, 403, 404, 405, 406)
                            AND (rm.IS_DELETE IS NULL)
                            AND TRIM(rm.PCODE) IN ('1', '2', '4', '5', '6')
                            AND rm.PAYCODE = 705
                            AND months_between(trunc(rm.cover2,'mm'),trunc(rm.cover1,'mm'))=12--年缴
              ) xr on xr.policyno = r.policyno
              left join xq_moneysch m
                on r.policyno = m.policyno and r.classcode = m.classcode
                left join xq_sales_info f on r.empno = f.empno
                where r.polist<>109
                and m.initial_paysch='10'
                and m.paysch='13'
                and r.classcode in(select p.classcode from xq_riskclass p where p.timestr = '1')
                and r.empno=cur_e.empno
                and f.sales_project = cur_e.sales_project
                and f.sales_organ = cur_e.sales_organ
                and f.sales_classify = cur_e.sales_classify;
        end loop;
        commit;
   close cur_emp;
   EXCEPTION
   WHEN OTHERS THEN
    begin
      if cur_branch%isopen then
        close cur_branch;
      end if;
      if cur_emp%isopen then
        close cur_emp;
      end if;
    rollback;
    dbms_output.put_line('==XQ_continuation_report_1325继续率报表(13/25个月)提取数据时产生错误=='||sqlerrm);
   end;
end XQ_continuation_report_1325;
/

prompt
prompt Creating procedure XQ_CONTINUATION_REPORT_3
prompt ===========================================
prompt
create or replace procedure unicall.XQ_CONTINUATION_REPORT_3
(
 sta_date varchar--统计日期
) is
  /*
  ******************************************************
  *  存储过程名 ：XQ_CONTINUATION_REPORT_3
  *  建立日期   ：2012-04-5
  *  作者       ：huayi,baichuanyin,yangguoqi
  *  模块       ：续收报表-继续率报表
  *  描述       ：继续率报表统计3个月未缴和已缴的当月、宽一、宽末、累计
  *----------------------------------------------------
  *  序号 修改日期    修改人     修改原因
  *  1
  ******************************************************
  */
 --v_paycode integer :=10;
 v_sta_date date;

 --每年的1月1日
 v_first_day_of_year date := trunc(sysdate,'yyyy');
 v_current_month integer;
 v_begin_date date; --计算累计时的起始时间
 v_end_date   date; --计算累计时的截止时间

  /*维度*/
   cursor cur_branch is
     select x.branch orgcode ,f.sales_project,f.sales_organ, 0 as t
     from xq_riskcon x, xq_sales_info f
     where x.empno = f.empno(+)    --左关联
     and x.classcode in (select c.classcode from xq_riskclass c where c.timestr = '1')
     --and x.appf='1'
     group by x.branch ,f.sales_project,f.sales_organ ; --落地分公司
  cursor cur_emp is
     select distinct s.empno, 1 as t, s.sales_project, s.sales_organ, s.sales_classify from xq_sales_info s, xq_riskcon r
     where s.empno = r.empno;--销售机构

  cur_b cur_branch%rowtype;
  cur_e cur_emp%rowtype;
begin
   if sta_date is null then
     v_sta_date:= sysdate;
   else
     v_sta_date:=to_date(sta_date,'yyyy-mm-dd');
   end if;
   v_first_day_of_year:=trunc(v_sta_date,'yyyy');--统计年份
   v_current_month:=to_number(to_char(v_sta_date,'mm'));--统计月份
   v_begin_date:= add_months(v_first_day_of_year,-4);--向前推4各月计算累计
   v_end_date:= add_months(v_begin_date,v_current_month);--计算机统计几个月累计

   --落地分公司
   open cur_branch;
        loop
          fetch cur_branch into cur_b ;
          exit when cur_branch%notfound;
          if cur_b.sales_project is not null and cur_b.sales_organ is not null then
          insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
           select trim(cur_b.orgcode),cur_b.t,to_char(v_sta_date,'yyyy-mm'),sysdate,0,3,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -2),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -2))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n1,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -2),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -2))
                 then r.initial_amount
                 else null
               end
           ),0) d1,
           nvl( sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -3),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -3))
                   and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n2,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -3),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -3))
                 then r.initial_amount
                 else null
               end
           ),0) d2,
           nvl( sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -4),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -4))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n3,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -4),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -4))
                 then r.initial_amount
                 else null
               end
           ),0) d3,
           nvl( sum(
               case
                 when r.begdate-1>=v_begin_date  and  r.begdate-1<v_end_date
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n4,
           nvl(sum(
               case
                 when r.begdate-1>=v_begin_date  and  r.begdate-1<v_end_date
                 then r.initial_amount
                 else null
               end
           ),0) d4,trim(cur_b.sales_project),trim(cur_b.sales_organ),null
           from xq_riskcon r
               left join xq_moneysch m
               on r.policyno = m.policyno and r.classcode = m.classcode
               left join xq_sales_info f on r.empno = f.empno
               where m.initial_paysch=10
                and m.paysch=m.initial_paysch
                and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=3--缴费满三期
                and exists(select 1 from xq_riskclass p where p.timestr = '1' and  p.classcode=r.classcode)
                and r.branch=cur_b.orgcode
                and f.sales_project = cur_b.sales_project
                and f.sales_organ = cur_b.sales_organ;

           --三期未缴
           insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
            select cur_b.orgcode,cur_b.t,to_char(v_sta_date,'yyyy-mm'),sysdate,0,5,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -2),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -2))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n1,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -2),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -2))
                 then r.initial_amount
                 else null
               end
           ),0) d1,
           nvl( sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -3),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -3))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n2,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -3),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -3))
                 then r.initial_amount
                 else null
               end
           ),0) d2,
           nvl( sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -4),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -4))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n3,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -4),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -4))
                 then r.initial_amount
                 else null
               end
           ),0) d3,
           nvl( sum(
               case
                 when r.begdate-1>=v_begin_date  and  r.begdate-1<v_end_date
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n4,
           nvl(sum(
               case
                 when r.begdate-1>=v_begin_date  and  r.begdate-1<v_end_date
                 then r.initial_amount
                 else null
               end
           ),0) d4,trim(cur_b.sales_project),trim(cur_b.sales_organ),null
           from xq_riskcon r
               left join xq_moneysch m
               on r.policyno = m.policyno and r.classcode = m.classcode
               left join xq_sales_info f on r.empno = f.empno
               where m.initial_paysch=10
                and m.paysch=m.initial_paysch
                and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))<3 --缴费未满三期
                and exists(select 1 from xq_riskclass p where p.timestr = '1' and  p.classcode=r.classcode)
                and r.branch=cur_b.orgcode
                and f.sales_project = cur_b.sales_project
                and f.sales_organ = cur_b.sales_organ;
        else
          insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
           select trim(cur_b.orgcode),cur_b.t,to_char(v_sta_date,'yyyy-mm'),sysdate,0,3,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -2),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -2))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n1,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -2),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -2))
                 then r.initial_amount
                 else null
               end
           ),0) d1,
           nvl( sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -3),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -3))
                   and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n2,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -3),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -3))
                 then r.initial_amount
                 else null
               end
           ),0) d2,
           nvl( sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -4),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -4))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n3,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -4),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -4))
                 then r.initial_amount
                 else null
               end
           ),0) d3,
           nvl( sum(
               case
                 when r.begdate-1>=v_begin_date  and  r.begdate-1<v_end_date
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n4,
           nvl(sum(
               case
                 when r.begdate-1>=v_begin_date  and  r.begdate-1<v_end_date
                 then r.initial_amount
                 else null
               end
           ),0) d4,trim(cur_b.sales_project),trim(cur_b.sales_organ),null
           from xq_riskcon r
               left join xq_moneysch m
               on r.policyno = m.policyno and r.classcode = m.classcode
               left join xq_sales_info f on r.empno = f.empno
               where m.initial_paysch=10
                and m.paysch=m.initial_paysch
                and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=3
                and exists(select 1 from xq_riskclass p where p.timestr = '1' and  p.classcode=r.classcode)
                and r.branch=cur_b.orgcode
                and f.sales_project is null
                and f.sales_organ is null;

           --三期未缴
           insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
            select cur_b.orgcode,cur_b.t,to_char(v_sta_date,'yyyy-mm'),sysdate,0,5,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -2),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -2))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n1,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -2),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -2))
                 then r.initial_amount
                 else null
               end
           ),0) d1,
           nvl( sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -3),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -3))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n2,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -3),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -3))
                 then r.initial_amount
                 else null
               end
           ),0) d2,
           nvl( sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -4),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -4))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n3,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -4),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -4))
                 then r.initial_amount
                 else null
               end
           ),0) d3,
           nvl( sum(
               case
                 when r.begdate-1>=v_begin_date  and  r.begdate-1<v_end_date
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n4,
           nvl(sum(
               case
                 when r.begdate-1>=v_begin_date  and  r.begdate-1<v_end_date
                 then r.initial_amount
                 else null
               end
           ),0) d4,trim(cur_b.sales_project),trim(cur_b.sales_organ),null
           from xq_riskcon r
               left join xq_moneysch m
               on r.policyno = m.policyno and r.classcode = m.classcode
               left join xq_sales_info f on r.empno = f.empno
               where m.initial_paysch=10
                and m.paysch=m.initial_paysch
                and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))<3
                and exists(select 1 from xq_riskclass p where p.timestr = '1' and  p.classcode=r.classcode)
                and r.branch=cur_b.orgcode
                and f.sales_project is null
                and f.sales_organ is null;
        end if;
        end loop;
        commit;
   close cur_branch;
   --销售机构
   open cur_emp;
        loop
          fetch cur_emp into cur_e ;
          exit when cur_emp%notfound;
           insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
           select trim(cur_e.empno),cur_e.t,to_char(v_sta_date,'yyyy-mm'),sysdate,0,3,
           nvl( sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -2),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -2))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n1,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -2),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -2))
                 then r.initial_amount
                 else null
               end
           ),0) d1,
           nvl( sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -3),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -3))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n2,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -3),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -3))
                 then r.initial_amount
                 else null
               end
           ),0) d2,
           nvl( sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -4),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -4))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n3,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -4),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -4))
                 then r.initial_amount
                 else null
               end
           ),0) d3,
           nvl( sum(
               case
                 when r.begdate-1>=v_begin_date  and  r.begdate-1<v_end_date
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n4,
           nvl(sum(
               case
                 when r.begdate-1>=v_begin_date  and  r.begdate-1<v_end_date
                 then r.initial_amount
                 else null
               end
           ),0) d4,trim(cur_e.sales_project),trim(cur_e.sales_organ),trim(cur_e.sales_classify)
           from xq_riskcon r
               left join xq_moneysch m
               on r.policyno = m.policyno and r.classcode = m.classcode
               left join xq_sales_info f on r.empno = f.empno
               where m.initial_paysch=10
                and m.paysch=m.initial_paysch
                and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=3
                and exists(select 1 from xq_riskclass p where p.timestr = '1' and  p.classcode=r.classcode)
                and r.empno=cur_e.empno
                and f.sales_project = cur_e.sales_project
                and f.sales_organ = cur_e.sales_organ
                and f.sales_classify = cur_e.sales_classify;
        --第三期未缴
          insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
           select trim(cur_e.empno),cur_e.t,to_char(v_sta_date,'yyyy-mm'),sysdate,0,5,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -2),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -2))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n1,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -2),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -2))
                 then r.initial_amount
                 else null
               end
           ),0) d1,
           nvl( sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -3),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -3))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n2,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -3),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -3))
                 then r.initial_amount
                 else null
               end
           ),0) d2,
           nvl( sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -4),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -4))
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n3,
           nvl(sum(
               case
                 when r.begdate-1>=trunc(add_months(v_sta_date, -4),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -4))
                 then r.initial_amount
                 else null
               end
           ),0) d3,
           nvl( sum(
               case
                 when r.begdate-1>=v_begin_date  and  r.begdate-1<v_end_date
                      and polist=109
                 then r.initial_amount
                 else null
               end
           ),0) n4,
           nvl(sum(
               case
                 when r.begdate-1>=v_begin_date  and  r.begdate-1<v_end_date
                 then r.initial_amount
                 else null
               end
           ),0) d4,trim(cur_e.sales_project),trim(cur_e.sales_organ),trim(cur_e.sales_classify)
           from xq_riskcon r
               left join xq_moneysch m
               on r.policyno = m.policyno and r.classcode = m.classcode
               left join xq_sales_info f on r.empno = f.empno
               where m.initial_paysch=10
                and m.paysch=m.initial_paysch
                and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))<3
                and exists(select 1 from xq_riskclass p where p.timestr = '1' and  p.classcode=r.classcode)
                and r.empno=cur_e.empno
                and f.sales_project = cur_e.sales_project
                and f.sales_organ = cur_e.sales_organ
                and f.sales_classify = cur_e.sales_classify;
        end loop;
        commit;
   close cur_emp;
   EXCEPTION
   WHEN OTHERS THEN
    begin
      if cur_branch%isopen then
        close cur_branch;
      end if;
      if cur_emp%isopen then
        close cur_emp;
      end if;
    rollback;
    dbms_output.put_line('==XQ_CONTINUATION_REPORT_3继续率报表提取数据时产生错误=='||sqlerrm);
   end;
end XQ_CONTINUATION_REPORT_3;
/

prompt
prompt Creating procedure XQ_CONTINUATION_REPORT_47
prompt ============================================
prompt
create or replace procedure unicall.xq_continuation_report_47
(
 paycode integer, --(4/7个月)月缴
 sta_date varchar,--统计日期
 sta_kind integer --统计类型 4/7个月
) is
  /*
  ******************************************************
  *  存储过程名 ：XQ_CONTINUATION_REPORT_47
  *  建立日期   ：2012-04-5
  *  作者       ：huayi,baichuanyin,yangguoqi
  *  模块       ：续收报表-继续率报表
  *  描述       ：继续率报表统计4/7个月当月、宽一、宽末、累计
  *----------------------------------------------------
  *  序号 修改日期    修改人     修改原因
  *  1
  ******************************************************
  */
 v_paycode integer :=nvl(paycode,10);
 v_sta_date date;
 v_sta_kind integer:=nvl(sta_kind,4);

 --每年的1月1日
 v_first_day_of_year date;
 v_current_month integer;
 v_begin_date date; --计算累计时的起始时间
 v_end_date   date; --计算累计时的截止时间

  /*维度*/
  cursor cur_branch is
     select x.branch orgcode ,f.sales_project,f.sales_organ, 0 as t
     from xq_riskcon x, xq_sales_info f
     where x.empno = f.empno(+)    --左关联
     and x.classcode in (select c.classcode from xq_riskclass c where c.timestr = '1')
     --and x.appf='1'
     group by x.branch ,f.sales_project,f.sales_organ ; --落地分公司
  cursor cur_emp is
     select distinct s.empno, 1 as t, s.sales_project, s.sales_organ, s.sales_classify from xq_sales_info s, xq_riskcon r
     where s.empno = r.empno;--销售机构

  cur_b cur_branch%rowtype;
  cur_e cur_emp%rowtype;
begin
   if sta_date is null then
     v_sta_date:= sysdate;
   else
     v_sta_date:=to_date(sta_date,'yyyy-mm-dd');
   end if;

   v_first_day_of_year:= trunc(v_sta_date,'yyyy');
   v_current_month:=to_number(to_char(v_sta_date,'mm'));
   v_begin_date:= add_months(v_first_day_of_year,-(sta_kind+1));
   v_end_date:= add_months(v_begin_date,v_current_month);

   --落地分公司
   open cur_branch;
        loop
          fetch cur_branch into cur_b ;
          exit when cur_branch%notfound;
          if cur_b.sales_project is not null and cur_b.sales_organ is not null then
          insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
           select trim(cur_b.orgcode),cur_b.t,to_char(v_sta_date,'yyyy-mm'),sysdate,v_paycode,v_sta_kind,
                  nvl(sum(
                   case
                     when r.begdate-1 >=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1< last_day(add_months(v_sta_date, -v_sta_kind+1))
                          and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                     then  r.initial_amount
                     else null
                   end
                   ),0) n1,
                  nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                     then  r.initial_amount
                     else null
                   end
                  ),0) d1,
                  nvl(sum(
                   case
                     when  r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                     and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                     then  r.initial_amount
                     else null
                  end
                  ),0) n2,
                  nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                     then  r.initial_amount
                     else null
                   end
                  ),0)d2,
                  nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                     and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                     then  r.initial_amount
                     else null
                   end
                  ),0) n3,
                  nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                     then  r.initial_amount
                     else null
                   end
                  ),0)d3,
                  nvl(sum(
                    case
                      when r.begdate-1>=v_begin_date and r.begdate-1<v_end_date
                      and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                      then r.initial_amount
                      else null
                    end
                  ),0) n4,
                  nvl(sum(
                    case
                        when  r.begdate-1>=v_begin_date and r.begdate-1<v_end_date
                        then r.initial_amount
                        else null
                    end
                  ),0) d4,trim(cur_b.sales_project),trim(cur_b.sales_organ),null
                  from xq_riskcon r
                  left join xq_moneysch m
                  on r.policyno = m.policyno and r.classcode = m.classcode
                  left join xq_sales_info f on r.empno = f.empno
                  where m.initial_paysch='10'
                  and (m.paysch='10' or m.paysch='13')
                  and exists(select 1 from xq_riskclass p where p.timestr = '1' and p.classcode=r.classcode)
                  and r.branch=cur_b.orgcode
                  and f.sales_project = cur_b.sales_project
                  and f.sales_organ = cur_b.sales_organ
                  and r.polist<>109 ;
        else
           insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
           select trim(cur_b.orgcode),cur_b.t,to_char(v_sta_date,'yyyy-mm'),sysdate,v_paycode,v_sta_kind,
                  nvl(sum(
                   case
                     when r.begdate-1 >=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1< last_day(add_months(v_sta_date, -v_sta_kind+1))
                          and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                     then  r.initial_amount
                     else null
                   end
                   ),0) n1,
                  nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                     then  r.initial_amount
                     else null
                   end
                  ),0) d1,
                  nvl(sum(
                   case
                     when  r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                     and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                     then  r.initial_amount
                     else null
                  end
                  ),0) n2,
                  nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                     then  r.initial_amount
                     else null
                   end
                  ),0)d2,
                  nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                     and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                     then  r.initial_amount
                     else null
                   end
                  ),0) n3,
                  nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                     then  r.initial_amount
                     else null
                   end
                  ),0)d3,
                  nvl(sum(
                    case
                      when r.begdate-1>=v_begin_date and r.begdate-1<v_end_date
                      and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                      then r.initial_amount
                      else null
                    end
                  ),0) n4,
                  nvl(sum(
                    case
                        when  r.begdate-1>=v_begin_date and r.begdate-1<v_end_date
                        then r.initial_amount
                        else null
                    end
                  ),0) d4,'','',null
                  from xq_riskcon r
                  left join xq_moneysch m
                  on r.policyno = m.policyno and r.classcode = m.classcode
                  left join xq_sales_info f on r.empno = f.empno
                  where m.initial_paysch='10'
                  and (m.paysch='10' or m.paysch='13')
                  and exists(select 1 from xq_riskclass p where p.timestr = '1' and p.classcode=r.classcode)
                  and r.branch=cur_b.orgcode
                  and f.sales_project is null
                  and f.sales_organ is null
                  and r.polist<>109 ;
             end if;
        end loop;
        commit;
   close cur_branch;

   --销售机构
   open cur_emp;
        loop
          fetch cur_emp into cur_e ;
          exit when cur_emp%notfound;
          insert into xq_rate_of_continuation(ORG_ID,ORG_TYPE,time_of_sta,task_date,sta_type,STA_RATE,D1,N1,D2,N2,D3,N3,D4,N4,sales_project,sales_organ,sales_classify)
           select trim(cur_e.empno),cur_e.t,to_char(v_sta_date,'yyyy-mm'),sysdate,v_paycode,v_sta_kind,
                 nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                     and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                     then  r.initial_amount
                     else null
                   end
                  ),0)n1,
                 nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind+1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind+1))
                     then  r.initial_amount
                     else null
                   end
                  ),0)d1,
                  nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                     and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                     then  r.initial_amount
                     else null
                   end
                  ),0)n2,
                 nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind))
                     then  r.initial_amount
                     else null
                   end
                  ),0)d2,
                  nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                     and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                     then  r.initial_amount
                     else null
                   end
                  ),0)n3,
                 nvl(sum(
                   case
                     when r.begdate-1>=trunc(add_months(v_sta_date, -v_sta_kind-1),'mm')  and r.begdate-1<=last_day(add_months(v_sta_date, -v_sta_kind-1))
                     then  r.initial_amount
                     else null
                   end
                  ),0)d3,
                  nvl(sum(
                    case
                      when  r.begdate-1>=v_begin_date and r.begdate-1<v_end_date
                      and months_between(trunc(m.nextdate,'mm'),trunc(r.begdate-1,'mm'))>=v_sta_kind
                      then r.initial_amount
                      else null
                    end
                  ),0) d4,
                  nvl(sum(
                    case
                      when r.begdate-1>=v_begin_date and  r.begdate-1<v_end_date
                      then r.initial_amount
                      else null
                    end
                  ),0) n4,trim(cur_e.sales_project),trim(cur_e.sales_organ),trim(cur_e.sales_classify)
                  from xq_riskcon r
                  left join xq_moneysch m
                  on r.policyno = m.policyno and r.classcode = m.classcode
                  left join xq_sales_info f on r.empno = f.empno
                  where m.initial_paysch='10'
                  and (m.paysch='10' or m.paysch='13')
                  and exists(select 1 from xq_riskclass p where p.timestr = '1' and p.classcode=r.classcode)
                  and r.empno=cur_e.empno
                  and f.sales_project = cur_e.sales_project
                  and f.sales_organ = cur_e.sales_organ
                  and f.sales_classify = cur_e.sales_classify
                  and r.polist<>109;
        end loop;
        commit;
   close cur_emp;
   EXCEPTION
   WHEN OTHERS THEN
    begin
      if cur_branch%isopen then
        close cur_branch;
      end if;
      if cur_emp%isopen then
        close cur_emp;
      end if;
    rollback;
    dbms_output.put_line('==xq_continuation_report_47继续率报表(4/7个月)提取数据时产生错误=='||sqlerrm);
   end;
end xq_continuation_report_47;
/

prompt
prompt Creating procedure XQ_CONTINUATION_REPORT_CLIENT
prompt ================================================
prompt
create or replace procedure unicall.XQ_continuation_report_client
(
   begindate varchar,
   enddate varchar
)
is
  /*
  ******************************************************
  *  存储过程名 ：XQ_CONTINUATION_REPORT_CLIENT
  *  建立日期   ：2012-04-5
  *  作者       ：huayi,baichuanyin,yangguoqi
  *  模块       ：IDS
  *  描述       ：客户端调用4个月、7个月、13个月、25个月存储过程
  *----------------------------------------------------
  *  序号 修改日期    修改人     修改原因
  *  1
  ******************************************************
  */
   mindate   date:=to_date(begindate,'yyyy-mm-dd');
   maxdate   date:=to_date(enddate,'yyyy-mm-dd');
begin
  if to_char(mindate,'yyyy-mm')=to_char(maxdate,'yyyy-mm') then
    maxdate := add_months(maxdate,1);--加1个月修正跳出循环
  end if;
  --查询，如果有当月的数据，删除
  loop
     exit when to_char(mindate,'yyyy-mm')=to_char(maxdate,'yyyy-mm');

      delete from xq_rate_of_continuation r where r.time_of_sta=to_char(mindate,'yyyy-mm') and r.sta_rate=4;
      commit;
      XQ_continuation_report_47(10,to_char(mindate,'yyyy-mm-dd'),4); --4个月

      delete from xq_rate_of_continuation r where r.time_of_sta=to_char(mindate,'yyyy-mm') and r.sta_rate=7;
      commit;
      XQ_continuation_report_47(10,to_char(mindate,'yyyy-mm-dd'),7); --7个月

      delete from xq_rate_of_continuation r where r.time_of_sta=to_char(mindate,'yyyy-mm') and r.sta_rate=13;
      commit;
      XQ_continuation_report_1325(to_char(mindate,'yyyy-mm-dd'),13);--13个月

      delete from xq_rate_of_continuation r where r.time_of_sta=to_char(mindate,'yyyy-mm') and r.sta_rate=25;
      commit;
      XQ_continuation_report_1325(to_char(mindate,'yyyy-mm-dd'),25);--25个月

      --第三期
      delete from xq_rate_of_continuation r where r.time_of_sta=to_char(mindate,'yyyy-mm')  and r.sta_type=0;
      commit;
      XQ_continuation_report_3(to_char(mindate,'yyyy-mm-dd'));

      mindate:= add_months(mindate,1);
  end loop;
end XQ_continuation_report_client;
/

prompt
prompt Creating procedure XU_QI_POLICY_DATA
prompt ====================================
prompt
create or replace procedure unicall.XU_QI_POLICY_DATA
is
begin

--delete t_billing_info
 --删除续期数据

delete t_billing_info tb where tb.app_no in
(
      select t.appno from (
        select t.appno,t.policyno from (
          select t.appno, s.insurance_id,t.policyno from (
            select t.appno,t.ins_id,t.policyno from (
              select t.appno,t.idorg,t.ins_id, t.policyno from(
                select distinct t.appno,t.idorg, t.tsrid ,r.policyno,
                  SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--险种代码 |%|47~47 @1~2
                  INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'@', 1, 1) + 1,
                  INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'@', 1, 2) -
                  INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'@', 1, 1) - 1) as ins_id
                 from tb_app t,riskcon r where t.appno=r.appno and t.iaccept ='1'
               ) t,(select c.use_id,cr.rig_sta_des from c_use c,C_RIG_STA cr where c.rig_sta_id=cr.rig_sta_id) c where t.tsrid= to_char(c.use_id(+))
             ) t,SHCPIC_COMPANY s where t.idorg=s.company_code
           ) t,SHCPIC_INSURANCE_TERM_CODE s where t.ins_id=s.insurance_code
         ) t,SHCPIC_INSURANCE s where t.insurance_id=s.id
       ) t,prerec p,moneysch m,sprerec s,charge_failure c where t.policyno=p.policyno and t.policyno=m.policyno and t.policyno=s.policyno and t.policyno=c.policyno group by t.appno
);
commit;

 --删除生效数据
delete t_billing_info tb where tb.app_no in
(
 select t.appno from(
    select t.appno from(
      select t.appno,s.insurance_id from(
            select t.appno,t.idorg,r.policyno,
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--险种代码 |%|47~47 @1~2
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'@', 1, 1) + 1,
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'@', 1, 2) -
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'@', 1, 1) - 1) as ins_id
             from tb_app t,riskcon r where t.appno=r.appno and t.iaccept ='1'
      ) t,SHCPIC_INSURANCE_TERM_CODE s where t.ins_id=s.insurance_code
    ) t,SHCPIC_INSURANCE s where t.insurance_id=s.id
  ) t group by t.appno
);
commit;

-- 插入续期保单及生效保单一部分
insert into T_BILLING_INFO(
select t.appno,t.policyno,polist,max(t.payment_type) payment_type,max(t.app_nm) app_nm,t.contact_tel,t.app_mobile,max(t.name) insurance_name,t.rig_sta_des,t.tsrid,
t.payment_account_name,t.payment_account_bankcode,t.payment_account,t.id_no,t.prj_id,max(t.opdate) opdate,max(to_date(t.submit_date,'YYYY-MM-DD')) submit_date, max(t.coverage) coverage,
max(t.years) years,max(t.cover1) cover1,max(t.cover2) cover2,max(t.amount) amount,max(t.nextdate) nextdate,t.rectele,max(t.sprerec_years) sprerec_years,max(t.pay_sum) pay_sum,
max(t.ins_id) insurance_code,t.company_id,max(t.owed) owed,max(t.owed_amount) owed_amount,max(t.appdate) appdate,t.charge_status,t.reason,max(t.owed_status) owed_status
from(
  select t.*,p.years,p.cover1,p.cover2,p.amount,m.nextdate,m.rectele,s.years sprerec_years,s.status pay_sum,s.years-s.status as owed,
  (s.years-s.status)*p.amount as owed_amount,c.appdate,c.status charge_status,c.reason,c.status owed_status
  from(
    select t.*,s.name from(
      select t.*,s.insurance_id from(
        select t.*,s.id company_id from (
          select t.*,c.rig_sta_des from(
            select t.appno,t.idorg,t.tsrid,r.policyno,r.polist,t.prj_id,r.opdate,
            SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 2) + 3,INSTR(t.contents,'|%|', 1, 3) -INSTR(t.contents,'|%|', 1, 2) - 3) as app_nm,--投保人姓名 |%|2~3
            SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 18) + 3,INSTR(t.contents,'|%|', 1, 19) -INSTR(t.contents,'|%|', 1, 18) - 3) as contact_tel,--投保人固定电话 |%|18~19
            SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 20) + 3,INSTR(t.contents,'|%|', 1, 21) -INSTR(t.contents,'|%|', 1, 20) - 3) as app_mobile,--投保人手机 |%|20~21
            SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 54) + 3,INSTR(t.contents,'|%|', 1, 55) -INSTR(t.contents,'|%|', 1, 54) - 3) as payment_type,--缴费方式 |%|54~55
            SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 56) + 3,INSTR(t.contents,'|%|', 1, 57) -INSTR(t.contents,'|%|', 1, 56) - 3) as payment_account_name,--缴费账户名 |%|56~57
            SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 55) + 3,INSTR(t.contents,'|%|', 1, 56) -INSTR(t.contents,'|%|', 1, 55) - 3) as payment_account_bankcode,--开户银行 |%|55~56
            SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 57) + 3,INSTR(t.contents,'|%|', 1, 58) -INSTR(t.contents,'|%|', 1, 57) - 3) as payment_account,--缴费账号 |%|57~58
            SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 5) + 3,INSTR(t.contents,'|%|', 1, 6) -INSTR(t.contents,'|%|', 1, 5) - 3) as id_no,--投保人证件号 |%|5~6
            SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 65) + 3,INSTR(t.contents,'|%|', 1, 66) -INSTR(t.contents,'|%|', 1, 65) - 3) as submit_date,--投保时间 |%|65~66
            --保额
            nvl(SUBSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
            1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
            ,INSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
            1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
            ,'@', 1, 2) + 1,INSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
            1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
            ,'@', 1, 3) -INSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
            1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
            ,'@', 1, 2) - 1),0)
            *
            SUBSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
            1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
            ,INSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
            1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
            ,'@', 1, 3) + 1,INSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
            1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
            ,'@', 1, 4) -INSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
            1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
            ,'@', 1, 3) - 1)
            +
            nvl(SUBSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
            ,INSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
            ,'@', 1, 2) + 1,INSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
            ,'@', 1, 3) -INSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
            ,'@', 1, 2) - 1),0)
            *
            SUBSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
            ,INSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
            ,'@', 1, 3) + 1,INSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
            ,'@', 1, 4) -INSTR(
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
            ,'@', 1, 3) - 1)
             as coverage,--投保时间 |%|65~66
            --保额
            SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--险种代码 |%|47~47 @1~2
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'@', 1, 1) + 1,
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'@', 1, 2) -
            INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'@', 1, 1) - 1) as ins_id
             from tb_app t,riskcon r where t.appno=r.appno and t.iaccept ='1'
           ) t,(select c.use_id,cr.rig_sta_des from c_use c,C_RIG_STA cr where c.rig_sta_id=cr.rig_sta_id) c where t.tsrid= to_char(c.use_id(+))
        ) t,SHCPIC_COMPANY s where t.idorg=s.company_code
      ) t,SHCPIC_INSURANCE_TERM_CODE s where t.ins_id=s.insurance_code
    ) t,SHCPIC_INSURANCE s where t.insurance_id=s.id
  ) t,prerec p,moneysch m,sprerec s,charge_failure c where t.policyno=p.policyno and t.policyno=m.policyno and t.policyno=s.policyno and t.policyno=c.policyno) t
   group by t.appno,t.idorg,t.policyno,t.app_nm,t.contact_tel,t.app_mobile,t.payment_account_name,t.payment_account_bankcode,t.payment_account,t.id_no,t.reason,
   t.rig_sta_des,t.tsrid,t.prj_id,t.charge_status,t.reason,t.rectele,t.polist,t.company_id
);
commit;

-- 插入生效保单 条件表中没有的数据
insert into T_BILLING_INFO(app_no,Policyno,Polist,App_Nm,Contact_Tel,Insurance_Name,Rig_Sta_Des,Tsrid,Id_No,Prj_Id,Opdate,Submit_Date,Coverage,Insurance_Code,Company_Id)(
select t.appno,t.policyno,polist,max(t.app_nm) app_nm,t.contact_tel,max(t.name) insurance_name,t.rig_sta_des,t.tsrid,
t.id_no,t.prj_id,max(t.opdate) opdate,max(to_date(t.submit_date,'YYYY-MM-DD')) submit_date, max(t.coverage) coverage,max(t.ins_id) insurance_code,max(t.company_id) company_id
from(
    select t.*,s.name from(
      select t.*,s.insurance_id from(
        select t.*,s.id company_id from(
            select t.*,c.rig_sta_des from(
              select t.appno,t.idorg,t.tsrid,r.policyno,r.polist,t.prj_id,r.opdate,
              SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 2) + 3,INSTR(t.contents,'|%|', 1, 3) -INSTR(t.contents,'|%|', 1, 2) - 3) as app_nm,--投保人姓名 |%|2~3
              SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 18) + 3,INSTR(t.contents,'|%|', 1, 19) -INSTR(t.contents,'|%|', 1, 18) - 3) as contact_tel,--投保人固定电话 |%|18~19

              SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 5) + 3,INSTR(t.contents,'|%|', 1, 6) -INSTR(t.contents,'|%|', 1, 5) - 3) as id_no,--投保人证件号 |%|5~6
              SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 65) + 3,INSTR(t.contents,'|%|', 1, 66) -INSTR(t.contents,'|%|', 1, 65) - 3) as submit_date,--投保时间 |%|65~66
              --保额
              nvl(SUBSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
              1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
              ,INSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
              1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
              ,'@', 1, 2) + 1,INSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
              1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
              ,'@', 1, 3) -INSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
              1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
              ,'@', 1, 2) - 1),0)
              *
              SUBSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
              1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
              ,INSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
              1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
              ,'@', 1, 3) + 1,INSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
              1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
              ,'@', 1, 4) -INSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--前半 |%|47~47 @1~2
              1,INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)- 1)
              ,'@', 1, 3) - 1)
              +
              nvl(SUBSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
              INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
              ,INSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
              INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
              ,'@', 1, 2) + 1,INSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
              INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
              ,'@', 1, 3) -INSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
              INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
              ,'@', 1, 2) - 1),0)
              *
              SUBSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
              INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
              ,INSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
              INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
              ,'@', 1, 3) + 1,INSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
              INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
              ,'@', 1, 4) -INSTR(
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--后半 |%|47~47 @1~2
              INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'&', 1, 1)+ 1)
              ,'@', 1, 3) - 1) as coverage,--投保时间 |%|65~66
              --保额
              SUBSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),--险种代码 |%|47~47 @1~2
              INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'@', 1, 1) + 1,
              INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'@', 1, 2) -
              INSTR(SUBSTR(t.contents,INSTR(t.contents,'|%|', 1, 47) + 3,INSTR(t.contents,'|%|', 1, 48) -INSTR(t.contents,'|%|', 1, 47) - 3),'@', 1, 1) - 1) as ins_id
               from tb_app t,riskcon r where t.appno=r.appno and t.iaccept ='1'
             ) t,(select c.use_id,cr.rig_sta_des from c_use c,C_RIG_STA cr where c.rig_sta_id=cr.rig_sta_id) c where t.tsrid= to_char(c.use_id(+))
           ) t,SHCPIC_COMPANY s where t.idorg=s.company_code
      ) t,SHCPIC_INSURANCE_TERM_CODE s where t.ins_id=s.insurance_code and t.appno not in(select app_no from t_billing_info)
    ) t,SHCPIC_INSURANCE s where t.insurance_id=s.id) t group by t.appno,t.idorg,t.policyno,t.app_nm,t.contact_tel,t.id_no,t.rig_sta_des,t.tsrid,t.prj_id,t.polist
) ;

commit;

end XU_QI_POLICY_DATA;
/

prompt
prompt Creating procedure XX
prompt =====================
prompt
create or replace procedure unicall.xx
 is
  v_k1  number(20) := '';
    v_k2  number(20) := '';
     v_k3  number(20) := '';
     v_cc  number(10) := 0;
     cur  types.cursorType;
begin

 open cur for
    select distinct  proposal_form_id,pro_product_id, insurance_id from shcpic_product_result t where t.pro_product_id=111 and  element_id<>11;
    loop
    fetch cur
      into v_k2,v_k1, v_k3;
    exit when cur%notfound;
    insert into shcpic_product_result
      (id, pro_product_id, proposal_form_id, insurance_id, element_id, element_value_value, element_value_name)
    values
      (v_cc, v_k1, v_k2,  v_k3, 11, '99', '99年限缴');
       dbms_output.put_line('v_cc='||v_cc);
       v_cc:=v_cc+1;
   end loop;
    close cur;
    commit;
    EXCEPTION
  when NO_DATA_FOUND then
    close cur;
    dbms_output.put_line('NO_DATA_FOUND error');
    rollback;
  when too_many_rows then
    close cur;
    dbms_output.put_line('返回值多行');
    rollback;
  when others then
    close cur;
    dbms_output.put_line('others error');
     dbms_output.put_line('v_cc='||v_cc);
    rollback;
end;
/

prompt
prompt Creating package body XQ_CONTINUATION_REPORT
prompt ============================================
prompt
create or replace package body unicall.XQ_CONTINUATION_REPORT
 AS
 PROCEDURE REPORT_CONTINUATION(p_orgtype integer,p_searchTime varchar2,p_rate integer,report out CUR_REPORT)
 is
  v_orgtype integer;--维度(0:落地分公司,1:销售机构)
  v_searchTime date;--查询时间
  v_rate integer;   --查询频率(4/7/13/25/第三期)

  begin
   if p_orgtype is null then
       v_orgtype:=0;
    else
       v_orgtype:=p_orgtype;
    end if;
    if p_searchTime is null then
       v_searchTime := sysdate;
    else
       v_searchTime:=to_date(p_searchTime,'yyyy-mm-dd');
    end if;
    if p_rate is null then
       v_rate:=4;
    else
       v_rate:=p_rate;
    end if;

    if v_orgtype=0 then --落地分公司
       open report for
           select (CASE WHEN roc.sales_project is null then '其他' ELSE roc.sales_project end) sales_project,
             nvl(roc.d1,0) dd1, nvl(roc.n1,0) nn1,  (CASE WHEN roc.n1=0 THEN 0  WHEN roc.d1/roc.n1=1 then 100 WHEN roc.d1/roc.n1 is null then 0 ELSE round(100*roc.d1/roc.n1,2) end) rate1,
             nvl(roc.d2,0) dd2, nvl(roc.n2,0) nn2,  (CASE WHEN roc.n2=0 THEN 0  WHEN roc.d2/roc.n2=1 then 100 WHEN roc.d2/roc.n2 is null then 0 ELSE round(100*roc.d2/roc.n2,2) end) rate2,
             nvl(roc.d3,0) dd3, nvl(roc.n3,0) nn3,  (CASE WHEN roc.n3=0 THEN 0  WHEN roc.d3/roc.n3=1 then 100 WHEN roc.d3/roc.n3 is null then 0 ELSE round(100*roc.d3/roc.n3,2) end) rate3,
             nvl(roc.d4,0) dd4, nvl(roc.n4,0) nn4,  (CASE WHEN roc.n4=0 THEN 0  WHEN roc.d4/roc.n4=1 then 100 WHEN roc.d4/roc.n4 is null then 0 ELSE round(100*roc.d4/roc.n4,2) end) rate4,
             trim(roc.org_id) org_id,trim(roc.sales_organ) sales_organ,roc.sales_project,(CASE WHEN substr(roc.sales_organ,-4,4)='电销中心' then 1 ELSE 0 end) sales_classify
           from xq_rate_of_continuation roc
               where roc.org_type=0
                 and not exists (select 1 from xq_rate_of_continuation t where t.rowid=roc.rowid and t.d1=0
                 and t.n1=0 and t.d2=0 and t.n2=0 and t.d3=0 and t.n3=0 and t.d4=0 and t.n4=0)
               and roc.sta_rate=v_rate
               and roc.time_of_sta=to_char(v_searchTime,'yyyy-mm')
            order by org_id,sales_organ;
    end if;
    if v_orgtype=1 then --销售机构
              open report for
               select sales_project,sum(d1) d1,sum(n1) n1,sum(rate1),sum(d2) d2,sum(n2) n2,sum(rate2),sum(d3) d3,sum(n3) n3,sum(rate3),sum(d4) d4,sum(n4) n4,sum(rate4),sales_organ
                from (select rs.sales_project,
                  nvl(rr.d1,0) d1, nvl(rr.n1,0) n1,(CASE WHEN rr.n1=0 THEN 0  WHEN rr.d1/rr.n1=1 then 100 WHEN rr.d1/rr.n1 is null then 0 ELSE round(100*rr.d1/rr.n1,2) end) rate1,
                  nvl(rr.d2,0) d2, nvl(rr.n2,0) n2,(CASE WHEN rr.n2=0 THEN 0  WHEN rr.d2/rr.n2=1 then 100 WHEN rr.d2/rr.n2 is null then 0 ELSE round(100*rr.d2/rr.n2,2) end) rate2,
                  nvl(rr.d3,0) d3, nvl(rr.n3,0) n3,(CASE WHEN rr.n3=0 THEN 0  WHEN rr.d3/rr.n3=1 then 100 WHEN rr.d3/rr.n3 is null then 0 ELSE round(100*rr.d3/rr.n3,2) end) rate3,
                  nvl(rr.d4,0) d4, nvl(rr.n4,0) n4,(CASE WHEN rr.n4=0 THEN 0  WHEN rr.d4/rr.n4=1 then 100 WHEN rr.d4/rr.n4 is null then 0 ELSE round(100*rr.d4/rr.n4,2) end) rate4,
                  rs.empno,rs.sales_organ
                  from (select distinct s.empno,s.sales_project, s.sales_organ from xq_sales_info s ,xq_riskcon  r where s.empno = r.empno)
                  rs left  join
                  (select org_id, org_type, time_of_sta, task_date, sta_type, sta_rate,d1, n1, d2, n2, d3, n3, d4, n4 from xq_rate_of_continuation  rrr   where rrr.org_type=v_orgtype  and rrr.sta_rate=v_rate  and rrr.time_of_sta=to_char(v_searchTime,'yyyy-mm'))rr
                   on trim(rs.empno) = trim(rr.org_id)
               ) tt where (d1+n1+d2+n2+d3+n3+d4+n4)>0
              group by  tt.sales_organ,tt.sales_project
              order by sales_organ;
    end if;
  end REPORT_CONTINUATION;
end XQ_CONTINUATION_REPORT;
/

prompt
prompt Creating trigger TRIGER_SATISFY_ID_SEQ
prompt ======================================
prompt
create or replace trigger "UNICALL".TRIGER_SATISFY_id_seq 
 before insert on SHCPIC_SATISFY for each row
begin
  select SATIFSYID_SEQ.nextval into :new.SATISFYID from dual;
end TRIGER_SATISFY_id_seq;
/


spool off
