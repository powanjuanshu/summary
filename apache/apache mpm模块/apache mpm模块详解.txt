老版本的NCSA server和Apache 1是在UNIX系统中成长起来的.当时Apache是一个多进程服务器,一个服务进程处理一个用户请求,如果当前并发客户访问数量大于服务进程数,Apache便
会增加新的服务进程来处理当前请求.在正常情况下,Apache会维护一定数量的服务进程来处理用户的请求.

尽管这种多进程服务机制在Unix类系统中能够很好地工作,但是在其他的平台上效率却很低,如在Windows中产生一个进程是非常费时的.因此,让Apache真正实现跨平台还需要其他的方法.
Apache2采用的方法是把核心任务处理作为一个可拔插的模块,即MPM,使其能针对不同的环境进行优化.MPM架构允许不同的Apache模块在一个操作系统平台下共存,能够为用户根据不同应用
做出选择.

在实际应用中,只有UNIX类操作系统有其他的选择,而其他系统平台(Windows,Netware,OS/2,BeOs)则只有唯一的根据操作系统优化的MPM.在UNIX平台上,Apache2.2目前已经有两种高质量的
作为标准的MPM(Prefork和Worder),第三(Event方式)在不使用SSL的情况下也是稳定可靠的.另外还有一些MPM可以实验应用,暂时不适合产品应用.其他第三方的MPM模块也是可用的.

Prefork MPM基于非线程模型,和Apache1.x版本的MPM很相似.Prefork MPM在所有情况下都很安全,对运行非线程安全(non-thread-safe)模式的软件如php,它是唯一的安全选择.对于某些
应用程序,包括在Apache1.3上非常流行的程序(如简单静态页面,CGI脚本等),Prefork MPM是最好的选择.
Worker MPM基于线程模式,具有内存消耗低(对繁忙的服务很重要),扩展性在某些特定应用情况下比Prefork更好等优点.

以上两种稳定的MPM方式在非常繁忙的服务器应用下都有些不足.尽管HTTP的Keepalive方式能减少TCP连接数量和网络负载,但是Keepalive需要和服务进程或者线程绑定,这就导致一个繁
忙的服务器会耗光所有的线程.Event MPM是解决这个问题的一种新模型,它把服务进程从连接中分离出来.在服务器处理速度很快,同事具有非常高的点击率时,可用的线程数量就是关键
的资源限制,此时Event MPM方式是最有效的.一个以Worker MPM方式工作的繁忙服务器能承受每秒好几万次的访问量(例如在大型新闻服务站点的高峰时),而Event MPM可以用来处理更
高负载.值得注意的是,Event MPM不能在安全HTTP(HTTPS)访问下工作.

还有一些针对UNIX系统的,处于实验中的MPM,在继续开发,有可能已经实现了.Perchild MPM具有一个非常好的特性:以不用的用户ID为不同的虚拟主机运行Apache服务器.其他的一些MPM
也提供类似的功能,包括第三方的Metux和Peruser,以及mod_ruid(只支持Linux).


















