<%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>center</title>
	<script type="text/javascript" src="content/jquery/jquery-1.9.1.js"></script>
	<script type="text/javascript">
	//----------------------
	var loca_tem = "city";
	//实际上创建一个Function实例并不一定要赋值给具体的指针,可以直接执行
	//这种写法的作用:
	//1.使这段代码被载入时候自动执行
	//2.避免污染全局变量
	//因为js是函数作用域,所以如果想实现某个功能又不想污染全局变量的时候,会用这个自执行的匿名函数,常见于jquery插件
	//用(function(){xxx})()是利用匿名函数和闭包用来执行xxx里面的代码,同时所有的定义比如变量的作用域都在闭包里,不会污染到外部命名空间
	//使用括号包裹定义函数体,解析器将会以函数表达式的方式去调用定义函数
	(function(x,y){
		var loca_tem = "school";
		alert(x+y);//打印:3
		alert("loc:"+loca_tem);//打印:school,闭包不会污染闭包外的变量
	})(1, 2);
	alert("glob:"+loca_tem);//打印:city
	//----------------------
	//1.  
	var foo = 'This is foo.';  
	(function(){
	   alert(foo);//打印:This is foo. 说明闭包外面的变量在包里可以使用
	})();
	  
	//2.  
	var foo = 'This is foo.';  
	(function(){  
	   alert(foo);//undefined  
	   var foo = 2;  
	})();
	//function对象的hoisting特性:函数内的所有变量都相当于自动在函数头部声明,故2等价于这种写法:
    	//var foo = 'This is foo.'; 
    	//(function(){ 
        //   var foo; 
        //   alert(foo); 
        //   foo = 2; 
    	//})();
    	//在2中，又定义了一个局部变量foo，（覆盖了上级范围的foo），但是没有给赋初值，故访问foo时，出现 undefined 提示。所以，在函数定义时，其所有用到的变量，要写在函数体前
	//----------------------
	//之所以用圆括号把function(){}括起来是因为js解释器会将function解释为函数声明，而函数声明不能直接跟着(x,y)，我们需要将其转换为函数表达式
	//(2, 3)表示要传递跟函数的参数
	//上面的例子也可以写成:(好像无法直接执行)
	function fool(x, y){
		alert(arguments.length);
		alert(x+y);//打印:5
	}(2, 3);
	//函数声明的方式无法定义匿名函数，因此如果想使用匿名函数，则必须用函数表达式的定义方式
	//----------------------
	function test_arguments() {//js可以不写参数,调用的时候再传参数,取参数的时候使用内置变量arguments即可
		alert(arguments.length);//打印4
		alert(arguments[0]);//打印8
		//arguments.callee()主要用在递归函数中调用函数自身的情境中。js和别的语言不同在于函数名只是一个指针，可以随时变化，函数中利用函数名来调用自身属于高耦合，可能会出现问题，而arguments.callee()调用自身就会规避掉这个问题
		//arguments.callee(4, 5);
	}(6, 4, 9)
	test_arguments(8, 5, 3, 9);
	//----------------------
	</script>
  </head>
</html>

---------------------------------
自执行匿名函数:

常见格式:(function() {})();
解释:包围函数（function(){})的第一对括号向脚本返回未命名的函数,随后一对空括号立即执行返回的未命名函数,括号内为匿名函数的参数,简称闭包.
作用:可以用它创建命名空间,只要把自己所有的代码都写在这个特殊的函数包装内,那么外部就不能访问,除非你允许(变量前加上window,这样该函数或变量就成为全局).各JavaScript库的代码也基本是这种组织形式.
总结一下,执行函数的作用主要为匿名和自动执行,代码在被解释时就已经在运行了.

其他写法
(function () {} ());
!function () {} ();
~function () {} ();
-function () {} ();
+function () {} ();
---------------------------------
js中(function(){})()立即执行函数写法理解

javascript和其他编程语言相比比较随意,所以javascript代码中充满各种奇葩的写法,有时雾里看花,当然,能理解各型各色的写法也是对javascript语言特性更进一步的深入理解.

( function(){} )()和( function (){} () )是两种javascript立即执行函数的常见写法,最初我以为是一个括号包裹匿名函数,再在后面加个括号调用函数,最后达到函数定义后立即执行的目的,后来发现加括号的原因并非如此.要理解立即执行函数,需要先理解一些函数的基本概念.

函数声明、函数表达式、匿名函数

函数声明:function fnName () {};使用function关键字声明一个函数,再指定一个函数名,叫函数声明.

函数表达式 var fnName = function () {};使用function关键字声明一个函数,但未给函数命名,最后将匿名函数赋予一个变量,叫函数表达式,这是最常见的函数表达式语法形式.

匿名函数:function () {}; 使用function关键字声明一个函数,但未给函数命名,所以叫匿名函数,匿名函数属于函数表达式,匿名函数有很多作用,赋予一个变量则创建函数,赋予一个事件则成为事件处理程序或创建闭包等等.

函数声明和函数表达式不同之处在于,一、Javascript引擎在解析javascript代码时会‘函数声明提升’（Function declaration Hoisting）当前执行环境（作用域）上的函数声明,而函数表达式必须等到Javascirtp引擎执行到它所在行时,才会从上而下一行一行地解析函数表达式,二、函数表达式后面可以加括号立即调用该函数,函数声明不可以,只能以fnName()形式调用 .以下是两者差别的两个例子.
fnName();
function fnName(){
    ...
}
//正常,因为‘提升’了函数声明,函数调用可在函数声明之前
 
fnName();
var fnName=function(){
    ...
}
//报错,变量fnName还未保存对函数的引用,函数调用必须在函数表达式之后
var fnName=function(){
    alert('Hello World');
}();
//函数表达式后面加括号,当javascript引擎解析到此处时能立即调用函数
function fnName(){
    alert('Hello World');
}();
//不会报错,但是javascript引擎只解析函数声明,忽略后面的括号,函数声明不会被调用
function(){
    console.log('Hello World');    
}();
//语法错误,虽然匿名函数属于函数表达式,但是未进行赋值操作,
//所以javascript引擎将开头的function关键字当做函数声明,报错:要求需要一个函数名

在理解了一些函数基本概念后,回头看看( function(){…} )()和( function (){…} () )这两种立即执行函数的写法,最初我以为是一个括号包裹匿名函数,并后面加个括号立即调用函数,当时不知道为什么要加括号,后来明白,要在函数体后面加括号就能立即调用,则这个函数必须是函数表达式,不能是函数声明.

(function(a){
    console.log(a);   //firebug输出123,使用（）运算符
})(123);
 
(function(a){
    console.log(a);   //firebug输出1234,使用（）运算符
}(1234));
 
!function(a){
    console.log(a);   //firebug输出12345,使用！运算符
}(12345);
 
+function(a){
    console.log(a);   //firebug输出123456,使用+运算符
}(123456);
 
-function(a){
    console.log(a);   //firebug输出1234567,使用-运算符
}(1234567);
 
var fn=function(a){
    console.log(a);   //firebug输出12345678,使用=运算符
}(12345678)
可以看到输出结果,在function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果,而（）、！、+、-、=等运算符,都将函数声明转换成函数表达式,消除了javascript引擎识别函数表达式和函数声明的歧义,告诉javascript引擎这是一个函数表达式,不是函数声明,可以在后面加括号,并立即执行函数的代码.

加括号是最安全的做法,因为！、+、-等运算符还会和函数的返回值进行运算,有时造成不必要的麻烦.

不过这样的写法有什么用呢？

javascript中没用私有作用域的概念,如果在多人开发的项目上,你在全局或局部作用域中声明了一些变量,可能会被其他人不小心用同名的变量给覆盖掉,根据javascript函数作用域链的特性,可以使用这种技术可以模仿一个私有作用域,用匿名函数作为一个“容器”,“容器”内部可以访问外部的变量,而外部环境不能访问“容器”内部的变量,所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突,俗称“匿名包裹器”或“命名空间”.

JQuery使用的就是这种方法,将JQuery代码包裹在( function (window,undefined){…jquery代码…} (window)中,在全局作用域中调用JQuery代码时,可以达到保护JQuery内部变量的作用.















