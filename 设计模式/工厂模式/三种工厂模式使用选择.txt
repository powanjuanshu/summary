* 工厂方法：一抽象产品类派生出多个具体产品类；一抽象工厂类派生出多个具体工厂类；每个具体工厂类只能创建一个具体产品类的实例。
* 即定义一个创建对象的接口（即抽象工厂类），让其子类（具体工厂类）决定实例化哪一个类（具体产品类）。“一对一”的关系。

* 抽象工厂：多个抽象产品类，派生出多个具体产品类；一个抽象工厂类，派生出多个具体工厂类；每个具体工厂类可创建多个具体产品类的实例。
* 即提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们的具体的类。“一对多”的关系。

4. 应用场景

工厂方法：

在以下情况下，适用于工厂方法模式：

(1) 当一个类不知道它所必须创建的对象的类的时候。

(2) 当一个类希望由它的子类来指定它所创建的对象的时候。

(3) 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。

抽象工厂：

(1) 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。

(2) 这个系统有多于一个的产品族，而系统只消费其中某一产品族。

(3) 同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。

(4) 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。


如果对象需要进行复杂并且彼此相关的设置,那么使用工厂模式可以减少每种对象所需的代码量.如果这种设置只需要为特定类型的所有实例执行一次即可,这种作用尤其突出.
把这种设置代码放到类的构造函数中并不是一种高效的做法,这是因为即便设置工作已经完成,每次创建新实例的时候这些代码还是会执行,而且这样做会把设置代码分散到不同的类中.
工厂方法非常适合于这种场合.它可以在实例化所有需要的对象之前先一次性地进行设置.无论有多少不同的类会被实例化,这种办法都可以让设置代码集中在一个地方. 

如果所用的类要求加载外部库的话,这尤其有用.工厂方法可以对这些库进行检查并动态加载那些未找到的库.这些设置代码只存在于一个地方,因此以后改起来也方便得多. 

7.3.3　用许多小型对象组成一个大对象 

工厂方法可以用来创建封装了许多较小对象的对象.考虑一下自行车对象的构造函数.自行车包含着许多更小的子系统：车轮、车架、传动部件以及车闸等.
如果你不想让某个子系统与较大的那个对象之间形成强耦合,而是想在运行时从许多子系统中进行挑选的话,那么工厂方法是一个理想的选择.
使用这种技术,某天你可以为售出的所有自行车配上某种链条,要是第二天找到另一种更中意的链条,可以改而采用这个新品种.
实现这种改变很容易,因为这些自行车类的构造函数并不依赖于某种特定的链条品种.本章后面RSS阅读器的例子演示了工厂模式在这方面的用途. 


工厂模式主要是为创建对象提供了接口.工厂模式按照《Java与模式》中的提法分为三类： 
1. 简单工厂模式(Simple Factory) 
2. 工厂方法模式(Factory Method) 
3. 抽象工厂模式(Abstract Factory) 
这三种模式从上到下逐步抽象,并且更具一般性.还有一种分类法,就是将简单工厂模式看为工厂方法模式的一种特例,两个归为一类.下面是使用工厂模式的两种情况： 
1.在编码时不能预见需要创建哪种类的实例. 
2.系统不应依赖于产品类实例如何被创建、组合和表达的细节 



工厂方法使用一个抽象工厂角色作为核心来代替在简单工厂模式中使用具体类作为核心。让我们来看看工厂方法模式给我们带来了什么?
使用开闭原则来分析下工厂方法模式。当有新的产品(即暴发户的汽车)产生时,只要按照抽象产品角色、抽象工厂角色提供的合同来生成,那么就可以被客户使用,
而不必去修改任何已有的代码。看来,工厂方法模式是完全符合开闭原则的！ 使用工厂方法模式足以应付我们可能遇到的大部分业务需求。
但是当产品种类非常多时,就会出现大量的与之对应的工厂类,这不应该是我们所希望的。所以我建议在这种情况下使用简单工厂模式与工厂方法模式相结合的方式来减少工厂类;
即对于产品树上类似的种类(一般是树的叶子中互为兄弟的)使用简单工厂模式来实现。 
当然特殊的情况,就要特殊对待了;对于系统中存在不同的产品树,而且产品树上存在产品族,那么这种情况下就可能可以使用抽象工厂模式了。 

让我们来看看简单工厂模式、工厂方法模式给我们的启迪; 
如果不使用工厂模式来实现我们的例子,也许代码会减少很多--只需要实现已有的车,不使用多态。但是在可维护性上,
可扩展性上是非常差的(你可以想象一下,添加一辆车后要牵动的类)。因此为了提高扩展性和维护性,多写些代码是值得的。 

先来认识下什么是产品族;位于不同产品等级结构中,功能相关联的产品组成的家族。如果光看这句话就能清楚的理解这个概念,我不得不佩服你啊。
还是让我们用一个例子来形象地说明一下吧。 图中的BmwCar和BenzCar就是两个产品树(产品层次结构)；而如图所示的BenzSportsCar和BmwSportsCar就是一个产品族。
他们都可以放到跑车家族中,因此功能有所关联。同理BmwBussinessCar和BenzSportsCar也是一个产品族。 回到抽象产品模式的话题上,
可以这么说,它和工厂方法模式的区别就在于需要创建对象的复杂程度上。而且抽象工厂模式是三个里面最为抽象、最具一般性的。
抽象工厂模式的用意为;给客户端提供一个接口,可以创建多个产品族中的产品对象。而且使用抽象工厂模式还要满足一下条件; 
1.系统中有多个产品族,而系统一次只可能消费其中一族产品 
2.同属于同一个产品族的产品以其使用。 
来看看抽象工厂模式的各个角色(和工厂方法的如出一辙); 
抽象工厂角色;这是工厂方法模式的核心,它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 
具体工厂角色;它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。在java中它由具体的类来实现。 
抽象产品角色;它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。 
具体产品角色;具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 
看过了前两个模式,对这个模式各个角色之间的协调情况应该心里有个数了,我就不举具体的例子了。
只是一定要注意满足使用抽象工厂模式的条件哦,不然即使存在了多个产品树,也存在产品族,但是不能使用的