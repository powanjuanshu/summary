客户端软件的安装:
* TortoiseSVN-1.6.5.16974-win32-svn-1.6.5.msi
* 双击安装
* 一路next
* finish

检出项目:
* 空白处右键->SVN Checkout->URL of repository：写上我们要访问svn的URL地址：svn://localhost/project1（如果写svn://localhost则此仓库中的所有项目全都checkout出来了,
  注意这里project1不是仓库的名字,仓库的名字叫svnrepo,我们程序员是看不到的）->OK->OK->取出成功
* 空白处右键->TortoiseSVN->Repo-browser->URL：svn://localhost/project1->OK->反键左边想要checkout的目录->Checkout->
  Checkout directory是我们想要存在哪个目录（默认会存在当前目录）->OK->取出成功

导出文件(Export):
* Tortoise SVN->Export->URL of repository:svn://localhost/project1->Export directory:E:\aaa->OK
* 这个功能只是单纯的把svn上库中的project1目录下面的所有文件下载到E盘的aaa目录中
注意这个Export导出功能并没有把下载下来的文件或文件夹关联到Tortoise SVN上,所有文件或文件夹都没有绿色的勾

回退到历史版本:
* svn回到历史的某个版本
* 下面介绍几种版本回滚的办法:
* 推荐的一种方法是,直接export一个你需要的版本到一个新建文件夹,然后用你export的版本覆盖你的最新的版本,然后再commit.
* 操作步骤:TortoiseSVN->Show log->选中需要回滚的版本->右键->Export.之后将修改的文件覆盖到你的最新版本,commit即可.

清除密码:
* 空白地方反键TortoiseSVN->Setting->Save Data->Authentication data->Clear
* C:\Documents and Settings\Administrator\Application Data\Subversion\auth 删除auth下面的所有文件
* 如果以上2个方法都不起作用,那么只能卸载TortoiseSVN,再重新安装一次,之后上面的2个方法就能起作用了.
linux下
* 删除~/.subversion/auth即可rm -rf ~/.subversion/auth

符号含义:
* 红色感叹号 在你编辑一个文件后,图标变成了红色感叹号.你可以很容易看出哪些文件被修改过,需要被提交.
* 蓝色十字架 把新建的文件加入到svn管理
* 蓝色问号 本地新增的文件/文件夹没有提交到版本库中去
* 绿色勾 一个新检出的使用绿色勾,表示subversion状态正常

得到所有命令的用法:
* svnadmin help

Clean up清除锁定:
SVN本地更新时,由于一些操作中断更新,如磁盘空间不够,用户取消,可能会造成本地文件被锁定的情况。一般出现这种情况的解决方法：
* 可以使用SVN clean up来清除锁定。
* 如果不是本目录锁定，系统提示上一层目录锁定，需要到上一层或者根目录中清除。
* 如果在根目录下都无法clean的话，一般采取的方法是另外找一个目录重新CHECKOUT。但有时有时SVN目录下可能有一些自己本地修改的文件，
  还未提交到SVN服务器，这时重新CHECKOUT需要注意本地文件的备份，并且不要强制覆盖服务器上其它人修改的内容。
* 如果觉得第３种很麻烦，可以考虑这样的方法。其实SVN加锁会在.SVN（隐藏文件）中生成一个名字叫lock的文件（无后缀），查找所有的，
  手工删除。然后再尝试更新，系统可能会提示某个.base文件无法访问。找到它，把相关的文件或其所在的目录删除，重新UPDATE。工作量就小多了。

合并版本:
svn从分支合并到主干
1.从主干上检出工作副本,TortoiseSVN -> Merge -> Merge type选择 Merge a range of revisions -> Next -> URL to merge from 选择你要合并的分支 -> Next -> 
  Merge depth:选择Working copy(工作副本) -> 在合并前可以先进行测试合并 -> 测试合并成功后 -> Merge

对svn分支合并类型和深度的理解：
合并的工作是把主干或者分支上合并范围内的所有改动列出,并对比当前工作副本的内容,由合并者手工修改冲突,然后提交到服务器的相应目录里.如果当前工作副本是主干,
则合并的范围是分支上的改动,如果工作副本是分支的,则合并范围是主干上的改动,并且一定要注意,合并的起始位置URL一定要和当前的工作副本的URL是相同的.

一、合并一个范围的版本
此类型应用最为广泛,主要是把分支中的修改合并到主干上来.在主干上点击右键选择合并,然后选择合并类型：合并一个范围的版本.合并的源URL填写的是要合并的分支的URL,
待合并的版本范围如果为空,则指的是合并分支上所有的版本,即自从分支创建以来到分支当前最新版本的所有演变.如果只是选择其中一个版本,或者几个版本,
那么就表示只是将指定的n个版本的变化合并到主干上.如果只是选择其中一个版本,那么表示只是选择那个版本的修改,之前或之后的修改将不被采纳.

二、复兴合并
复兴合并可以理解为是第一种合并类型的一种特例,在复兴合并中,主干可以理解为是自从开创分支之后没有任何修改,而分支是经过修改的,而且合并中分支是没有版本选择的.
经过复兴合并,分支中所有的修改都会合并到主干中,合并的结果将使得分支和主干一模一样,从而可以删除分支.

三、合并两个不同的树
此类型与前两种类型不同,第一种类型可以选择分支合并的版本,主干不能选择版本；第二种类型是主干和分支都不能选择合并的版本；而这种类型则是无论是主干还是分支都可以选择合并的版本,
即可以选择过去的一个主干版本与分支的某个版本进行合并.合并的时候以选择的分支版本为主,如果选择的主干版本与分支版本有不同的地方,合并时主干部分将被放弃.
起始URL：选择主干目录的URL（应当和当前工作副本的URL一致,这个是所谓的合并点）
结束URL：选择要合并的分支的URL.
起始和结束的版本：一般起始版本应当找到最后一次同步时的版本,如果从没有同步过（第一次合并）,则选择创建分支时的版本,结束版本一般是最新版本,
如果你不想将某些内容合并进主干的话,也可以选择一个合并点.

实例：
主干A在95版本的时候创建分支B,此时两棵树都是95版本
1. 我在分支B上增加文件test.txt,提交.此时版本库升级到了96版本；
2. 我在A上选择合并类型1,合并分支最新版本,结果是把test.txt加入A；
3. 我在A上选择合并类型2,合并分支最新版本,结果同上；
4. 我在A上选择合并类型3,合并分支最新版本,结果同上；
5. 我在A上增加文件test2.txt,提交,此时版本库升级到了97版本；
6. 我在A上选择合并类型1,合并分支最新版本,结果是把test.txt加入A；
7. 我在A上选择合并类型2,合并分支最新版本,结果是把test.txt加入A；
8. 我在A上选择合并类型3,主干选择当前97版本,合并分支最新版本,结果是把test.txt加入A,把test2.txt从A删除；
9. 我在A上选择合并类型3,主干97以前的版本,合并分支最新版本,结果是把test.txt加入A,而A中保留着test2.txt.
将分支合并到主干上,首先需要在主干的工作副本下进行,合并的范围是从主干的上次合并的版本开始到分支上最新的版本结束,如果是第一次合并,则从主干创建分支的版本开始,
所以每次合并要做好说明,在日志中体现,不然忘记了下次再合并就有点麻烦.其实,应当尽量避免一个分支合并多次,分支的作用一般为了解决bug,一旦bug对应结束了,
分支的使命就结束了,以后再出现其他的问题,应当重新建立分支,这样就不会出现多次合并的问题了.
 
分支的合并深度
合并深度：
一. 工作副本：即你当前的工作目录,一般默认为这个选项；
二. 全递归：即你选择的目录的版本库,包括了其下面的子文件,子文件夹,包括子文件夹里面的内容；
三. 直接子节点,包括文件夹：即你选择的目录下面的文件,文件夹,但是不包括文件夹里面的子文件,子文件夹；
四. 仅文件子节点：即你选择的目录下面的文件,但不包括文件夹,当然不包括的文件夹下面的所有内容也都不纳入合并范围；
五. 仅此项：没有任何合并内容.
实例：
1. 主干test文件夹下面有text.txt文件,把test文件夹创建分支test2
2. 在test2文件夹下面增加test21文件夹,在test21文件夹下面增加文件夹test211,在test211文件夹下面增加文件test211.txt；修改test2文件夹下面的文件test.txt,增加文件test2.txt.提交
3. 右键test文件夹合并test2文件夹,选择工作副本.则test文件夹中原先的test.txt文件则显示修改状态,test2.txt文件显示新增状态,
   文件夹test21和test211以及里面的test211.txt文件都显示为新增状态.选择将test文件夹svn还原,则新增状态下的文件夹或者文件显示为无版本控制状态,原先的test.txt还原为常规常态.
4. 右键test文件夹合并test2文件夹,选择全递归,结果和3一样.但是我们之前的test文件夹和仓库上的test的内容是一致的,如果不一致,那么选全递归,是已仓库版本为标准.选工作副本,
   顾名思义,则以你本地的工作副本文件为主,分支上有而工作副本中没有的文件夹或文件则不进行比较合并.
5. 右键test文件夹合并test2文件夹,选择直接子节点,包含文件夹.则test文件夹中原先的test.txt文件显示为修改状态,test2.txt文件显示为新增状态,test21文件夹显示为新增状态,
   但是其里面内容则为空,那么就证明了分支中test21文件夹以下的内容并没有合并到主干test中来,合并行为只是选取了当前目录.选择将test文件夹svn还原,则新增状态下的文件夹或者文件显示为无版本控制状态,原先的test.txt还原为常规状态.
6. 右键test文件夹合并test2文件夹,选择仅文件子节点.则test文件夹中原先的test.txt文件显示为修改状态,test2.txt文件显示为新增状态,分支test2中的test21文件夹没有合并到test中来.
   选择将test文件夹svn还原,则新增状态下的文件显示为无版本控制状态,原先的test.txt还原为常规状态.
7. 右键test文件夹合并test2文件夹,选择仅此项.则test文件夹显示为修改状态,但是内容没有任何改动.将test文件夹svn还原,则该文件夹显示为常规状态.

只记录合并（阻止这些版本将来被合并）
选择此项意味着并没有实际的合并动作,只是在将来的合并过程中,svn将过滤掉此版本的修改动作.例如,我在合并的过程中,选择对分支的23版本只记录合并（阻止这个版本将来被合并）,
那么23版本并不会合并到主干中.在以后的合并中,如果选择合并分支的22到24版本,那么23版本将被忽略,我们也可以看到,在选择版本的对话框上,23版本的字体是灰色的.
所以要慎重使用这个选项,一旦使用了,那么表示这个版本在以后的合并中就不能再使用了.
忽略祖先：如果在分支上有一个文件曾经被删除过,后来又加了一个同文件名的文件,那么在merge的时候svn会识别到这两个文件不是同一个祖先而直接覆盖旧文件增加新文件.
而实际上我是要对这两个不同祖先的文件进行合并的,这个时候就需要使用svn merge --ignore-ancestry 忽略祖先来进行合并才能保证正确.
实例：
1. 将主干test创建分支test1；
2. 将test1文件夹下的test.txt文件删除,提交；
3. 在test1下创建文件test.txt,提交；
4. 将test1合并到主干test,如果默认选择,则提示将test1中的test.txt文件替换test文件夹中的test.txt文件；如果选择了忽略祖先,那么系统将把两个test.txt作比较,必要时提示冲突.
carriage return是一个符号（指回车符号CR）,而一般在代码文件或文体文件里（WINDOWS下）里换行是CR和LF（即\r\n或十六进制码0D 0A),而你行中只有CR,所以将要加一个LF（即OA）.
说得很明确了,其实LF就是line feed的简写.whitespace包括line feeds, tabs, spaces, and carriage returns.
合并情况：
1. 将分支的最新版本合并到主干.
2. 将分支的某个版本合并到主干
3. 将分支的全部更改合并到主干

















