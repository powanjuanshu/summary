@echo off
goto b
:a
echo aaaaa
goto end
:b
echo bbbbb
goto end
:end
----------------------------------------------------
@echo off
call :sub "abc"
pause
call :sub abc"
pause
call :sub "abc
pause
goto :eof
:sub
echo %1 %~1

::  输出以下信息:
::  "abc" abc
::  请按任意键继续. . .
::  abc" abc"
::  请按任意键继续. . .
::  "abc abc
::  请按任意键继续. . .
----------------------------------------------------
一般的批处理命令，都是按照自上而下的流程逐行执行的，也就是说，只有第一行的命令执行了之后，才可能执行第二行，第二行执行完之后，再执行第三行……如此依次执行。
如果对不同的情况，需要执行不同的既定操作，若还是按照常规的执行流程的话，是无法完成任务的，这个时候，就需要引入流程跳转的概念，动用流程跳转语句 goto 了。流程跳转的含义是：改变默认的执行顺序，强制跳转到指定的位置执行特定的程序块。
先来看个例子：假设需要判断用户输入的是A还是B，代码可以写成这样：

@echo off
set /p input=请输入字母A或B：
if "%input%"=="A" goto A
if "%input%"=="B" goto B
pause
exit

:A
echo 您输入的字母是A
pause
exit

:B
echo 您输入的字母是B
pause
exit

按照一般的执行流程，所有的代码都会自上而下逐行执行一次，结果将显示"您输入的字母是A"和"您输入的字母是B"这两行内容，很显然，这是达不到我们的要求的；但是，实际的结果是：如果您输入的字母非A即B，则结果只会显示"您输入的字母是A"或者"您输入的字母是B"；也就是说，代码的执行顺序发生了改变，不再一成不变地自上而下逐行执行了：当输入字母A后，将执行第一条if语句，此条语句执行后，将跳转到标签段:A，从而绕过了第一条if语句和:A之间的所有代码行；当输入字母B后，将执行头两条if语句，当执行完第二条if语句后，将跳转到标签段:B，从而绕过了第二条if语句和:B之间的所有代码行。

从上面的例子可以看到，要让goto语句起作用，还需要:A或:B之类的标签段的配合。所谓的标签段，就是这样的一些代码块：在首行上以单个冒号打头，其后紧跟一串字符，第二行及其之后的所有行为代码语句行。在这里，第一行的冒号是标签标志，紧跟它之后的字符串是标签名，两者合称标签。goto语句后面的部分为标签名，指引着该语句执行完之后该跳到转何方，标签则接收goto语句的跳转指令，引导着goto语句的后续操作。goto语句和标签互相呼应，在实现流程跳转时相辅相成，缺一不可。

下面说一下使用跳转语句goto的注意事项：

1、goto语句和标签要互相呼应，不能只有goto语句而没有相应的标签段，否则，程序将找不到相应的标签段而直接退出；只有标签段而没有goto语句是允许的，但不能实现流程跳转功能，从代码精简的角度来看，有标签段而没有goto语句，则此标签是多余的，可以精简掉；
2、若有多个标签段，则需要注意标签段之间是否需要添加合适的退出语句来终止程序继续向下执行，这是很多新手很容易犯错的地方，需要谨慎。以上面这段代码为例，如果去掉:A和:B之间的exit语句，那么，当输入字母A之后，结果将同时显示"您输入的字母是A"和"您输入的字母是B"这两行内容，而保留exit语句将只会在显示"您输入的字母是A"后，按任意键推出批处理程序，因为批处理是自上而下逐行执行的，即使用goto语句跳转之后，在新的位置上，这一执行流程仍然会保持，直到碰上另一个流程跳转语句，执行过程并不会在两个标签段之间自动终止。
3、标签名只可以使用常量，而不能使用变量；
4、若有同名的标签段，将执行位于最顶层的标签段，其后的标签段是否得到执行，将视具体的情况加以处理。
----------------------------------------------------
goto call命令使用说明

goto的定义:
将cmd.exe定向到批处理程序中带标签的行
GOTO label
  label   指定批处理程序中用作标签的文字字符串。 

标签必须单独一行，并且以冒号打头。 

如果命令扩展被启用，GOTO 会如下改变: 

GOTO 命令现在接受目标标签 :EOF，这个标签将控制转移到当前 
批脚本文件的结尾。不定义就退出批脚本文件，这是一个容易的
办法。有关能使该功能有用的 CALL 命令的扩展描述，请键入 
CALL /?
----------------------------------------------------
从批处理程序调用另一个批处理程序

CALL [drive:][path]filename [batch-parameters] 

  batch-parameters   指定批处理程序所需的命令行信息。 

如果命令扩展被启用，CALL 会如下改变: 

CALL 命令现在将卷标当作 CALL 的目标接受。语法是: 

    CALL:label arguments 

一个新的批文件上下文由指定的参数所创建，控制在卷标被指定 
后传递到语句。您必须通过达到批脚本文件末两次来 "exit" 两次。 
第一次读到文件末时，控制会回到 CALL 语句的紧后面。第二次 
会退出批脚本。键入 GOTO /?，参看 GOTO :EOF 扩展的描述， 
此描述允许您从一个批脚本返回。 

另外，批脚本文本参数参照(%0、%1、等等)已如下改变: 


     批脚本里的 %* 指出所有的参数(如 %1 %2 %3 %4 %5 ...) 

     批参数(%n)的替代已被增强。您可以使用以下语法: 

         %~1         - 删除引号(")，扩展 %1 
         %~f1        - 将 %1 扩展到一个完全合格的路径名 
         %~d1        - 仅将 %1 扩展到一个驱动器号 
         %~p1        - 仅将 %1 扩展到一个路径 
         %~n1        - 仅将 %1 扩展到一个文件名 
         %~x1        - 仅将 %1 扩展到一个文件扩展名 
         %~s1        - 扩展的路径只含有短名 
         %~a1        - 将 %1 扩展到文件属性 
         %~t1        - 将 %1 扩展到文件的日期/时间 
         %~z1        - 将 %1 扩展到文件的大小 
         %~$PATH:1   - 查找列在 PATH 环境变量的目录，并将 %1 
                       扩展到找到的第一个完全合格的名称。如果 
                       环境变量名未被定义，或者没有找到文件， 
                       此修改符会扩展到空字符串 

    可以组合修改符来取得多重结果: 

        %~dp1       - 只将 %1 扩展到驱动器号和路径 
        %~nx1       - 只将 %1 扩展到文件名和扩展名 
        %~dp$PATH:1 - 在列在 PATH 环境变量中的目录里查找 %1， 
                      并扩展到找到的第一个文件的驱动器号和路径。 
        %~ftza1     - 将 %1 扩展到类似 DIR 的输出行。 

    在上面的例子中，%1 和 PATH 可以被其他有效数值替换。 
    %~ 语法被一个有效参数号码终止。%~ 修定符不能跟 %* 
